
Robot_Car.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000070ce  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000124  00800060  000070ce  00007162  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000004be  00800184  00800184  00007286  2**0
                  ALLOC
  3 .stab         00009a2c  00000000  00000000  00007288  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000059b7  00000000  00000000  00010cb4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001e0  00000000  00000000  0001666b  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000232  00000000  00000000  0001684b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002891  00000000  00000000  00016a7d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001628  00000000  00000000  0001930e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000013de  00000000  00000000  0001a936  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000200  00000000  00000000  0001bd14  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000030f  00000000  00000000  0001bf14  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000a56  00000000  00000000  0001c223  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0001cc79  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 e0 15 	jmp	0x2bc0	; 0x2bc0 <__vector_1>
       8:	0c 94 13 16 	jmp	0x2c26	; 0x2c26 <__vector_2>
       c:	0c 94 46 16 	jmp	0x2c8c	; 0x2c8c <__vector_3>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 ed 0f 	jmp	0x1fda	; 0x1fda <__vector_6>
      1c:	0c 94 44 26 	jmp	0x4c88	; 0x4c88 <__vector_7>
      20:	0c 94 ba 0f 	jmp	0x1f74	; 0x1f74 <__vector_8>
      24:	0c 94 54 0f 	jmp	0x1ea8	; 0x1ea8 <__vector_9>
      28:	0c 94 e3 13 	jmp	0x27c6	; 0x27c6 <__vector_10>
      2c:	0c 94 a7 13 	jmp	0x274e	; 0x274e <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ee ec       	ldi	r30, 0xCE	; 206
      68:	f0 e7       	ldi	r31, 0x70	; 112
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a4 38       	cpi	r26, 0x84	; 132
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	16 e0       	ldi	r17, 0x06	; 6
      78:	a4 e8       	ldi	r26, 0x84	; 132
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a2 34       	cpi	r26, 0x42	; 66
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 00 38 	call	0x7000	; 0x7000 <main>
      8a:	0c 94 65 38 	jmp	0x70ca	; 0x70ca <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 2e 38 	jmp	0x705c	; 0x705c <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a5 e6       	ldi	r26, 0x65	; 101
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 4a 38 	jmp	0x7094	; 0x7094 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 3a 38 	jmp	0x7074	; 0x7074 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 ff 05 	call	0xbfe	; 0xbfe <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 56 38 	jmp	0x70ac	; 0x70ac <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 3a 38 	jmp	0x7074	; 0x7074 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 ff 05 	call	0xbfe	; 0xbfe <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 56 38 	jmp	0x70ac	; 0x70ac <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 2e 38 	jmp	0x705c	; 0x705c <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	85 e6       	ldi	r24, 0x65	; 101
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 ff 05 	call	0xbfe	; 0xbfe <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 4a 38 	jmp	0x7094	; 0x7094 <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 36 38 	jmp	0x706c	; 0x706c <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	65 e6       	ldi	r22, 0x65	; 101
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 ff 05 	call	0xbfe	; 0xbfe <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 52 38 	jmp	0x70a4	; 0x70a4 <__epilogue_restores__+0x10>

0000078a <__gtsf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 3a 38 	jmp	0x7074	; 0x7074 <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__gtsf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__gtsf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 4c 07 	call	0xe98	; 0xe98 <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__gtsf2+0x58>
     7e0:	8f ef       	ldi	r24, 0xFF	; 255
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 56 38 	jmp	0x70ac	; 0x70ac <__epilogue_restores__+0x18>

000007ea <__gesf2>:
     7ea:	a8 e1       	ldi	r26, 0x18	; 24
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 3a 38 	jmp	0x7074	; 0x7074 <__prologue_saves__+0x18>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	2d 83       	std	Y+5, r18	; 0x05
     800:	3e 83       	std	Y+6, r19	; 0x06
     802:	4f 83       	std	Y+7, r20	; 0x07
     804:	58 87       	std	Y+8, r21	; 0x08
     806:	89 e0       	ldi	r24, 0x09	; 9
     808:	e8 2e       	mov	r14, r24
     80a:	f1 2c       	mov	r15, r1
     80c:	ec 0e       	add	r14, r28
     80e:	fd 1e       	adc	r15, r29
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	b7 01       	movw	r22, r14
     816:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     81a:	8e 01       	movw	r16, r28
     81c:	0f 5e       	subi	r16, 0xEF	; 239
     81e:	1f 4f       	sbci	r17, 0xFF	; 255
     820:	ce 01       	movw	r24, r28
     822:	05 96       	adiw	r24, 0x05	; 5
     824:	b8 01       	movw	r22, r16
     826:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     82a:	89 85       	ldd	r24, Y+9	; 0x09
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	40 f0       	brcs	.+16     	; 0x840 <__gesf2+0x56>
     830:	89 89       	ldd	r24, Y+17	; 0x11
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	28 f0       	brcs	.+10     	; 0x840 <__gesf2+0x56>
     836:	c7 01       	movw	r24, r14
     838:	b8 01       	movw	r22, r16
     83a:	0e 94 4c 07 	call	0xe98	; 0xe98 <__fpcmp_parts_f>
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__gesf2+0x58>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	68 96       	adiw	r28, 0x18	; 24
     844:	e6 e0       	ldi	r30, 0x06	; 6
     846:	0c 94 56 38 	jmp	0x70ac	; 0x70ac <__epilogue_restores__+0x18>

0000084a <__ltsf2>:
     84a:	a8 e1       	ldi	r26, 0x18	; 24
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	eb e2       	ldi	r30, 0x2B	; 43
     850:	f4 e0       	ldi	r31, 0x04	; 4
     852:	0c 94 3a 38 	jmp	0x7074	; 0x7074 <__prologue_saves__+0x18>
     856:	69 83       	std	Y+1, r22	; 0x01
     858:	7a 83       	std	Y+2, r23	; 0x02
     85a:	8b 83       	std	Y+3, r24	; 0x03
     85c:	9c 83       	std	Y+4, r25	; 0x04
     85e:	2d 83       	std	Y+5, r18	; 0x05
     860:	3e 83       	std	Y+6, r19	; 0x06
     862:	4f 83       	std	Y+7, r20	; 0x07
     864:	58 87       	std	Y+8, r21	; 0x08
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 2e       	mov	r14, r24
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	b7 01       	movw	r22, r14
     876:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     87a:	8e 01       	movw	r16, r28
     87c:	0f 5e       	subi	r16, 0xEF	; 239
     87e:	1f 4f       	sbci	r17, 0xFF	; 255
     880:	ce 01       	movw	r24, r28
     882:	05 96       	adiw	r24, 0x05	; 5
     884:	b8 01       	movw	r22, r16
     886:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     88a:	89 85       	ldd	r24, Y+9	; 0x09
     88c:	82 30       	cpi	r24, 0x02	; 2
     88e:	40 f0       	brcs	.+16     	; 0x8a0 <__stack+0x41>
     890:	89 89       	ldd	r24, Y+17	; 0x11
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	28 f0       	brcs	.+10     	; 0x8a0 <__stack+0x41>
     896:	c7 01       	movw	r24, r14
     898:	b8 01       	movw	r22, r16
     89a:	0e 94 4c 07 	call	0xe98	; 0xe98 <__fpcmp_parts_f>
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <__stack+0x43>
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	68 96       	adiw	r28, 0x18	; 24
     8a4:	e6 e0       	ldi	r30, 0x06	; 6
     8a6:	0c 94 56 38 	jmp	0x70ac	; 0x70ac <__epilogue_restores__+0x18>

000008aa <__lesf2>:
     8aa:	a8 e1       	ldi	r26, 0x18	; 24
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	eb e5       	ldi	r30, 0x5B	; 91
     8b0:	f4 e0       	ldi	r31, 0x04	; 4
     8b2:	0c 94 3a 38 	jmp	0x7074	; 0x7074 <__prologue_saves__+0x18>
     8b6:	69 83       	std	Y+1, r22	; 0x01
     8b8:	7a 83       	std	Y+2, r23	; 0x02
     8ba:	8b 83       	std	Y+3, r24	; 0x03
     8bc:	9c 83       	std	Y+4, r25	; 0x04
     8be:	2d 83       	std	Y+5, r18	; 0x05
     8c0:	3e 83       	std	Y+6, r19	; 0x06
     8c2:	4f 83       	std	Y+7, r20	; 0x07
     8c4:	58 87       	std	Y+8, r21	; 0x08
     8c6:	89 e0       	ldi	r24, 0x09	; 9
     8c8:	e8 2e       	mov	r14, r24
     8ca:	f1 2c       	mov	r15, r1
     8cc:	ec 0e       	add	r14, r28
     8ce:	fd 1e       	adc	r15, r29
     8d0:	ce 01       	movw	r24, r28
     8d2:	01 96       	adiw	r24, 0x01	; 1
     8d4:	b7 01       	movw	r22, r14
     8d6:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     8da:	8e 01       	movw	r16, r28
     8dc:	0f 5e       	subi	r16, 0xEF	; 239
     8de:	1f 4f       	sbci	r17, 0xFF	; 255
     8e0:	ce 01       	movw	r24, r28
     8e2:	05 96       	adiw	r24, 0x05	; 5
     8e4:	b8 01       	movw	r22, r16
     8e6:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     8ea:	89 85       	ldd	r24, Y+9	; 0x09
     8ec:	82 30       	cpi	r24, 0x02	; 2
     8ee:	40 f0       	brcs	.+16     	; 0x900 <__lesf2+0x56>
     8f0:	89 89       	ldd	r24, Y+17	; 0x11
     8f2:	82 30       	cpi	r24, 0x02	; 2
     8f4:	28 f0       	brcs	.+10     	; 0x900 <__lesf2+0x56>
     8f6:	c7 01       	movw	r24, r14
     8f8:	b8 01       	movw	r22, r16
     8fa:	0e 94 4c 07 	call	0xe98	; 0xe98 <__fpcmp_parts_f>
     8fe:	01 c0       	rjmp	.+2      	; 0x902 <__lesf2+0x58>
     900:	81 e0       	ldi	r24, 0x01	; 1
     902:	68 96       	adiw	r28, 0x18	; 24
     904:	e6 e0       	ldi	r30, 0x06	; 6
     906:	0c 94 56 38 	jmp	0x70ac	; 0x70ac <__epilogue_restores__+0x18>

0000090a <__floatsisf>:
     90a:	a8 e0       	ldi	r26, 0x08	; 8
     90c:	b0 e0       	ldi	r27, 0x00	; 0
     90e:	eb e8       	ldi	r30, 0x8B	; 139
     910:	f4 e0       	ldi	r31, 0x04	; 4
     912:	0c 94 37 38 	jmp	0x706e	; 0x706e <__prologue_saves__+0x12>
     916:	9b 01       	movw	r18, r22
     918:	ac 01       	movw	r20, r24
     91a:	83 e0       	ldi	r24, 0x03	; 3
     91c:	89 83       	std	Y+1, r24	; 0x01
     91e:	da 01       	movw	r26, r20
     920:	c9 01       	movw	r24, r18
     922:	88 27       	eor	r24, r24
     924:	b7 fd       	sbrc	r27, 7
     926:	83 95       	inc	r24
     928:	99 27       	eor	r25, r25
     92a:	aa 27       	eor	r26, r26
     92c:	bb 27       	eor	r27, r27
     92e:	b8 2e       	mov	r11, r24
     930:	21 15       	cp	r18, r1
     932:	31 05       	cpc	r19, r1
     934:	41 05       	cpc	r20, r1
     936:	51 05       	cpc	r21, r1
     938:	19 f4       	brne	.+6      	; 0x940 <__floatsisf+0x36>
     93a:	82 e0       	ldi	r24, 0x02	; 2
     93c:	89 83       	std	Y+1, r24	; 0x01
     93e:	3a c0       	rjmp	.+116    	; 0x9b4 <__floatsisf+0xaa>
     940:	88 23       	and	r24, r24
     942:	a9 f0       	breq	.+42     	; 0x96e <__floatsisf+0x64>
     944:	20 30       	cpi	r18, 0x00	; 0
     946:	80 e0       	ldi	r24, 0x00	; 0
     948:	38 07       	cpc	r19, r24
     94a:	80 e0       	ldi	r24, 0x00	; 0
     94c:	48 07       	cpc	r20, r24
     94e:	80 e8       	ldi	r24, 0x80	; 128
     950:	58 07       	cpc	r21, r24
     952:	29 f4       	brne	.+10     	; 0x95e <__floatsisf+0x54>
     954:	60 e0       	ldi	r22, 0x00	; 0
     956:	70 e0       	ldi	r23, 0x00	; 0
     958:	80 e0       	ldi	r24, 0x00	; 0
     95a:	9f ec       	ldi	r25, 0xCF	; 207
     95c:	30 c0       	rjmp	.+96     	; 0x9be <__floatsisf+0xb4>
     95e:	ee 24       	eor	r14, r14
     960:	ff 24       	eor	r15, r15
     962:	87 01       	movw	r16, r14
     964:	e2 1a       	sub	r14, r18
     966:	f3 0a       	sbc	r15, r19
     968:	04 0b       	sbc	r16, r20
     96a:	15 0b       	sbc	r17, r21
     96c:	02 c0       	rjmp	.+4      	; 0x972 <__floatsisf+0x68>
     96e:	79 01       	movw	r14, r18
     970:	8a 01       	movw	r16, r20
     972:	8e e1       	ldi	r24, 0x1E	; 30
     974:	c8 2e       	mov	r12, r24
     976:	d1 2c       	mov	r13, r1
     978:	dc 82       	std	Y+4, r13	; 0x04
     97a:	cb 82       	std	Y+3, r12	; 0x03
     97c:	ed 82       	std	Y+5, r14	; 0x05
     97e:	fe 82       	std	Y+6, r15	; 0x06
     980:	0f 83       	std	Y+7, r16	; 0x07
     982:	18 87       	std	Y+8, r17	; 0x08
     984:	c8 01       	movw	r24, r16
     986:	b7 01       	movw	r22, r14
     988:	0e 94 b0 05 	call	0xb60	; 0xb60 <__clzsi2>
     98c:	01 97       	sbiw	r24, 0x01	; 1
     98e:	18 16       	cp	r1, r24
     990:	19 06       	cpc	r1, r25
     992:	84 f4       	brge	.+32     	; 0x9b4 <__floatsisf+0xaa>
     994:	08 2e       	mov	r0, r24
     996:	04 c0       	rjmp	.+8      	; 0x9a0 <__floatsisf+0x96>
     998:	ee 0c       	add	r14, r14
     99a:	ff 1c       	adc	r15, r15
     99c:	00 1f       	adc	r16, r16
     99e:	11 1f       	adc	r17, r17
     9a0:	0a 94       	dec	r0
     9a2:	d2 f7       	brpl	.-12     	; 0x998 <__floatsisf+0x8e>
     9a4:	ed 82       	std	Y+5, r14	; 0x05
     9a6:	fe 82       	std	Y+6, r15	; 0x06
     9a8:	0f 83       	std	Y+7, r16	; 0x07
     9aa:	18 87       	std	Y+8, r17	; 0x08
     9ac:	c8 1a       	sub	r12, r24
     9ae:	d9 0a       	sbc	r13, r25
     9b0:	dc 82       	std	Y+4, r13	; 0x04
     9b2:	cb 82       	std	Y+3, r12	; 0x03
     9b4:	ba 82       	std	Y+2, r11	; 0x02
     9b6:	ce 01       	movw	r24, r28
     9b8:	01 96       	adiw	r24, 0x01	; 1
     9ba:	0e 94 ff 05 	call	0xbfe	; 0xbfe <__pack_f>
     9be:	28 96       	adiw	r28, 0x08	; 8
     9c0:	e9 e0       	ldi	r30, 0x09	; 9
     9c2:	0c 94 53 38 	jmp	0x70a6	; 0x70a6 <__epilogue_restores__+0x12>

000009c6 <__fixsfsi>:
     9c6:	ac e0       	ldi	r26, 0x0C	; 12
     9c8:	b0 e0       	ldi	r27, 0x00	; 0
     9ca:	e9 ee       	ldi	r30, 0xE9	; 233
     9cc:	f4 e0       	ldi	r31, 0x04	; 4
     9ce:	0c 94 3e 38 	jmp	0x707c	; 0x707c <__prologue_saves__+0x20>
     9d2:	69 83       	std	Y+1, r22	; 0x01
     9d4:	7a 83       	std	Y+2, r23	; 0x02
     9d6:	8b 83       	std	Y+3, r24	; 0x03
     9d8:	9c 83       	std	Y+4, r25	; 0x04
     9da:	ce 01       	movw	r24, r28
     9dc:	01 96       	adiw	r24, 0x01	; 1
     9de:	be 01       	movw	r22, r28
     9e0:	6b 5f       	subi	r22, 0xFB	; 251
     9e2:	7f 4f       	sbci	r23, 0xFF	; 255
     9e4:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     9e8:	8d 81       	ldd	r24, Y+5	; 0x05
     9ea:	82 30       	cpi	r24, 0x02	; 2
     9ec:	61 f1       	breq	.+88     	; 0xa46 <__fixsfsi+0x80>
     9ee:	82 30       	cpi	r24, 0x02	; 2
     9f0:	50 f1       	brcs	.+84     	; 0xa46 <__fixsfsi+0x80>
     9f2:	84 30       	cpi	r24, 0x04	; 4
     9f4:	21 f4       	brne	.+8      	; 0x9fe <__fixsfsi+0x38>
     9f6:	8e 81       	ldd	r24, Y+6	; 0x06
     9f8:	88 23       	and	r24, r24
     9fa:	51 f1       	breq	.+84     	; 0xa50 <__fixsfsi+0x8a>
     9fc:	2e c0       	rjmp	.+92     	; 0xa5a <__fixsfsi+0x94>
     9fe:	2f 81       	ldd	r18, Y+7	; 0x07
     a00:	38 85       	ldd	r19, Y+8	; 0x08
     a02:	37 fd       	sbrc	r19, 7
     a04:	20 c0       	rjmp	.+64     	; 0xa46 <__fixsfsi+0x80>
     a06:	6e 81       	ldd	r22, Y+6	; 0x06
     a08:	2f 31       	cpi	r18, 0x1F	; 31
     a0a:	31 05       	cpc	r19, r1
     a0c:	1c f0       	brlt	.+6      	; 0xa14 <__fixsfsi+0x4e>
     a0e:	66 23       	and	r22, r22
     a10:	f9 f0       	breq	.+62     	; 0xa50 <__fixsfsi+0x8a>
     a12:	23 c0       	rjmp	.+70     	; 0xa5a <__fixsfsi+0x94>
     a14:	8e e1       	ldi	r24, 0x1E	; 30
     a16:	90 e0       	ldi	r25, 0x00	; 0
     a18:	82 1b       	sub	r24, r18
     a1a:	93 0b       	sbc	r25, r19
     a1c:	29 85       	ldd	r18, Y+9	; 0x09
     a1e:	3a 85       	ldd	r19, Y+10	; 0x0a
     a20:	4b 85       	ldd	r20, Y+11	; 0x0b
     a22:	5c 85       	ldd	r21, Y+12	; 0x0c
     a24:	04 c0       	rjmp	.+8      	; 0xa2e <__fixsfsi+0x68>
     a26:	56 95       	lsr	r21
     a28:	47 95       	ror	r20
     a2a:	37 95       	ror	r19
     a2c:	27 95       	ror	r18
     a2e:	8a 95       	dec	r24
     a30:	d2 f7       	brpl	.-12     	; 0xa26 <__fixsfsi+0x60>
     a32:	66 23       	and	r22, r22
     a34:	b1 f0       	breq	.+44     	; 0xa62 <__fixsfsi+0x9c>
     a36:	50 95       	com	r21
     a38:	40 95       	com	r20
     a3a:	30 95       	com	r19
     a3c:	21 95       	neg	r18
     a3e:	3f 4f       	sbci	r19, 0xFF	; 255
     a40:	4f 4f       	sbci	r20, 0xFF	; 255
     a42:	5f 4f       	sbci	r21, 0xFF	; 255
     a44:	0e c0       	rjmp	.+28     	; 0xa62 <__fixsfsi+0x9c>
     a46:	20 e0       	ldi	r18, 0x00	; 0
     a48:	30 e0       	ldi	r19, 0x00	; 0
     a4a:	40 e0       	ldi	r20, 0x00	; 0
     a4c:	50 e0       	ldi	r21, 0x00	; 0
     a4e:	09 c0       	rjmp	.+18     	; 0xa62 <__fixsfsi+0x9c>
     a50:	2f ef       	ldi	r18, 0xFF	; 255
     a52:	3f ef       	ldi	r19, 0xFF	; 255
     a54:	4f ef       	ldi	r20, 0xFF	; 255
     a56:	5f e7       	ldi	r21, 0x7F	; 127
     a58:	04 c0       	rjmp	.+8      	; 0xa62 <__fixsfsi+0x9c>
     a5a:	20 e0       	ldi	r18, 0x00	; 0
     a5c:	30 e0       	ldi	r19, 0x00	; 0
     a5e:	40 e0       	ldi	r20, 0x00	; 0
     a60:	50 e8       	ldi	r21, 0x80	; 128
     a62:	b9 01       	movw	r22, r18
     a64:	ca 01       	movw	r24, r20
     a66:	2c 96       	adiw	r28, 0x0c	; 12
     a68:	e2 e0       	ldi	r30, 0x02	; 2
     a6a:	0c 94 5a 38 	jmp	0x70b4	; 0x70b4 <__epilogue_restores__+0x20>

00000a6e <__floatunsisf>:
     a6e:	a8 e0       	ldi	r26, 0x08	; 8
     a70:	b0 e0       	ldi	r27, 0x00	; 0
     a72:	ed e3       	ldi	r30, 0x3D	; 61
     a74:	f5 e0       	ldi	r31, 0x05	; 5
     a76:	0c 94 36 38 	jmp	0x706c	; 0x706c <__prologue_saves__+0x10>
     a7a:	7b 01       	movw	r14, r22
     a7c:	8c 01       	movw	r16, r24
     a7e:	61 15       	cp	r22, r1
     a80:	71 05       	cpc	r23, r1
     a82:	81 05       	cpc	r24, r1
     a84:	91 05       	cpc	r25, r1
     a86:	19 f4       	brne	.+6      	; 0xa8e <__floatunsisf+0x20>
     a88:	82 e0       	ldi	r24, 0x02	; 2
     a8a:	89 83       	std	Y+1, r24	; 0x01
     a8c:	60 c0       	rjmp	.+192    	; 0xb4e <__floatunsisf+0xe0>
     a8e:	83 e0       	ldi	r24, 0x03	; 3
     a90:	89 83       	std	Y+1, r24	; 0x01
     a92:	8e e1       	ldi	r24, 0x1E	; 30
     a94:	c8 2e       	mov	r12, r24
     a96:	d1 2c       	mov	r13, r1
     a98:	dc 82       	std	Y+4, r13	; 0x04
     a9a:	cb 82       	std	Y+3, r12	; 0x03
     a9c:	ed 82       	std	Y+5, r14	; 0x05
     a9e:	fe 82       	std	Y+6, r15	; 0x06
     aa0:	0f 83       	std	Y+7, r16	; 0x07
     aa2:	18 87       	std	Y+8, r17	; 0x08
     aa4:	c8 01       	movw	r24, r16
     aa6:	b7 01       	movw	r22, r14
     aa8:	0e 94 b0 05 	call	0xb60	; 0xb60 <__clzsi2>
     aac:	fc 01       	movw	r30, r24
     aae:	31 97       	sbiw	r30, 0x01	; 1
     ab0:	f7 ff       	sbrs	r31, 7
     ab2:	3b c0       	rjmp	.+118    	; 0xb2a <__floatunsisf+0xbc>
     ab4:	22 27       	eor	r18, r18
     ab6:	33 27       	eor	r19, r19
     ab8:	2e 1b       	sub	r18, r30
     aba:	3f 0b       	sbc	r19, r31
     abc:	57 01       	movw	r10, r14
     abe:	68 01       	movw	r12, r16
     ac0:	02 2e       	mov	r0, r18
     ac2:	04 c0       	rjmp	.+8      	; 0xacc <__floatunsisf+0x5e>
     ac4:	d6 94       	lsr	r13
     ac6:	c7 94       	ror	r12
     ac8:	b7 94       	ror	r11
     aca:	a7 94       	ror	r10
     acc:	0a 94       	dec	r0
     ace:	d2 f7       	brpl	.-12     	; 0xac4 <__floatunsisf+0x56>
     ad0:	40 e0       	ldi	r20, 0x00	; 0
     ad2:	50 e0       	ldi	r21, 0x00	; 0
     ad4:	60 e0       	ldi	r22, 0x00	; 0
     ad6:	70 e0       	ldi	r23, 0x00	; 0
     ad8:	81 e0       	ldi	r24, 0x01	; 1
     ada:	90 e0       	ldi	r25, 0x00	; 0
     adc:	a0 e0       	ldi	r26, 0x00	; 0
     ade:	b0 e0       	ldi	r27, 0x00	; 0
     ae0:	04 c0       	rjmp	.+8      	; 0xaea <__floatunsisf+0x7c>
     ae2:	88 0f       	add	r24, r24
     ae4:	99 1f       	adc	r25, r25
     ae6:	aa 1f       	adc	r26, r26
     ae8:	bb 1f       	adc	r27, r27
     aea:	2a 95       	dec	r18
     aec:	d2 f7       	brpl	.-12     	; 0xae2 <__floatunsisf+0x74>
     aee:	01 97       	sbiw	r24, 0x01	; 1
     af0:	a1 09       	sbc	r26, r1
     af2:	b1 09       	sbc	r27, r1
     af4:	8e 21       	and	r24, r14
     af6:	9f 21       	and	r25, r15
     af8:	a0 23       	and	r26, r16
     afa:	b1 23       	and	r27, r17
     afc:	00 97       	sbiw	r24, 0x00	; 0
     afe:	a1 05       	cpc	r26, r1
     b00:	b1 05       	cpc	r27, r1
     b02:	21 f0       	breq	.+8      	; 0xb0c <__floatunsisf+0x9e>
     b04:	41 e0       	ldi	r20, 0x01	; 1
     b06:	50 e0       	ldi	r21, 0x00	; 0
     b08:	60 e0       	ldi	r22, 0x00	; 0
     b0a:	70 e0       	ldi	r23, 0x00	; 0
     b0c:	4a 29       	or	r20, r10
     b0e:	5b 29       	or	r21, r11
     b10:	6c 29       	or	r22, r12
     b12:	7d 29       	or	r23, r13
     b14:	4d 83       	std	Y+5, r20	; 0x05
     b16:	5e 83       	std	Y+6, r21	; 0x06
     b18:	6f 83       	std	Y+7, r22	; 0x07
     b1a:	78 87       	std	Y+8, r23	; 0x08
     b1c:	8e e1       	ldi	r24, 0x1E	; 30
     b1e:	90 e0       	ldi	r25, 0x00	; 0
     b20:	8e 1b       	sub	r24, r30
     b22:	9f 0b       	sbc	r25, r31
     b24:	9c 83       	std	Y+4, r25	; 0x04
     b26:	8b 83       	std	Y+3, r24	; 0x03
     b28:	12 c0       	rjmp	.+36     	; 0xb4e <__floatunsisf+0xe0>
     b2a:	30 97       	sbiw	r30, 0x00	; 0
     b2c:	81 f0       	breq	.+32     	; 0xb4e <__floatunsisf+0xe0>
     b2e:	0e 2e       	mov	r0, r30
     b30:	04 c0       	rjmp	.+8      	; 0xb3a <__floatunsisf+0xcc>
     b32:	ee 0c       	add	r14, r14
     b34:	ff 1c       	adc	r15, r15
     b36:	00 1f       	adc	r16, r16
     b38:	11 1f       	adc	r17, r17
     b3a:	0a 94       	dec	r0
     b3c:	d2 f7       	brpl	.-12     	; 0xb32 <__floatunsisf+0xc4>
     b3e:	ed 82       	std	Y+5, r14	; 0x05
     b40:	fe 82       	std	Y+6, r15	; 0x06
     b42:	0f 83       	std	Y+7, r16	; 0x07
     b44:	18 87       	std	Y+8, r17	; 0x08
     b46:	ce 1a       	sub	r12, r30
     b48:	df 0a       	sbc	r13, r31
     b4a:	dc 82       	std	Y+4, r13	; 0x04
     b4c:	cb 82       	std	Y+3, r12	; 0x03
     b4e:	1a 82       	std	Y+2, r1	; 0x02
     b50:	ce 01       	movw	r24, r28
     b52:	01 96       	adiw	r24, 0x01	; 1
     b54:	0e 94 ff 05 	call	0xbfe	; 0xbfe <__pack_f>
     b58:	28 96       	adiw	r28, 0x08	; 8
     b5a:	ea e0       	ldi	r30, 0x0A	; 10
     b5c:	0c 94 52 38 	jmp	0x70a4	; 0x70a4 <__epilogue_restores__+0x10>

00000b60 <__clzsi2>:
     b60:	ef 92       	push	r14
     b62:	ff 92       	push	r15
     b64:	0f 93       	push	r16
     b66:	1f 93       	push	r17
     b68:	7b 01       	movw	r14, r22
     b6a:	8c 01       	movw	r16, r24
     b6c:	80 e0       	ldi	r24, 0x00	; 0
     b6e:	e8 16       	cp	r14, r24
     b70:	80 e0       	ldi	r24, 0x00	; 0
     b72:	f8 06       	cpc	r15, r24
     b74:	81 e0       	ldi	r24, 0x01	; 1
     b76:	08 07       	cpc	r16, r24
     b78:	80 e0       	ldi	r24, 0x00	; 0
     b7a:	18 07       	cpc	r17, r24
     b7c:	88 f4       	brcc	.+34     	; 0xba0 <__clzsi2+0x40>
     b7e:	8f ef       	ldi	r24, 0xFF	; 255
     b80:	e8 16       	cp	r14, r24
     b82:	f1 04       	cpc	r15, r1
     b84:	01 05       	cpc	r16, r1
     b86:	11 05       	cpc	r17, r1
     b88:	31 f0       	breq	.+12     	; 0xb96 <__clzsi2+0x36>
     b8a:	28 f0       	brcs	.+10     	; 0xb96 <__clzsi2+0x36>
     b8c:	88 e0       	ldi	r24, 0x08	; 8
     b8e:	90 e0       	ldi	r25, 0x00	; 0
     b90:	a0 e0       	ldi	r26, 0x00	; 0
     b92:	b0 e0       	ldi	r27, 0x00	; 0
     b94:	17 c0       	rjmp	.+46     	; 0xbc4 <__clzsi2+0x64>
     b96:	80 e0       	ldi	r24, 0x00	; 0
     b98:	90 e0       	ldi	r25, 0x00	; 0
     b9a:	a0 e0       	ldi	r26, 0x00	; 0
     b9c:	b0 e0       	ldi	r27, 0x00	; 0
     b9e:	12 c0       	rjmp	.+36     	; 0xbc4 <__clzsi2+0x64>
     ba0:	80 e0       	ldi	r24, 0x00	; 0
     ba2:	e8 16       	cp	r14, r24
     ba4:	80 e0       	ldi	r24, 0x00	; 0
     ba6:	f8 06       	cpc	r15, r24
     ba8:	80 e0       	ldi	r24, 0x00	; 0
     baa:	08 07       	cpc	r16, r24
     bac:	81 e0       	ldi	r24, 0x01	; 1
     bae:	18 07       	cpc	r17, r24
     bb0:	28 f0       	brcs	.+10     	; 0xbbc <__clzsi2+0x5c>
     bb2:	88 e1       	ldi	r24, 0x18	; 24
     bb4:	90 e0       	ldi	r25, 0x00	; 0
     bb6:	a0 e0       	ldi	r26, 0x00	; 0
     bb8:	b0 e0       	ldi	r27, 0x00	; 0
     bba:	04 c0       	rjmp	.+8      	; 0xbc4 <__clzsi2+0x64>
     bbc:	80 e1       	ldi	r24, 0x10	; 16
     bbe:	90 e0       	ldi	r25, 0x00	; 0
     bc0:	a0 e0       	ldi	r26, 0x00	; 0
     bc2:	b0 e0       	ldi	r27, 0x00	; 0
     bc4:	20 e2       	ldi	r18, 0x20	; 32
     bc6:	30 e0       	ldi	r19, 0x00	; 0
     bc8:	40 e0       	ldi	r20, 0x00	; 0
     bca:	50 e0       	ldi	r21, 0x00	; 0
     bcc:	28 1b       	sub	r18, r24
     bce:	39 0b       	sbc	r19, r25
     bd0:	4a 0b       	sbc	r20, r26
     bd2:	5b 0b       	sbc	r21, r27
     bd4:	04 c0       	rjmp	.+8      	; 0xbde <__clzsi2+0x7e>
     bd6:	16 95       	lsr	r17
     bd8:	07 95       	ror	r16
     bda:	f7 94       	ror	r15
     bdc:	e7 94       	ror	r14
     bde:	8a 95       	dec	r24
     be0:	d2 f7       	brpl	.-12     	; 0xbd6 <__clzsi2+0x76>
     be2:	f7 01       	movw	r30, r14
     be4:	e3 59       	subi	r30, 0x93	; 147
     be6:	ff 4f       	sbci	r31, 0xFF	; 255
     be8:	80 81       	ld	r24, Z
     bea:	28 1b       	sub	r18, r24
     bec:	31 09       	sbc	r19, r1
     bee:	41 09       	sbc	r20, r1
     bf0:	51 09       	sbc	r21, r1
     bf2:	c9 01       	movw	r24, r18
     bf4:	1f 91       	pop	r17
     bf6:	0f 91       	pop	r16
     bf8:	ff 90       	pop	r15
     bfa:	ef 90       	pop	r14
     bfc:	08 95       	ret

00000bfe <__pack_f>:
     bfe:	df 92       	push	r13
     c00:	ef 92       	push	r14
     c02:	ff 92       	push	r15
     c04:	0f 93       	push	r16
     c06:	1f 93       	push	r17
     c08:	fc 01       	movw	r30, r24
     c0a:	e4 80       	ldd	r14, Z+4	; 0x04
     c0c:	f5 80       	ldd	r15, Z+5	; 0x05
     c0e:	06 81       	ldd	r16, Z+6	; 0x06
     c10:	17 81       	ldd	r17, Z+7	; 0x07
     c12:	d1 80       	ldd	r13, Z+1	; 0x01
     c14:	80 81       	ld	r24, Z
     c16:	82 30       	cpi	r24, 0x02	; 2
     c18:	48 f4       	brcc	.+18     	; 0xc2c <__pack_f+0x2e>
     c1a:	80 e0       	ldi	r24, 0x00	; 0
     c1c:	90 e0       	ldi	r25, 0x00	; 0
     c1e:	a0 e1       	ldi	r26, 0x10	; 16
     c20:	b0 e0       	ldi	r27, 0x00	; 0
     c22:	e8 2a       	or	r14, r24
     c24:	f9 2a       	or	r15, r25
     c26:	0a 2b       	or	r16, r26
     c28:	1b 2b       	or	r17, r27
     c2a:	a5 c0       	rjmp	.+330    	; 0xd76 <__pack_f+0x178>
     c2c:	84 30       	cpi	r24, 0x04	; 4
     c2e:	09 f4       	brne	.+2      	; 0xc32 <__pack_f+0x34>
     c30:	9f c0       	rjmp	.+318    	; 0xd70 <__pack_f+0x172>
     c32:	82 30       	cpi	r24, 0x02	; 2
     c34:	21 f4       	brne	.+8      	; 0xc3e <__pack_f+0x40>
     c36:	ee 24       	eor	r14, r14
     c38:	ff 24       	eor	r15, r15
     c3a:	87 01       	movw	r16, r14
     c3c:	05 c0       	rjmp	.+10     	; 0xc48 <__pack_f+0x4a>
     c3e:	e1 14       	cp	r14, r1
     c40:	f1 04       	cpc	r15, r1
     c42:	01 05       	cpc	r16, r1
     c44:	11 05       	cpc	r17, r1
     c46:	19 f4       	brne	.+6      	; 0xc4e <__pack_f+0x50>
     c48:	e0 e0       	ldi	r30, 0x00	; 0
     c4a:	f0 e0       	ldi	r31, 0x00	; 0
     c4c:	96 c0       	rjmp	.+300    	; 0xd7a <__pack_f+0x17c>
     c4e:	62 81       	ldd	r22, Z+2	; 0x02
     c50:	73 81       	ldd	r23, Z+3	; 0x03
     c52:	9f ef       	ldi	r25, 0xFF	; 255
     c54:	62 38       	cpi	r22, 0x82	; 130
     c56:	79 07       	cpc	r23, r25
     c58:	0c f0       	brlt	.+2      	; 0xc5c <__pack_f+0x5e>
     c5a:	5b c0       	rjmp	.+182    	; 0xd12 <__pack_f+0x114>
     c5c:	22 e8       	ldi	r18, 0x82	; 130
     c5e:	3f ef       	ldi	r19, 0xFF	; 255
     c60:	26 1b       	sub	r18, r22
     c62:	37 0b       	sbc	r19, r23
     c64:	2a 31       	cpi	r18, 0x1A	; 26
     c66:	31 05       	cpc	r19, r1
     c68:	2c f0       	brlt	.+10     	; 0xc74 <__pack_f+0x76>
     c6a:	20 e0       	ldi	r18, 0x00	; 0
     c6c:	30 e0       	ldi	r19, 0x00	; 0
     c6e:	40 e0       	ldi	r20, 0x00	; 0
     c70:	50 e0       	ldi	r21, 0x00	; 0
     c72:	2a c0       	rjmp	.+84     	; 0xcc8 <__pack_f+0xca>
     c74:	b8 01       	movw	r22, r16
     c76:	a7 01       	movw	r20, r14
     c78:	02 2e       	mov	r0, r18
     c7a:	04 c0       	rjmp	.+8      	; 0xc84 <__pack_f+0x86>
     c7c:	76 95       	lsr	r23
     c7e:	67 95       	ror	r22
     c80:	57 95       	ror	r21
     c82:	47 95       	ror	r20
     c84:	0a 94       	dec	r0
     c86:	d2 f7       	brpl	.-12     	; 0xc7c <__pack_f+0x7e>
     c88:	81 e0       	ldi	r24, 0x01	; 1
     c8a:	90 e0       	ldi	r25, 0x00	; 0
     c8c:	a0 e0       	ldi	r26, 0x00	; 0
     c8e:	b0 e0       	ldi	r27, 0x00	; 0
     c90:	04 c0       	rjmp	.+8      	; 0xc9a <__pack_f+0x9c>
     c92:	88 0f       	add	r24, r24
     c94:	99 1f       	adc	r25, r25
     c96:	aa 1f       	adc	r26, r26
     c98:	bb 1f       	adc	r27, r27
     c9a:	2a 95       	dec	r18
     c9c:	d2 f7       	brpl	.-12     	; 0xc92 <__pack_f+0x94>
     c9e:	01 97       	sbiw	r24, 0x01	; 1
     ca0:	a1 09       	sbc	r26, r1
     ca2:	b1 09       	sbc	r27, r1
     ca4:	8e 21       	and	r24, r14
     ca6:	9f 21       	and	r25, r15
     ca8:	a0 23       	and	r26, r16
     caa:	b1 23       	and	r27, r17
     cac:	00 97       	sbiw	r24, 0x00	; 0
     cae:	a1 05       	cpc	r26, r1
     cb0:	b1 05       	cpc	r27, r1
     cb2:	21 f0       	breq	.+8      	; 0xcbc <__pack_f+0xbe>
     cb4:	81 e0       	ldi	r24, 0x01	; 1
     cb6:	90 e0       	ldi	r25, 0x00	; 0
     cb8:	a0 e0       	ldi	r26, 0x00	; 0
     cba:	b0 e0       	ldi	r27, 0x00	; 0
     cbc:	9a 01       	movw	r18, r20
     cbe:	ab 01       	movw	r20, r22
     cc0:	28 2b       	or	r18, r24
     cc2:	39 2b       	or	r19, r25
     cc4:	4a 2b       	or	r20, r26
     cc6:	5b 2b       	or	r21, r27
     cc8:	da 01       	movw	r26, r20
     cca:	c9 01       	movw	r24, r18
     ccc:	8f 77       	andi	r24, 0x7F	; 127
     cce:	90 70       	andi	r25, 0x00	; 0
     cd0:	a0 70       	andi	r26, 0x00	; 0
     cd2:	b0 70       	andi	r27, 0x00	; 0
     cd4:	80 34       	cpi	r24, 0x40	; 64
     cd6:	91 05       	cpc	r25, r1
     cd8:	a1 05       	cpc	r26, r1
     cda:	b1 05       	cpc	r27, r1
     cdc:	39 f4       	brne	.+14     	; 0xcec <__pack_f+0xee>
     cde:	27 ff       	sbrs	r18, 7
     ce0:	09 c0       	rjmp	.+18     	; 0xcf4 <__pack_f+0xf6>
     ce2:	20 5c       	subi	r18, 0xC0	; 192
     ce4:	3f 4f       	sbci	r19, 0xFF	; 255
     ce6:	4f 4f       	sbci	r20, 0xFF	; 255
     ce8:	5f 4f       	sbci	r21, 0xFF	; 255
     cea:	04 c0       	rjmp	.+8      	; 0xcf4 <__pack_f+0xf6>
     cec:	21 5c       	subi	r18, 0xC1	; 193
     cee:	3f 4f       	sbci	r19, 0xFF	; 255
     cf0:	4f 4f       	sbci	r20, 0xFF	; 255
     cf2:	5f 4f       	sbci	r21, 0xFF	; 255
     cf4:	e0 e0       	ldi	r30, 0x00	; 0
     cf6:	f0 e0       	ldi	r31, 0x00	; 0
     cf8:	20 30       	cpi	r18, 0x00	; 0
     cfa:	a0 e0       	ldi	r26, 0x00	; 0
     cfc:	3a 07       	cpc	r19, r26
     cfe:	a0 e0       	ldi	r26, 0x00	; 0
     d00:	4a 07       	cpc	r20, r26
     d02:	a0 e4       	ldi	r26, 0x40	; 64
     d04:	5a 07       	cpc	r21, r26
     d06:	10 f0       	brcs	.+4      	; 0xd0c <__pack_f+0x10e>
     d08:	e1 e0       	ldi	r30, 0x01	; 1
     d0a:	f0 e0       	ldi	r31, 0x00	; 0
     d0c:	79 01       	movw	r14, r18
     d0e:	8a 01       	movw	r16, r20
     d10:	27 c0       	rjmp	.+78     	; 0xd60 <__pack_f+0x162>
     d12:	60 38       	cpi	r22, 0x80	; 128
     d14:	71 05       	cpc	r23, r1
     d16:	64 f5       	brge	.+88     	; 0xd70 <__pack_f+0x172>
     d18:	fb 01       	movw	r30, r22
     d1a:	e1 58       	subi	r30, 0x81	; 129
     d1c:	ff 4f       	sbci	r31, 0xFF	; 255
     d1e:	d8 01       	movw	r26, r16
     d20:	c7 01       	movw	r24, r14
     d22:	8f 77       	andi	r24, 0x7F	; 127
     d24:	90 70       	andi	r25, 0x00	; 0
     d26:	a0 70       	andi	r26, 0x00	; 0
     d28:	b0 70       	andi	r27, 0x00	; 0
     d2a:	80 34       	cpi	r24, 0x40	; 64
     d2c:	91 05       	cpc	r25, r1
     d2e:	a1 05       	cpc	r26, r1
     d30:	b1 05       	cpc	r27, r1
     d32:	39 f4       	brne	.+14     	; 0xd42 <__pack_f+0x144>
     d34:	e7 fe       	sbrs	r14, 7
     d36:	0d c0       	rjmp	.+26     	; 0xd52 <__pack_f+0x154>
     d38:	80 e4       	ldi	r24, 0x40	; 64
     d3a:	90 e0       	ldi	r25, 0x00	; 0
     d3c:	a0 e0       	ldi	r26, 0x00	; 0
     d3e:	b0 e0       	ldi	r27, 0x00	; 0
     d40:	04 c0       	rjmp	.+8      	; 0xd4a <__pack_f+0x14c>
     d42:	8f e3       	ldi	r24, 0x3F	; 63
     d44:	90 e0       	ldi	r25, 0x00	; 0
     d46:	a0 e0       	ldi	r26, 0x00	; 0
     d48:	b0 e0       	ldi	r27, 0x00	; 0
     d4a:	e8 0e       	add	r14, r24
     d4c:	f9 1e       	adc	r15, r25
     d4e:	0a 1f       	adc	r16, r26
     d50:	1b 1f       	adc	r17, r27
     d52:	17 ff       	sbrs	r17, 7
     d54:	05 c0       	rjmp	.+10     	; 0xd60 <__pack_f+0x162>
     d56:	16 95       	lsr	r17
     d58:	07 95       	ror	r16
     d5a:	f7 94       	ror	r15
     d5c:	e7 94       	ror	r14
     d5e:	31 96       	adiw	r30, 0x01	; 1
     d60:	87 e0       	ldi	r24, 0x07	; 7
     d62:	16 95       	lsr	r17
     d64:	07 95       	ror	r16
     d66:	f7 94       	ror	r15
     d68:	e7 94       	ror	r14
     d6a:	8a 95       	dec	r24
     d6c:	d1 f7       	brne	.-12     	; 0xd62 <__pack_f+0x164>
     d6e:	05 c0       	rjmp	.+10     	; 0xd7a <__pack_f+0x17c>
     d70:	ee 24       	eor	r14, r14
     d72:	ff 24       	eor	r15, r15
     d74:	87 01       	movw	r16, r14
     d76:	ef ef       	ldi	r30, 0xFF	; 255
     d78:	f0 e0       	ldi	r31, 0x00	; 0
     d7a:	6e 2f       	mov	r22, r30
     d7c:	67 95       	ror	r22
     d7e:	66 27       	eor	r22, r22
     d80:	67 95       	ror	r22
     d82:	90 2f       	mov	r25, r16
     d84:	9f 77       	andi	r25, 0x7F	; 127
     d86:	d7 94       	ror	r13
     d88:	dd 24       	eor	r13, r13
     d8a:	d7 94       	ror	r13
     d8c:	8e 2f       	mov	r24, r30
     d8e:	86 95       	lsr	r24
     d90:	49 2f       	mov	r20, r25
     d92:	46 2b       	or	r20, r22
     d94:	58 2f       	mov	r21, r24
     d96:	5d 29       	or	r21, r13
     d98:	b7 01       	movw	r22, r14
     d9a:	ca 01       	movw	r24, r20
     d9c:	1f 91       	pop	r17
     d9e:	0f 91       	pop	r16
     da0:	ff 90       	pop	r15
     da2:	ef 90       	pop	r14
     da4:	df 90       	pop	r13
     da6:	08 95       	ret

00000da8 <__unpack_f>:
     da8:	fc 01       	movw	r30, r24
     daa:	db 01       	movw	r26, r22
     dac:	40 81       	ld	r20, Z
     dae:	51 81       	ldd	r21, Z+1	; 0x01
     db0:	22 81       	ldd	r18, Z+2	; 0x02
     db2:	62 2f       	mov	r22, r18
     db4:	6f 77       	andi	r22, 0x7F	; 127
     db6:	70 e0       	ldi	r23, 0x00	; 0
     db8:	22 1f       	adc	r18, r18
     dba:	22 27       	eor	r18, r18
     dbc:	22 1f       	adc	r18, r18
     dbe:	93 81       	ldd	r25, Z+3	; 0x03
     dc0:	89 2f       	mov	r24, r25
     dc2:	88 0f       	add	r24, r24
     dc4:	82 2b       	or	r24, r18
     dc6:	28 2f       	mov	r18, r24
     dc8:	30 e0       	ldi	r19, 0x00	; 0
     dca:	99 1f       	adc	r25, r25
     dcc:	99 27       	eor	r25, r25
     dce:	99 1f       	adc	r25, r25
     dd0:	11 96       	adiw	r26, 0x01	; 1
     dd2:	9c 93       	st	X, r25
     dd4:	11 97       	sbiw	r26, 0x01	; 1
     dd6:	21 15       	cp	r18, r1
     dd8:	31 05       	cpc	r19, r1
     dda:	a9 f5       	brne	.+106    	; 0xe46 <__unpack_f+0x9e>
     ddc:	41 15       	cp	r20, r1
     dde:	51 05       	cpc	r21, r1
     de0:	61 05       	cpc	r22, r1
     de2:	71 05       	cpc	r23, r1
     de4:	11 f4       	brne	.+4      	; 0xdea <__unpack_f+0x42>
     de6:	82 e0       	ldi	r24, 0x02	; 2
     de8:	37 c0       	rjmp	.+110    	; 0xe58 <__unpack_f+0xb0>
     dea:	82 e8       	ldi	r24, 0x82	; 130
     dec:	9f ef       	ldi	r25, 0xFF	; 255
     dee:	13 96       	adiw	r26, 0x03	; 3
     df0:	9c 93       	st	X, r25
     df2:	8e 93       	st	-X, r24
     df4:	12 97       	sbiw	r26, 0x02	; 2
     df6:	9a 01       	movw	r18, r20
     df8:	ab 01       	movw	r20, r22
     dfa:	67 e0       	ldi	r22, 0x07	; 7
     dfc:	22 0f       	add	r18, r18
     dfe:	33 1f       	adc	r19, r19
     e00:	44 1f       	adc	r20, r20
     e02:	55 1f       	adc	r21, r21
     e04:	6a 95       	dec	r22
     e06:	d1 f7       	brne	.-12     	; 0xdfc <__unpack_f+0x54>
     e08:	83 e0       	ldi	r24, 0x03	; 3
     e0a:	8c 93       	st	X, r24
     e0c:	0d c0       	rjmp	.+26     	; 0xe28 <__unpack_f+0x80>
     e0e:	22 0f       	add	r18, r18
     e10:	33 1f       	adc	r19, r19
     e12:	44 1f       	adc	r20, r20
     e14:	55 1f       	adc	r21, r21
     e16:	12 96       	adiw	r26, 0x02	; 2
     e18:	8d 91       	ld	r24, X+
     e1a:	9c 91       	ld	r25, X
     e1c:	13 97       	sbiw	r26, 0x03	; 3
     e1e:	01 97       	sbiw	r24, 0x01	; 1
     e20:	13 96       	adiw	r26, 0x03	; 3
     e22:	9c 93       	st	X, r25
     e24:	8e 93       	st	-X, r24
     e26:	12 97       	sbiw	r26, 0x02	; 2
     e28:	20 30       	cpi	r18, 0x00	; 0
     e2a:	80 e0       	ldi	r24, 0x00	; 0
     e2c:	38 07       	cpc	r19, r24
     e2e:	80 e0       	ldi	r24, 0x00	; 0
     e30:	48 07       	cpc	r20, r24
     e32:	80 e4       	ldi	r24, 0x40	; 64
     e34:	58 07       	cpc	r21, r24
     e36:	58 f3       	brcs	.-42     	; 0xe0e <__unpack_f+0x66>
     e38:	14 96       	adiw	r26, 0x04	; 4
     e3a:	2d 93       	st	X+, r18
     e3c:	3d 93       	st	X+, r19
     e3e:	4d 93       	st	X+, r20
     e40:	5c 93       	st	X, r21
     e42:	17 97       	sbiw	r26, 0x07	; 7
     e44:	08 95       	ret
     e46:	2f 3f       	cpi	r18, 0xFF	; 255
     e48:	31 05       	cpc	r19, r1
     e4a:	79 f4       	brne	.+30     	; 0xe6a <__unpack_f+0xc2>
     e4c:	41 15       	cp	r20, r1
     e4e:	51 05       	cpc	r21, r1
     e50:	61 05       	cpc	r22, r1
     e52:	71 05       	cpc	r23, r1
     e54:	19 f4       	brne	.+6      	; 0xe5c <__unpack_f+0xb4>
     e56:	84 e0       	ldi	r24, 0x04	; 4
     e58:	8c 93       	st	X, r24
     e5a:	08 95       	ret
     e5c:	64 ff       	sbrs	r22, 4
     e5e:	03 c0       	rjmp	.+6      	; 0xe66 <__unpack_f+0xbe>
     e60:	81 e0       	ldi	r24, 0x01	; 1
     e62:	8c 93       	st	X, r24
     e64:	12 c0       	rjmp	.+36     	; 0xe8a <__unpack_f+0xe2>
     e66:	1c 92       	st	X, r1
     e68:	10 c0       	rjmp	.+32     	; 0xe8a <__unpack_f+0xe2>
     e6a:	2f 57       	subi	r18, 0x7F	; 127
     e6c:	30 40       	sbci	r19, 0x00	; 0
     e6e:	13 96       	adiw	r26, 0x03	; 3
     e70:	3c 93       	st	X, r19
     e72:	2e 93       	st	-X, r18
     e74:	12 97       	sbiw	r26, 0x02	; 2
     e76:	83 e0       	ldi	r24, 0x03	; 3
     e78:	8c 93       	st	X, r24
     e7a:	87 e0       	ldi	r24, 0x07	; 7
     e7c:	44 0f       	add	r20, r20
     e7e:	55 1f       	adc	r21, r21
     e80:	66 1f       	adc	r22, r22
     e82:	77 1f       	adc	r23, r23
     e84:	8a 95       	dec	r24
     e86:	d1 f7       	brne	.-12     	; 0xe7c <__unpack_f+0xd4>
     e88:	70 64       	ori	r23, 0x40	; 64
     e8a:	14 96       	adiw	r26, 0x04	; 4
     e8c:	4d 93       	st	X+, r20
     e8e:	5d 93       	st	X+, r21
     e90:	6d 93       	st	X+, r22
     e92:	7c 93       	st	X, r23
     e94:	17 97       	sbiw	r26, 0x07	; 7
     e96:	08 95       	ret

00000e98 <__fpcmp_parts_f>:
     e98:	1f 93       	push	r17
     e9a:	dc 01       	movw	r26, r24
     e9c:	fb 01       	movw	r30, r22
     e9e:	9c 91       	ld	r25, X
     ea0:	92 30       	cpi	r25, 0x02	; 2
     ea2:	08 f4       	brcc	.+2      	; 0xea6 <__fpcmp_parts_f+0xe>
     ea4:	47 c0       	rjmp	.+142    	; 0xf34 <__fpcmp_parts_f+0x9c>
     ea6:	80 81       	ld	r24, Z
     ea8:	82 30       	cpi	r24, 0x02	; 2
     eaa:	08 f4       	brcc	.+2      	; 0xeae <__fpcmp_parts_f+0x16>
     eac:	43 c0       	rjmp	.+134    	; 0xf34 <__fpcmp_parts_f+0x9c>
     eae:	94 30       	cpi	r25, 0x04	; 4
     eb0:	51 f4       	brne	.+20     	; 0xec6 <__fpcmp_parts_f+0x2e>
     eb2:	11 96       	adiw	r26, 0x01	; 1
     eb4:	1c 91       	ld	r17, X
     eb6:	84 30       	cpi	r24, 0x04	; 4
     eb8:	99 f5       	brne	.+102    	; 0xf20 <__fpcmp_parts_f+0x88>
     eba:	81 81       	ldd	r24, Z+1	; 0x01
     ebc:	68 2f       	mov	r22, r24
     ebe:	70 e0       	ldi	r23, 0x00	; 0
     ec0:	61 1b       	sub	r22, r17
     ec2:	71 09       	sbc	r23, r1
     ec4:	3f c0       	rjmp	.+126    	; 0xf44 <__fpcmp_parts_f+0xac>
     ec6:	84 30       	cpi	r24, 0x04	; 4
     ec8:	21 f0       	breq	.+8      	; 0xed2 <__fpcmp_parts_f+0x3a>
     eca:	92 30       	cpi	r25, 0x02	; 2
     ecc:	31 f4       	brne	.+12     	; 0xeda <__fpcmp_parts_f+0x42>
     ece:	82 30       	cpi	r24, 0x02	; 2
     ed0:	b9 f1       	breq	.+110    	; 0xf40 <__fpcmp_parts_f+0xa8>
     ed2:	81 81       	ldd	r24, Z+1	; 0x01
     ed4:	88 23       	and	r24, r24
     ed6:	89 f1       	breq	.+98     	; 0xf3a <__fpcmp_parts_f+0xa2>
     ed8:	2d c0       	rjmp	.+90     	; 0xf34 <__fpcmp_parts_f+0x9c>
     eda:	11 96       	adiw	r26, 0x01	; 1
     edc:	1c 91       	ld	r17, X
     ede:	11 97       	sbiw	r26, 0x01	; 1
     ee0:	82 30       	cpi	r24, 0x02	; 2
     ee2:	f1 f0       	breq	.+60     	; 0xf20 <__fpcmp_parts_f+0x88>
     ee4:	81 81       	ldd	r24, Z+1	; 0x01
     ee6:	18 17       	cp	r17, r24
     ee8:	d9 f4       	brne	.+54     	; 0xf20 <__fpcmp_parts_f+0x88>
     eea:	12 96       	adiw	r26, 0x02	; 2
     eec:	2d 91       	ld	r18, X+
     eee:	3c 91       	ld	r19, X
     ef0:	13 97       	sbiw	r26, 0x03	; 3
     ef2:	82 81       	ldd	r24, Z+2	; 0x02
     ef4:	93 81       	ldd	r25, Z+3	; 0x03
     ef6:	82 17       	cp	r24, r18
     ef8:	93 07       	cpc	r25, r19
     efa:	94 f0       	brlt	.+36     	; 0xf20 <__fpcmp_parts_f+0x88>
     efc:	28 17       	cp	r18, r24
     efe:	39 07       	cpc	r19, r25
     f00:	bc f0       	brlt	.+46     	; 0xf30 <__fpcmp_parts_f+0x98>
     f02:	14 96       	adiw	r26, 0x04	; 4
     f04:	8d 91       	ld	r24, X+
     f06:	9d 91       	ld	r25, X+
     f08:	0d 90       	ld	r0, X+
     f0a:	bc 91       	ld	r27, X
     f0c:	a0 2d       	mov	r26, r0
     f0e:	24 81       	ldd	r18, Z+4	; 0x04
     f10:	35 81       	ldd	r19, Z+5	; 0x05
     f12:	46 81       	ldd	r20, Z+6	; 0x06
     f14:	57 81       	ldd	r21, Z+7	; 0x07
     f16:	28 17       	cp	r18, r24
     f18:	39 07       	cpc	r19, r25
     f1a:	4a 07       	cpc	r20, r26
     f1c:	5b 07       	cpc	r21, r27
     f1e:	18 f4       	brcc	.+6      	; 0xf26 <__fpcmp_parts_f+0x8e>
     f20:	11 23       	and	r17, r17
     f22:	41 f0       	breq	.+16     	; 0xf34 <__fpcmp_parts_f+0x9c>
     f24:	0a c0       	rjmp	.+20     	; 0xf3a <__fpcmp_parts_f+0xa2>
     f26:	82 17       	cp	r24, r18
     f28:	93 07       	cpc	r25, r19
     f2a:	a4 07       	cpc	r26, r20
     f2c:	b5 07       	cpc	r27, r21
     f2e:	40 f4       	brcc	.+16     	; 0xf40 <__fpcmp_parts_f+0xa8>
     f30:	11 23       	and	r17, r17
     f32:	19 f0       	breq	.+6      	; 0xf3a <__fpcmp_parts_f+0xa2>
     f34:	61 e0       	ldi	r22, 0x01	; 1
     f36:	70 e0       	ldi	r23, 0x00	; 0
     f38:	05 c0       	rjmp	.+10     	; 0xf44 <__fpcmp_parts_f+0xac>
     f3a:	6f ef       	ldi	r22, 0xFF	; 255
     f3c:	7f ef       	ldi	r23, 0xFF	; 255
     f3e:	02 c0       	rjmp	.+4      	; 0xf44 <__fpcmp_parts_f+0xac>
     f40:	60 e0       	ldi	r22, 0x00	; 0
     f42:	70 e0       	ldi	r23, 0x00	; 0
     f44:	cb 01       	movw	r24, r22
     f46:	1f 91       	pop	r17
     f48:	08 95       	ret

00000f4a <MCAL_UART_UARTInit>:
 */

#include "UART.h"
//#include "avr/interrupt.h"

void MCAL_UART_UARTInit(void) {
     f4a:	df 93       	push	r29
     f4c:	cf 93       	push	r28
     f4e:	cd b7       	in	r28, 0x3d	; 61
     f50:	de b7       	in	r29, 0x3e	; 62
	/* Set baud rate */
	UBRRH = (u8) (Baud_Rate >> Shift_8_bit);
     f52:	e0 e4       	ldi	r30, 0x40	; 64
     f54:	f0 e0       	ldi	r31, 0x00	; 0
     f56:	10 82       	st	Z, r1
	UBRRL = (u8) Baud_Rate;
     f58:	e9 e2       	ldi	r30, 0x29	; 41
     f5a:	f0 e0       	ldi	r31, 0x00	; 0
     f5c:	87 e6       	ldi	r24, 0x67	; 103
     f5e:	80 83       	st	Z, r24

	/* Enable RX and TX */
//	UCSRB = (1 << RXEN) | (1 << TXEN);
	SET_BIT(UCSRB,RXEN_PIN);
     f60:	aa e2       	ldi	r26, 0x2A	; 42
     f62:	b0 e0       	ldi	r27, 0x00	; 0
     f64:	ea e2       	ldi	r30, 0x2A	; 42
     f66:	f0 e0       	ldi	r31, 0x00	; 0
     f68:	80 81       	ld	r24, Z
     f6a:	80 61       	ori	r24, 0x10	; 16
     f6c:	8c 93       	st	X, r24
	SET_BIT(UCSRB,TXEN_PIN);
     f6e:	aa e2       	ldi	r26, 0x2A	; 42
     f70:	b0 e0       	ldi	r27, 0x00	; 0
     f72:	ea e2       	ldi	r30, 0x2A	; 42
     f74:	f0 e0       	ldi	r31, 0x00	; 0
     f76:	80 81       	ld	r24, Z
     f78:	88 60       	ori	r24, 0x08	; 8
     f7a:	8c 93       	st	X, r24

	/* Set frame format: 8data, 2stop bit */
//	UCSRC = (1 << URSEL) | (1 << USBS) | (3 << UCSZ0);
	UCSRC = UCSRC_Size;
     f7c:	e0 e4       	ldi	r30, 0x40	; 64
     f7e:	f0 e0       	ldi	r31, 0x00	; 0
     f80:	8e e8       	ldi	r24, 0x8E	; 142
     f82:	80 83       	st	Z, r24
	//Logical Error
//	SET_BIT(UCSRC,URSEL_PIN);
//	SET_BIT(UCSRC,USBS_PIN);
//	SET_BIT(UCSRC,UCSZ0_PIN);
//	SET_BIT(UCSRC,UCSZ1_PIN);
}
     f84:	cf 91       	pop	r28
     f86:	df 91       	pop	r29
     f88:	08 95       	ret

00000f8a <MCAL_UART_UARTTransmit>:

void MCAL_UART_UARTTransmit(u8 Loc_u8data) {
     f8a:	df 93       	push	r29
     f8c:	cf 93       	push	r28
     f8e:	0f 92       	push	r0
     f90:	cd b7       	in	r28, 0x3d	; 61
     f92:	de b7       	in	r29, 0x3e	; 62
     f94:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for empty transmit buffer */
//	while (!( UCSRA & (1 << UDRE_PIN)));
	while (GET_BIT(UCSRA,UDRE_PIN)==0);
     f96:	eb e2       	ldi	r30, 0x2B	; 43
     f98:	f0 e0       	ldi	r31, 0x00	; 0
     f9a:	80 81       	ld	r24, Z
     f9c:	82 95       	swap	r24
     f9e:	86 95       	lsr	r24
     fa0:	87 70       	andi	r24, 0x07	; 7
     fa2:	88 2f       	mov	r24, r24
     fa4:	90 e0       	ldi	r25, 0x00	; 0
     fa6:	81 70       	andi	r24, 0x01	; 1
     fa8:	90 70       	andi	r25, 0x00	; 0
     faa:	00 97       	sbiw	r24, 0x00	; 0
     fac:	a1 f3       	breq	.-24     	; 0xf96 <MCAL_UART_UARTTransmit+0xc>

	/* Put data into buffer, sends the data */
	UDR = Loc_u8data;
     fae:	ec e2       	ldi	r30, 0x2C	; 44
     fb0:	f0 e0       	ldi	r31, 0x00	; 0
     fb2:	89 81       	ldd	r24, Y+1	; 0x01
     fb4:	80 83       	st	Z, r24

	/* Wait for data to be transmitted */
	while (GET_BIT(UCSRA,TXC_PIN)==0);
     fb6:	eb e2       	ldi	r30, 0x2B	; 43
     fb8:	f0 e0       	ldi	r31, 0x00	; 0
     fba:	80 81       	ld	r24, Z
     fbc:	82 95       	swap	r24
     fbe:	86 95       	lsr	r24
     fc0:	86 95       	lsr	r24
     fc2:	83 70       	andi	r24, 0x03	; 3
     fc4:	88 2f       	mov	r24, r24
     fc6:	90 e0       	ldi	r25, 0x00	; 0
     fc8:	81 70       	andi	r24, 0x01	; 1
     fca:	90 70       	andi	r25, 0x00	; 0
     fcc:	00 97       	sbiw	r24, 0x00	; 0
     fce:	99 f3       	breq	.-26     	; 0xfb6 <MCAL_UART_UARTTransmit+0x2c>
	SET_BIT(UCSRA,TXC_PIN);
     fd0:	ab e2       	ldi	r26, 0x2B	; 43
     fd2:	b0 e0       	ldi	r27, 0x00	; 0
     fd4:	eb e2       	ldi	r30, 0x2B	; 43
     fd6:	f0 e0       	ldi	r31, 0x00	; 0
     fd8:	80 81       	ld	r24, Z
     fda:	80 64       	ori	r24, 0x40	; 64
     fdc:	8c 93       	st	X, r24

}
     fde:	0f 90       	pop	r0
     fe0:	cf 91       	pop	r28
     fe2:	df 91       	pop	r29
     fe4:	08 95       	ret

00000fe6 <MCAL_UART_UARTTransmitString>:
void MCAL_UART_UARTTransmitString(u8* Loc_u8data) {
     fe6:	df 93       	push	r29
     fe8:	cf 93       	push	r28
     fea:	00 d0       	rcall	.+0      	; 0xfec <MCAL_UART_UARTTransmitString+0x6>
     fec:	00 d0       	rcall	.+0      	; 0xfee <MCAL_UART_UARTTransmitString+0x8>
     fee:	00 d0       	rcall	.+0      	; 0xff0 <MCAL_UART_UARTTransmitString+0xa>
     ff0:	cd b7       	in	r28, 0x3d	; 61
     ff2:	de b7       	in	r29, 0x3e	; 62
     ff4:	9e 83       	std	Y+6, r25	; 0x06
     ff6:	8d 83       	std	Y+5, r24	; 0x05

	for(u32 i=0;i<10;i++){
     ff8:	19 82       	std	Y+1, r1	; 0x01
     ffa:	1a 82       	std	Y+2, r1	; 0x02
     ffc:	1b 82       	std	Y+3, r1	; 0x03
     ffe:	1c 82       	std	Y+4, r1	; 0x04
    1000:	15 c0       	rjmp	.+42     	; 0x102c <MCAL_UART_UARTTransmitString+0x46>
		MCAL_UART_UARTTransmit(Loc_u8data[i]);
    1002:	29 81       	ldd	r18, Y+1	; 0x01
    1004:	3a 81       	ldd	r19, Y+2	; 0x02
    1006:	8d 81       	ldd	r24, Y+5	; 0x05
    1008:	9e 81       	ldd	r25, Y+6	; 0x06
    100a:	fc 01       	movw	r30, r24
    100c:	e2 0f       	add	r30, r18
    100e:	f3 1f       	adc	r31, r19
    1010:	80 81       	ld	r24, Z
    1012:	0e 94 c5 07 	call	0xf8a	; 0xf8a <MCAL_UART_UARTTransmit>
	SET_BIT(UCSRA,TXC_PIN);

}
void MCAL_UART_UARTTransmitString(u8* Loc_u8data) {

	for(u32 i=0;i<10;i++){
    1016:	89 81       	ldd	r24, Y+1	; 0x01
    1018:	9a 81       	ldd	r25, Y+2	; 0x02
    101a:	ab 81       	ldd	r26, Y+3	; 0x03
    101c:	bc 81       	ldd	r27, Y+4	; 0x04
    101e:	01 96       	adiw	r24, 0x01	; 1
    1020:	a1 1d       	adc	r26, r1
    1022:	b1 1d       	adc	r27, r1
    1024:	89 83       	std	Y+1, r24	; 0x01
    1026:	9a 83       	std	Y+2, r25	; 0x02
    1028:	ab 83       	std	Y+3, r26	; 0x03
    102a:	bc 83       	std	Y+4, r27	; 0x04
    102c:	89 81       	ldd	r24, Y+1	; 0x01
    102e:	9a 81       	ldd	r25, Y+2	; 0x02
    1030:	ab 81       	ldd	r26, Y+3	; 0x03
    1032:	bc 81       	ldd	r27, Y+4	; 0x04
    1034:	8a 30       	cpi	r24, 0x0A	; 10
    1036:	91 05       	cpc	r25, r1
    1038:	a1 05       	cpc	r26, r1
    103a:	b1 05       	cpc	r27, r1
    103c:	10 f3       	brcs	.-60     	; 0x1002 <MCAL_UART_UARTTransmitString+0x1c>
		MCAL_UART_UARTTransmit(Loc_u8data[i]);
	}

}
    103e:	26 96       	adiw	r28, 0x06	; 6
    1040:	0f b6       	in	r0, 0x3f	; 63
    1042:	f8 94       	cli
    1044:	de bf       	out	0x3e, r29	; 62
    1046:	0f be       	out	0x3f, r0	; 63
    1048:	cd bf       	out	0x3d, r28	; 61
    104a:	cf 91       	pop	r28
    104c:	df 91       	pop	r29
    104e:	08 95       	ret

00001050 <MCAL_UART_UARTReceive>:

void MCAL_UART_UARTReceive(u8* Loc_u8data) {
    1050:	df 93       	push	r29
    1052:	cf 93       	push	r28
    1054:	00 d0       	rcall	.+0      	; 0x1056 <MCAL_UART_UARTReceive+0x6>
    1056:	cd b7       	in	r28, 0x3d	; 61
    1058:	de b7       	in	r29, 0x3e	; 62
    105a:	9a 83       	std	Y+2, r25	; 0x02
    105c:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for data to be received */
//	while (!(UCSRA & (1 << RXC_PIN)));
	while (GET_BIT(UCSRA,RXC_PIN)==0);
    105e:	eb e2       	ldi	r30, 0x2B	; 43
    1060:	f0 e0       	ldi	r31, 0x00	; 0
    1062:	80 81       	ld	r24, Z
    1064:	88 23       	and	r24, r24
    1066:	dc f7       	brge	.-10     	; 0x105e <MCAL_UART_UARTReceive+0xe>

	/* 	Save Received Data in Var-Loc_u8data */
	*Loc_u8data=UDR;
    1068:	ec e2       	ldi	r30, 0x2C	; 44
    106a:	f0 e0       	ldi	r31, 0x00	; 0
    106c:	80 81       	ld	r24, Z
    106e:	e9 81       	ldd	r30, Y+1	; 0x01
    1070:	fa 81       	ldd	r31, Y+2	; 0x02
    1072:	80 83       	st	Z, r24
}
    1074:	0f 90       	pop	r0
    1076:	0f 90       	pop	r0
    1078:	cf 91       	pop	r28
    107a:	df 91       	pop	r29
    107c:	08 95       	ret

0000107e <UART_voidInit>:
#include "UART_interface.h"
#include "UART_config.h"
#include "UART_private.h"

void UART_voidInit()
{
    107e:	df 93       	push	r29
    1080:	cf 93       	push	r28
    1082:	0f 92       	push	r0
    1084:	cd b7       	in	r28, 0x3d	; 61
    1086:	de b7       	in	r29, 0x3e	; 62
    u8 Local_u8CtrlCvalue = 0;
    1088:	19 82       	std	Y+1, r1	; 0x01
    SET_BIT(Local_u8CtrlCvalue, 7);
    108a:	89 81       	ldd	r24, Y+1	; 0x01
    108c:	80 68       	ori	r24, 0x80	; 128
    108e:	89 83       	std	Y+1, r24	; 0x01
    SET_BIT(Local_u8CtrlCvalue, 1);
    1090:	89 81       	ldd	r24, Y+1	; 0x01
    1092:	82 60       	ori	r24, 0x02	; 2
    1094:	89 83       	std	Y+1, r24	; 0x01
    SET_BIT(Local_u8CtrlCvalue, 2);
    1096:	89 81       	ldd	r24, Y+1	; 0x01
    1098:	84 60       	ori	r24, 0x04	; 4
    109a:	89 83       	std	Y+1, r24	; 0x01
    CLR_BIT(Local_u8CtrlCvalue, 3);
    109c:	89 81       	ldd	r24, Y+1	; 0x01
    109e:	87 7f       	andi	r24, 0xF7	; 247
    10a0:	89 83       	std	Y+1, r24	; 0x01
    UCSRC = Local_u8CtrlCvalue;
    10a2:	e0 e4       	ldi	r30, 0x40	; 64
    10a4:	f0 e0       	ldi	r31, 0x00	; 0
    10a6:	89 81       	ldd	r24, Y+1	; 0x01
    10a8:	80 83       	st	Z, r24
    // NO INT
    // NO PARITY
    // UART
    // 9600 BaudRate
    UBRRL = 51;
    10aa:	e9 e2       	ldi	r30, 0x29	; 41
    10ac:	f0 e0       	ldi	r31, 0x00	; 0
    10ae:	83 e3       	ldi	r24, 0x33	; 51
    10b0:	80 83       	st	Z, r24
    // Ch size -> 8 bits
    CLR_BIT(UCSRB, 2);
    10b2:	aa e2       	ldi	r26, 0x2A	; 42
    10b4:	b0 e0       	ldi	r27, 0x00	; 0
    10b6:	ea e2       	ldi	r30, 0x2A	; 42
    10b8:	f0 e0       	ldi	r31, 0x00	; 0
    10ba:	80 81       	ld	r24, Z
    10bc:	8b 7f       	andi	r24, 0xFB	; 251
    10be:	8c 93       	st	X, r24
    // Full duplex
    SET_BIT(UCSRB, 3);
    10c0:	aa e2       	ldi	r26, 0x2A	; 42
    10c2:	b0 e0       	ldi	r27, 0x00	; 0
    10c4:	ea e2       	ldi	r30, 0x2A	; 42
    10c6:	f0 e0       	ldi	r31, 0x00	; 0
    10c8:	80 81       	ld	r24, Z
    10ca:	88 60       	ori	r24, 0x08	; 8
    10cc:	8c 93       	st	X, r24
    SET_BIT(UCSRB, 4);
    10ce:	aa e2       	ldi	r26, 0x2A	; 42
    10d0:	b0 e0       	ldi	r27, 0x00	; 0
    10d2:	ea e2       	ldi	r30, 0x2A	; 42
    10d4:	f0 e0       	ldi	r31, 0x00	; 0
    10d6:	80 81       	ld	r24, Z
    10d8:	80 61       	ori	r24, 0x10	; 16
    10da:	8c 93       	st	X, r24
}
    10dc:	0f 90       	pop	r0
    10de:	cf 91       	pop	r28
    10e0:	df 91       	pop	r29
    10e2:	08 95       	ret

000010e4 <UART_voidSendData>:

void UART_voidSendData(u8 Copy_u8Data)
{
    10e4:	df 93       	push	r29
    10e6:	cf 93       	push	r28
    10e8:	0f 92       	push	r0
    10ea:	cd b7       	in	r28, 0x3d	; 61
    10ec:	de b7       	in	r29, 0x3e	; 62
    10ee:	89 83       	std	Y+1, r24	; 0x01
    // Polling UDRE -> Send Data
    while (!GET_BIT(UCSRA, 5));
    10f0:	eb e2       	ldi	r30, 0x2B	; 43
    10f2:	f0 e0       	ldi	r31, 0x00	; 0
    10f4:	80 81       	ld	r24, Z
    10f6:	82 95       	swap	r24
    10f8:	86 95       	lsr	r24
    10fa:	87 70       	andi	r24, 0x07	; 7
    10fc:	88 2f       	mov	r24, r24
    10fe:	90 e0       	ldi	r25, 0x00	; 0
    1100:	81 70       	andi	r24, 0x01	; 1
    1102:	90 70       	andi	r25, 0x00	; 0
    1104:	00 97       	sbiw	r24, 0x00	; 0
    1106:	a1 f3       	breq	.-24     	; 0x10f0 <UART_voidSendData+0xc>
    UDR = Copy_u8Data;
    1108:	ec e2       	ldi	r30, 0x2C	; 44
    110a:	f0 e0       	ldi	r31, 0x00	; 0
    110c:	89 81       	ldd	r24, Y+1	; 0x01
    110e:	80 83       	st	Z, r24
}
    1110:	0f 90       	pop	r0
    1112:	cf 91       	pop	r28
    1114:	df 91       	pop	r29
    1116:	08 95       	ret

00001118 <UART_u8ReceiveData>:

u8 UART_u8ReceiveData()
{
    1118:	df 93       	push	r29
    111a:	cf 93       	push	r28
    111c:	cd b7       	in	r28, 0x3d	; 61
    111e:	de b7       	in	r29, 0x3e	; 62
    while (!GET_BIT(UCSRA, 7));
    1120:	eb e2       	ldi	r30, 0x2B	; 43
    1122:	f0 e0       	ldi	r31, 0x00	; 0
    1124:	80 81       	ld	r24, Z
    1126:	88 23       	and	r24, r24
    1128:	dc f7       	brge	.-10     	; 0x1120 <UART_u8ReceiveData+0x8>
    return UDR;
    112a:	ec e2       	ldi	r30, 0x2C	; 44
    112c:	f0 e0       	ldi	r31, 0x00	; 0
    112e:	80 81       	ld	r24, Z
}
    1130:	cf 91       	pop	r28
    1132:	df 91       	pop	r29
    1134:	08 95       	ret

00001136 <UART_voidSendNumber>:

void UART_voidSendNumber(u32 Copy_u32Number)
{
    1136:	0f 93       	push	r16
    1138:	1f 93       	push	r17
    113a:	df 93       	push	r29
    113c:	cf 93       	push	r28
    113e:	cd b7       	in	r28, 0x3d	; 61
    1140:	de b7       	in	r29, 0x3e	; 62
    1142:	60 97       	sbiw	r28, 0x10	; 16
    1144:	0f b6       	in	r0, 0x3f	; 63
    1146:	f8 94       	cli
    1148:	de bf       	out	0x3e, r29	; 62
    114a:	0f be       	out	0x3f, r0	; 63
    114c:	cd bf       	out	0x3d, r28	; 61
    114e:	6d 87       	std	Y+13, r22	; 0x0d
    1150:	7e 87       	std	Y+14, r23	; 0x0e
    1152:	8f 87       	std	Y+15, r24	; 0x0f
    1154:	98 8b       	std	Y+16, r25	; 0x10
    char buffer[11]; // Enough for 10 digits + null terminator for u32
    u8 i = 0;
    1156:	19 82       	std	Y+1, r1	; 0x01

    // Convert number to string
    if (Copy_u32Number == 0)
    1158:	8d 85       	ldd	r24, Y+13	; 0x0d
    115a:	9e 85       	ldd	r25, Y+14	; 0x0e
    115c:	af 85       	ldd	r26, Y+15	; 0x0f
    115e:	b8 89       	ldd	r27, Y+16	; 0x10
    1160:	00 97       	sbiw	r24, 0x00	; 0
    1162:	a1 05       	cpc	r26, r1
    1164:	b1 05       	cpc	r27, r1
    1166:	91 f5       	brne	.+100    	; 0x11cc <UART_voidSendNumber+0x96>
    {
        UART_voidSendData('0');
    1168:	80 e3       	ldi	r24, 0x30	; 48
    116a:	0e 94 72 08 	call	0x10e4	; 0x10e4 <UART_voidSendData>
    116e:	48 c0       	rjmp	.+144    	; 0x1200 <UART_voidSendNumber+0xca>
        return;
    }

    while (Copy_u32Number > 0)
    {
        buffer[i++] = (Copy_u32Number % 10) + '0'; // Convert digit to ASCII
    1170:	89 81       	ldd	r24, Y+1	; 0x01
    1172:	08 2f       	mov	r16, r24
    1174:	10 e0       	ldi	r17, 0x00	; 0
    1176:	8d 85       	ldd	r24, Y+13	; 0x0d
    1178:	9e 85       	ldd	r25, Y+14	; 0x0e
    117a:	af 85       	ldd	r26, Y+15	; 0x0f
    117c:	b8 89       	ldd	r27, Y+16	; 0x10
    117e:	2a e0       	ldi	r18, 0x0A	; 10
    1180:	30 e0       	ldi	r19, 0x00	; 0
    1182:	40 e0       	ldi	r20, 0x00	; 0
    1184:	50 e0       	ldi	r21, 0x00	; 0
    1186:	bc 01       	movw	r22, r24
    1188:	cd 01       	movw	r24, r26
    118a:	0e 94 0c 38 	call	0x7018	; 0x7018 <__udivmodsi4>
    118e:	dc 01       	movw	r26, r24
    1190:	cb 01       	movw	r24, r22
    1192:	28 2f       	mov	r18, r24
    1194:	20 5d       	subi	r18, 0xD0	; 208
    1196:	ce 01       	movw	r24, r28
    1198:	02 96       	adiw	r24, 0x02	; 2
    119a:	fc 01       	movw	r30, r24
    119c:	e0 0f       	add	r30, r16
    119e:	f1 1f       	adc	r31, r17
    11a0:	20 83       	st	Z, r18
    11a2:	89 81       	ldd	r24, Y+1	; 0x01
    11a4:	8f 5f       	subi	r24, 0xFF	; 255
    11a6:	89 83       	std	Y+1, r24	; 0x01
        Copy_u32Number /= 10;
    11a8:	8d 85       	ldd	r24, Y+13	; 0x0d
    11aa:	9e 85       	ldd	r25, Y+14	; 0x0e
    11ac:	af 85       	ldd	r26, Y+15	; 0x0f
    11ae:	b8 89       	ldd	r27, Y+16	; 0x10
    11b0:	2a e0       	ldi	r18, 0x0A	; 10
    11b2:	30 e0       	ldi	r19, 0x00	; 0
    11b4:	40 e0       	ldi	r20, 0x00	; 0
    11b6:	50 e0       	ldi	r21, 0x00	; 0
    11b8:	bc 01       	movw	r22, r24
    11ba:	cd 01       	movw	r24, r26
    11bc:	0e 94 0c 38 	call	0x7018	; 0x7018 <__udivmodsi4>
    11c0:	da 01       	movw	r26, r20
    11c2:	c9 01       	movw	r24, r18
    11c4:	8d 87       	std	Y+13, r24	; 0x0d
    11c6:	9e 87       	std	Y+14, r25	; 0x0e
    11c8:	af 87       	std	Y+15, r26	; 0x0f
    11ca:	b8 8b       	std	Y+16, r27	; 0x10
    {
        UART_voidSendData('0');
        return;
    }

    while (Copy_u32Number > 0)
    11cc:	8d 85       	ldd	r24, Y+13	; 0x0d
    11ce:	9e 85       	ldd	r25, Y+14	; 0x0e
    11d0:	af 85       	ldd	r26, Y+15	; 0x0f
    11d2:	b8 89       	ldd	r27, Y+16	; 0x10
    11d4:	00 97       	sbiw	r24, 0x00	; 0
    11d6:	a1 05       	cpc	r26, r1
    11d8:	b1 05       	cpc	r27, r1
    11da:	51 f6       	brne	.-108    	; 0x1170 <UART_voidSendNumber+0x3a>
    11dc:	0e c0       	rjmp	.+28     	; 0x11fa <UART_voidSendNumber+0xc4>
    }

    // Send digits in correct order (reverse the string)
    while (i > 0)
    {
        UART_voidSendData(buffer[--i]);
    11de:	89 81       	ldd	r24, Y+1	; 0x01
    11e0:	81 50       	subi	r24, 0x01	; 1
    11e2:	89 83       	std	Y+1, r24	; 0x01
    11e4:	89 81       	ldd	r24, Y+1	; 0x01
    11e6:	28 2f       	mov	r18, r24
    11e8:	30 e0       	ldi	r19, 0x00	; 0
    11ea:	ce 01       	movw	r24, r28
    11ec:	02 96       	adiw	r24, 0x02	; 2
    11ee:	fc 01       	movw	r30, r24
    11f0:	e2 0f       	add	r30, r18
    11f2:	f3 1f       	adc	r31, r19
    11f4:	80 81       	ld	r24, Z
    11f6:	0e 94 72 08 	call	0x10e4	; 0x10e4 <UART_voidSendData>
        buffer[i++] = (Copy_u32Number % 10) + '0'; // Convert digit to ASCII
        Copy_u32Number /= 10;
    }

    // Send digits in correct order (reverse the string)
    while (i > 0)
    11fa:	89 81       	ldd	r24, Y+1	; 0x01
    11fc:	88 23       	and	r24, r24
    11fe:	79 f7       	brne	.-34     	; 0x11de <UART_voidSendNumber+0xa8>
    {
        UART_voidSendData(buffer[--i]);
    }
}
    1200:	60 96       	adiw	r28, 0x10	; 16
    1202:	0f b6       	in	r0, 0x3f	; 63
    1204:	f8 94       	cli
    1206:	de bf       	out	0x3e, r29	; 62
    1208:	0f be       	out	0x3f, r0	; 63
    120a:	cd bf       	out	0x3d, r28	; 61
    120c:	cf 91       	pop	r28
    120e:	df 91       	pop	r29
    1210:	1f 91       	pop	r17
    1212:	0f 91       	pop	r16
    1214:	08 95       	ret

00001216 <MCAL_T1_u8T1Init>:
 *  Created on: Oct 22, 2023
 *      Author: TOP_WORLD
 */
#include "Timer1.h"
void (*Gptr_3)(void)='\0';
u8 MCAL_T1_u8T1Init(u8 LOC_u8Timer1Mode) {
    1216:	df 93       	push	r29
    1218:	cf 93       	push	r28
    121a:	00 d0       	rcall	.+0      	; 0x121c <MCAL_T1_u8T1Init+0x6>
    121c:	cd b7       	in	r28, 0x3d	; 61
    121e:	de b7       	in	r29, 0x3e	; 62
    1220:	8a 83       	std	Y+2, r24	; 0x02
	u8 LOC_u8ReturnValue = E_NOT_OK;
    1222:	81 e0       	ldi	r24, 0x01	; 1
    1224:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_u8Timer1Mode <= FAST_PWM_OCR1A) {
    1226:	8a 81       	ldd	r24, Y+2	; 0x02
    1228:	80 31       	cpi	r24, 0x10	; 16
    122a:	08 f0       	brcs	.+2      	; 0x122e <MCAL_T1_u8T1Init+0x18>
    122c:	0f c2       	rjmp	.+1054   	; 0x164c <MCAL_T1_u8T1Init+0x436>
		if (LOC_u8Timer1Mode == NORMAL_MODE) {
    122e:	8a 81       	ldd	r24, Y+2	; 0x02
    1230:	88 23       	and	r24, r24
    1232:	f1 f4       	brne	.+60     	; 0x1270 <MCAL_T1_u8T1Init+0x5a>
			CLR_BIT(TCCR1A, PIN0);
    1234:	af e4       	ldi	r26, 0x4F	; 79
    1236:	b0 e0       	ldi	r27, 0x00	; 0
    1238:	ef e4       	ldi	r30, 0x4F	; 79
    123a:	f0 e0       	ldi	r31, 0x00	; 0
    123c:	80 81       	ld	r24, Z
    123e:	8e 7f       	andi	r24, 0xFE	; 254
    1240:	8c 93       	st	X, r24
			CLR_BIT(TCCR1A, PIN1);
    1242:	af e4       	ldi	r26, 0x4F	; 79
    1244:	b0 e0       	ldi	r27, 0x00	; 0
    1246:	ef e4       	ldi	r30, 0x4F	; 79
    1248:	f0 e0       	ldi	r31, 0x00	; 0
    124a:	80 81       	ld	r24, Z
    124c:	8d 7f       	andi	r24, 0xFD	; 253
    124e:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN3);
    1250:	ae e4       	ldi	r26, 0x4E	; 78
    1252:	b0 e0       	ldi	r27, 0x00	; 0
    1254:	ee e4       	ldi	r30, 0x4E	; 78
    1256:	f0 e0       	ldi	r31, 0x00	; 0
    1258:	80 81       	ld	r24, Z
    125a:	87 7f       	andi	r24, 0xF7	; 247
    125c:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN4);
    125e:	ae e4       	ldi	r26, 0x4E	; 78
    1260:	b0 e0       	ldi	r27, 0x00	; 0
    1262:	ee e4       	ldi	r30, 0x4E	; 78
    1264:	f0 e0       	ldi	r31, 0x00	; 0
    1266:	80 81       	ld	r24, Z
    1268:	8f 7e       	andi	r24, 0xEF	; 239
    126a:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    126c:	19 82       	std	Y+1, r1	; 0x01
    126e:	ee c1       	rjmp	.+988    	; 0x164c <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == PWM_PHASE_CORRECT_8bit) {
    1270:	8a 81       	ldd	r24, Y+2	; 0x02
    1272:	81 30       	cpi	r24, 0x01	; 1
    1274:	f1 f4       	brne	.+60     	; 0x12b2 <MCAL_T1_u8T1Init+0x9c>
			SET_BIT(TCCR1A, PIN0);
    1276:	af e4       	ldi	r26, 0x4F	; 79
    1278:	b0 e0       	ldi	r27, 0x00	; 0
    127a:	ef e4       	ldi	r30, 0x4F	; 79
    127c:	f0 e0       	ldi	r31, 0x00	; 0
    127e:	80 81       	ld	r24, Z
    1280:	81 60       	ori	r24, 0x01	; 1
    1282:	8c 93       	st	X, r24
			CLR_BIT(TCCR1A, PIN1);
    1284:	af e4       	ldi	r26, 0x4F	; 79
    1286:	b0 e0       	ldi	r27, 0x00	; 0
    1288:	ef e4       	ldi	r30, 0x4F	; 79
    128a:	f0 e0       	ldi	r31, 0x00	; 0
    128c:	80 81       	ld	r24, Z
    128e:	8d 7f       	andi	r24, 0xFD	; 253
    1290:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN3);
    1292:	ae e4       	ldi	r26, 0x4E	; 78
    1294:	b0 e0       	ldi	r27, 0x00	; 0
    1296:	ee e4       	ldi	r30, 0x4E	; 78
    1298:	f0 e0       	ldi	r31, 0x00	; 0
    129a:	80 81       	ld	r24, Z
    129c:	87 7f       	andi	r24, 0xF7	; 247
    129e:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN4);
    12a0:	ae e4       	ldi	r26, 0x4E	; 78
    12a2:	b0 e0       	ldi	r27, 0x00	; 0
    12a4:	ee e4       	ldi	r30, 0x4E	; 78
    12a6:	f0 e0       	ldi	r31, 0x00	; 0
    12a8:	80 81       	ld	r24, Z
    12aa:	8f 7e       	andi	r24, 0xEF	; 239
    12ac:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    12ae:	19 82       	std	Y+1, r1	; 0x01
    12b0:	cd c1       	rjmp	.+922    	; 0x164c <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == PWM_PHASE_CORRECT_9bit) {
    12b2:	8a 81       	ldd	r24, Y+2	; 0x02
    12b4:	82 30       	cpi	r24, 0x02	; 2
    12b6:	f1 f4       	brne	.+60     	; 0x12f4 <MCAL_T1_u8T1Init+0xde>
			CLR_BIT(TCCR1A, PIN0);
    12b8:	af e4       	ldi	r26, 0x4F	; 79
    12ba:	b0 e0       	ldi	r27, 0x00	; 0
    12bc:	ef e4       	ldi	r30, 0x4F	; 79
    12be:	f0 e0       	ldi	r31, 0x00	; 0
    12c0:	80 81       	ld	r24, Z
    12c2:	8e 7f       	andi	r24, 0xFE	; 254
    12c4:	8c 93       	st	X, r24
			SET_BIT(TCCR1A, PIN1);
    12c6:	af e4       	ldi	r26, 0x4F	; 79
    12c8:	b0 e0       	ldi	r27, 0x00	; 0
    12ca:	ef e4       	ldi	r30, 0x4F	; 79
    12cc:	f0 e0       	ldi	r31, 0x00	; 0
    12ce:	80 81       	ld	r24, Z
    12d0:	82 60       	ori	r24, 0x02	; 2
    12d2:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN3);
    12d4:	ae e4       	ldi	r26, 0x4E	; 78
    12d6:	b0 e0       	ldi	r27, 0x00	; 0
    12d8:	ee e4       	ldi	r30, 0x4E	; 78
    12da:	f0 e0       	ldi	r31, 0x00	; 0
    12dc:	80 81       	ld	r24, Z
    12de:	87 7f       	andi	r24, 0xF7	; 247
    12e0:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN4);
    12e2:	ae e4       	ldi	r26, 0x4E	; 78
    12e4:	b0 e0       	ldi	r27, 0x00	; 0
    12e6:	ee e4       	ldi	r30, 0x4E	; 78
    12e8:	f0 e0       	ldi	r31, 0x00	; 0
    12ea:	80 81       	ld	r24, Z
    12ec:	8f 7e       	andi	r24, 0xEF	; 239
    12ee:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    12f0:	19 82       	std	Y+1, r1	; 0x01
    12f2:	ac c1       	rjmp	.+856    	; 0x164c <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == PWM_PHASE_CORRECT_10bit) {
    12f4:	8a 81       	ldd	r24, Y+2	; 0x02
    12f6:	83 30       	cpi	r24, 0x03	; 3
    12f8:	f1 f4       	brne	.+60     	; 0x1336 <MCAL_T1_u8T1Init+0x120>
			SET_BIT(TCCR1A, PIN0);
    12fa:	af e4       	ldi	r26, 0x4F	; 79
    12fc:	b0 e0       	ldi	r27, 0x00	; 0
    12fe:	ef e4       	ldi	r30, 0x4F	; 79
    1300:	f0 e0       	ldi	r31, 0x00	; 0
    1302:	80 81       	ld	r24, Z
    1304:	81 60       	ori	r24, 0x01	; 1
    1306:	8c 93       	st	X, r24
			SET_BIT(TCCR1A, PIN1);
    1308:	af e4       	ldi	r26, 0x4F	; 79
    130a:	b0 e0       	ldi	r27, 0x00	; 0
    130c:	ef e4       	ldi	r30, 0x4F	; 79
    130e:	f0 e0       	ldi	r31, 0x00	; 0
    1310:	80 81       	ld	r24, Z
    1312:	82 60       	ori	r24, 0x02	; 2
    1314:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN3);
    1316:	ae e4       	ldi	r26, 0x4E	; 78
    1318:	b0 e0       	ldi	r27, 0x00	; 0
    131a:	ee e4       	ldi	r30, 0x4E	; 78
    131c:	f0 e0       	ldi	r31, 0x00	; 0
    131e:	80 81       	ld	r24, Z
    1320:	87 7f       	andi	r24, 0xF7	; 247
    1322:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN4);
    1324:	ae e4       	ldi	r26, 0x4E	; 78
    1326:	b0 e0       	ldi	r27, 0x00	; 0
    1328:	ee e4       	ldi	r30, 0x4E	; 78
    132a:	f0 e0       	ldi	r31, 0x00	; 0
    132c:	80 81       	ld	r24, Z
    132e:	8f 7e       	andi	r24, 0xEF	; 239
    1330:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    1332:	19 82       	std	Y+1, r1	; 0x01
    1334:	8b c1       	rjmp	.+790    	; 0x164c <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == CTC_OCR1A) {
    1336:	8a 81       	ldd	r24, Y+2	; 0x02
    1338:	84 30       	cpi	r24, 0x04	; 4
    133a:	f1 f4       	brne	.+60     	; 0x1378 <MCAL_T1_u8T1Init+0x162>
			CLR_BIT(TCCR1A, PIN0);
    133c:	af e4       	ldi	r26, 0x4F	; 79
    133e:	b0 e0       	ldi	r27, 0x00	; 0
    1340:	ef e4       	ldi	r30, 0x4F	; 79
    1342:	f0 e0       	ldi	r31, 0x00	; 0
    1344:	80 81       	ld	r24, Z
    1346:	8e 7f       	andi	r24, 0xFE	; 254
    1348:	8c 93       	st	X, r24
			CLR_BIT(TCCR1A, PIN1);
    134a:	af e4       	ldi	r26, 0x4F	; 79
    134c:	b0 e0       	ldi	r27, 0x00	; 0
    134e:	ef e4       	ldi	r30, 0x4F	; 79
    1350:	f0 e0       	ldi	r31, 0x00	; 0
    1352:	80 81       	ld	r24, Z
    1354:	8d 7f       	andi	r24, 0xFD	; 253
    1356:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN3);
    1358:	ae e4       	ldi	r26, 0x4E	; 78
    135a:	b0 e0       	ldi	r27, 0x00	; 0
    135c:	ee e4       	ldi	r30, 0x4E	; 78
    135e:	f0 e0       	ldi	r31, 0x00	; 0
    1360:	80 81       	ld	r24, Z
    1362:	88 60       	ori	r24, 0x08	; 8
    1364:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN4);
    1366:	ae e4       	ldi	r26, 0x4E	; 78
    1368:	b0 e0       	ldi	r27, 0x00	; 0
    136a:	ee e4       	ldi	r30, 0x4E	; 78
    136c:	f0 e0       	ldi	r31, 0x00	; 0
    136e:	80 81       	ld	r24, Z
    1370:	8f 7e       	andi	r24, 0xEF	; 239
    1372:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    1374:	19 82       	std	Y+1, r1	; 0x01
    1376:	6a c1       	rjmp	.+724    	; 0x164c <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == FAST_PWM_8bit) {
    1378:	8a 81       	ldd	r24, Y+2	; 0x02
    137a:	85 30       	cpi	r24, 0x05	; 5
    137c:	f1 f4       	brne	.+60     	; 0x13ba <MCAL_T1_u8T1Init+0x1a4>
			SET_BIT(TCCR1A, PIN0);
    137e:	af e4       	ldi	r26, 0x4F	; 79
    1380:	b0 e0       	ldi	r27, 0x00	; 0
    1382:	ef e4       	ldi	r30, 0x4F	; 79
    1384:	f0 e0       	ldi	r31, 0x00	; 0
    1386:	80 81       	ld	r24, Z
    1388:	81 60       	ori	r24, 0x01	; 1
    138a:	8c 93       	st	X, r24
			CLR_BIT(TCCR1A, PIN1);
    138c:	af e4       	ldi	r26, 0x4F	; 79
    138e:	b0 e0       	ldi	r27, 0x00	; 0
    1390:	ef e4       	ldi	r30, 0x4F	; 79
    1392:	f0 e0       	ldi	r31, 0x00	; 0
    1394:	80 81       	ld	r24, Z
    1396:	8d 7f       	andi	r24, 0xFD	; 253
    1398:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN3);
    139a:	ae e4       	ldi	r26, 0x4E	; 78
    139c:	b0 e0       	ldi	r27, 0x00	; 0
    139e:	ee e4       	ldi	r30, 0x4E	; 78
    13a0:	f0 e0       	ldi	r31, 0x00	; 0
    13a2:	80 81       	ld	r24, Z
    13a4:	88 60       	ori	r24, 0x08	; 8
    13a6:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN4);
    13a8:	ae e4       	ldi	r26, 0x4E	; 78
    13aa:	b0 e0       	ldi	r27, 0x00	; 0
    13ac:	ee e4       	ldi	r30, 0x4E	; 78
    13ae:	f0 e0       	ldi	r31, 0x00	; 0
    13b0:	80 81       	ld	r24, Z
    13b2:	8f 7e       	andi	r24, 0xEF	; 239
    13b4:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    13b6:	19 82       	std	Y+1, r1	; 0x01
    13b8:	49 c1       	rjmp	.+658    	; 0x164c <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == FAST_PWM_9bit) {
    13ba:	8a 81       	ldd	r24, Y+2	; 0x02
    13bc:	86 30       	cpi	r24, 0x06	; 6
    13be:	f1 f4       	brne	.+60     	; 0x13fc <MCAL_T1_u8T1Init+0x1e6>
			CLR_BIT(TCCR1A, PIN0);
    13c0:	af e4       	ldi	r26, 0x4F	; 79
    13c2:	b0 e0       	ldi	r27, 0x00	; 0
    13c4:	ef e4       	ldi	r30, 0x4F	; 79
    13c6:	f0 e0       	ldi	r31, 0x00	; 0
    13c8:	80 81       	ld	r24, Z
    13ca:	8e 7f       	andi	r24, 0xFE	; 254
    13cc:	8c 93       	st	X, r24
			SET_BIT(TCCR1A, PIN1);
    13ce:	af e4       	ldi	r26, 0x4F	; 79
    13d0:	b0 e0       	ldi	r27, 0x00	; 0
    13d2:	ef e4       	ldi	r30, 0x4F	; 79
    13d4:	f0 e0       	ldi	r31, 0x00	; 0
    13d6:	80 81       	ld	r24, Z
    13d8:	82 60       	ori	r24, 0x02	; 2
    13da:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN3);
    13dc:	ae e4       	ldi	r26, 0x4E	; 78
    13de:	b0 e0       	ldi	r27, 0x00	; 0
    13e0:	ee e4       	ldi	r30, 0x4E	; 78
    13e2:	f0 e0       	ldi	r31, 0x00	; 0
    13e4:	80 81       	ld	r24, Z
    13e6:	88 60       	ori	r24, 0x08	; 8
    13e8:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN4);
    13ea:	ae e4       	ldi	r26, 0x4E	; 78
    13ec:	b0 e0       	ldi	r27, 0x00	; 0
    13ee:	ee e4       	ldi	r30, 0x4E	; 78
    13f0:	f0 e0       	ldi	r31, 0x00	; 0
    13f2:	80 81       	ld	r24, Z
    13f4:	8f 7e       	andi	r24, 0xEF	; 239
    13f6:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    13f8:	19 82       	std	Y+1, r1	; 0x01
    13fa:	28 c1       	rjmp	.+592    	; 0x164c <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == FAST_PWM_10bit) {
    13fc:	8a 81       	ldd	r24, Y+2	; 0x02
    13fe:	87 30       	cpi	r24, 0x07	; 7
    1400:	f1 f4       	brne	.+60     	; 0x143e <MCAL_T1_u8T1Init+0x228>
			SET_BIT(TCCR1A, PIN0);
    1402:	af e4       	ldi	r26, 0x4F	; 79
    1404:	b0 e0       	ldi	r27, 0x00	; 0
    1406:	ef e4       	ldi	r30, 0x4F	; 79
    1408:	f0 e0       	ldi	r31, 0x00	; 0
    140a:	80 81       	ld	r24, Z
    140c:	81 60       	ori	r24, 0x01	; 1
    140e:	8c 93       	st	X, r24
			SET_BIT(TCCR1A, PIN1);
    1410:	af e4       	ldi	r26, 0x4F	; 79
    1412:	b0 e0       	ldi	r27, 0x00	; 0
    1414:	ef e4       	ldi	r30, 0x4F	; 79
    1416:	f0 e0       	ldi	r31, 0x00	; 0
    1418:	80 81       	ld	r24, Z
    141a:	82 60       	ori	r24, 0x02	; 2
    141c:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN3);
    141e:	ae e4       	ldi	r26, 0x4E	; 78
    1420:	b0 e0       	ldi	r27, 0x00	; 0
    1422:	ee e4       	ldi	r30, 0x4E	; 78
    1424:	f0 e0       	ldi	r31, 0x00	; 0
    1426:	80 81       	ld	r24, Z
    1428:	88 60       	ori	r24, 0x08	; 8
    142a:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN4);
    142c:	ae e4       	ldi	r26, 0x4E	; 78
    142e:	b0 e0       	ldi	r27, 0x00	; 0
    1430:	ee e4       	ldi	r30, 0x4E	; 78
    1432:	f0 e0       	ldi	r31, 0x00	; 0
    1434:	80 81       	ld	r24, Z
    1436:	8f 7e       	andi	r24, 0xEF	; 239
    1438:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    143a:	19 82       	std	Y+1, r1	; 0x01
    143c:	07 c1       	rjmp	.+526    	; 0x164c <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == PWM_PHASE_AND_FREQUANCY_CORRECT_ICR1) {
    143e:	8a 81       	ldd	r24, Y+2	; 0x02
    1440:	88 30       	cpi	r24, 0x08	; 8
    1442:	f1 f4       	brne	.+60     	; 0x1480 <MCAL_T1_u8T1Init+0x26a>
			CLR_BIT(TCCR1A, PIN0);
    1444:	af e4       	ldi	r26, 0x4F	; 79
    1446:	b0 e0       	ldi	r27, 0x00	; 0
    1448:	ef e4       	ldi	r30, 0x4F	; 79
    144a:	f0 e0       	ldi	r31, 0x00	; 0
    144c:	80 81       	ld	r24, Z
    144e:	8e 7f       	andi	r24, 0xFE	; 254
    1450:	8c 93       	st	X, r24
			CLR_BIT(TCCR1A, PIN1);
    1452:	af e4       	ldi	r26, 0x4F	; 79
    1454:	b0 e0       	ldi	r27, 0x00	; 0
    1456:	ef e4       	ldi	r30, 0x4F	; 79
    1458:	f0 e0       	ldi	r31, 0x00	; 0
    145a:	80 81       	ld	r24, Z
    145c:	8d 7f       	andi	r24, 0xFD	; 253
    145e:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN3);
    1460:	ae e4       	ldi	r26, 0x4E	; 78
    1462:	b0 e0       	ldi	r27, 0x00	; 0
    1464:	ee e4       	ldi	r30, 0x4E	; 78
    1466:	f0 e0       	ldi	r31, 0x00	; 0
    1468:	80 81       	ld	r24, Z
    146a:	87 7f       	andi	r24, 0xF7	; 247
    146c:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN4);
    146e:	ae e4       	ldi	r26, 0x4E	; 78
    1470:	b0 e0       	ldi	r27, 0x00	; 0
    1472:	ee e4       	ldi	r30, 0x4E	; 78
    1474:	f0 e0       	ldi	r31, 0x00	; 0
    1476:	80 81       	ld	r24, Z
    1478:	80 61       	ori	r24, 0x10	; 16
    147a:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    147c:	19 82       	std	Y+1, r1	; 0x01
    147e:	e6 c0       	rjmp	.+460    	; 0x164c <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == PWM_PHASE_AND_FREQUANCY_CORRECT_OCR1A) {
    1480:	8a 81       	ldd	r24, Y+2	; 0x02
    1482:	89 30       	cpi	r24, 0x09	; 9
    1484:	f1 f4       	brne	.+60     	; 0x14c2 <MCAL_T1_u8T1Init+0x2ac>
			SET_BIT(TCCR1A, PIN0);
    1486:	af e4       	ldi	r26, 0x4F	; 79
    1488:	b0 e0       	ldi	r27, 0x00	; 0
    148a:	ef e4       	ldi	r30, 0x4F	; 79
    148c:	f0 e0       	ldi	r31, 0x00	; 0
    148e:	80 81       	ld	r24, Z
    1490:	81 60       	ori	r24, 0x01	; 1
    1492:	8c 93       	st	X, r24
			CLR_BIT(TCCR1A, PIN1);
    1494:	af e4       	ldi	r26, 0x4F	; 79
    1496:	b0 e0       	ldi	r27, 0x00	; 0
    1498:	ef e4       	ldi	r30, 0x4F	; 79
    149a:	f0 e0       	ldi	r31, 0x00	; 0
    149c:	80 81       	ld	r24, Z
    149e:	8d 7f       	andi	r24, 0xFD	; 253
    14a0:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN3);
    14a2:	ae e4       	ldi	r26, 0x4E	; 78
    14a4:	b0 e0       	ldi	r27, 0x00	; 0
    14a6:	ee e4       	ldi	r30, 0x4E	; 78
    14a8:	f0 e0       	ldi	r31, 0x00	; 0
    14aa:	80 81       	ld	r24, Z
    14ac:	87 7f       	andi	r24, 0xF7	; 247
    14ae:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN4);
    14b0:	ae e4       	ldi	r26, 0x4E	; 78
    14b2:	b0 e0       	ldi	r27, 0x00	; 0
    14b4:	ee e4       	ldi	r30, 0x4E	; 78
    14b6:	f0 e0       	ldi	r31, 0x00	; 0
    14b8:	80 81       	ld	r24, Z
    14ba:	80 61       	ori	r24, 0x10	; 16
    14bc:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    14be:	19 82       	std	Y+1, r1	; 0x01
    14c0:	c5 c0       	rjmp	.+394    	; 0x164c <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == PWM_PHASE_CORRECT_ICR1) {
    14c2:	8a 81       	ldd	r24, Y+2	; 0x02
    14c4:	8a 30       	cpi	r24, 0x0A	; 10
    14c6:	f1 f4       	brne	.+60     	; 0x1504 <MCAL_T1_u8T1Init+0x2ee>
			CLR_BIT(TCCR1A, PIN0);
    14c8:	af e4       	ldi	r26, 0x4F	; 79
    14ca:	b0 e0       	ldi	r27, 0x00	; 0
    14cc:	ef e4       	ldi	r30, 0x4F	; 79
    14ce:	f0 e0       	ldi	r31, 0x00	; 0
    14d0:	80 81       	ld	r24, Z
    14d2:	8e 7f       	andi	r24, 0xFE	; 254
    14d4:	8c 93       	st	X, r24
			SET_BIT(TCCR1A, PIN1);
    14d6:	af e4       	ldi	r26, 0x4F	; 79
    14d8:	b0 e0       	ldi	r27, 0x00	; 0
    14da:	ef e4       	ldi	r30, 0x4F	; 79
    14dc:	f0 e0       	ldi	r31, 0x00	; 0
    14de:	80 81       	ld	r24, Z
    14e0:	82 60       	ori	r24, 0x02	; 2
    14e2:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN3);
    14e4:	ae e4       	ldi	r26, 0x4E	; 78
    14e6:	b0 e0       	ldi	r27, 0x00	; 0
    14e8:	ee e4       	ldi	r30, 0x4E	; 78
    14ea:	f0 e0       	ldi	r31, 0x00	; 0
    14ec:	80 81       	ld	r24, Z
    14ee:	87 7f       	andi	r24, 0xF7	; 247
    14f0:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN4);
    14f2:	ae e4       	ldi	r26, 0x4E	; 78
    14f4:	b0 e0       	ldi	r27, 0x00	; 0
    14f6:	ee e4       	ldi	r30, 0x4E	; 78
    14f8:	f0 e0       	ldi	r31, 0x00	; 0
    14fa:	80 81       	ld	r24, Z
    14fc:	80 61       	ori	r24, 0x10	; 16
    14fe:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    1500:	19 82       	std	Y+1, r1	; 0x01
    1502:	a4 c0       	rjmp	.+328    	; 0x164c <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == PWM_PHASE_CORRECT_OCR1A) {
    1504:	8a 81       	ldd	r24, Y+2	; 0x02
    1506:	8b 30       	cpi	r24, 0x0B	; 11
    1508:	f1 f4       	brne	.+60     	; 0x1546 <MCAL_T1_u8T1Init+0x330>
			SET_BIT(TCCR1A, PIN0);
    150a:	af e4       	ldi	r26, 0x4F	; 79
    150c:	b0 e0       	ldi	r27, 0x00	; 0
    150e:	ef e4       	ldi	r30, 0x4F	; 79
    1510:	f0 e0       	ldi	r31, 0x00	; 0
    1512:	80 81       	ld	r24, Z
    1514:	81 60       	ori	r24, 0x01	; 1
    1516:	8c 93       	st	X, r24
			SET_BIT(TCCR1A, PIN1);
    1518:	af e4       	ldi	r26, 0x4F	; 79
    151a:	b0 e0       	ldi	r27, 0x00	; 0
    151c:	ef e4       	ldi	r30, 0x4F	; 79
    151e:	f0 e0       	ldi	r31, 0x00	; 0
    1520:	80 81       	ld	r24, Z
    1522:	82 60       	ori	r24, 0x02	; 2
    1524:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN3);
    1526:	ae e4       	ldi	r26, 0x4E	; 78
    1528:	b0 e0       	ldi	r27, 0x00	; 0
    152a:	ee e4       	ldi	r30, 0x4E	; 78
    152c:	f0 e0       	ldi	r31, 0x00	; 0
    152e:	80 81       	ld	r24, Z
    1530:	87 7f       	andi	r24, 0xF7	; 247
    1532:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN4);
    1534:	ae e4       	ldi	r26, 0x4E	; 78
    1536:	b0 e0       	ldi	r27, 0x00	; 0
    1538:	ee e4       	ldi	r30, 0x4E	; 78
    153a:	f0 e0       	ldi	r31, 0x00	; 0
    153c:	80 81       	ld	r24, Z
    153e:	80 61       	ori	r24, 0x10	; 16
    1540:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    1542:	19 82       	std	Y+1, r1	; 0x01
    1544:	83 c0       	rjmp	.+262    	; 0x164c <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == CTC_ICR1) {
    1546:	8a 81       	ldd	r24, Y+2	; 0x02
    1548:	8c 30       	cpi	r24, 0x0C	; 12
    154a:	f1 f4       	brne	.+60     	; 0x1588 <MCAL_T1_u8T1Init+0x372>
			CLR_BIT(TCCR1A, PIN0);
    154c:	af e4       	ldi	r26, 0x4F	; 79
    154e:	b0 e0       	ldi	r27, 0x00	; 0
    1550:	ef e4       	ldi	r30, 0x4F	; 79
    1552:	f0 e0       	ldi	r31, 0x00	; 0
    1554:	80 81       	ld	r24, Z
    1556:	8e 7f       	andi	r24, 0xFE	; 254
    1558:	8c 93       	st	X, r24
			CLR_BIT(TCCR1A, PIN1);
    155a:	af e4       	ldi	r26, 0x4F	; 79
    155c:	b0 e0       	ldi	r27, 0x00	; 0
    155e:	ef e4       	ldi	r30, 0x4F	; 79
    1560:	f0 e0       	ldi	r31, 0x00	; 0
    1562:	80 81       	ld	r24, Z
    1564:	8d 7f       	andi	r24, 0xFD	; 253
    1566:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN3);
    1568:	ae e4       	ldi	r26, 0x4E	; 78
    156a:	b0 e0       	ldi	r27, 0x00	; 0
    156c:	ee e4       	ldi	r30, 0x4E	; 78
    156e:	f0 e0       	ldi	r31, 0x00	; 0
    1570:	80 81       	ld	r24, Z
    1572:	88 60       	ori	r24, 0x08	; 8
    1574:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN4);
    1576:	ae e4       	ldi	r26, 0x4E	; 78
    1578:	b0 e0       	ldi	r27, 0x00	; 0
    157a:	ee e4       	ldi	r30, 0x4E	; 78
    157c:	f0 e0       	ldi	r31, 0x00	; 0
    157e:	80 81       	ld	r24, Z
    1580:	80 61       	ori	r24, 0x10	; 16
    1582:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    1584:	19 82       	std	Y+1, r1	; 0x01
    1586:	62 c0       	rjmp	.+196    	; 0x164c <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == REVERSED_MODE) {
    1588:	8a 81       	ldd	r24, Y+2	; 0x02
    158a:	8d 30       	cpi	r24, 0x0D	; 13
    158c:	f1 f4       	brne	.+60     	; 0x15ca <MCAL_T1_u8T1Init+0x3b4>
			SET_BIT(TCCR1A, PIN0);
    158e:	af e4       	ldi	r26, 0x4F	; 79
    1590:	b0 e0       	ldi	r27, 0x00	; 0
    1592:	ef e4       	ldi	r30, 0x4F	; 79
    1594:	f0 e0       	ldi	r31, 0x00	; 0
    1596:	80 81       	ld	r24, Z
    1598:	81 60       	ori	r24, 0x01	; 1
    159a:	8c 93       	st	X, r24
			CLR_BIT(TCCR1A, PIN1);
    159c:	af e4       	ldi	r26, 0x4F	; 79
    159e:	b0 e0       	ldi	r27, 0x00	; 0
    15a0:	ef e4       	ldi	r30, 0x4F	; 79
    15a2:	f0 e0       	ldi	r31, 0x00	; 0
    15a4:	80 81       	ld	r24, Z
    15a6:	8d 7f       	andi	r24, 0xFD	; 253
    15a8:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN3);
    15aa:	ae e4       	ldi	r26, 0x4E	; 78
    15ac:	b0 e0       	ldi	r27, 0x00	; 0
    15ae:	ee e4       	ldi	r30, 0x4E	; 78
    15b0:	f0 e0       	ldi	r31, 0x00	; 0
    15b2:	80 81       	ld	r24, Z
    15b4:	88 60       	ori	r24, 0x08	; 8
    15b6:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN4);
    15b8:	ae e4       	ldi	r26, 0x4E	; 78
    15ba:	b0 e0       	ldi	r27, 0x00	; 0
    15bc:	ee e4       	ldi	r30, 0x4E	; 78
    15be:	f0 e0       	ldi	r31, 0x00	; 0
    15c0:	80 81       	ld	r24, Z
    15c2:	80 61       	ori	r24, 0x10	; 16
    15c4:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    15c6:	19 82       	std	Y+1, r1	; 0x01
    15c8:	41 c0       	rjmp	.+130    	; 0x164c <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == FAST_PWM_ICR1) {
    15ca:	8a 81       	ldd	r24, Y+2	; 0x02
    15cc:	8e 30       	cpi	r24, 0x0E	; 14
    15ce:	f1 f4       	brne	.+60     	; 0x160c <MCAL_T1_u8T1Init+0x3f6>
			CLR_BIT(TCCR1A, PIN0);
    15d0:	af e4       	ldi	r26, 0x4F	; 79
    15d2:	b0 e0       	ldi	r27, 0x00	; 0
    15d4:	ef e4       	ldi	r30, 0x4F	; 79
    15d6:	f0 e0       	ldi	r31, 0x00	; 0
    15d8:	80 81       	ld	r24, Z
    15da:	8e 7f       	andi	r24, 0xFE	; 254
    15dc:	8c 93       	st	X, r24
			SET_BIT(TCCR1A, PIN1);
    15de:	af e4       	ldi	r26, 0x4F	; 79
    15e0:	b0 e0       	ldi	r27, 0x00	; 0
    15e2:	ef e4       	ldi	r30, 0x4F	; 79
    15e4:	f0 e0       	ldi	r31, 0x00	; 0
    15e6:	80 81       	ld	r24, Z
    15e8:	82 60       	ori	r24, 0x02	; 2
    15ea:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN3);
    15ec:	ae e4       	ldi	r26, 0x4E	; 78
    15ee:	b0 e0       	ldi	r27, 0x00	; 0
    15f0:	ee e4       	ldi	r30, 0x4E	; 78
    15f2:	f0 e0       	ldi	r31, 0x00	; 0
    15f4:	80 81       	ld	r24, Z
    15f6:	88 60       	ori	r24, 0x08	; 8
    15f8:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN4);
    15fa:	ae e4       	ldi	r26, 0x4E	; 78
    15fc:	b0 e0       	ldi	r27, 0x00	; 0
    15fe:	ee e4       	ldi	r30, 0x4E	; 78
    1600:	f0 e0       	ldi	r31, 0x00	; 0
    1602:	80 81       	ld	r24, Z
    1604:	80 61       	ori	r24, 0x10	; 16
    1606:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    1608:	19 82       	std	Y+1, r1	; 0x01
    160a:	20 c0       	rjmp	.+64     	; 0x164c <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == FAST_PWM_OCR1A) {
    160c:	8a 81       	ldd	r24, Y+2	; 0x02
    160e:	8f 30       	cpi	r24, 0x0F	; 15
    1610:	e9 f4       	brne	.+58     	; 0x164c <MCAL_T1_u8T1Init+0x436>
			SET_BIT(TCCR1A, PIN0);
    1612:	af e4       	ldi	r26, 0x4F	; 79
    1614:	b0 e0       	ldi	r27, 0x00	; 0
    1616:	ef e4       	ldi	r30, 0x4F	; 79
    1618:	f0 e0       	ldi	r31, 0x00	; 0
    161a:	80 81       	ld	r24, Z
    161c:	81 60       	ori	r24, 0x01	; 1
    161e:	8c 93       	st	X, r24
			SET_BIT(TCCR1A, PIN1);
    1620:	af e4       	ldi	r26, 0x4F	; 79
    1622:	b0 e0       	ldi	r27, 0x00	; 0
    1624:	ef e4       	ldi	r30, 0x4F	; 79
    1626:	f0 e0       	ldi	r31, 0x00	; 0
    1628:	80 81       	ld	r24, Z
    162a:	82 60       	ori	r24, 0x02	; 2
    162c:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN3);
    162e:	ae e4       	ldi	r26, 0x4E	; 78
    1630:	b0 e0       	ldi	r27, 0x00	; 0
    1632:	ee e4       	ldi	r30, 0x4E	; 78
    1634:	f0 e0       	ldi	r31, 0x00	; 0
    1636:	80 81       	ld	r24, Z
    1638:	88 60       	ori	r24, 0x08	; 8
    163a:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN4);
    163c:	ae e4       	ldi	r26, 0x4E	; 78
    163e:	b0 e0       	ldi	r27, 0x00	; 0
    1640:	ee e4       	ldi	r30, 0x4E	; 78
    1642:	f0 e0       	ldi	r31, 0x00	; 0
    1644:	80 81       	ld	r24, Z
    1646:	80 61       	ori	r24, 0x10	; 16
    1648:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    164a:	19 82       	std	Y+1, r1	; 0x01
			//NOTHING
		}
	} else {
		//NOTHING
	}
	return LOC_u8ReturnValue;
    164c:	89 81       	ldd	r24, Y+1	; 0x01
}
    164e:	0f 90       	pop	r0
    1650:	0f 90       	pop	r0
    1652:	cf 91       	pop	r28
    1654:	df 91       	pop	r29
    1656:	08 95       	ret

00001658 <MCAL_T1_u8T1Prescaler>:
u8 MCAL_T1_u8T1Prescaler(u8 LOC_u8Clock_Selection, f32 *LOC_pfl32TickTime) {
    1658:	df 93       	push	r29
    165a:	cf 93       	push	r28
    165c:	00 d0       	rcall	.+0      	; 0x165e <MCAL_T1_u8T1Prescaler+0x6>
    165e:	00 d0       	rcall	.+0      	; 0x1660 <MCAL_T1_u8T1Prescaler+0x8>
    1660:	cd b7       	in	r28, 0x3d	; 61
    1662:	de b7       	in	r29, 0x3e	; 62
    1664:	8a 83       	std	Y+2, r24	; 0x02
    1666:	7c 83       	std	Y+4, r23	; 0x04
    1668:	6b 83       	std	Y+3, r22	; 0x03
	u8 LOC_u8ReturnValue = E_NOT_OK;
    166a:	81 e0       	ldi	r24, 0x01	; 1
    166c:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_u8Clock_Selection <= EXTERNAL_RISING_EDGE) {
    166e:	8a 81       	ldd	r24, Y+2	; 0x02
    1670:	88 30       	cpi	r24, 0x08	; 8
    1672:	08 f0       	brcs	.+2      	; 0x1676 <MCAL_T1_u8T1Prescaler+0x1e>
    1674:	01 c1       	rjmp	.+514    	; 0x1878 <MCAL_T1_u8T1Prescaler+0x220>
		if (LOC_u8Clock_Selection == COUNTER_STOP) {
    1676:	8a 81       	ldd	r24, Y+2	; 0x02
    1678:	88 23       	and	r24, r24
    167a:	b9 f4       	brne	.+46     	; 0x16aa <MCAL_T1_u8T1Prescaler+0x52>
			CLR_BIT(TCCR1B, PIN0);
    167c:	ae e4       	ldi	r26, 0x4E	; 78
    167e:	b0 e0       	ldi	r27, 0x00	; 0
    1680:	ee e4       	ldi	r30, 0x4E	; 78
    1682:	f0 e0       	ldi	r31, 0x00	; 0
    1684:	80 81       	ld	r24, Z
    1686:	8e 7f       	andi	r24, 0xFE	; 254
    1688:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN1);
    168a:	ae e4       	ldi	r26, 0x4E	; 78
    168c:	b0 e0       	ldi	r27, 0x00	; 0
    168e:	ee e4       	ldi	r30, 0x4E	; 78
    1690:	f0 e0       	ldi	r31, 0x00	; 0
    1692:	80 81       	ld	r24, Z
    1694:	8d 7f       	andi	r24, 0xFD	; 253
    1696:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN2);
    1698:	ae e4       	ldi	r26, 0x4E	; 78
    169a:	b0 e0       	ldi	r27, 0x00	; 0
    169c:	ee e4       	ldi	r30, 0x4E	; 78
    169e:	f0 e0       	ldi	r31, 0x00	; 0
    16a0:	80 81       	ld	r24, Z
    16a2:	8b 7f       	andi	r24, 0xFB	; 251
    16a4:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    16a6:	19 82       	std	Y+1, r1	; 0x01
    16a8:	e7 c0       	rjmp	.+462    	; 0x1878 <MCAL_T1_u8T1Prescaler+0x220>
		} else if (LOC_u8Clock_Selection == PRESCALLING_0) {
    16aa:	8a 81       	ldd	r24, Y+2	; 0x02
    16ac:	81 30       	cpi	r24, 0x01	; 1
    16ae:	09 f5       	brne	.+66     	; 0x16f2 <MCAL_T1_u8T1Prescaler+0x9a>
			SET_BIT(TCCR1B, PIN0);
    16b0:	ae e4       	ldi	r26, 0x4E	; 78
    16b2:	b0 e0       	ldi	r27, 0x00	; 0
    16b4:	ee e4       	ldi	r30, 0x4E	; 78
    16b6:	f0 e0       	ldi	r31, 0x00	; 0
    16b8:	80 81       	ld	r24, Z
    16ba:	81 60       	ori	r24, 0x01	; 1
    16bc:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN1);
    16be:	ae e4       	ldi	r26, 0x4E	; 78
    16c0:	b0 e0       	ldi	r27, 0x00	; 0
    16c2:	ee e4       	ldi	r30, 0x4E	; 78
    16c4:	f0 e0       	ldi	r31, 0x00	; 0
    16c6:	80 81       	ld	r24, Z
    16c8:	8d 7f       	andi	r24, 0xFD	; 253
    16ca:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN2);
    16cc:	ae e4       	ldi	r26, 0x4E	; 78
    16ce:	b0 e0       	ldi	r27, 0x00	; 0
    16d0:	ee e4       	ldi	r30, 0x4E	; 78
    16d2:	f0 e0       	ldi	r31, 0x00	; 0
    16d4:	80 81       	ld	r24, Z
    16d6:	8b 7f       	andi	r24, 0xFB	; 251
    16d8:	8c 93       	st	X, r24
			*LOC_pfl32TickTime = PRESCALLING0 / (f32) CPU_FREQUNCY;
    16da:	eb 81       	ldd	r30, Y+3	; 0x03
    16dc:	fc 81       	ldd	r31, Y+4	; 0x04
    16de:	8d eb       	ldi	r24, 0xBD	; 189
    16e0:	97 e3       	ldi	r25, 0x37	; 55
    16e2:	a6 e0       	ldi	r26, 0x06	; 6
    16e4:	b4 e3       	ldi	r27, 0x34	; 52
    16e6:	80 83       	st	Z, r24
    16e8:	91 83       	std	Z+1, r25	; 0x01
    16ea:	a2 83       	std	Z+2, r26	; 0x02
    16ec:	b3 83       	std	Z+3, r27	; 0x03
			LOC_u8ReturnValue = E_OK;
    16ee:	19 82       	std	Y+1, r1	; 0x01
    16f0:	c3 c0       	rjmp	.+390    	; 0x1878 <MCAL_T1_u8T1Prescaler+0x220>
		} else if (LOC_u8Clock_Selection == PRESCALLING_8) {
    16f2:	8a 81       	ldd	r24, Y+2	; 0x02
    16f4:	82 30       	cpi	r24, 0x02	; 2
    16f6:	09 f5       	brne	.+66     	; 0x173a <MCAL_T1_u8T1Prescaler+0xe2>
			CLR_BIT(TCCR1B, PIN0);
    16f8:	ae e4       	ldi	r26, 0x4E	; 78
    16fa:	b0 e0       	ldi	r27, 0x00	; 0
    16fc:	ee e4       	ldi	r30, 0x4E	; 78
    16fe:	f0 e0       	ldi	r31, 0x00	; 0
    1700:	80 81       	ld	r24, Z
    1702:	8e 7f       	andi	r24, 0xFE	; 254
    1704:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN1);
    1706:	ae e4       	ldi	r26, 0x4E	; 78
    1708:	b0 e0       	ldi	r27, 0x00	; 0
    170a:	ee e4       	ldi	r30, 0x4E	; 78
    170c:	f0 e0       	ldi	r31, 0x00	; 0
    170e:	80 81       	ld	r24, Z
    1710:	82 60       	ori	r24, 0x02	; 2
    1712:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN2);
    1714:	ae e4       	ldi	r26, 0x4E	; 78
    1716:	b0 e0       	ldi	r27, 0x00	; 0
    1718:	ee e4       	ldi	r30, 0x4E	; 78
    171a:	f0 e0       	ldi	r31, 0x00	; 0
    171c:	80 81       	ld	r24, Z
    171e:	8b 7f       	andi	r24, 0xFB	; 251
    1720:	8c 93       	st	X, r24
			*LOC_pfl32TickTime = PRESCALLING8 / (f32) CPU_FREQUNCY;
    1722:	eb 81       	ldd	r30, Y+3	; 0x03
    1724:	fc 81       	ldd	r31, Y+4	; 0x04
    1726:	8d eb       	ldi	r24, 0xBD	; 189
    1728:	97 e3       	ldi	r25, 0x37	; 55
    172a:	a6 e8       	ldi	r26, 0x86	; 134
    172c:	b5 e3       	ldi	r27, 0x35	; 53
    172e:	80 83       	st	Z, r24
    1730:	91 83       	std	Z+1, r25	; 0x01
    1732:	a2 83       	std	Z+2, r26	; 0x02
    1734:	b3 83       	std	Z+3, r27	; 0x03
			LOC_u8ReturnValue = E_OK;
    1736:	19 82       	std	Y+1, r1	; 0x01
    1738:	9f c0       	rjmp	.+318    	; 0x1878 <MCAL_T1_u8T1Prescaler+0x220>
		} else if (LOC_u8Clock_Selection == PRESCALLING_64) {
    173a:	8a 81       	ldd	r24, Y+2	; 0x02
    173c:	83 30       	cpi	r24, 0x03	; 3
    173e:	09 f5       	brne	.+66     	; 0x1782 <MCAL_T1_u8T1Prescaler+0x12a>
			SET_BIT(TCCR1B, PIN0);
    1740:	ae e4       	ldi	r26, 0x4E	; 78
    1742:	b0 e0       	ldi	r27, 0x00	; 0
    1744:	ee e4       	ldi	r30, 0x4E	; 78
    1746:	f0 e0       	ldi	r31, 0x00	; 0
    1748:	80 81       	ld	r24, Z
    174a:	81 60       	ori	r24, 0x01	; 1
    174c:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN1);
    174e:	ae e4       	ldi	r26, 0x4E	; 78
    1750:	b0 e0       	ldi	r27, 0x00	; 0
    1752:	ee e4       	ldi	r30, 0x4E	; 78
    1754:	f0 e0       	ldi	r31, 0x00	; 0
    1756:	80 81       	ld	r24, Z
    1758:	82 60       	ori	r24, 0x02	; 2
    175a:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN2);
    175c:	ae e4       	ldi	r26, 0x4E	; 78
    175e:	b0 e0       	ldi	r27, 0x00	; 0
    1760:	ee e4       	ldi	r30, 0x4E	; 78
    1762:	f0 e0       	ldi	r31, 0x00	; 0
    1764:	80 81       	ld	r24, Z
    1766:	8b 7f       	andi	r24, 0xFB	; 251
    1768:	8c 93       	st	X, r24
			*LOC_pfl32TickTime = PRESCALLING64 / (f32) CPU_FREQUNCY;
    176a:	eb 81       	ldd	r30, Y+3	; 0x03
    176c:	fc 81       	ldd	r31, Y+4	; 0x04
    176e:	8d eb       	ldi	r24, 0xBD	; 189
    1770:	97 e3       	ldi	r25, 0x37	; 55
    1772:	a6 e0       	ldi	r26, 0x06	; 6
    1774:	b7 e3       	ldi	r27, 0x37	; 55
    1776:	80 83       	st	Z, r24
    1778:	91 83       	std	Z+1, r25	; 0x01
    177a:	a2 83       	std	Z+2, r26	; 0x02
    177c:	b3 83       	std	Z+3, r27	; 0x03
			LOC_u8ReturnValue = E_OK;
    177e:	19 82       	std	Y+1, r1	; 0x01
    1780:	7b c0       	rjmp	.+246    	; 0x1878 <MCAL_T1_u8T1Prescaler+0x220>
		} else if (LOC_u8Clock_Selection == PRESCALLING_256) {
    1782:	8a 81       	ldd	r24, Y+2	; 0x02
    1784:	84 30       	cpi	r24, 0x04	; 4
    1786:	09 f5       	brne	.+66     	; 0x17ca <MCAL_T1_u8T1Prescaler+0x172>
			CLR_BIT(TCCR1B, PIN0);
    1788:	ae e4       	ldi	r26, 0x4E	; 78
    178a:	b0 e0       	ldi	r27, 0x00	; 0
    178c:	ee e4       	ldi	r30, 0x4E	; 78
    178e:	f0 e0       	ldi	r31, 0x00	; 0
    1790:	80 81       	ld	r24, Z
    1792:	8e 7f       	andi	r24, 0xFE	; 254
    1794:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN1);
    1796:	ae e4       	ldi	r26, 0x4E	; 78
    1798:	b0 e0       	ldi	r27, 0x00	; 0
    179a:	ee e4       	ldi	r30, 0x4E	; 78
    179c:	f0 e0       	ldi	r31, 0x00	; 0
    179e:	80 81       	ld	r24, Z
    17a0:	8d 7f       	andi	r24, 0xFD	; 253
    17a2:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN2);
    17a4:	ae e4       	ldi	r26, 0x4E	; 78
    17a6:	b0 e0       	ldi	r27, 0x00	; 0
    17a8:	ee e4       	ldi	r30, 0x4E	; 78
    17aa:	f0 e0       	ldi	r31, 0x00	; 0
    17ac:	80 81       	ld	r24, Z
    17ae:	84 60       	ori	r24, 0x04	; 4
    17b0:	8c 93       	st	X, r24
			*LOC_pfl32TickTime = PRESCALLING256 / (f32) CPU_FREQUNCY;
    17b2:	eb 81       	ldd	r30, Y+3	; 0x03
    17b4:	fc 81       	ldd	r31, Y+4	; 0x04
    17b6:	8d eb       	ldi	r24, 0xBD	; 189
    17b8:	97 e3       	ldi	r25, 0x37	; 55
    17ba:	a6 e0       	ldi	r26, 0x06	; 6
    17bc:	b8 e3       	ldi	r27, 0x38	; 56
    17be:	80 83       	st	Z, r24
    17c0:	91 83       	std	Z+1, r25	; 0x01
    17c2:	a2 83       	std	Z+2, r26	; 0x02
    17c4:	b3 83       	std	Z+3, r27	; 0x03
			LOC_u8ReturnValue = E_OK;
    17c6:	19 82       	std	Y+1, r1	; 0x01
    17c8:	57 c0       	rjmp	.+174    	; 0x1878 <MCAL_T1_u8T1Prescaler+0x220>
		} else if (LOC_u8Clock_Selection == PRESCALLING_1024) {
    17ca:	8a 81       	ldd	r24, Y+2	; 0x02
    17cc:	85 30       	cpi	r24, 0x05	; 5
    17ce:	09 f5       	brne	.+66     	; 0x1812 <MCAL_T1_u8T1Prescaler+0x1ba>
			SET_BIT(TCCR1B, PIN0);
    17d0:	ae e4       	ldi	r26, 0x4E	; 78
    17d2:	b0 e0       	ldi	r27, 0x00	; 0
    17d4:	ee e4       	ldi	r30, 0x4E	; 78
    17d6:	f0 e0       	ldi	r31, 0x00	; 0
    17d8:	80 81       	ld	r24, Z
    17da:	81 60       	ori	r24, 0x01	; 1
    17dc:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN1);
    17de:	ae e4       	ldi	r26, 0x4E	; 78
    17e0:	b0 e0       	ldi	r27, 0x00	; 0
    17e2:	ee e4       	ldi	r30, 0x4E	; 78
    17e4:	f0 e0       	ldi	r31, 0x00	; 0
    17e6:	80 81       	ld	r24, Z
    17e8:	8d 7f       	andi	r24, 0xFD	; 253
    17ea:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN2);
    17ec:	ae e4       	ldi	r26, 0x4E	; 78
    17ee:	b0 e0       	ldi	r27, 0x00	; 0
    17f0:	ee e4       	ldi	r30, 0x4E	; 78
    17f2:	f0 e0       	ldi	r31, 0x00	; 0
    17f4:	80 81       	ld	r24, Z
    17f6:	84 60       	ori	r24, 0x04	; 4
    17f8:	8c 93       	st	X, r24
			*LOC_pfl32TickTime = PRESCALLING1024 / (f32) CPU_FREQUNCY;
    17fa:	eb 81       	ldd	r30, Y+3	; 0x03
    17fc:	fc 81       	ldd	r31, Y+4	; 0x04
    17fe:	8d eb       	ldi	r24, 0xBD	; 189
    1800:	97 e3       	ldi	r25, 0x37	; 55
    1802:	a6 e0       	ldi	r26, 0x06	; 6
    1804:	b9 e3       	ldi	r27, 0x39	; 57
    1806:	80 83       	st	Z, r24
    1808:	91 83       	std	Z+1, r25	; 0x01
    180a:	a2 83       	std	Z+2, r26	; 0x02
    180c:	b3 83       	std	Z+3, r27	; 0x03
			LOC_u8ReturnValue = E_OK;
    180e:	19 82       	std	Y+1, r1	; 0x01
    1810:	33 c0       	rjmp	.+102    	; 0x1878 <MCAL_T1_u8T1Prescaler+0x220>
		} else if (LOC_u8Clock_Selection == EXTERNAL_FALLING_EDGE) {
    1812:	8a 81       	ldd	r24, Y+2	; 0x02
    1814:	86 30       	cpi	r24, 0x06	; 6
    1816:	b9 f4       	brne	.+46     	; 0x1846 <MCAL_T1_u8T1Prescaler+0x1ee>
			CLR_BIT(TCCR1B, PIN0);
    1818:	ae e4       	ldi	r26, 0x4E	; 78
    181a:	b0 e0       	ldi	r27, 0x00	; 0
    181c:	ee e4       	ldi	r30, 0x4E	; 78
    181e:	f0 e0       	ldi	r31, 0x00	; 0
    1820:	80 81       	ld	r24, Z
    1822:	8e 7f       	andi	r24, 0xFE	; 254
    1824:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN1);
    1826:	ae e4       	ldi	r26, 0x4E	; 78
    1828:	b0 e0       	ldi	r27, 0x00	; 0
    182a:	ee e4       	ldi	r30, 0x4E	; 78
    182c:	f0 e0       	ldi	r31, 0x00	; 0
    182e:	80 81       	ld	r24, Z
    1830:	82 60       	ori	r24, 0x02	; 2
    1832:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN2);
    1834:	ae e4       	ldi	r26, 0x4E	; 78
    1836:	b0 e0       	ldi	r27, 0x00	; 0
    1838:	ee e4       	ldi	r30, 0x4E	; 78
    183a:	f0 e0       	ldi	r31, 0x00	; 0
    183c:	80 81       	ld	r24, Z
    183e:	84 60       	ori	r24, 0x04	; 4
    1840:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    1842:	19 82       	std	Y+1, r1	; 0x01
    1844:	19 c0       	rjmp	.+50     	; 0x1878 <MCAL_T1_u8T1Prescaler+0x220>
		} else if (LOC_u8Clock_Selection == EXTERNAL_RISING_EDGE) {
    1846:	8a 81       	ldd	r24, Y+2	; 0x02
    1848:	87 30       	cpi	r24, 0x07	; 7
    184a:	b1 f4       	brne	.+44     	; 0x1878 <MCAL_T1_u8T1Prescaler+0x220>
			SET_BIT(TCCR1B, PIN0);
    184c:	ae e4       	ldi	r26, 0x4E	; 78
    184e:	b0 e0       	ldi	r27, 0x00	; 0
    1850:	ee e4       	ldi	r30, 0x4E	; 78
    1852:	f0 e0       	ldi	r31, 0x00	; 0
    1854:	80 81       	ld	r24, Z
    1856:	81 60       	ori	r24, 0x01	; 1
    1858:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN1);
    185a:	ae e4       	ldi	r26, 0x4E	; 78
    185c:	b0 e0       	ldi	r27, 0x00	; 0
    185e:	ee e4       	ldi	r30, 0x4E	; 78
    1860:	f0 e0       	ldi	r31, 0x00	; 0
    1862:	80 81       	ld	r24, Z
    1864:	82 60       	ori	r24, 0x02	; 2
    1866:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN2);
    1868:	ae e4       	ldi	r26, 0x4E	; 78
    186a:	b0 e0       	ldi	r27, 0x00	; 0
    186c:	ee e4       	ldi	r30, 0x4E	; 78
    186e:	f0 e0       	ldi	r31, 0x00	; 0
    1870:	80 81       	ld	r24, Z
    1872:	84 60       	ori	r24, 0x04	; 4
    1874:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    1876:	19 82       	std	Y+1, r1	; 0x01
			//NOTHING
		}
	} else {
		//NOTHING
	}
	return LOC_u8ReturnValue;
    1878:	89 81       	ldd	r24, Y+1	; 0x01
}
    187a:	0f 90       	pop	r0
    187c:	0f 90       	pop	r0
    187e:	0f 90       	pop	r0
    1880:	0f 90       	pop	r0
    1882:	cf 91       	pop	r28
    1884:	df 91       	pop	r29
    1886:	08 95       	ret

00001888 <MCAL_T1_u8T1CompareOutputMode>:
//Fast MODE PWM & PHASE CORRECT
u8 MCAL_T1_u8T1CompareOutputMode(u8 LOC_u8OutputMode, u8 LOC_u8Channel) {
    1888:	df 93       	push	r29
    188a:	cf 93       	push	r28
    188c:	00 d0       	rcall	.+0      	; 0x188e <MCAL_T1_u8T1CompareOutputMode+0x6>
    188e:	0f 92       	push	r0
    1890:	cd b7       	in	r28, 0x3d	; 61
    1892:	de b7       	in	r29, 0x3e	; 62
    1894:	8a 83       	std	Y+2, r24	; 0x02
    1896:	6b 83       	std	Y+3, r22	; 0x03
	u8 LOC_u8ReturnValue = E_NOT_OK;
    1898:	81 e0       	ldi	r24, 0x01	; 1
    189a:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_u8OutputMode <= INVERTING_MODE && LOC_u8Channel <= CHENNEL_B) {
    189c:	8a 81       	ldd	r24, Y+2	; 0x02
    189e:	82 30       	cpi	r24, 0x02	; 2
    18a0:	08 f0       	brcs	.+2      	; 0x18a4 <MCAL_T1_u8T1CompareOutputMode+0x1c>
    18a2:	72 c0       	rjmp	.+228    	; 0x1988 <MCAL_T1_u8T1CompareOutputMode+0x100>
    18a4:	8b 81       	ldd	r24, Y+3	; 0x03
    18a6:	82 30       	cpi	r24, 0x02	; 2
    18a8:	08 f0       	brcs	.+2      	; 0x18ac <MCAL_T1_u8T1CompareOutputMode+0x24>
    18aa:	6e c0       	rjmp	.+220    	; 0x1988 <MCAL_T1_u8T1CompareOutputMode+0x100>
		if (LOC_u8Channel == CHENNEL_A) {
    18ac:	8b 81       	ldd	r24, Y+3	; 0x03
    18ae:	88 23       	and	r24, r24
    18b0:	a9 f5       	brne	.+106    	; 0x191c <MCAL_T1_u8T1CompareOutputMode+0x94>
			if (LOC_u8OutputMode == NON_INVERTING_MODE) {
    18b2:	8a 81       	ldd	r24, Y+2	; 0x02
    18b4:	88 23       	and	r24, r24
    18b6:	b9 f4       	brne	.+46     	; 0x18e6 <MCAL_T1_u8T1CompareOutputMode+0x5e>
				CLR_BIT(TCCR1A, PIN6);
    18b8:	af e4       	ldi	r26, 0x4F	; 79
    18ba:	b0 e0       	ldi	r27, 0x00	; 0
    18bc:	ef e4       	ldi	r30, 0x4F	; 79
    18be:	f0 e0       	ldi	r31, 0x00	; 0
    18c0:	80 81       	ld	r24, Z
    18c2:	8f 7b       	andi	r24, 0xBF	; 191
    18c4:	8c 93       	st	X, r24
				SET_BIT(TCCR1A, PIN7);
    18c6:	af e4       	ldi	r26, 0x4F	; 79
    18c8:	b0 e0       	ldi	r27, 0x00	; 0
    18ca:	ef e4       	ldi	r30, 0x4F	; 79
    18cc:	f0 e0       	ldi	r31, 0x00	; 0
    18ce:	80 81       	ld	r24, Z
    18d0:	80 68       	ori	r24, 0x80	; 128
    18d2:	8c 93       	st	X, r24
				SET_BIT(DDRD, PIN5);
    18d4:	a1 e3       	ldi	r26, 0x31	; 49
    18d6:	b0 e0       	ldi	r27, 0x00	; 0
    18d8:	e1 e3       	ldi	r30, 0x31	; 49
    18da:	f0 e0       	ldi	r31, 0x00	; 0
    18dc:	80 81       	ld	r24, Z
    18de:	80 62       	ori	r24, 0x20	; 32
    18e0:	8c 93       	st	X, r24
				LOC_u8ReturnValue = E_OK;
    18e2:	19 82       	std	Y+1, r1	; 0x01
    18e4:	51 c0       	rjmp	.+162    	; 0x1988 <MCAL_T1_u8T1CompareOutputMode+0x100>
			} else if (LOC_u8OutputMode == INVERTING_MODE) {
    18e6:	8a 81       	ldd	r24, Y+2	; 0x02
    18e8:	81 30       	cpi	r24, 0x01	; 1
    18ea:	09 f0       	breq	.+2      	; 0x18ee <MCAL_T1_u8T1CompareOutputMode+0x66>
    18ec:	4d c0       	rjmp	.+154    	; 0x1988 <MCAL_T1_u8T1CompareOutputMode+0x100>
				SET_BIT(TCCR1A, PIN6);
    18ee:	af e4       	ldi	r26, 0x4F	; 79
    18f0:	b0 e0       	ldi	r27, 0x00	; 0
    18f2:	ef e4       	ldi	r30, 0x4F	; 79
    18f4:	f0 e0       	ldi	r31, 0x00	; 0
    18f6:	80 81       	ld	r24, Z
    18f8:	80 64       	ori	r24, 0x40	; 64
    18fa:	8c 93       	st	X, r24
				SET_BIT(TCCR1A, PIN7);
    18fc:	af e4       	ldi	r26, 0x4F	; 79
    18fe:	b0 e0       	ldi	r27, 0x00	; 0
    1900:	ef e4       	ldi	r30, 0x4F	; 79
    1902:	f0 e0       	ldi	r31, 0x00	; 0
    1904:	80 81       	ld	r24, Z
    1906:	80 68       	ori	r24, 0x80	; 128
    1908:	8c 93       	st	X, r24
				SET_BIT(DDRD, PIN5);
    190a:	a1 e3       	ldi	r26, 0x31	; 49
    190c:	b0 e0       	ldi	r27, 0x00	; 0
    190e:	e1 e3       	ldi	r30, 0x31	; 49
    1910:	f0 e0       	ldi	r31, 0x00	; 0
    1912:	80 81       	ld	r24, Z
    1914:	80 62       	ori	r24, 0x20	; 32
    1916:	8c 93       	st	X, r24
				LOC_u8ReturnValue = E_OK;
    1918:	19 82       	std	Y+1, r1	; 0x01
    191a:	36 c0       	rjmp	.+108    	; 0x1988 <MCAL_T1_u8T1CompareOutputMode+0x100>
			} else {
				//NOTHING
			}
		} else if (LOC_u8Channel == CHENNEL_B) {
    191c:	8b 81       	ldd	r24, Y+3	; 0x03
    191e:	81 30       	cpi	r24, 0x01	; 1
    1920:	99 f5       	brne	.+102    	; 0x1988 <MCAL_T1_u8T1CompareOutputMode+0x100>
			if (LOC_u8OutputMode == NON_INVERTING_MODE) {
    1922:	8a 81       	ldd	r24, Y+2	; 0x02
    1924:	88 23       	and	r24, r24
    1926:	b9 f4       	brne	.+46     	; 0x1956 <MCAL_T1_u8T1CompareOutputMode+0xce>
				CLR_BIT(TCCR1A, PIN4);
    1928:	af e4       	ldi	r26, 0x4F	; 79
    192a:	b0 e0       	ldi	r27, 0x00	; 0
    192c:	ef e4       	ldi	r30, 0x4F	; 79
    192e:	f0 e0       	ldi	r31, 0x00	; 0
    1930:	80 81       	ld	r24, Z
    1932:	8f 7e       	andi	r24, 0xEF	; 239
    1934:	8c 93       	st	X, r24
				SET_BIT(TCCR1A, PIN5);
    1936:	af e4       	ldi	r26, 0x4F	; 79
    1938:	b0 e0       	ldi	r27, 0x00	; 0
    193a:	ef e4       	ldi	r30, 0x4F	; 79
    193c:	f0 e0       	ldi	r31, 0x00	; 0
    193e:	80 81       	ld	r24, Z
    1940:	80 62       	ori	r24, 0x20	; 32
    1942:	8c 93       	st	X, r24
				SET_BIT(DDRD, PIN4);
    1944:	a1 e3       	ldi	r26, 0x31	; 49
    1946:	b0 e0       	ldi	r27, 0x00	; 0
    1948:	e1 e3       	ldi	r30, 0x31	; 49
    194a:	f0 e0       	ldi	r31, 0x00	; 0
    194c:	80 81       	ld	r24, Z
    194e:	80 61       	ori	r24, 0x10	; 16
    1950:	8c 93       	st	X, r24
				LOC_u8ReturnValue = E_OK;
    1952:	19 82       	std	Y+1, r1	; 0x01
    1954:	19 c0       	rjmp	.+50     	; 0x1988 <MCAL_T1_u8T1CompareOutputMode+0x100>
			} else if (LOC_u8OutputMode == INVERTING_MODE) {
    1956:	8a 81       	ldd	r24, Y+2	; 0x02
    1958:	81 30       	cpi	r24, 0x01	; 1
    195a:	b1 f4       	brne	.+44     	; 0x1988 <MCAL_T1_u8T1CompareOutputMode+0x100>
				SET_BIT(TCCR1A, PIN4);
    195c:	af e4       	ldi	r26, 0x4F	; 79
    195e:	b0 e0       	ldi	r27, 0x00	; 0
    1960:	ef e4       	ldi	r30, 0x4F	; 79
    1962:	f0 e0       	ldi	r31, 0x00	; 0
    1964:	80 81       	ld	r24, Z
    1966:	80 61       	ori	r24, 0x10	; 16
    1968:	8c 93       	st	X, r24
				SET_BIT(TCCR1A, PIN5);
    196a:	af e4       	ldi	r26, 0x4F	; 79
    196c:	b0 e0       	ldi	r27, 0x00	; 0
    196e:	ef e4       	ldi	r30, 0x4F	; 79
    1970:	f0 e0       	ldi	r31, 0x00	; 0
    1972:	80 81       	ld	r24, Z
    1974:	80 62       	ori	r24, 0x20	; 32
    1976:	8c 93       	st	X, r24
				SET_BIT(DDRD, PIN4);
    1978:	a1 e3       	ldi	r26, 0x31	; 49
    197a:	b0 e0       	ldi	r27, 0x00	; 0
    197c:	e1 e3       	ldi	r30, 0x31	; 49
    197e:	f0 e0       	ldi	r31, 0x00	; 0
    1980:	80 81       	ld	r24, Z
    1982:	80 61       	ori	r24, 0x10	; 16
    1984:	8c 93       	st	X, r24
				LOC_u8ReturnValue = E_OK;
    1986:	19 82       	std	Y+1, r1	; 0x01
			//NOTHING
		}
	} else {
		//NOTHING
	}
	return LOC_u8ReturnValue;
    1988:	89 81       	ldd	r24, Y+1	; 0x01
}
    198a:	0f 90       	pop	r0
    198c:	0f 90       	pop	r0
    198e:	0f 90       	pop	r0
    1990:	cf 91       	pop	r28
    1992:	df 91       	pop	r29
    1994:	08 95       	ret

00001996 <MCAL_T1_voidNoiseCancller>:
//NOISE CANCLLER
void MCAL_T1_voidNoiseCancller(void) {
    1996:	df 93       	push	r29
    1998:	cf 93       	push	r28
    199a:	cd b7       	in	r28, 0x3d	; 61
    199c:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(TCCR1B, PIN7);
    199e:	ae e4       	ldi	r26, 0x4E	; 78
    19a0:	b0 e0       	ldi	r27, 0x00	; 0
    19a2:	ee e4       	ldi	r30, 0x4E	; 78
    19a4:	f0 e0       	ldi	r31, 0x00	; 0
    19a6:	80 81       	ld	r24, Z
    19a8:	80 68       	ori	r24, 0x80	; 128
    19aa:	8c 93       	st	X, r24
}
    19ac:	cf 91       	pop	r28
    19ae:	df 91       	pop	r29
    19b0:	08 95       	ret

000019b2 <MCAL_T1_voidSetTCNT1Value>:
//Set TCNT1 Value
void MCAL_T1_voidSetTCNT1Value(u16 LOC_u16Value) {
    19b2:	df 93       	push	r29
    19b4:	cf 93       	push	r28
    19b6:	00 d0       	rcall	.+0      	; 0x19b8 <MCAL_T1_voidSetTCNT1Value+0x6>
    19b8:	cd b7       	in	r28, 0x3d	; 61
    19ba:	de b7       	in	r29, 0x3e	; 62
    19bc:	9a 83       	std	Y+2, r25	; 0x02
    19be:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_u16Value <= SIXTEEN_BIT_MAX_VALUE) {
		TCNT1 = LOC_u16Value;
    19c0:	ec e4       	ldi	r30, 0x4C	; 76
    19c2:	f0 e0       	ldi	r31, 0x00	; 0
    19c4:	89 81       	ldd	r24, Y+1	; 0x01
    19c6:	9a 81       	ldd	r25, Y+2	; 0x02
    19c8:	91 83       	std	Z+1, r25	; 0x01
    19ca:	80 83       	st	Z, r24
	} else {
		//NOTHING
	}
}
    19cc:	0f 90       	pop	r0
    19ce:	0f 90       	pop	r0
    19d0:	cf 91       	pop	r28
    19d2:	df 91       	pop	r29
    19d4:	08 95       	ret

000019d6 <MCAL_T1_voidGetTCNT1Value>:
//GIT TCNT1
void MCAL_T1_voidGetTCNT1Value(u16 *LOC_pu16Value) {
    19d6:	df 93       	push	r29
    19d8:	cf 93       	push	r28
    19da:	00 d0       	rcall	.+0      	; 0x19dc <MCAL_T1_voidGetTCNT1Value+0x6>
    19dc:	cd b7       	in	r28, 0x3d	; 61
    19de:	de b7       	in	r29, 0x3e	; 62
    19e0:	9a 83       	std	Y+2, r25	; 0x02
    19e2:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_pu16Value) {
    19e4:	89 81       	ldd	r24, Y+1	; 0x01
    19e6:	9a 81       	ldd	r25, Y+2	; 0x02
    19e8:	00 97       	sbiw	r24, 0x00	; 0
    19ea:	41 f0       	breq	.+16     	; 0x19fc <MCAL_T1_voidGetTCNT1Value+0x26>
		*LOC_pu16Value = TCNT1;
    19ec:	ec e4       	ldi	r30, 0x4C	; 76
    19ee:	f0 e0       	ldi	r31, 0x00	; 0
    19f0:	80 81       	ld	r24, Z
    19f2:	91 81       	ldd	r25, Z+1	; 0x01
    19f4:	e9 81       	ldd	r30, Y+1	; 0x01
    19f6:	fa 81       	ldd	r31, Y+2	; 0x02
    19f8:	91 83       	std	Z+1, r25	; 0x01
    19fa:	80 83       	st	Z, r24
	}
}
    19fc:	0f 90       	pop	r0
    19fe:	0f 90       	pop	r0
    1a00:	cf 91       	pop	r28
    1a02:	df 91       	pop	r29
    1a04:	08 95       	ret

00001a06 <MCAL_T1_voidSetOCR1AValue>:
//Set OCR1A
void MCAL_T1_voidSetOCR1AValue(u16 LOC_u16Value) {
    1a06:	df 93       	push	r29
    1a08:	cf 93       	push	r28
    1a0a:	00 d0       	rcall	.+0      	; 0x1a0c <MCAL_T1_voidSetOCR1AValue+0x6>
    1a0c:	cd b7       	in	r28, 0x3d	; 61
    1a0e:	de b7       	in	r29, 0x3e	; 62
    1a10:	9a 83       	std	Y+2, r25	; 0x02
    1a12:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_u16Value <= SIXTEEN_BIT_MAX_VALUE) {
		OCR1A = LOC_u16Value;
    1a14:	ea e4       	ldi	r30, 0x4A	; 74
    1a16:	f0 e0       	ldi	r31, 0x00	; 0
    1a18:	89 81       	ldd	r24, Y+1	; 0x01
    1a1a:	9a 81       	ldd	r25, Y+2	; 0x02
    1a1c:	91 83       	std	Z+1, r25	; 0x01
    1a1e:	80 83       	st	Z, r24
	} else {
		//NOTHING
	}
}
    1a20:	0f 90       	pop	r0
    1a22:	0f 90       	pop	r0
    1a24:	cf 91       	pop	r28
    1a26:	df 91       	pop	r29
    1a28:	08 95       	ret

00001a2a <MCAL_T1_voidSetOCR1BValue>:
//SET OCR1B
void MCAL_T1_voidSetOCR1BValue(u16 LOC_u16Value) {
    1a2a:	df 93       	push	r29
    1a2c:	cf 93       	push	r28
    1a2e:	00 d0       	rcall	.+0      	; 0x1a30 <MCAL_T1_voidSetOCR1BValue+0x6>
    1a30:	cd b7       	in	r28, 0x3d	; 61
    1a32:	de b7       	in	r29, 0x3e	; 62
    1a34:	9a 83       	std	Y+2, r25	; 0x02
    1a36:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_u16Value <= SIXTEEN_BIT_MAX_VALUE) {
		OCR1B = LOC_u16Value;
    1a38:	e8 e4       	ldi	r30, 0x48	; 72
    1a3a:	f0 e0       	ldi	r31, 0x00	; 0
    1a3c:	89 81       	ldd	r24, Y+1	; 0x01
    1a3e:	9a 81       	ldd	r25, Y+2	; 0x02
    1a40:	91 83       	std	Z+1, r25	; 0x01
    1a42:	80 83       	st	Z, r24
	} else {
		//NOTHING
	}
}
    1a44:	0f 90       	pop	r0
    1a46:	0f 90       	pop	r0
    1a48:	cf 91       	pop	r28
    1a4a:	df 91       	pop	r29
    1a4c:	08 95       	ret

00001a4e <MCAL_T1_voidSetICR1Value>:
//SET ICR1
void MCAL_T1_voidSetICR1Value(u16 LOC_u16Value) {
    1a4e:	df 93       	push	r29
    1a50:	cf 93       	push	r28
    1a52:	00 d0       	rcall	.+0      	; 0x1a54 <MCAL_T1_voidSetICR1Value+0x6>
    1a54:	cd b7       	in	r28, 0x3d	; 61
    1a56:	de b7       	in	r29, 0x3e	; 62
    1a58:	9a 83       	std	Y+2, r25	; 0x02
    1a5a:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_u16Value <= SIXTEEN_BIT_MAX_VALUE) {
		ICR1 = LOC_u16Value;
    1a5c:	e6 e4       	ldi	r30, 0x46	; 70
    1a5e:	f0 e0       	ldi	r31, 0x00	; 0
    1a60:	89 81       	ldd	r24, Y+1	; 0x01
    1a62:	9a 81       	ldd	r25, Y+2	; 0x02
    1a64:	91 83       	std	Z+1, r25	; 0x01
    1a66:	80 83       	st	Z, r24
	} else {
		//NOTHING
	}
}
    1a68:	0f 90       	pop	r0
    1a6a:	0f 90       	pop	r0
    1a6c:	cf 91       	pop	r28
    1a6e:	df 91       	pop	r29
    1a70:	08 95       	ret

00001a72 <MCAL_T1_voidGetICR1Value>:
//Get ICR1
void MCAL_T1_voidGetICR1Value(u16 *LOC_pu16Value) {
    1a72:	df 93       	push	r29
    1a74:	cf 93       	push	r28
    1a76:	00 d0       	rcall	.+0      	; 0x1a78 <MCAL_T1_voidGetICR1Value+0x6>
    1a78:	cd b7       	in	r28, 0x3d	; 61
    1a7a:	de b7       	in	r29, 0x3e	; 62
    1a7c:	9a 83       	std	Y+2, r25	; 0x02
    1a7e:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_pu16Value) {
    1a80:	89 81       	ldd	r24, Y+1	; 0x01
    1a82:	9a 81       	ldd	r25, Y+2	; 0x02
    1a84:	00 97       	sbiw	r24, 0x00	; 0
    1a86:	41 f0       	breq	.+16     	; 0x1a98 <MCAL_T1_voidGetICR1Value+0x26>
		*LOC_pu16Value =ICR1;
    1a88:	e6 e4       	ldi	r30, 0x46	; 70
    1a8a:	f0 e0       	ldi	r31, 0x00	; 0
    1a8c:	80 81       	ld	r24, Z
    1a8e:	91 81       	ldd	r25, Z+1	; 0x01
    1a90:	e9 81       	ldd	r30, Y+1	; 0x01
    1a92:	fa 81       	ldd	r31, Y+2	; 0x02
    1a94:	91 83       	std	Z+1, r25	; 0x01
    1a96:	80 83       	st	Z, r24
	}
}
    1a98:	0f 90       	pop	r0
    1a9a:	0f 90       	pop	r0
    1a9c:	cf 91       	pop	r28
    1a9e:	df 91       	pop	r29
    1aa0:	08 95       	ret

00001aa2 <MCAL_T1_voidTCNT1_GIEEnable>:
//TCNT1 PIE
void MCAL_T1_voidTCNT1_GIEEnable(void) {
    1aa2:	df 93       	push	r29
    1aa4:	cf 93       	push	r28
    1aa6:	cd b7       	in	r28, 0x3d	; 61
    1aa8:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG, PIN7);
    1aaa:	af e5       	ldi	r26, 0x5F	; 95
    1aac:	b0 e0       	ldi	r27, 0x00	; 0
    1aae:	ef e5       	ldi	r30, 0x5F	; 95
    1ab0:	f0 e0       	ldi	r31, 0x00	; 0
    1ab2:	80 81       	ld	r24, Z
    1ab4:	80 68       	ori	r24, 0x80	; 128
    1ab6:	8c 93       	st	X, r24
	SET_BIT(TIMSK, PIN2);
    1ab8:	a9 e5       	ldi	r26, 0x59	; 89
    1aba:	b0 e0       	ldi	r27, 0x00	; 0
    1abc:	e9 e5       	ldi	r30, 0x59	; 89
    1abe:	f0 e0       	ldi	r31, 0x00	; 0
    1ac0:	80 81       	ld	r24, Z
    1ac2:	84 60       	ori	r24, 0x04	; 4
    1ac4:	8c 93       	st	X, r24
}
    1ac6:	cf 91       	pop	r28
    1ac8:	df 91       	pop	r29
    1aca:	08 95       	ret

00001acc <MCAL_T1_voidTCNT1_GIEDisable>:
void MCAL_T1_voidTCNT1_GIEDisable(void) {
    1acc:	df 93       	push	r29
    1ace:	cf 93       	push	r28
    1ad0:	cd b7       	in	r28, 0x3d	; 61
    1ad2:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK, PIN2);
    1ad4:	a9 e5       	ldi	r26, 0x59	; 89
    1ad6:	b0 e0       	ldi	r27, 0x00	; 0
    1ad8:	e9 e5       	ldi	r30, 0x59	; 89
    1ada:	f0 e0       	ldi	r31, 0x00	; 0
    1adc:	80 81       	ld	r24, Z
    1ade:	8b 7f       	andi	r24, 0xFB	; 251
    1ae0:	8c 93       	st	X, r24
}
    1ae2:	cf 91       	pop	r28
    1ae4:	df 91       	pop	r29
    1ae6:	08 95       	ret

00001ae8 <MCAL_T1_voidOCR1B_GIEEnable>:
//OCR1B PIE
void MCAL_T1_voidOCR1B_GIEEnable(void) {
    1ae8:	df 93       	push	r29
    1aea:	cf 93       	push	r28
    1aec:	cd b7       	in	r28, 0x3d	; 61
    1aee:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG, PIN7);
    1af0:	af e5       	ldi	r26, 0x5F	; 95
    1af2:	b0 e0       	ldi	r27, 0x00	; 0
    1af4:	ef e5       	ldi	r30, 0x5F	; 95
    1af6:	f0 e0       	ldi	r31, 0x00	; 0
    1af8:	80 81       	ld	r24, Z
    1afa:	80 68       	ori	r24, 0x80	; 128
    1afc:	8c 93       	st	X, r24
	SET_BIT(TIMSK, PIN3);
    1afe:	a9 e5       	ldi	r26, 0x59	; 89
    1b00:	b0 e0       	ldi	r27, 0x00	; 0
    1b02:	e9 e5       	ldi	r30, 0x59	; 89
    1b04:	f0 e0       	ldi	r31, 0x00	; 0
    1b06:	80 81       	ld	r24, Z
    1b08:	88 60       	ori	r24, 0x08	; 8
    1b0a:	8c 93       	st	X, r24
}
    1b0c:	cf 91       	pop	r28
    1b0e:	df 91       	pop	r29
    1b10:	08 95       	ret

00001b12 <MCAL_T1_voidOCR1B_GIEDisable>:
void MCAL_T1_voidOCR1B_GIEDisable(void) {
    1b12:	df 93       	push	r29
    1b14:	cf 93       	push	r28
    1b16:	cd b7       	in	r28, 0x3d	; 61
    1b18:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK, PIN3);
    1b1a:	a9 e5       	ldi	r26, 0x59	; 89
    1b1c:	b0 e0       	ldi	r27, 0x00	; 0
    1b1e:	e9 e5       	ldi	r30, 0x59	; 89
    1b20:	f0 e0       	ldi	r31, 0x00	; 0
    1b22:	80 81       	ld	r24, Z
    1b24:	87 7f       	andi	r24, 0xF7	; 247
    1b26:	8c 93       	st	X, r24
}
    1b28:	cf 91       	pop	r28
    1b2a:	df 91       	pop	r29
    1b2c:	08 95       	ret

00001b2e <MCAL_T1_voidOCR1A_GIEEnable>:
//OCR1A PIE
void MCAL_T1_voidOCR1A_GIEEnable(void) {
    1b2e:	df 93       	push	r29
    1b30:	cf 93       	push	r28
    1b32:	cd b7       	in	r28, 0x3d	; 61
    1b34:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG, PIN7);
    1b36:	af e5       	ldi	r26, 0x5F	; 95
    1b38:	b0 e0       	ldi	r27, 0x00	; 0
    1b3a:	ef e5       	ldi	r30, 0x5F	; 95
    1b3c:	f0 e0       	ldi	r31, 0x00	; 0
    1b3e:	80 81       	ld	r24, Z
    1b40:	80 68       	ori	r24, 0x80	; 128
    1b42:	8c 93       	st	X, r24
	SET_BIT(TIMSK, PIN4);
    1b44:	a9 e5       	ldi	r26, 0x59	; 89
    1b46:	b0 e0       	ldi	r27, 0x00	; 0
    1b48:	e9 e5       	ldi	r30, 0x59	; 89
    1b4a:	f0 e0       	ldi	r31, 0x00	; 0
    1b4c:	80 81       	ld	r24, Z
    1b4e:	80 61       	ori	r24, 0x10	; 16
    1b50:	8c 93       	st	X, r24
}
    1b52:	cf 91       	pop	r28
    1b54:	df 91       	pop	r29
    1b56:	08 95       	ret

00001b58 <MCAL_T1_voidOCR1A_GIEDisable>:
void MCAL_T1_voidOCR1A_GIEDisable(void) {
    1b58:	df 93       	push	r29
    1b5a:	cf 93       	push	r28
    1b5c:	cd b7       	in	r28, 0x3d	; 61
    1b5e:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK, PIN4);
    1b60:	a9 e5       	ldi	r26, 0x59	; 89
    1b62:	b0 e0       	ldi	r27, 0x00	; 0
    1b64:	e9 e5       	ldi	r30, 0x59	; 89
    1b66:	f0 e0       	ldi	r31, 0x00	; 0
    1b68:	80 81       	ld	r24, Z
    1b6a:	8f 7e       	andi	r24, 0xEF	; 239
    1b6c:	8c 93       	st	X, r24
}
    1b6e:	cf 91       	pop	r28
    1b70:	df 91       	pop	r29
    1b72:	08 95       	ret

00001b74 <MCAL_T1_voidICR1_GIEEnable>:
//ICR1 PIE
void MCAL_T1_voidICR1_GIEEnable(void) {
    1b74:	df 93       	push	r29
    1b76:	cf 93       	push	r28
    1b78:	cd b7       	in	r28, 0x3d	; 61
    1b7a:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG, PIN7);
    1b7c:	af e5       	ldi	r26, 0x5F	; 95
    1b7e:	b0 e0       	ldi	r27, 0x00	; 0
    1b80:	ef e5       	ldi	r30, 0x5F	; 95
    1b82:	f0 e0       	ldi	r31, 0x00	; 0
    1b84:	80 81       	ld	r24, Z
    1b86:	80 68       	ori	r24, 0x80	; 128
    1b88:	8c 93       	st	X, r24
	SET_BIT(TIMSK, PIN5);
    1b8a:	a9 e5       	ldi	r26, 0x59	; 89
    1b8c:	b0 e0       	ldi	r27, 0x00	; 0
    1b8e:	e9 e5       	ldi	r30, 0x59	; 89
    1b90:	f0 e0       	ldi	r31, 0x00	; 0
    1b92:	80 81       	ld	r24, Z
    1b94:	80 62       	ori	r24, 0x20	; 32
    1b96:	8c 93       	st	X, r24
}
    1b98:	cf 91       	pop	r28
    1b9a:	df 91       	pop	r29
    1b9c:	08 95       	ret

00001b9e <MCAL_T1_voidICR1_GIEDisable>:
void MCAL_T1_voidICR1_GIEDisable(void) {
    1b9e:	df 93       	push	r29
    1ba0:	cf 93       	push	r28
    1ba2:	cd b7       	in	r28, 0x3d	; 61
    1ba4:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK, PIN5);
    1ba6:	a9 e5       	ldi	r26, 0x59	; 89
    1ba8:	b0 e0       	ldi	r27, 0x00	; 0
    1baa:	e9 e5       	ldi	r30, 0x59	; 89
    1bac:	f0 e0       	ldi	r31, 0x00	; 0
    1bae:	80 81       	ld	r24, Z
    1bb0:	8f 7d       	andi	r24, 0xDF	; 223
    1bb2:	8c 93       	st	X, r24
}
    1bb4:	cf 91       	pop	r28
    1bb6:	df 91       	pop	r29
    1bb8:	08 95       	ret

00001bba <MCAL_T1_u8T1DelayNormalMode>:

u8 MCAL_T1_u8T1DelayNormalMode(u8 LOC_u8Clock_Selection,
		f32 LOC_f32NumOFSecond, u16 *LOC_pu8StartValue, u16 *LOC_pu16Counter) {
    1bba:	0f 93       	push	r16
    1bbc:	1f 93       	push	r17
    1bbe:	df 93       	push	r29
    1bc0:	cf 93       	push	r28
    1bc2:	cd b7       	in	r28, 0x3d	; 61
    1bc4:	de b7       	in	r29, 0x3e	; 62
    1bc6:	66 97       	sbiw	r28, 0x16	; 22
    1bc8:	0f b6       	in	r0, 0x3f	; 63
    1bca:	f8 94       	cli
    1bcc:	de bf       	out	0x3e, r29	; 62
    1bce:	0f be       	out	0x3f, r0	; 63
    1bd0:	cd bf       	out	0x3d, r28	; 61
    1bd2:	8e 87       	std	Y+14, r24	; 0x0e
    1bd4:	4f 87       	std	Y+15, r20	; 0x0f
    1bd6:	58 8b       	std	Y+16, r21	; 0x10
    1bd8:	69 8b       	std	Y+17, r22	; 0x11
    1bda:	7a 8b       	std	Y+18, r23	; 0x12
    1bdc:	3c 8b       	std	Y+20, r19	; 0x14
    1bde:	2b 8b       	std	Y+19, r18	; 0x13
    1be0:	1e 8b       	std	Y+22, r17	; 0x16
    1be2:	0d 8b       	std	Y+21, r16	; 0x15
	u8 LOC_u8ReturnValue = E_NOT_OK;
    1be4:	81 e0       	ldi	r24, 0x01	; 1
    1be6:	89 87       	std	Y+9, r24	; 0x09
	f32 TickTime = NUMBER_0;
    1be8:	80 e0       	ldi	r24, 0x00	; 0
    1bea:	90 e0       	ldi	r25, 0x00	; 0
    1bec:	a0 e0       	ldi	r26, 0x00	; 0
    1bee:	b0 e0       	ldi	r27, 0x00	; 0
    1bf0:	8a 87       	std	Y+10, r24	; 0x0a
    1bf2:	9b 87       	std	Y+11, r25	; 0x0b
    1bf4:	ac 87       	std	Y+12, r26	; 0x0c
    1bf6:	bd 87       	std	Y+13, r27	; 0x0d
	u32 N = NUMBER_0;
    1bf8:	1d 82       	std	Y+5, r1	; 0x05
    1bfa:	1e 82       	std	Y+6, r1	; 0x06
    1bfc:	1f 82       	std	Y+7, r1	; 0x07
    1bfe:	18 86       	std	Y+8, r1	; 0x08
	u16 counter = NUMBER_0;
    1c00:	1c 82       	std	Y+4, r1	; 0x04
    1c02:	1b 82       	std	Y+3, r1	; 0x03
	u16 Reminder = NUMBER_0;
    1c04:	1a 82       	std	Y+2, r1	; 0x02
    1c06:	19 82       	std	Y+1, r1	; 0x01
	MCAL_T1_u8T1Prescaler(LOC_u8Clock_Selection, &TickTime);
    1c08:	9e 01       	movw	r18, r28
    1c0a:	26 5f       	subi	r18, 0xF6	; 246
    1c0c:	3f 4f       	sbci	r19, 0xFF	; 255
    1c0e:	8e 85       	ldd	r24, Y+14	; 0x0e
    1c10:	b9 01       	movw	r22, r18
    1c12:	0e 94 2c 0b 	call	0x1658	; 0x1658 <MCAL_T1_u8T1Prescaler>
	if (LOC_f32NumOFSecond <= 0 || LOC_f32NumOFSecond > 0) {
    1c16:	6f 85       	ldd	r22, Y+15	; 0x0f
    1c18:	78 89       	ldd	r23, Y+16	; 0x10
    1c1a:	89 89       	ldd	r24, Y+17	; 0x11
    1c1c:	9a 89       	ldd	r25, Y+18	; 0x12
    1c1e:	20 e0       	ldi	r18, 0x00	; 0
    1c20:	30 e0       	ldi	r19, 0x00	; 0
    1c22:	40 e0       	ldi	r20, 0x00	; 0
    1c24:	50 e0       	ldi	r21, 0x00	; 0
    1c26:	0e 94 55 04 	call	0x8aa	; 0x8aa <__lesf2>
    1c2a:	18 16       	cp	r1, r24
    1c2c:	6c f4       	brge	.+26     	; 0x1c48 <MCAL_T1_u8T1DelayNormalMode+0x8e>
    1c2e:	6f 85       	ldd	r22, Y+15	; 0x0f
    1c30:	78 89       	ldd	r23, Y+16	; 0x10
    1c32:	89 89       	ldd	r24, Y+17	; 0x11
    1c34:	9a 89       	ldd	r25, Y+18	; 0x12
    1c36:	20 e0       	ldi	r18, 0x00	; 0
    1c38:	30 e0       	ldi	r19, 0x00	; 0
    1c3a:	40 e0       	ldi	r20, 0x00	; 0
    1c3c:	50 e0       	ldi	r21, 0x00	; 0
    1c3e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1c42:	18 16       	cp	r1, r24
    1c44:	0c f0       	brlt	.+2      	; 0x1c48 <MCAL_T1_u8T1DelayNormalMode+0x8e>
    1c46:	6b c0       	rjmp	.+214    	; 0x1d1e <MCAL_T1_u8T1DelayNormalMode+0x164>
		N = LOC_f32NumOFSecond / (f32) TickTime;
    1c48:	2a 85       	ldd	r18, Y+10	; 0x0a
    1c4a:	3b 85       	ldd	r19, Y+11	; 0x0b
    1c4c:	4c 85       	ldd	r20, Y+12	; 0x0c
    1c4e:	5d 85       	ldd	r21, Y+13	; 0x0d
    1c50:	6f 85       	ldd	r22, Y+15	; 0x0f
    1c52:	78 89       	ldd	r23, Y+16	; 0x10
    1c54:	89 89       	ldd	r24, Y+17	; 0x11
    1c56:	9a 89       	ldd	r25, Y+18	; 0x12
    1c58:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1c5c:	dc 01       	movw	r26, r24
    1c5e:	cb 01       	movw	r24, r22
    1c60:	bc 01       	movw	r22, r24
    1c62:	cd 01       	movw	r24, r26
    1c64:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1c68:	dc 01       	movw	r26, r24
    1c6a:	cb 01       	movw	r24, r22
    1c6c:	8d 83       	std	Y+5, r24	; 0x05
    1c6e:	9e 83       	std	Y+6, r25	; 0x06
    1c70:	af 83       	std	Y+7, r26	; 0x07
    1c72:	b8 87       	std	Y+8, r27	; 0x08
		Reminder = N % OVER_FLOW_COUNT;
    1c74:	8d 81       	ldd	r24, Y+5	; 0x05
    1c76:	9e 81       	ldd	r25, Y+6	; 0x06
    1c78:	af 81       	ldd	r26, Y+7	; 0x07
    1c7a:	b8 85       	ldd	r27, Y+8	; 0x08
    1c7c:	2f ef       	ldi	r18, 0xFF	; 255
    1c7e:	3f ef       	ldi	r19, 0xFF	; 255
    1c80:	40 e0       	ldi	r20, 0x00	; 0
    1c82:	50 e0       	ldi	r21, 0x00	; 0
    1c84:	bc 01       	movw	r22, r24
    1c86:	cd 01       	movw	r24, r26
    1c88:	0e 94 0c 38 	call	0x7018	; 0x7018 <__udivmodsi4>
    1c8c:	dc 01       	movw	r26, r24
    1c8e:	cb 01       	movw	r24, r22
    1c90:	9a 83       	std	Y+2, r25	; 0x02
    1c92:	89 83       	std	Y+1, r24	; 0x01
		*LOC_pu8StartValue = Reminder;
    1c94:	eb 89       	ldd	r30, Y+19	; 0x13
    1c96:	fc 89       	ldd	r31, Y+20	; 0x14
    1c98:	89 81       	ldd	r24, Y+1	; 0x01
    1c9a:	9a 81       	ldd	r25, Y+2	; 0x02
    1c9c:	91 83       	std	Z+1, r25	; 0x01
    1c9e:	80 83       	st	Z, r24
		if (Reminder == NUMBER_0) {
    1ca0:	89 81       	ldd	r24, Y+1	; 0x01
    1ca2:	9a 81       	ldd	r25, Y+2	; 0x02
    1ca4:	00 97       	sbiw	r24, 0x00	; 0
    1ca6:	d9 f4       	brne	.+54     	; 0x1cde <MCAL_T1_u8T1DelayNormalMode+0x124>
			MCAL_T1_voidSetTCNT1Value(Reminder);
    1ca8:	89 81       	ldd	r24, Y+1	; 0x01
    1caa:	9a 81       	ldd	r25, Y+2	; 0x02
    1cac:	0e 94 d9 0c 	call	0x19b2	; 0x19b2 <MCAL_T1_voidSetTCNT1Value>
			counter = N / OVER_FLOW_COUNT;
    1cb0:	8d 81       	ldd	r24, Y+5	; 0x05
    1cb2:	9e 81       	ldd	r25, Y+6	; 0x06
    1cb4:	af 81       	ldd	r26, Y+7	; 0x07
    1cb6:	b8 85       	ldd	r27, Y+8	; 0x08
    1cb8:	2f ef       	ldi	r18, 0xFF	; 255
    1cba:	3f ef       	ldi	r19, 0xFF	; 255
    1cbc:	40 e0       	ldi	r20, 0x00	; 0
    1cbe:	50 e0       	ldi	r21, 0x00	; 0
    1cc0:	bc 01       	movw	r22, r24
    1cc2:	cd 01       	movw	r24, r26
    1cc4:	0e 94 0c 38 	call	0x7018	; 0x7018 <__udivmodsi4>
    1cc8:	da 01       	movw	r26, r20
    1cca:	c9 01       	movw	r24, r18
    1ccc:	9c 83       	std	Y+4, r25	; 0x04
    1cce:	8b 83       	std	Y+3, r24	; 0x03
			*LOC_pu16Counter = counter;
    1cd0:	ed 89       	ldd	r30, Y+21	; 0x15
    1cd2:	fe 89       	ldd	r31, Y+22	; 0x16
    1cd4:	8b 81       	ldd	r24, Y+3	; 0x03
    1cd6:	9c 81       	ldd	r25, Y+4	; 0x04
    1cd8:	91 83       	std	Z+1, r25	; 0x01
    1cda:	80 83       	st	Z, r24
    1cdc:	1f c0       	rjmp	.+62     	; 0x1d1c <MCAL_T1_u8T1DelayNormalMode+0x162>
		} else if (Reminder != NUMBER_0) {
    1cde:	89 81       	ldd	r24, Y+1	; 0x01
    1ce0:	9a 81       	ldd	r25, Y+2	; 0x02
    1ce2:	00 97       	sbiw	r24, 0x00	; 0
    1ce4:	d9 f0       	breq	.+54     	; 0x1d1c <MCAL_T1_u8T1DelayNormalMode+0x162>
			MCAL_T1_voidSetTCNT1Value(Reminder);
    1ce6:	89 81       	ldd	r24, Y+1	; 0x01
    1ce8:	9a 81       	ldd	r25, Y+2	; 0x02
    1cea:	0e 94 d9 0c 	call	0x19b2	; 0x19b2 <MCAL_T1_voidSetTCNT1Value>
			counter = ((N / OVER_FLOW_COUNT) + NUMBER_1);
    1cee:	8d 81       	ldd	r24, Y+5	; 0x05
    1cf0:	9e 81       	ldd	r25, Y+6	; 0x06
    1cf2:	af 81       	ldd	r26, Y+7	; 0x07
    1cf4:	b8 85       	ldd	r27, Y+8	; 0x08
    1cf6:	2f ef       	ldi	r18, 0xFF	; 255
    1cf8:	3f ef       	ldi	r19, 0xFF	; 255
    1cfa:	40 e0       	ldi	r20, 0x00	; 0
    1cfc:	50 e0       	ldi	r21, 0x00	; 0
    1cfe:	bc 01       	movw	r22, r24
    1d00:	cd 01       	movw	r24, r26
    1d02:	0e 94 0c 38 	call	0x7018	; 0x7018 <__udivmodsi4>
    1d06:	da 01       	movw	r26, r20
    1d08:	c9 01       	movw	r24, r18
    1d0a:	01 96       	adiw	r24, 0x01	; 1
    1d0c:	9c 83       	std	Y+4, r25	; 0x04
    1d0e:	8b 83       	std	Y+3, r24	; 0x03
			*LOC_pu16Counter = counter;
    1d10:	ed 89       	ldd	r30, Y+21	; 0x15
    1d12:	fe 89       	ldd	r31, Y+22	; 0x16
    1d14:	8b 81       	ldd	r24, Y+3	; 0x03
    1d16:	9c 81       	ldd	r25, Y+4	; 0x04
    1d18:	91 83       	std	Z+1, r25	; 0x01
    1d1a:	80 83       	st	Z, r24
		} else {
			//NOTHING
		}
		LOC_u8ReturnValue = E_OK;
    1d1c:	19 86       	std	Y+9, r1	; 0x09
	}
	return LOC_u8ReturnValue;
    1d1e:	89 85       	ldd	r24, Y+9	; 0x09

}
    1d20:	66 96       	adiw	r28, 0x16	; 22
    1d22:	0f b6       	in	r0, 0x3f	; 63
    1d24:	f8 94       	cli
    1d26:	de bf       	out	0x3e, r29	; 62
    1d28:	0f be       	out	0x3f, r0	; 63
    1d2a:	cd bf       	out	0x3d, r28	; 61
    1d2c:	cf 91       	pop	r28
    1d2e:	df 91       	pop	r29
    1d30:	1f 91       	pop	r17
    1d32:	0f 91       	pop	r16
    1d34:	08 95       	ret

00001d36 <MCAL_T1_voidDelayCTCMode>:

void MCAL_T1_voidDelayCTCMode(u8 LOC_u8Clock_Selection,
		f32 LOC_fl32NumOFSecond, u16 *LOC_pu16Counter) {
    1d36:	df 93       	push	r29
    1d38:	cf 93       	push	r28
    1d3a:	cd b7       	in	r28, 0x3d	; 61
    1d3c:	de b7       	in	r29, 0x3e	; 62
    1d3e:	61 97       	sbiw	r28, 0x11	; 17
    1d40:	0f b6       	in	r0, 0x3f	; 63
    1d42:	f8 94       	cli
    1d44:	de bf       	out	0x3e, r29	; 62
    1d46:	0f be       	out	0x3f, r0	; 63
    1d48:	cd bf       	out	0x3d, r28	; 61
    1d4a:	8b 87       	std	Y+11, r24	; 0x0b
    1d4c:	4c 87       	std	Y+12, r20	; 0x0c
    1d4e:	5d 87       	std	Y+13, r21	; 0x0d
    1d50:	6e 87       	std	Y+14, r22	; 0x0e
    1d52:	7f 87       	std	Y+15, r23	; 0x0f
    1d54:	39 8b       	std	Y+17, r19	; 0x11
    1d56:	28 8b       	std	Y+16, r18	; 0x10
	f32 TickTime = NUMBER_0;
    1d58:	80 e0       	ldi	r24, 0x00	; 0
    1d5a:	90 e0       	ldi	r25, 0x00	; 0
    1d5c:	a0 e0       	ldi	r26, 0x00	; 0
    1d5e:	b0 e0       	ldi	r27, 0x00	; 0
    1d60:	8f 83       	std	Y+7, r24	; 0x07
    1d62:	98 87       	std	Y+8, r25	; 0x08
    1d64:	a9 87       	std	Y+9, r26	; 0x09
    1d66:	ba 87       	std	Y+10, r27	; 0x0a
	f32 N = NUMBER_0;
    1d68:	80 e0       	ldi	r24, 0x00	; 0
    1d6a:	90 e0       	ldi	r25, 0x00	; 0
    1d6c:	a0 e0       	ldi	r26, 0x00	; 0
    1d6e:	b0 e0       	ldi	r27, 0x00	; 0
    1d70:	8b 83       	std	Y+3, r24	; 0x03
    1d72:	9c 83       	std	Y+4, r25	; 0x04
    1d74:	ad 83       	std	Y+5, r26	; 0x05
    1d76:	be 83       	std	Y+6, r27	; 0x06
	u16 counter = NUMBER_0;
    1d78:	1a 82       	std	Y+2, r1	; 0x02
    1d7a:	19 82       	std	Y+1, r1	; 0x01
	MCAL_T1_u8T1Prescaler(LOC_u8Clock_Selection, &TickTime);
    1d7c:	9e 01       	movw	r18, r28
    1d7e:	29 5f       	subi	r18, 0xF9	; 249
    1d80:	3f 4f       	sbci	r19, 0xFF	; 255
    1d82:	8b 85       	ldd	r24, Y+11	; 0x0b
    1d84:	b9 01       	movw	r22, r18
    1d86:	0e 94 2c 0b 	call	0x1658	; 0x1658 <MCAL_T1_u8T1Prescaler>
	MCAL_T1_voidSetOCR1AValue(CTC_DELAY_CONST);
    1d8a:	87 ec       	ldi	r24, 0xC7	; 199
    1d8c:	90 e0       	ldi	r25, 0x00	; 0
    1d8e:	0e 94 03 0d 	call	0x1a06	; 0x1a06 <MCAL_T1_voidSetOCR1AValue>
	if (LOC_fl32NumOFSecond <= 0 || LOC_fl32NumOFSecond > 0) {
    1d92:	6c 85       	ldd	r22, Y+12	; 0x0c
    1d94:	7d 85       	ldd	r23, Y+13	; 0x0d
    1d96:	8e 85       	ldd	r24, Y+14	; 0x0e
    1d98:	9f 85       	ldd	r25, Y+15	; 0x0f
    1d9a:	20 e0       	ldi	r18, 0x00	; 0
    1d9c:	30 e0       	ldi	r19, 0x00	; 0
    1d9e:	40 e0       	ldi	r20, 0x00	; 0
    1da0:	50 e0       	ldi	r21, 0x00	; 0
    1da2:	0e 94 55 04 	call	0x8aa	; 0x8aa <__lesf2>
    1da6:	18 16       	cp	r1, r24
    1da8:	64 f4       	brge	.+24     	; 0x1dc2 <MCAL_T1_voidDelayCTCMode+0x8c>
    1daa:	6c 85       	ldd	r22, Y+12	; 0x0c
    1dac:	7d 85       	ldd	r23, Y+13	; 0x0d
    1dae:	8e 85       	ldd	r24, Y+14	; 0x0e
    1db0:	9f 85       	ldd	r25, Y+15	; 0x0f
    1db2:	20 e0       	ldi	r18, 0x00	; 0
    1db4:	30 e0       	ldi	r19, 0x00	; 0
    1db6:	40 e0       	ldi	r20, 0x00	; 0
    1db8:	50 e0       	ldi	r21, 0x00	; 0
    1dba:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1dbe:	18 16       	cp	r1, r24
    1dc0:	64 f5       	brge	.+88     	; 0x1e1a <MCAL_T1_voidDelayCTCMode+0xe4>
		N = ((CTC_DELAY_CONST + NUMBER_1) * TickTime);
    1dc2:	8f 81       	ldd	r24, Y+7	; 0x07
    1dc4:	98 85       	ldd	r25, Y+8	; 0x08
    1dc6:	a9 85       	ldd	r26, Y+9	; 0x09
    1dc8:	ba 85       	ldd	r27, Y+10	; 0x0a
    1dca:	bc 01       	movw	r22, r24
    1dcc:	cd 01       	movw	r24, r26
    1dce:	20 e0       	ldi	r18, 0x00	; 0
    1dd0:	30 e0       	ldi	r19, 0x00	; 0
    1dd2:	48 e4       	ldi	r20, 0x48	; 72
    1dd4:	53 e4       	ldi	r21, 0x43	; 67
    1dd6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1dda:	dc 01       	movw	r26, r24
    1ddc:	cb 01       	movw	r24, r22
    1dde:	8b 83       	std	Y+3, r24	; 0x03
    1de0:	9c 83       	std	Y+4, r25	; 0x04
    1de2:	ad 83       	std	Y+5, r26	; 0x05
    1de4:	be 83       	std	Y+6, r27	; 0x06
		counter = (LOC_fl32NumOFSecond / N);
    1de6:	6c 85       	ldd	r22, Y+12	; 0x0c
    1de8:	7d 85       	ldd	r23, Y+13	; 0x0d
    1dea:	8e 85       	ldd	r24, Y+14	; 0x0e
    1dec:	9f 85       	ldd	r25, Y+15	; 0x0f
    1dee:	2b 81       	ldd	r18, Y+3	; 0x03
    1df0:	3c 81       	ldd	r19, Y+4	; 0x04
    1df2:	4d 81       	ldd	r20, Y+5	; 0x05
    1df4:	5e 81       	ldd	r21, Y+6	; 0x06
    1df6:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1dfa:	dc 01       	movw	r26, r24
    1dfc:	cb 01       	movw	r24, r22
    1dfe:	bc 01       	movw	r22, r24
    1e00:	cd 01       	movw	r24, r26
    1e02:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1e06:	dc 01       	movw	r26, r24
    1e08:	cb 01       	movw	r24, r22
    1e0a:	9a 83       	std	Y+2, r25	; 0x02
    1e0c:	89 83       	std	Y+1, r24	; 0x01
		*LOC_pu16Counter = counter;
    1e0e:	e8 89       	ldd	r30, Y+16	; 0x10
    1e10:	f9 89       	ldd	r31, Y+17	; 0x11
    1e12:	89 81       	ldd	r24, Y+1	; 0x01
    1e14:	9a 81       	ldd	r25, Y+2	; 0x02
    1e16:	91 83       	std	Z+1, r25	; 0x01
    1e18:	80 83       	st	Z, r24
	} else {
		//NOTING
	}
}
    1e1a:	61 96       	adiw	r28, 0x11	; 17
    1e1c:	0f b6       	in	r0, 0x3f	; 63
    1e1e:	f8 94       	cli
    1e20:	de bf       	out	0x3e, r29	; 62
    1e22:	0f be       	out	0x3f, r0	; 63
    1e24:	cd bf       	out	0x3d, r28	; 61
    1e26:	cf 91       	pop	r28
    1e28:	df 91       	pop	r29
    1e2a:	08 95       	ret

00001e2c <MCAL_T1_voidSetTriggerEdge>:
//ICU EDGE
void MCAL_T1_voidSetTriggerEdge(u8 LOC_u8TriggerEdge) {
    1e2c:	df 93       	push	r29
    1e2e:	cf 93       	push	r28
    1e30:	0f 92       	push	r0
    1e32:	cd b7       	in	r28, 0x3d	; 61
    1e34:	de b7       	in	r29, 0x3e	; 62
    1e36:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_u8TriggerEdge <= RISING_EDGE) {
    1e38:	89 81       	ldd	r24, Y+1	; 0x01
    1e3a:	82 30       	cpi	r24, 0x02	; 2
    1e3c:	a8 f4       	brcc	.+42     	; 0x1e68 <MCAL_T1_voidSetTriggerEdge+0x3c>
		if (LOC_u8TriggerEdge == RISING_EDGE) {
    1e3e:	89 81       	ldd	r24, Y+1	; 0x01
    1e40:	81 30       	cpi	r24, 0x01	; 1
    1e42:	41 f4       	brne	.+16     	; 0x1e54 <MCAL_T1_voidSetTriggerEdge+0x28>
			SET_BIT(TCCR1B, PIN6);
    1e44:	ae e4       	ldi	r26, 0x4E	; 78
    1e46:	b0 e0       	ldi	r27, 0x00	; 0
    1e48:	ee e4       	ldi	r30, 0x4E	; 78
    1e4a:	f0 e0       	ldi	r31, 0x00	; 0
    1e4c:	80 81       	ld	r24, Z
    1e4e:	80 64       	ori	r24, 0x40	; 64
    1e50:	8c 93       	st	X, r24
    1e52:	0a c0       	rjmp	.+20     	; 0x1e68 <MCAL_T1_voidSetTriggerEdge+0x3c>
		} else if (LOC_u8TriggerEdge == FALLING_EDGE) {
    1e54:	89 81       	ldd	r24, Y+1	; 0x01
    1e56:	88 23       	and	r24, r24
    1e58:	39 f4       	brne	.+14     	; 0x1e68 <MCAL_T1_voidSetTriggerEdge+0x3c>
			CLR_BIT(TCCR1B, PIN6);
    1e5a:	ae e4       	ldi	r26, 0x4E	; 78
    1e5c:	b0 e0       	ldi	r27, 0x00	; 0
    1e5e:	ee e4       	ldi	r30, 0x4E	; 78
    1e60:	f0 e0       	ldi	r31, 0x00	; 0
    1e62:	80 81       	ld	r24, Z
    1e64:	8f 7b       	andi	r24, 0xBF	; 191
    1e66:	8c 93       	st	X, r24
			//NOTHING
		}
	} else {
		//NOTHING
	}
}
    1e68:	0f 90       	pop	r0
    1e6a:	cf 91       	pop	r28
    1e6c:	df 91       	pop	r29
    1e6e:	08 95       	ret

00001e70 <MCAL_T1_u8T1_Callback>:
u8 MCAL_T1_u8T1_Callback(void (*ptr)(void)) {
    1e70:	df 93       	push	r29
    1e72:	cf 93       	push	r28
    1e74:	00 d0       	rcall	.+0      	; 0x1e76 <MCAL_T1_u8T1_Callback+0x6>
    1e76:	0f 92       	push	r0
    1e78:	cd b7       	in	r28, 0x3d	; 61
    1e7a:	de b7       	in	r29, 0x3e	; 62
    1e7c:	9b 83       	std	Y+3, r25	; 0x03
    1e7e:	8a 83       	std	Y+2, r24	; 0x02
	u8 LOC_u8ReturnValue = E_NOT_OK;
    1e80:	81 e0       	ldi	r24, 0x01	; 1
    1e82:	89 83       	std	Y+1, r24	; 0x01
	if (ptr != '\0') {
    1e84:	8a 81       	ldd	r24, Y+2	; 0x02
    1e86:	9b 81       	ldd	r25, Y+3	; 0x03
    1e88:	00 97       	sbiw	r24, 0x00	; 0
    1e8a:	39 f0       	breq	.+14     	; 0x1e9a <MCAL_T1_u8T1_Callback+0x2a>
		Gptr_3 = ptr;
    1e8c:	8a 81       	ldd	r24, Y+2	; 0x02
    1e8e:	9b 81       	ldd	r25, Y+3	; 0x03
    1e90:	90 93 85 01 	sts	0x0185, r25
    1e94:	80 93 84 01 	sts	0x0184, r24
		LOC_u8ReturnValue = E_OK;
    1e98:	19 82       	std	Y+1, r1	; 0x01
	}
	return LOC_u8ReturnValue;
    1e9a:	89 81       	ldd	r24, Y+1	; 0x01
}
    1e9c:	0f 90       	pop	r0
    1e9e:	0f 90       	pop	r0
    1ea0:	0f 90       	pop	r0
    1ea2:	cf 91       	pop	r28
    1ea4:	df 91       	pop	r29
    1ea6:	08 95       	ret

00001ea8 <__vector_9>:

ISR(TIMER1_OVF_vect) {
    1ea8:	1f 92       	push	r1
    1eaa:	0f 92       	push	r0
    1eac:	0f b6       	in	r0, 0x3f	; 63
    1eae:	0f 92       	push	r0
    1eb0:	11 24       	eor	r1, r1
    1eb2:	2f 93       	push	r18
    1eb4:	3f 93       	push	r19
    1eb6:	4f 93       	push	r20
    1eb8:	5f 93       	push	r21
    1eba:	6f 93       	push	r22
    1ebc:	7f 93       	push	r23
    1ebe:	8f 93       	push	r24
    1ec0:	9f 93       	push	r25
    1ec2:	af 93       	push	r26
    1ec4:	bf 93       	push	r27
    1ec6:	ef 93       	push	r30
    1ec8:	ff 93       	push	r31
    1eca:	df 93       	push	r29
    1ecc:	cf 93       	push	r28
    1ece:	cd b7       	in	r28, 0x3d	; 61
    1ed0:	de b7       	in	r29, 0x3e	; 62
	if (Gptr_3 != '\0') {
    1ed2:	80 91 84 01 	lds	r24, 0x0184
    1ed6:	90 91 85 01 	lds	r25, 0x0185
    1eda:	00 97       	sbiw	r24, 0x00	; 0
    1edc:	29 f0       	breq	.+10     	; 0x1ee8 <__vector_9+0x40>
		Gptr_3();
    1ede:	e0 91 84 01 	lds	r30, 0x0184
    1ee2:	f0 91 85 01 	lds	r31, 0x0185
    1ee6:	09 95       	icall
	}
}
    1ee8:	cf 91       	pop	r28
    1eea:	df 91       	pop	r29
    1eec:	ff 91       	pop	r31
    1eee:	ef 91       	pop	r30
    1ef0:	bf 91       	pop	r27
    1ef2:	af 91       	pop	r26
    1ef4:	9f 91       	pop	r25
    1ef6:	8f 91       	pop	r24
    1ef8:	7f 91       	pop	r23
    1efa:	6f 91       	pop	r22
    1efc:	5f 91       	pop	r21
    1efe:	4f 91       	pop	r20
    1f00:	3f 91       	pop	r19
    1f02:	2f 91       	pop	r18
    1f04:	0f 90       	pop	r0
    1f06:	0f be       	out	0x3f, r0	; 63
    1f08:	0f 90       	pop	r0
    1f0a:	1f 90       	pop	r1
    1f0c:	18 95       	reti

00001f0e <TIMER1_COMPA_vect>:
ISR(TIMER1_COMPA_vect) {
    1f0e:	1f 92       	push	r1
    1f10:	0f 92       	push	r0
    1f12:	0f b6       	in	r0, 0x3f	; 63
    1f14:	0f 92       	push	r0
    1f16:	11 24       	eor	r1, r1
    1f18:	2f 93       	push	r18
    1f1a:	3f 93       	push	r19
    1f1c:	4f 93       	push	r20
    1f1e:	5f 93       	push	r21
    1f20:	6f 93       	push	r22
    1f22:	7f 93       	push	r23
    1f24:	8f 93       	push	r24
    1f26:	9f 93       	push	r25
    1f28:	af 93       	push	r26
    1f2a:	bf 93       	push	r27
    1f2c:	ef 93       	push	r30
    1f2e:	ff 93       	push	r31
    1f30:	df 93       	push	r29
    1f32:	cf 93       	push	r28
    1f34:	cd b7       	in	r28, 0x3d	; 61
    1f36:	de b7       	in	r29, 0x3e	; 62
	if (Gptr_3 != '\0') {
    1f38:	80 91 84 01 	lds	r24, 0x0184
    1f3c:	90 91 85 01 	lds	r25, 0x0185
    1f40:	00 97       	sbiw	r24, 0x00	; 0
    1f42:	29 f0       	breq	.+10     	; 0x1f4e <TIMER1_COMPA_vect+0x40>
		Gptr_3();
    1f44:	e0 91 84 01 	lds	r30, 0x0184
    1f48:	f0 91 85 01 	lds	r31, 0x0185
    1f4c:	09 95       	icall
	}
}
    1f4e:	cf 91       	pop	r28
    1f50:	df 91       	pop	r29
    1f52:	ff 91       	pop	r31
    1f54:	ef 91       	pop	r30
    1f56:	bf 91       	pop	r27
    1f58:	af 91       	pop	r26
    1f5a:	9f 91       	pop	r25
    1f5c:	8f 91       	pop	r24
    1f5e:	7f 91       	pop	r23
    1f60:	6f 91       	pop	r22
    1f62:	5f 91       	pop	r21
    1f64:	4f 91       	pop	r20
    1f66:	3f 91       	pop	r19
    1f68:	2f 91       	pop	r18
    1f6a:	0f 90       	pop	r0
    1f6c:	0f be       	out	0x3f, r0	; 63
    1f6e:	0f 90       	pop	r0
    1f70:	1f 90       	pop	r1
    1f72:	18 95       	reti

00001f74 <__vector_8>:
ISR(TIMER1_COMPB_vect) {
    1f74:	1f 92       	push	r1
    1f76:	0f 92       	push	r0
    1f78:	0f b6       	in	r0, 0x3f	; 63
    1f7a:	0f 92       	push	r0
    1f7c:	11 24       	eor	r1, r1
    1f7e:	2f 93       	push	r18
    1f80:	3f 93       	push	r19
    1f82:	4f 93       	push	r20
    1f84:	5f 93       	push	r21
    1f86:	6f 93       	push	r22
    1f88:	7f 93       	push	r23
    1f8a:	8f 93       	push	r24
    1f8c:	9f 93       	push	r25
    1f8e:	af 93       	push	r26
    1f90:	bf 93       	push	r27
    1f92:	ef 93       	push	r30
    1f94:	ff 93       	push	r31
    1f96:	df 93       	push	r29
    1f98:	cf 93       	push	r28
    1f9a:	cd b7       	in	r28, 0x3d	; 61
    1f9c:	de b7       	in	r29, 0x3e	; 62
	if (Gptr_3 != '\0') {
    1f9e:	80 91 84 01 	lds	r24, 0x0184
    1fa2:	90 91 85 01 	lds	r25, 0x0185
    1fa6:	00 97       	sbiw	r24, 0x00	; 0
    1fa8:	29 f0       	breq	.+10     	; 0x1fb4 <__vector_8+0x40>
		Gptr_3();
    1faa:	e0 91 84 01 	lds	r30, 0x0184
    1fae:	f0 91 85 01 	lds	r31, 0x0185
    1fb2:	09 95       	icall
	}
}
    1fb4:	cf 91       	pop	r28
    1fb6:	df 91       	pop	r29
    1fb8:	ff 91       	pop	r31
    1fba:	ef 91       	pop	r30
    1fbc:	bf 91       	pop	r27
    1fbe:	af 91       	pop	r26
    1fc0:	9f 91       	pop	r25
    1fc2:	8f 91       	pop	r24
    1fc4:	7f 91       	pop	r23
    1fc6:	6f 91       	pop	r22
    1fc8:	5f 91       	pop	r21
    1fca:	4f 91       	pop	r20
    1fcc:	3f 91       	pop	r19
    1fce:	2f 91       	pop	r18
    1fd0:	0f 90       	pop	r0
    1fd2:	0f be       	out	0x3f, r0	; 63
    1fd4:	0f 90       	pop	r0
    1fd6:	1f 90       	pop	r1
    1fd8:	18 95       	reti

00001fda <__vector_6>:
ISR(TIMER1_CAPT_vect) {
    1fda:	1f 92       	push	r1
    1fdc:	0f 92       	push	r0
    1fde:	0f b6       	in	r0, 0x3f	; 63
    1fe0:	0f 92       	push	r0
    1fe2:	11 24       	eor	r1, r1
    1fe4:	2f 93       	push	r18
    1fe6:	3f 93       	push	r19
    1fe8:	4f 93       	push	r20
    1fea:	5f 93       	push	r21
    1fec:	6f 93       	push	r22
    1fee:	7f 93       	push	r23
    1ff0:	8f 93       	push	r24
    1ff2:	9f 93       	push	r25
    1ff4:	af 93       	push	r26
    1ff6:	bf 93       	push	r27
    1ff8:	ef 93       	push	r30
    1ffa:	ff 93       	push	r31
    1ffc:	df 93       	push	r29
    1ffe:	cf 93       	push	r28
    2000:	cd b7       	in	r28, 0x3d	; 61
    2002:	de b7       	in	r29, 0x3e	; 62
	if (Gptr_3 != '\0') {
    2004:	80 91 84 01 	lds	r24, 0x0184
    2008:	90 91 85 01 	lds	r25, 0x0185
    200c:	00 97       	sbiw	r24, 0x00	; 0
    200e:	29 f0       	breq	.+10     	; 0x201a <__vector_6+0x40>
		Gptr_3();
    2010:	e0 91 84 01 	lds	r30, 0x0184
    2014:	f0 91 85 01 	lds	r31, 0x0185
    2018:	09 95       	icall
	}
}
    201a:	cf 91       	pop	r28
    201c:	df 91       	pop	r29
    201e:	ff 91       	pop	r31
    2020:	ef 91       	pop	r30
    2022:	bf 91       	pop	r27
    2024:	af 91       	pop	r26
    2026:	9f 91       	pop	r25
    2028:	8f 91       	pop	r24
    202a:	7f 91       	pop	r23
    202c:	6f 91       	pop	r22
    202e:	5f 91       	pop	r21
    2030:	4f 91       	pop	r20
    2032:	3f 91       	pop	r19
    2034:	2f 91       	pop	r18
    2036:	0f 90       	pop	r0
    2038:	0f be       	out	0x3f, r0	; 63
    203a:	0f 90       	pop	r0
    203c:	1f 90       	pop	r1
    203e:	18 95       	reti

00002040 <MCAL_T1_FPWM_10bitRES>:

void MCAL_T1_FPWM_10bitRES(u8 copy_u8Channel, u8 copy_u8Duty) {
    2040:	0f 93       	push	r16
    2042:	1f 93       	push	r17
    2044:	df 93       	push	r29
    2046:	cf 93       	push	r28
    2048:	00 d0       	rcall	.+0      	; 0x204a <MCAL_T1_FPWM_10bitRES+0xa>
    204a:	00 d0       	rcall	.+0      	; 0x204c <MCAL_T1_FPWM_10bitRES+0xc>
    204c:	00 d0       	rcall	.+0      	; 0x204e <MCAL_T1_FPWM_10bitRES+0xe>
    204e:	cd b7       	in	r28, 0x3d	; 61
    2050:	de b7       	in	r29, 0x3e	; 62
    2052:	8d 83       	std	Y+5, r24	; 0x05
    2054:	6e 83       	std	Y+6, r22	; 0x06
	f32 LOC_fl32tickTime = 0;
    2056:	80 e0       	ldi	r24, 0x00	; 0
    2058:	90 e0       	ldi	r25, 0x00	; 0
    205a:	a0 e0       	ldi	r26, 0x00	; 0
    205c:	b0 e0       	ldi	r27, 0x00	; 0
    205e:	89 83       	std	Y+1, r24	; 0x01
    2060:	9a 83       	std	Y+2, r25	; 0x02
    2062:	ab 83       	std	Y+3, r26	; 0x03
    2064:	bc 83       	std	Y+4, r27	; 0x04
	//Set Mode
	MCAL_T1_u8T1Init(PWM_PHASE_CORRECT_10bit);
    2066:	83 e0       	ldi	r24, 0x03	; 3
    2068:	0e 94 0b 09 	call	0x1216	; 0x1216 <MCAL_T1_u8T1Init>
	//Select Prescaler
	MCAL_T1_u8T1Prescaler(PRESCALLING_64, &LOC_fl32tickTime);
    206c:	83 e0       	ldi	r24, 0x03	; 3
    206e:	9e 01       	movw	r18, r28
    2070:	2f 5f       	subi	r18, 0xFF	; 255
    2072:	3f 4f       	sbci	r19, 0xFF	; 255
    2074:	b9 01       	movw	r22, r18
    2076:	0e 94 2c 0b 	call	0x1658	; 0x1658 <MCAL_T1_u8T1Prescaler>
	MCAL_T1_u8T1CompareOutputMode(NON_INVERTING_MODE, copy_u8Channel);
    207a:	80 e0       	ldi	r24, 0x00	; 0
    207c:	6d 81       	ldd	r22, Y+5	; 0x05
    207e:	0e 94 44 0c 	call	0x1888	; 0x1888 <MCAL_T1_u8T1CompareOutputMode>
	if (copy_u8Channel == CHENNEL_A) {
    2082:	8d 81       	ldd	r24, Y+5	; 0x05
    2084:	88 23       	and	r24, r24
    2086:	19 f5       	brne	.+70     	; 0x20ce <MCAL_T1_FPWM_10bitRES+0x8e>
		OCR1A = copy_u8Duty * 10.23;
    2088:	0a e4       	ldi	r16, 0x4A	; 74
    208a:	10 e0       	ldi	r17, 0x00	; 0
    208c:	8e 81       	ldd	r24, Y+6	; 0x06
    208e:	88 2f       	mov	r24, r24
    2090:	90 e0       	ldi	r25, 0x00	; 0
    2092:	aa 27       	eor	r26, r26
    2094:	97 fd       	sbrc	r25, 7
    2096:	a0 95       	com	r26
    2098:	ba 2f       	mov	r27, r26
    209a:	bc 01       	movw	r22, r24
    209c:	cd 01       	movw	r24, r26
    209e:	0e 94 85 04 	call	0x90a	; 0x90a <__floatsisf>
    20a2:	dc 01       	movw	r26, r24
    20a4:	cb 01       	movw	r24, r22
    20a6:	bc 01       	movw	r22, r24
    20a8:	cd 01       	movw	r24, r26
    20aa:	24 e1       	ldi	r18, 0x14	; 20
    20ac:	3e ea       	ldi	r19, 0xAE	; 174
    20ae:	43 e2       	ldi	r20, 0x23	; 35
    20b0:	51 e4       	ldi	r21, 0x41	; 65
    20b2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    20b6:	dc 01       	movw	r26, r24
    20b8:	cb 01       	movw	r24, r22
    20ba:	bc 01       	movw	r22, r24
    20bc:	cd 01       	movw	r24, r26
    20be:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    20c2:	dc 01       	movw	r26, r24
    20c4:	cb 01       	movw	r24, r22
    20c6:	f8 01       	movw	r30, r16
    20c8:	91 83       	std	Z+1, r25	; 0x01
    20ca:	80 83       	st	Z, r24
    20cc:	25 c0       	rjmp	.+74     	; 0x2118 <MCAL_T1_FPWM_10bitRES+0xd8>
	} else if (copy_u8Channel == CHENNEL_B) {
    20ce:	8d 81       	ldd	r24, Y+5	; 0x05
    20d0:	81 30       	cpi	r24, 0x01	; 1
    20d2:	11 f5       	brne	.+68     	; 0x2118 <MCAL_T1_FPWM_10bitRES+0xd8>
		OCR1B = copy_u8Duty * 10.23;
    20d4:	08 e4       	ldi	r16, 0x48	; 72
    20d6:	10 e0       	ldi	r17, 0x00	; 0
    20d8:	8e 81       	ldd	r24, Y+6	; 0x06
    20da:	88 2f       	mov	r24, r24
    20dc:	90 e0       	ldi	r25, 0x00	; 0
    20de:	aa 27       	eor	r26, r26
    20e0:	97 fd       	sbrc	r25, 7
    20e2:	a0 95       	com	r26
    20e4:	ba 2f       	mov	r27, r26
    20e6:	bc 01       	movw	r22, r24
    20e8:	cd 01       	movw	r24, r26
    20ea:	0e 94 85 04 	call	0x90a	; 0x90a <__floatsisf>
    20ee:	dc 01       	movw	r26, r24
    20f0:	cb 01       	movw	r24, r22
    20f2:	bc 01       	movw	r22, r24
    20f4:	cd 01       	movw	r24, r26
    20f6:	24 e1       	ldi	r18, 0x14	; 20
    20f8:	3e ea       	ldi	r19, 0xAE	; 174
    20fa:	43 e2       	ldi	r20, 0x23	; 35
    20fc:	51 e4       	ldi	r21, 0x41	; 65
    20fe:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2102:	dc 01       	movw	r26, r24
    2104:	cb 01       	movw	r24, r22
    2106:	bc 01       	movw	r22, r24
    2108:	cd 01       	movw	r24, r26
    210a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    210e:	dc 01       	movw	r26, r24
    2110:	cb 01       	movw	r24, r22
    2112:	f8 01       	movw	r30, r16
    2114:	91 83       	std	Z+1, r25	; 0x01
    2116:	80 83       	st	Z, r24

	} else {
		//NOTHING
	}
}
    2118:	26 96       	adiw	r28, 0x06	; 6
    211a:	0f b6       	in	r0, 0x3f	; 63
    211c:	f8 94       	cli
    211e:	de bf       	out	0x3e, r29	; 62
    2120:	0f be       	out	0x3f, r0	; 63
    2122:	cd bf       	out	0x3d, r28	; 61
    2124:	cf 91       	pop	r28
    2126:	df 91       	pop	r29
    2128:	1f 91       	pop	r17
    212a:	0f 91       	pop	r16
    212c:	08 95       	ret

0000212e <MCAL_Timer0_Init>:
void (*Gptr3)(void)= '\0' ;
f32 Glob_TickTime;
u16 Start = 0;
u16 Counter = 0;

void MCAL_Timer0_Init(u8 Loc_u8Mode, u8 Loc_u8Prescaller,u8 Loc_u8OC0Mode) {
    212e:	df 93       	push	r29
    2130:	cf 93       	push	r28
    2132:	00 d0       	rcall	.+0      	; 0x2134 <MCAL_Timer0_Init+0x6>
    2134:	00 d0       	rcall	.+0      	; 0x2136 <MCAL_Timer0_Init+0x8>
    2136:	cd b7       	in	r28, 0x3d	; 61
    2138:	de b7       	in	r29, 0x3e	; 62
    213a:	8a 83       	std	Y+2, r24	; 0x02
    213c:	6b 83       	std	Y+3, r22	; 0x03
    213e:	4c 83       	std	Y+4, r20	; 0x04
	u8 LOC_u8ReturnValue = E_NOT_OK;
    2140:	81 e0       	ldi	r24, 0x01	; 1
    2142:	89 83       	std	Y+1, r24	; 0x01
	SET_BIT(SREG, 7);
    2144:	af e5       	ldi	r26, 0x5F	; 95
    2146:	b0 e0       	ldi	r27, 0x00	; 0
    2148:	ef e5       	ldi	r30, 0x5F	; 95
    214a:	f0 e0       	ldi	r31, 0x00	; 0
    214c:	80 81       	ld	r24, Z
    214e:	80 68       	ori	r24, 0x80	; 128
    2150:	8c 93       	st	X, r24
	if (Loc_u8Mode == Normal_Mode) {
    2152:	8a 81       	ldd	r24, Y+2	; 0x02
    2154:	88 23       	and	r24, r24
    2156:	b1 f4       	brne	.+44     	; 0x2184 <MCAL_Timer0_Init+0x56>
		CLR_BIT(TCCR0, 3);
    2158:	a3 e5       	ldi	r26, 0x53	; 83
    215a:	b0 e0       	ldi	r27, 0x00	; 0
    215c:	e3 e5       	ldi	r30, 0x53	; 83
    215e:	f0 e0       	ldi	r31, 0x00	; 0
    2160:	80 81       	ld	r24, Z
    2162:	87 7f       	andi	r24, 0xF7	; 247
    2164:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 6);
    2166:	a3 e5       	ldi	r26, 0x53	; 83
    2168:	b0 e0       	ldi	r27, 0x00	; 0
    216a:	e3 e5       	ldi	r30, 0x53	; 83
    216c:	f0 e0       	ldi	r31, 0x00	; 0
    216e:	80 81       	ld	r24, Z
    2170:	8f 7b       	andi	r24, 0xBF	; 191
    2172:	8c 93       	st	X, r24
		SET_BIT(TIMSK, 0);
    2174:	a9 e5       	ldi	r26, 0x59	; 89
    2176:	b0 e0       	ldi	r27, 0x00	; 0
    2178:	e9 e5       	ldi	r30, 0x59	; 89
    217a:	f0 e0       	ldi	r31, 0x00	; 0
    217c:	80 81       	ld	r24, Z
    217e:	81 60       	ori	r24, 0x01	; 1
    2180:	8c 93       	st	X, r24
    2182:	35 c0       	rjmp	.+106    	; 0x21ee <MCAL_Timer0_Init+0xc0>
	} else if (Loc_u8Mode == CTC_Mode) {
    2184:	8a 81       	ldd	r24, Y+2	; 0x02
    2186:	81 30       	cpi	r24, 0x01	; 1
    2188:	b1 f4       	brne	.+44     	; 0x21b6 <MCAL_Timer0_Init+0x88>
		SET_BIT(TCCR0, 3);
    218a:	a3 e5       	ldi	r26, 0x53	; 83
    218c:	b0 e0       	ldi	r27, 0x00	; 0
    218e:	e3 e5       	ldi	r30, 0x53	; 83
    2190:	f0 e0       	ldi	r31, 0x00	; 0
    2192:	80 81       	ld	r24, Z
    2194:	88 60       	ori	r24, 0x08	; 8
    2196:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 6);
    2198:	a3 e5       	ldi	r26, 0x53	; 83
    219a:	b0 e0       	ldi	r27, 0x00	; 0
    219c:	e3 e5       	ldi	r30, 0x53	; 83
    219e:	f0 e0       	ldi	r31, 0x00	; 0
    21a0:	80 81       	ld	r24, Z
    21a2:	8f 7b       	andi	r24, 0xBF	; 191
    21a4:	8c 93       	st	X, r24
		SET_BIT(TIMSK, 1);
    21a6:	a9 e5       	ldi	r26, 0x59	; 89
    21a8:	b0 e0       	ldi	r27, 0x00	; 0
    21aa:	e9 e5       	ldi	r30, 0x59	; 89
    21ac:	f0 e0       	ldi	r31, 0x00	; 0
    21ae:	80 81       	ld	r24, Z
    21b0:	82 60       	ori	r24, 0x02	; 2
    21b2:	8c 93       	st	X, r24
    21b4:	1c c0       	rjmp	.+56     	; 0x21ee <MCAL_Timer0_Init+0xc0>
	} else if (Loc_u8Mode == PWM_Mode) {
    21b6:	8a 81       	ldd	r24, Y+2	; 0x02
    21b8:	82 30       	cpi	r24, 0x02	; 2
    21ba:	79 f4       	brne	.+30     	; 0x21da <MCAL_Timer0_Init+0xac>
		CLR_BIT(TCCR0, 3);
    21bc:	a3 e5       	ldi	r26, 0x53	; 83
    21be:	b0 e0       	ldi	r27, 0x00	; 0
    21c0:	e3 e5       	ldi	r30, 0x53	; 83
    21c2:	f0 e0       	ldi	r31, 0x00	; 0
    21c4:	80 81       	ld	r24, Z
    21c6:	87 7f       	andi	r24, 0xF7	; 247
    21c8:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 6);
    21ca:	a3 e5       	ldi	r26, 0x53	; 83
    21cc:	b0 e0       	ldi	r27, 0x00	; 0
    21ce:	e3 e5       	ldi	r30, 0x53	; 83
    21d0:	f0 e0       	ldi	r31, 0x00	; 0
    21d2:	80 81       	ld	r24, Z
    21d4:	80 64       	ori	r24, 0x40	; 64
    21d6:	8c 93       	st	X, r24
    21d8:	0a c0       	rjmp	.+20     	; 0x21ee <MCAL_Timer0_Init+0xc0>
	} else if (Loc_u8Mode == FastPWM_Mode) {
    21da:	8a 81       	ldd	r24, Y+2	; 0x02
    21dc:	83 30       	cpi	r24, 0x03	; 3
    21de:	39 f4       	brne	.+14     	; 0x21ee <MCAL_Timer0_Init+0xc0>
//		SET_BIT(TCCR0, 3);
//		SET_BIT(TCCR0, 6);
		SET_BIT(TIMSK, 1);
    21e0:	a9 e5       	ldi	r26, 0x59	; 89
    21e2:	b0 e0       	ldi	r27, 0x00	; 0
    21e4:	e9 e5       	ldi	r30, 0x59	; 89
    21e6:	f0 e0       	ldi	r31, 0x00	; 0
    21e8:	80 81       	ld	r24, Z
    21ea:	82 60       	ori	r24, 0x02	; 2
    21ec:	8c 93       	st	X, r24
	}
	if (Loc_u8Prescaller == NoPrescaller) {
    21ee:	8b 81       	ldd	r24, Y+3	; 0x03
    21f0:	88 23       	and	r24, r24
    21f2:	b9 f4       	brne	.+46     	; 0x2222 <MCAL_Timer0_Init+0xf4>
		CLR_BIT(TCCR0, 0);
    21f4:	a3 e5       	ldi	r26, 0x53	; 83
    21f6:	b0 e0       	ldi	r27, 0x00	; 0
    21f8:	e3 e5       	ldi	r30, 0x53	; 83
    21fa:	f0 e0       	ldi	r31, 0x00	; 0
    21fc:	80 81       	ld	r24, Z
    21fe:	8e 7f       	andi	r24, 0xFE	; 254
    2200:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 1);
    2202:	a3 e5       	ldi	r26, 0x53	; 83
    2204:	b0 e0       	ldi	r27, 0x00	; 0
    2206:	e3 e5       	ldi	r30, 0x53	; 83
    2208:	f0 e0       	ldi	r31, 0x00	; 0
    220a:	80 81       	ld	r24, Z
    220c:	8d 7f       	andi	r24, 0xFD	; 253
    220e:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 2);
    2210:	a3 e5       	ldi	r26, 0x53	; 83
    2212:	b0 e0       	ldi	r27, 0x00	; 0
    2214:	e3 e5       	ldi	r30, 0x53	; 83
    2216:	f0 e0       	ldi	r31, 0x00	; 0
    2218:	80 81       	ld	r24, Z
    221a:	8b 7f       	andi	r24, 0xFB	; 251
    221c:	8c 93       	st	X, r24
		LOC_u8ReturnValue = E_OK;
    221e:	19 82       	std	Y+1, r1	; 0x01
    2220:	f1 c0       	rjmp	.+482    	; 0x2404 <MCAL_Timer0_Init+0x2d6>
	} else if (Loc_u8Prescaller == Prescaller_1) {
    2222:	8b 81       	ldd	r24, Y+3	; 0x03
    2224:	81 30       	cpi	r24, 0x01	; 1
    2226:	19 f5       	brne	.+70     	; 0x226e <MCAL_Timer0_Init+0x140>
		SET_BIT(TCCR0, 0);
    2228:	a3 e5       	ldi	r26, 0x53	; 83
    222a:	b0 e0       	ldi	r27, 0x00	; 0
    222c:	e3 e5       	ldi	r30, 0x53	; 83
    222e:	f0 e0       	ldi	r31, 0x00	; 0
    2230:	80 81       	ld	r24, Z
    2232:	81 60       	ori	r24, 0x01	; 1
    2234:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 1);
    2236:	a3 e5       	ldi	r26, 0x53	; 83
    2238:	b0 e0       	ldi	r27, 0x00	; 0
    223a:	e3 e5       	ldi	r30, 0x53	; 83
    223c:	f0 e0       	ldi	r31, 0x00	; 0
    223e:	80 81       	ld	r24, Z
    2240:	8d 7f       	andi	r24, 0xFD	; 253
    2242:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 2);
    2244:	a3 e5       	ldi	r26, 0x53	; 83
    2246:	b0 e0       	ldi	r27, 0x00	; 0
    2248:	e3 e5       	ldi	r30, 0x53	; 83
    224a:	f0 e0       	ldi	r31, 0x00	; 0
    224c:	80 81       	ld	r24, Z
    224e:	8b 7f       	andi	r24, 0xFB	; 251
    2250:	8c 93       	st	X, r24
		Glob_TickTime = Prescaller1_Value / (f32) CPU_Frequancy;
    2252:	8d eb       	ldi	r24, 0xBD	; 189
    2254:	97 e3       	ldi	r25, 0x37	; 55
    2256:	a6 e8       	ldi	r26, 0x86	; 134
    2258:	b3 e3       	ldi	r27, 0x33	; 51
    225a:	80 93 3a 06 	sts	0x063A, r24
    225e:	90 93 3b 06 	sts	0x063B, r25
    2262:	a0 93 3c 06 	sts	0x063C, r26
    2266:	b0 93 3d 06 	sts	0x063D, r27
		LOC_u8ReturnValue = E_OK;
    226a:	19 82       	std	Y+1, r1	; 0x01
    226c:	cb c0       	rjmp	.+406    	; 0x2404 <MCAL_Timer0_Init+0x2d6>
	} else if (Loc_u8Prescaller == Prescaller_8) {
    226e:	8b 81       	ldd	r24, Y+3	; 0x03
    2270:	82 30       	cpi	r24, 0x02	; 2
    2272:	19 f5       	brne	.+70     	; 0x22ba <MCAL_Timer0_Init+0x18c>
		CLR_BIT(TCCR0, 0);
    2274:	a3 e5       	ldi	r26, 0x53	; 83
    2276:	b0 e0       	ldi	r27, 0x00	; 0
    2278:	e3 e5       	ldi	r30, 0x53	; 83
    227a:	f0 e0       	ldi	r31, 0x00	; 0
    227c:	80 81       	ld	r24, Z
    227e:	8e 7f       	andi	r24, 0xFE	; 254
    2280:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 1);
    2282:	a3 e5       	ldi	r26, 0x53	; 83
    2284:	b0 e0       	ldi	r27, 0x00	; 0
    2286:	e3 e5       	ldi	r30, 0x53	; 83
    2288:	f0 e0       	ldi	r31, 0x00	; 0
    228a:	80 81       	ld	r24, Z
    228c:	82 60       	ori	r24, 0x02	; 2
    228e:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 2);
    2290:	a3 e5       	ldi	r26, 0x53	; 83
    2292:	b0 e0       	ldi	r27, 0x00	; 0
    2294:	e3 e5       	ldi	r30, 0x53	; 83
    2296:	f0 e0       	ldi	r31, 0x00	; 0
    2298:	80 81       	ld	r24, Z
    229a:	8b 7f       	andi	r24, 0xFB	; 251
    229c:	8c 93       	st	X, r24
		Glob_TickTime = Prescaller8_Value / (f32) CPU_Frequancy;
    229e:	8d eb       	ldi	r24, 0xBD	; 189
    22a0:	97 e3       	ldi	r25, 0x37	; 55
    22a2:	a6 e0       	ldi	r26, 0x06	; 6
    22a4:	b5 e3       	ldi	r27, 0x35	; 53
    22a6:	80 93 3a 06 	sts	0x063A, r24
    22aa:	90 93 3b 06 	sts	0x063B, r25
    22ae:	a0 93 3c 06 	sts	0x063C, r26
    22b2:	b0 93 3d 06 	sts	0x063D, r27
		LOC_u8ReturnValue = E_OK;
    22b6:	19 82       	std	Y+1, r1	; 0x01
    22b8:	a5 c0       	rjmp	.+330    	; 0x2404 <MCAL_Timer0_Init+0x2d6>
	} else if (Loc_u8Prescaller == Prescaller_64) {
    22ba:	8b 81       	ldd	r24, Y+3	; 0x03
    22bc:	83 30       	cpi	r24, 0x03	; 3
    22be:	19 f5       	brne	.+70     	; 0x2306 <MCAL_Timer0_Init+0x1d8>
		SET_BIT(TCCR0, 0);
    22c0:	a3 e5       	ldi	r26, 0x53	; 83
    22c2:	b0 e0       	ldi	r27, 0x00	; 0
    22c4:	e3 e5       	ldi	r30, 0x53	; 83
    22c6:	f0 e0       	ldi	r31, 0x00	; 0
    22c8:	80 81       	ld	r24, Z
    22ca:	81 60       	ori	r24, 0x01	; 1
    22cc:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 1);
    22ce:	a3 e5       	ldi	r26, 0x53	; 83
    22d0:	b0 e0       	ldi	r27, 0x00	; 0
    22d2:	e3 e5       	ldi	r30, 0x53	; 83
    22d4:	f0 e0       	ldi	r31, 0x00	; 0
    22d6:	80 81       	ld	r24, Z
    22d8:	82 60       	ori	r24, 0x02	; 2
    22da:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 2);
    22dc:	a3 e5       	ldi	r26, 0x53	; 83
    22de:	b0 e0       	ldi	r27, 0x00	; 0
    22e0:	e3 e5       	ldi	r30, 0x53	; 83
    22e2:	f0 e0       	ldi	r31, 0x00	; 0
    22e4:	80 81       	ld	r24, Z
    22e6:	8b 7f       	andi	r24, 0xFB	; 251
    22e8:	8c 93       	st	X, r24
		Glob_TickTime = Prescaller64_Value / (f32) CPU_Frequancy;
    22ea:	8d eb       	ldi	r24, 0xBD	; 189
    22ec:	97 e3       	ldi	r25, 0x37	; 55
    22ee:	a6 e8       	ldi	r26, 0x86	; 134
    22f0:	b6 e3       	ldi	r27, 0x36	; 54
    22f2:	80 93 3a 06 	sts	0x063A, r24
    22f6:	90 93 3b 06 	sts	0x063B, r25
    22fa:	a0 93 3c 06 	sts	0x063C, r26
    22fe:	b0 93 3d 06 	sts	0x063D, r27
		LOC_u8ReturnValue = E_OK;
    2302:	19 82       	std	Y+1, r1	; 0x01
    2304:	7f c0       	rjmp	.+254    	; 0x2404 <MCAL_Timer0_Init+0x2d6>
	} else if (Loc_u8Prescaller == Prescaller_256) {
    2306:	8b 81       	ldd	r24, Y+3	; 0x03
    2308:	84 30       	cpi	r24, 0x04	; 4
    230a:	19 f5       	brne	.+70     	; 0x2352 <MCAL_Timer0_Init+0x224>
		CLR_BIT(TCCR0, 0);
    230c:	a3 e5       	ldi	r26, 0x53	; 83
    230e:	b0 e0       	ldi	r27, 0x00	; 0
    2310:	e3 e5       	ldi	r30, 0x53	; 83
    2312:	f0 e0       	ldi	r31, 0x00	; 0
    2314:	80 81       	ld	r24, Z
    2316:	8e 7f       	andi	r24, 0xFE	; 254
    2318:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 1);
    231a:	a3 e5       	ldi	r26, 0x53	; 83
    231c:	b0 e0       	ldi	r27, 0x00	; 0
    231e:	e3 e5       	ldi	r30, 0x53	; 83
    2320:	f0 e0       	ldi	r31, 0x00	; 0
    2322:	80 81       	ld	r24, Z
    2324:	8d 7f       	andi	r24, 0xFD	; 253
    2326:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 2);
    2328:	a3 e5       	ldi	r26, 0x53	; 83
    232a:	b0 e0       	ldi	r27, 0x00	; 0
    232c:	e3 e5       	ldi	r30, 0x53	; 83
    232e:	f0 e0       	ldi	r31, 0x00	; 0
    2330:	80 81       	ld	r24, Z
    2332:	84 60       	ori	r24, 0x04	; 4
    2334:	8c 93       	st	X, r24
		Glob_TickTime = Prescaller256_Value / (f32) CPU_Frequancy;
    2336:	8d eb       	ldi	r24, 0xBD	; 189
    2338:	97 e3       	ldi	r25, 0x37	; 55
    233a:	a6 e8       	ldi	r26, 0x86	; 134
    233c:	b7 e3       	ldi	r27, 0x37	; 55
    233e:	80 93 3a 06 	sts	0x063A, r24
    2342:	90 93 3b 06 	sts	0x063B, r25
    2346:	a0 93 3c 06 	sts	0x063C, r26
    234a:	b0 93 3d 06 	sts	0x063D, r27
		LOC_u8ReturnValue = E_OK;
    234e:	19 82       	std	Y+1, r1	; 0x01
    2350:	59 c0       	rjmp	.+178    	; 0x2404 <MCAL_Timer0_Init+0x2d6>
	} else if (Loc_u8Prescaller == Prescaller_1024) {
    2352:	8b 81       	ldd	r24, Y+3	; 0x03
    2354:	85 30       	cpi	r24, 0x05	; 5
    2356:	19 f5       	brne	.+70     	; 0x239e <MCAL_Timer0_Init+0x270>
		SET_BIT(TCCR0, 0);
    2358:	a3 e5       	ldi	r26, 0x53	; 83
    235a:	b0 e0       	ldi	r27, 0x00	; 0
    235c:	e3 e5       	ldi	r30, 0x53	; 83
    235e:	f0 e0       	ldi	r31, 0x00	; 0
    2360:	80 81       	ld	r24, Z
    2362:	81 60       	ori	r24, 0x01	; 1
    2364:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 1);
    2366:	a3 e5       	ldi	r26, 0x53	; 83
    2368:	b0 e0       	ldi	r27, 0x00	; 0
    236a:	e3 e5       	ldi	r30, 0x53	; 83
    236c:	f0 e0       	ldi	r31, 0x00	; 0
    236e:	80 81       	ld	r24, Z
    2370:	8d 7f       	andi	r24, 0xFD	; 253
    2372:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 2);
    2374:	a3 e5       	ldi	r26, 0x53	; 83
    2376:	b0 e0       	ldi	r27, 0x00	; 0
    2378:	e3 e5       	ldi	r30, 0x53	; 83
    237a:	f0 e0       	ldi	r31, 0x00	; 0
    237c:	80 81       	ld	r24, Z
    237e:	84 60       	ori	r24, 0x04	; 4
    2380:	8c 93       	st	X, r24
		Glob_TickTime = Prescaller1024_Value / (f32) CPU_Frequancy;
    2382:	8d eb       	ldi	r24, 0xBD	; 189
    2384:	97 e3       	ldi	r25, 0x37	; 55
    2386:	a6 e8       	ldi	r26, 0x86	; 134
    2388:	b8 e3       	ldi	r27, 0x38	; 56
    238a:	80 93 3a 06 	sts	0x063A, r24
    238e:	90 93 3b 06 	sts	0x063B, r25
    2392:	a0 93 3c 06 	sts	0x063C, r26
    2396:	b0 93 3d 06 	sts	0x063D, r27
		LOC_u8ReturnValue = E_OK;
    239a:	19 82       	std	Y+1, r1	; 0x01
    239c:	33 c0       	rjmp	.+102    	; 0x2404 <MCAL_Timer0_Init+0x2d6>
	} else if (Loc_u8Prescaller == Clock_on_falling_edge) {
    239e:	8b 81       	ldd	r24, Y+3	; 0x03
    23a0:	86 30       	cpi	r24, 0x06	; 6
    23a2:	b9 f4       	brne	.+46     	; 0x23d2 <MCAL_Timer0_Init+0x2a4>
		CLR_BIT(TCCR0, 0);
    23a4:	a3 e5       	ldi	r26, 0x53	; 83
    23a6:	b0 e0       	ldi	r27, 0x00	; 0
    23a8:	e3 e5       	ldi	r30, 0x53	; 83
    23aa:	f0 e0       	ldi	r31, 0x00	; 0
    23ac:	80 81       	ld	r24, Z
    23ae:	8e 7f       	andi	r24, 0xFE	; 254
    23b0:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 1);
    23b2:	a3 e5       	ldi	r26, 0x53	; 83
    23b4:	b0 e0       	ldi	r27, 0x00	; 0
    23b6:	e3 e5       	ldi	r30, 0x53	; 83
    23b8:	f0 e0       	ldi	r31, 0x00	; 0
    23ba:	80 81       	ld	r24, Z
    23bc:	82 60       	ori	r24, 0x02	; 2
    23be:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 2);
    23c0:	a3 e5       	ldi	r26, 0x53	; 83
    23c2:	b0 e0       	ldi	r27, 0x00	; 0
    23c4:	e3 e5       	ldi	r30, 0x53	; 83
    23c6:	f0 e0       	ldi	r31, 0x00	; 0
    23c8:	80 81       	ld	r24, Z
    23ca:	84 60       	ori	r24, 0x04	; 4
    23cc:	8c 93       	st	X, r24
		LOC_u8ReturnValue = E_OK;
    23ce:	19 82       	std	Y+1, r1	; 0x01
    23d0:	19 c0       	rjmp	.+50     	; 0x2404 <MCAL_Timer0_Init+0x2d6>
	} else if (Loc_u8Prescaller == Clock_on_rising_edge) {
    23d2:	8b 81       	ldd	r24, Y+3	; 0x03
    23d4:	87 30       	cpi	r24, 0x07	; 7
    23d6:	b1 f4       	brne	.+44     	; 0x2404 <MCAL_Timer0_Init+0x2d6>
		SET_BIT(TCCR0, 0);
    23d8:	a3 e5       	ldi	r26, 0x53	; 83
    23da:	b0 e0       	ldi	r27, 0x00	; 0
    23dc:	e3 e5       	ldi	r30, 0x53	; 83
    23de:	f0 e0       	ldi	r31, 0x00	; 0
    23e0:	80 81       	ld	r24, Z
    23e2:	81 60       	ori	r24, 0x01	; 1
    23e4:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 1);
    23e6:	a3 e5       	ldi	r26, 0x53	; 83
    23e8:	b0 e0       	ldi	r27, 0x00	; 0
    23ea:	e3 e5       	ldi	r30, 0x53	; 83
    23ec:	f0 e0       	ldi	r31, 0x00	; 0
    23ee:	80 81       	ld	r24, Z
    23f0:	82 60       	ori	r24, 0x02	; 2
    23f2:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 2);
    23f4:	a3 e5       	ldi	r26, 0x53	; 83
    23f6:	b0 e0       	ldi	r27, 0x00	; 0
    23f8:	e3 e5       	ldi	r30, 0x53	; 83
    23fa:	f0 e0       	ldi	r31, 0x00	; 0
    23fc:	80 81       	ld	r24, Z
    23fe:	84 60       	ori	r24, 0x04	; 4
    2400:	8c 93       	st	X, r24
		LOC_u8ReturnValue = E_OK;
    2402:	19 82       	std	Y+1, r1	; 0x01
	} else {
		//NOTHING
	}
	if (Loc_u8OC0Mode == Disconnected) {
    2404:	8c 81       	ldd	r24, Y+4	; 0x04
    2406:	88 23       	and	r24, r24
    2408:	79 f4       	brne	.+30     	; 0x2428 <MCAL_Timer0_Init+0x2fa>
			CLR_BIT(TCCR0, 4);
    240a:	a3 e5       	ldi	r26, 0x53	; 83
    240c:	b0 e0       	ldi	r27, 0x00	; 0
    240e:	e3 e5       	ldi	r30, 0x53	; 83
    2410:	f0 e0       	ldi	r31, 0x00	; 0
    2412:	80 81       	ld	r24, Z
    2414:	8f 7e       	andi	r24, 0xEF	; 239
    2416:	8c 93       	st	X, r24
			CLR_BIT(TCCR0, 5);
    2418:	a3 e5       	ldi	r26, 0x53	; 83
    241a:	b0 e0       	ldi	r27, 0x00	; 0
    241c:	e3 e5       	ldi	r30, 0x53	; 83
    241e:	f0 e0       	ldi	r31, 0x00	; 0
    2420:	80 81       	ld	r24, Z
    2422:	8f 7d       	andi	r24, 0xDF	; 223
    2424:	8c 93       	st	X, r24
    2426:	43 c0       	rjmp	.+134    	; 0x24ae <MCAL_Timer0_Init+0x380>
		} else if (Loc_u8OC0Mode == Reserved) {
    2428:	8c 81       	ldd	r24, Y+4	; 0x04
    242a:	81 30       	cpi	r24, 0x01	; 1
    242c:	79 f4       	brne	.+30     	; 0x244c <MCAL_Timer0_Init+0x31e>
			SET_BIT(TCCR0, 4);
    242e:	a3 e5       	ldi	r26, 0x53	; 83
    2430:	b0 e0       	ldi	r27, 0x00	; 0
    2432:	e3 e5       	ldi	r30, 0x53	; 83
    2434:	f0 e0       	ldi	r31, 0x00	; 0
    2436:	80 81       	ld	r24, Z
    2438:	80 61       	ori	r24, 0x10	; 16
    243a:	8c 93       	st	X, r24
			CLR_BIT(TCCR0, 5);
    243c:	a3 e5       	ldi	r26, 0x53	; 83
    243e:	b0 e0       	ldi	r27, 0x00	; 0
    2440:	e3 e5       	ldi	r30, 0x53	; 83
    2442:	f0 e0       	ldi	r31, 0x00	; 0
    2444:	80 81       	ld	r24, Z
    2446:	8f 7d       	andi	r24, 0xDF	; 223
    2448:	8c 93       	st	X, r24
    244a:	31 c0       	rjmp	.+98     	; 0x24ae <MCAL_Timer0_Init+0x380>
			//PWM, Fast PWM
		} else if (Loc_u8OC0Mode == Non_Inverted) {
    244c:	8c 81       	ldd	r24, Y+4	; 0x04
    244e:	82 30       	cpi	r24, 0x02	; 2
    2450:	b1 f4       	brne	.+44     	; 0x247e <MCAL_Timer0_Init+0x350>
			SET_BIT(TCCR0, 5);
    2452:	a3 e5       	ldi	r26, 0x53	; 83
    2454:	b0 e0       	ldi	r27, 0x00	; 0
    2456:	e3 e5       	ldi	r30, 0x53	; 83
    2458:	f0 e0       	ldi	r31, 0x00	; 0
    245a:	80 81       	ld	r24, Z
    245c:	80 62       	ori	r24, 0x20	; 32
    245e:	8c 93       	st	X, r24
			CLR_BIT(TCCR0, 4);
    2460:	a3 e5       	ldi	r26, 0x53	; 83
    2462:	b0 e0       	ldi	r27, 0x00	; 0
    2464:	e3 e5       	ldi	r30, 0x53	; 83
    2466:	f0 e0       	ldi	r31, 0x00	; 0
    2468:	80 81       	ld	r24, Z
    246a:	8f 7e       	andi	r24, 0xEF	; 239
    246c:	8c 93       	st	X, r24
			// OC0
			SET_BIT(DDRB, 3);
    246e:	a7 e3       	ldi	r26, 0x37	; 55
    2470:	b0 e0       	ldi	r27, 0x00	; 0
    2472:	e7 e3       	ldi	r30, 0x37	; 55
    2474:	f0 e0       	ldi	r31, 0x00	; 0
    2476:	80 81       	ld	r24, Z
    2478:	88 60       	ori	r24, 0x08	; 8
    247a:	8c 93       	st	X, r24
    247c:	18 c0       	rjmp	.+48     	; 0x24ae <MCAL_Timer0_Init+0x380>
			//PWM, Fast PWM
		} else if (Loc_u8OC0Mode == Inverted) {
    247e:	8c 81       	ldd	r24, Y+4	; 0x04
    2480:	83 30       	cpi	r24, 0x03	; 3
    2482:	a9 f4       	brne	.+42     	; 0x24ae <MCAL_Timer0_Init+0x380>
			SET_BIT(TCCR0, 4);
    2484:	a3 e5       	ldi	r26, 0x53	; 83
    2486:	b0 e0       	ldi	r27, 0x00	; 0
    2488:	e3 e5       	ldi	r30, 0x53	; 83
    248a:	f0 e0       	ldi	r31, 0x00	; 0
    248c:	80 81       	ld	r24, Z
    248e:	80 61       	ori	r24, 0x10	; 16
    2490:	8c 93       	st	X, r24
			SET_BIT(TCCR0, 5);
    2492:	a3 e5       	ldi	r26, 0x53	; 83
    2494:	b0 e0       	ldi	r27, 0x00	; 0
    2496:	e3 e5       	ldi	r30, 0x53	; 83
    2498:	f0 e0       	ldi	r31, 0x00	; 0
    249a:	80 81       	ld	r24, Z
    249c:	80 62       	ori	r24, 0x20	; 32
    249e:	8c 93       	st	X, r24
			// OC0
			SET_BIT(DDRB, 3);
    24a0:	a7 e3       	ldi	r26, 0x37	; 55
    24a2:	b0 e0       	ldi	r27, 0x00	; 0
    24a4:	e7 e3       	ldi	r30, 0x37	; 55
    24a6:	f0 e0       	ldi	r31, 0x00	; 0
    24a8:	80 81       	ld	r24, Z
    24aa:	88 60       	ori	r24, 0x08	; 8
    24ac:	8c 93       	st	X, r24
		}
}
    24ae:	0f 90       	pop	r0
    24b0:	0f 90       	pop	r0
    24b2:	0f 90       	pop	r0
    24b4:	0f 90       	pop	r0
    24b6:	cf 91       	pop	r28
    24b8:	df 91       	pop	r29
    24ba:	08 95       	ret

000024bc <MCAL_Timer0_SetPreloadValue>:
void MCAL_Timer0_SetPreloadValue(u8 Loc_u8Value) {
    24bc:	df 93       	push	r29
    24be:	cf 93       	push	r28
    24c0:	0f 92       	push	r0
    24c2:	cd b7       	in	r28, 0x3d	; 61
    24c4:	de b7       	in	r29, 0x3e	; 62
    24c6:	89 83       	std	Y+1, r24	; 0x01
	TCNT0 = Loc_u8Value;
    24c8:	e2 e5       	ldi	r30, 0x52	; 82
    24ca:	f0 e0       	ldi	r31, 0x00	; 0
    24cc:	89 81       	ldd	r24, Y+1	; 0x01
    24ce:	80 83       	st	Z, r24
}
    24d0:	0f 90       	pop	r0
    24d2:	cf 91       	pop	r28
    24d4:	df 91       	pop	r29
    24d6:	08 95       	ret

000024d8 <MCAL_Timer0_SetCompareValue>:
void MCAL_Timer0_SetCompareValue(u8 Loc_u8Value) {
    24d8:	df 93       	push	r29
    24da:	cf 93       	push	r28
    24dc:	0f 92       	push	r0
    24de:	cd b7       	in	r28, 0x3d	; 61
    24e0:	de b7       	in	r29, 0x3e	; 62
    24e2:	89 83       	std	Y+1, r24	; 0x01
	OCR0 = Loc_u8Value;
    24e4:	ec e5       	ldi	r30, 0x5C	; 92
    24e6:	f0 e0       	ldi	r31, 0x00	; 0
    24e8:	89 81       	ldd	r24, Y+1	; 0x01
    24ea:	80 83       	st	Z, r24
}
    24ec:	0f 90       	pop	r0
    24ee:	cf 91       	pop	r28
    24f0:	df 91       	pop	r29
    24f2:	08 95       	ret

000024f4 <MCAL_Timer0_EnableNormalMode>:
void MCAL_Timer0_EnableNormalMode() {
    24f4:	df 93       	push	r29
    24f6:	cf 93       	push	r28
    24f8:	cd b7       	in	r28, 0x3d	; 61
    24fa:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(TIMSK, 0);
    24fc:	a9 e5       	ldi	r26, 0x59	; 89
    24fe:	b0 e0       	ldi	r27, 0x00	; 0
    2500:	e9 e5       	ldi	r30, 0x59	; 89
    2502:	f0 e0       	ldi	r31, 0x00	; 0
    2504:	80 81       	ld	r24, Z
    2506:	81 60       	ori	r24, 0x01	; 1
    2508:	8c 93       	st	X, r24
}
    250a:	cf 91       	pop	r28
    250c:	df 91       	pop	r29
    250e:	08 95       	ret

00002510 <MCAL_Timer0_DisableNormalMode>:
void MCAL_Timer0_DisableNormalMode() {
    2510:	df 93       	push	r29
    2512:	cf 93       	push	r28
    2514:	cd b7       	in	r28, 0x3d	; 61
    2516:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK, 0);
    2518:	a9 e5       	ldi	r26, 0x59	; 89
    251a:	b0 e0       	ldi	r27, 0x00	; 0
    251c:	e9 e5       	ldi	r30, 0x59	; 89
    251e:	f0 e0       	ldi	r31, 0x00	; 0
    2520:	80 81       	ld	r24, Z
    2522:	8e 7f       	andi	r24, 0xFE	; 254
    2524:	8c 93       	st	X, r24
}
    2526:	cf 91       	pop	r28
    2528:	df 91       	pop	r29
    252a:	08 95       	ret

0000252c <MCAL_Timer0_EnableCTCMode>:
void MCAL_Timer0_EnableCTCMode() {
    252c:	df 93       	push	r29
    252e:	cf 93       	push	r28
    2530:	cd b7       	in	r28, 0x3d	; 61
    2532:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(TIMSK, 1);
    2534:	a9 e5       	ldi	r26, 0x59	; 89
    2536:	b0 e0       	ldi	r27, 0x00	; 0
    2538:	e9 e5       	ldi	r30, 0x59	; 89
    253a:	f0 e0       	ldi	r31, 0x00	; 0
    253c:	80 81       	ld	r24, Z
    253e:	82 60       	ori	r24, 0x02	; 2
    2540:	8c 93       	st	X, r24
}
    2542:	cf 91       	pop	r28
    2544:	df 91       	pop	r29
    2546:	08 95       	ret

00002548 <MCAL_Timer0_DisableCTCMode>:
void MCAL_Timer0_DisableCTCMode() {
    2548:	df 93       	push	r29
    254a:	cf 93       	push	r28
    254c:	cd b7       	in	r28, 0x3d	; 61
    254e:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK, 1);
    2550:	a9 e5       	ldi	r26, 0x59	; 89
    2552:	b0 e0       	ldi	r27, 0x00	; 0
    2554:	e9 e5       	ldi	r30, 0x59	; 89
    2556:	f0 e0       	ldi	r31, 0x00	; 0
    2558:	80 81       	ld	r24, Z
    255a:	8d 7f       	andi	r24, 0xFD	; 253
    255c:	8c 93       	st	X, r24
}
    255e:	cf 91       	pop	r28
    2560:	df 91       	pop	r29
    2562:	08 95       	ret

00002564 <MCAL_Timer0_Delayms_NormalMode>:

void MCAL_Timer0_Delayms_NormalMode(u32 Loc_u32MilliSeconds) {
    2564:	df 93       	push	r29
    2566:	cf 93       	push	r28
    2568:	cd b7       	in	r28, 0x3d	; 61
    256a:	de b7       	in	r29, 0x3e	; 62
    256c:	28 97       	sbiw	r28, 0x08	; 8
    256e:	0f b6       	in	r0, 0x3f	; 63
    2570:	f8 94       	cli
    2572:	de bf       	out	0x3e, r29	; 62
    2574:	0f be       	out	0x3f, r0	; 63
    2576:	cd bf       	out	0x3d, r28	; 61
    2578:	6d 83       	std	Y+5, r22	; 0x05
    257a:	7e 83       	std	Y+6, r23	; 0x06
    257c:	8f 83       	std	Y+7, r24	; 0x07
    257e:	98 87       	std	Y+8, r25	; 0x08
	u32 N = 0;
    2580:	19 82       	std	Y+1, r1	; 0x01
    2582:	1a 82       	std	Y+2, r1	; 0x02
    2584:	1b 82       	std	Y+3, r1	; 0x03
    2586:	1c 82       	std	Y+4, r1	; 0x04
	N = (Loc_u32MilliSeconds / 1000.0) / (f32) Glob_TickTime;
    2588:	6d 81       	ldd	r22, Y+5	; 0x05
    258a:	7e 81       	ldd	r23, Y+6	; 0x06
    258c:	8f 81       	ldd	r24, Y+7	; 0x07
    258e:	98 85       	ldd	r25, Y+8	; 0x08
    2590:	0e 94 37 05 	call	0xa6e	; 0xa6e <__floatunsisf>
    2594:	dc 01       	movw	r26, r24
    2596:	cb 01       	movw	r24, r22
    2598:	bc 01       	movw	r22, r24
    259a:	cd 01       	movw	r24, r26
    259c:	20 e0       	ldi	r18, 0x00	; 0
    259e:	30 e0       	ldi	r19, 0x00	; 0
    25a0:	4a e7       	ldi	r20, 0x7A	; 122
    25a2:	54 e4       	ldi	r21, 0x44	; 68
    25a4:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    25a8:	dc 01       	movw	r26, r24
    25aa:	cb 01       	movw	r24, r22
    25ac:	20 91 3a 06 	lds	r18, 0x063A
    25b0:	30 91 3b 06 	lds	r19, 0x063B
    25b4:	40 91 3c 06 	lds	r20, 0x063C
    25b8:	50 91 3d 06 	lds	r21, 0x063D
    25bc:	bc 01       	movw	r22, r24
    25be:	cd 01       	movw	r24, r26
    25c0:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    25c4:	dc 01       	movw	r26, r24
    25c6:	cb 01       	movw	r24, r22
    25c8:	bc 01       	movw	r22, r24
    25ca:	cd 01       	movw	r24, r26
    25cc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    25d0:	dc 01       	movw	r26, r24
    25d2:	cb 01       	movw	r24, r22
    25d4:	89 83       	std	Y+1, r24	; 0x01
    25d6:	9a 83       	std	Y+2, r25	; 0x02
    25d8:	ab 83       	std	Y+3, r26	; 0x03
    25da:	bc 83       	std	Y+4, r27	; 0x04
	Start = N % 256;
    25dc:	89 81       	ldd	r24, Y+1	; 0x01
    25de:	9a 81       	ldd	r25, Y+2	; 0x02
    25e0:	90 70       	andi	r25, 0x00	; 0
    25e2:	90 93 8b 01 	sts	0x018B, r25
    25e6:	80 93 8a 01 	sts	0x018A, r24
	if (Start == 0) {
    25ea:	80 91 8a 01 	lds	r24, 0x018A
    25ee:	90 91 8b 01 	lds	r25, 0x018B
    25f2:	00 97       	sbiw	r24, 0x00	; 0
    25f4:	99 f4       	brne	.+38     	; 0x261c <MCAL_Timer0_Delayms_NormalMode+0xb8>
		MCAL_Timer0_SetPreloadValue(Start);
    25f6:	80 91 8a 01 	lds	r24, 0x018A
    25fa:	90 91 8b 01 	lds	r25, 0x018B
    25fe:	0e 94 5e 12 	call	0x24bc	; 0x24bc <MCAL_Timer0_SetPreloadValue>
		Counter = N / 256;
    2602:	89 81       	ldd	r24, Y+1	; 0x01
    2604:	9a 81       	ldd	r25, Y+2	; 0x02
    2606:	ab 81       	ldd	r26, Y+3	; 0x03
    2608:	bc 81       	ldd	r27, Y+4	; 0x04
    260a:	89 2f       	mov	r24, r25
    260c:	9a 2f       	mov	r25, r26
    260e:	ab 2f       	mov	r26, r27
    2610:	bb 27       	eor	r27, r27
    2612:	90 93 8d 01 	sts	0x018D, r25
    2616:	80 93 8c 01 	sts	0x018C, r24
    261a:	19 c0       	rjmp	.+50     	; 0x264e <MCAL_Timer0_Delayms_NormalMode+0xea>
	} else if (Start != 0) {
    261c:	80 91 8a 01 	lds	r24, 0x018A
    2620:	90 91 8b 01 	lds	r25, 0x018B
    2624:	00 97       	sbiw	r24, 0x00	; 0
    2626:	99 f0       	breq	.+38     	; 0x264e <MCAL_Timer0_Delayms_NormalMode+0xea>
		MCAL_Timer0_SetPreloadValue(Start);
    2628:	80 91 8a 01 	lds	r24, 0x018A
    262c:	90 91 8b 01 	lds	r25, 0x018B
    2630:	0e 94 5e 12 	call	0x24bc	; 0x24bc <MCAL_Timer0_SetPreloadValue>
		Counter = ((N / 256) + 1);
    2634:	89 81       	ldd	r24, Y+1	; 0x01
    2636:	9a 81       	ldd	r25, Y+2	; 0x02
    2638:	ab 81       	ldd	r26, Y+3	; 0x03
    263a:	bc 81       	ldd	r27, Y+4	; 0x04
    263c:	89 2f       	mov	r24, r25
    263e:	9a 2f       	mov	r25, r26
    2640:	ab 2f       	mov	r26, r27
    2642:	bb 27       	eor	r27, r27
    2644:	01 96       	adiw	r24, 0x01	; 1
    2646:	90 93 8d 01 	sts	0x018D, r25
    264a:	80 93 8c 01 	sts	0x018C, r24
	} else {
		//NOTHING
	}
}
    264e:	28 96       	adiw	r28, 0x08	; 8
    2650:	0f b6       	in	r0, 0x3f	; 63
    2652:	f8 94       	cli
    2654:	de bf       	out	0x3e, r29	; 62
    2656:	0f be       	out	0x3f, r0	; 63
    2658:	cd bf       	out	0x3d, r28	; 61
    265a:	cf 91       	pop	r28
    265c:	df 91       	pop	r29
    265e:	08 95       	ret

00002660 <MCAL_Timer0_Delayms_CTCMode>:
void MCAL_Timer0_Delayms_CTCMode(u32 Loc_u32MilliSeconds) {
    2660:	df 93       	push	r29
    2662:	cf 93       	push	r28
    2664:	cd b7       	in	r28, 0x3d	; 61
    2666:	de b7       	in	r29, 0x3e	; 62
    2668:	29 97       	sbiw	r28, 0x09	; 9
    266a:	0f b6       	in	r0, 0x3f	; 63
    266c:	f8 94       	cli
    266e:	de bf       	out	0x3e, r29	; 62
    2670:	0f be       	out	0x3f, r0	; 63
    2672:	cd bf       	out	0x3d, r28	; 61
    2674:	6e 83       	std	Y+6, r22	; 0x06
    2676:	7f 83       	std	Y+7, r23	; 0x07
    2678:	88 87       	std	Y+8, r24	; 0x08
    267a:	99 87       	std	Y+9, r25	; 0x09
	u8 LOC_u8ReturnValue = E_NOT_OK;
    267c:	81 e0       	ldi	r24, 0x01	; 1
    267e:	8d 83       	std	Y+5, r24	; 0x05
	f32 N = 0;
    2680:	80 e0       	ldi	r24, 0x00	; 0
    2682:	90 e0       	ldi	r25, 0x00	; 0
    2684:	a0 e0       	ldi	r26, 0x00	; 0
    2686:	b0 e0       	ldi	r27, 0x00	; 0
    2688:	89 83       	std	Y+1, r24	; 0x01
    268a:	9a 83       	std	Y+2, r25	; 0x02
    268c:	ab 83       	std	Y+3, r26	; 0x03
    268e:	bc 83       	std	Y+4, r27	; 0x04
	MCAL_Timer0_SetCompareValue(CompareStartValue);
    2690:	87 ec       	ldi	r24, 0xC7	; 199
    2692:	0e 94 6c 12 	call	0x24d8	; 0x24d8 <MCAL_Timer0_SetCompareValue>
	N = ((CompareStartValue + 1) * Glob_TickTime);
    2696:	80 91 3a 06 	lds	r24, 0x063A
    269a:	90 91 3b 06 	lds	r25, 0x063B
    269e:	a0 91 3c 06 	lds	r26, 0x063C
    26a2:	b0 91 3d 06 	lds	r27, 0x063D
    26a6:	bc 01       	movw	r22, r24
    26a8:	cd 01       	movw	r24, r26
    26aa:	20 e0       	ldi	r18, 0x00	; 0
    26ac:	30 e0       	ldi	r19, 0x00	; 0
    26ae:	48 e4       	ldi	r20, 0x48	; 72
    26b0:	53 e4       	ldi	r21, 0x43	; 67
    26b2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    26b6:	dc 01       	movw	r26, r24
    26b8:	cb 01       	movw	r24, r22
    26ba:	89 83       	std	Y+1, r24	; 0x01
    26bc:	9a 83       	std	Y+2, r25	; 0x02
    26be:	ab 83       	std	Y+3, r26	; 0x03
    26c0:	bc 83       	std	Y+4, r27	; 0x04
	Counter = ((Loc_u32MilliSeconds/1000.0) / N);
    26c2:	6e 81       	ldd	r22, Y+6	; 0x06
    26c4:	7f 81       	ldd	r23, Y+7	; 0x07
    26c6:	88 85       	ldd	r24, Y+8	; 0x08
    26c8:	99 85       	ldd	r25, Y+9	; 0x09
    26ca:	0e 94 37 05 	call	0xa6e	; 0xa6e <__floatunsisf>
    26ce:	dc 01       	movw	r26, r24
    26d0:	cb 01       	movw	r24, r22
    26d2:	bc 01       	movw	r22, r24
    26d4:	cd 01       	movw	r24, r26
    26d6:	20 e0       	ldi	r18, 0x00	; 0
    26d8:	30 e0       	ldi	r19, 0x00	; 0
    26da:	4a e7       	ldi	r20, 0x7A	; 122
    26dc:	54 e4       	ldi	r21, 0x44	; 68
    26de:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    26e2:	dc 01       	movw	r26, r24
    26e4:	cb 01       	movw	r24, r22
    26e6:	bc 01       	movw	r22, r24
    26e8:	cd 01       	movw	r24, r26
    26ea:	29 81       	ldd	r18, Y+1	; 0x01
    26ec:	3a 81       	ldd	r19, Y+2	; 0x02
    26ee:	4b 81       	ldd	r20, Y+3	; 0x03
    26f0:	5c 81       	ldd	r21, Y+4	; 0x04
    26f2:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    26f6:	dc 01       	movw	r26, r24
    26f8:	cb 01       	movw	r24, r22
    26fa:	bc 01       	movw	r22, r24
    26fc:	cd 01       	movw	r24, r26
    26fe:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2702:	dc 01       	movw	r26, r24
    2704:	cb 01       	movw	r24, r22
    2706:	90 93 8d 01 	sts	0x018D, r25
    270a:	80 93 8c 01 	sts	0x018C, r24

	LOC_u8ReturnValue = E_OK;
    270e:	1d 82       	std	Y+5, r1	; 0x05
}
    2710:	29 96       	adiw	r28, 0x09	; 9
    2712:	0f b6       	in	r0, 0x3f	; 63
    2714:	f8 94       	cli
    2716:	de bf       	out	0x3e, r29	; 62
    2718:	0f be       	out	0x3f, r0	; 63
    271a:	cd bf       	out	0x3d, r28	; 61
    271c:	cf 91       	pop	r28
    271e:	df 91       	pop	r29
    2720:	08 95       	ret

00002722 <MCAL_Timer0_CallBack>:

void MCAL_Timer0_CallBack(void (*ptr)(void)) {
    2722:	df 93       	push	r29
    2724:	cf 93       	push	r28
    2726:	00 d0       	rcall	.+0      	; 0x2728 <MCAL_Timer0_CallBack+0x6>
    2728:	cd b7       	in	r28, 0x3d	; 61
    272a:	de b7       	in	r29, 0x3e	; 62
    272c:	9a 83       	std	Y+2, r25	; 0x02
    272e:	89 83       	std	Y+1, r24	; 0x01
	if (ptr != '\0')
    2730:	89 81       	ldd	r24, Y+1	; 0x01
    2732:	9a 81       	ldd	r25, Y+2	; 0x02
    2734:	00 97       	sbiw	r24, 0x00	; 0
    2736:	31 f0       	breq	.+12     	; 0x2744 <MCAL_Timer0_CallBack+0x22>
		Gptr3 = ptr;
    2738:	89 81       	ldd	r24, Y+1	; 0x01
    273a:	9a 81       	ldd	r25, Y+2	; 0x02
    273c:	90 93 89 01 	sts	0x0189, r25
    2740:	80 93 88 01 	sts	0x0188, r24
}
    2744:	0f 90       	pop	r0
    2746:	0f 90       	pop	r0
    2748:	cf 91       	pop	r28
    274a:	df 91       	pop	r29
    274c:	08 95       	ret

0000274e <__vector_11>:

ISR(TIMER0_OVF_vect) {
    274e:	1f 92       	push	r1
    2750:	0f 92       	push	r0
    2752:	0f b6       	in	r0, 0x3f	; 63
    2754:	0f 92       	push	r0
    2756:	11 24       	eor	r1, r1
    2758:	2f 93       	push	r18
    275a:	3f 93       	push	r19
    275c:	4f 93       	push	r20
    275e:	5f 93       	push	r21
    2760:	6f 93       	push	r22
    2762:	7f 93       	push	r23
    2764:	8f 93       	push	r24
    2766:	9f 93       	push	r25
    2768:	af 93       	push	r26
    276a:	bf 93       	push	r27
    276c:	ef 93       	push	r30
    276e:	ff 93       	push	r31
    2770:	df 93       	push	r29
    2772:	cf 93       	push	r28
    2774:	cd b7       	in	r28, 0x3d	; 61
    2776:	de b7       	in	r29, 0x3e	; 62
	if (Gptr3 != '\0')
    2778:	80 91 88 01 	lds	r24, 0x0188
    277c:	90 91 89 01 	lds	r25, 0x0189
    2780:	00 97       	sbiw	r24, 0x00	; 0
    2782:	29 f0       	breq	.+10     	; 0x278e <__vector_11+0x40>
		Gptr3();
    2784:	e0 91 88 01 	lds	r30, 0x0188
    2788:	f0 91 89 01 	lds	r31, 0x0189
    278c:	09 95       	icall
	Glob_u16OvfCounter++;
    278e:	80 91 86 01 	lds	r24, 0x0186
    2792:	90 91 87 01 	lds	r25, 0x0187
    2796:	01 96       	adiw	r24, 0x01	; 1
    2798:	90 93 87 01 	sts	0x0187, r25
    279c:	80 93 86 01 	sts	0x0186, r24
}
    27a0:	cf 91       	pop	r28
    27a2:	df 91       	pop	r29
    27a4:	ff 91       	pop	r31
    27a6:	ef 91       	pop	r30
    27a8:	bf 91       	pop	r27
    27aa:	af 91       	pop	r26
    27ac:	9f 91       	pop	r25
    27ae:	8f 91       	pop	r24
    27b0:	7f 91       	pop	r23
    27b2:	6f 91       	pop	r22
    27b4:	5f 91       	pop	r21
    27b6:	4f 91       	pop	r20
    27b8:	3f 91       	pop	r19
    27ba:	2f 91       	pop	r18
    27bc:	0f 90       	pop	r0
    27be:	0f be       	out	0x3f, r0	; 63
    27c0:	0f 90       	pop	r0
    27c2:	1f 90       	pop	r1
    27c4:	18 95       	reti

000027c6 <__vector_10>:
ISR(TIMER0_COMP_vect) {
    27c6:	1f 92       	push	r1
    27c8:	0f 92       	push	r0
    27ca:	0f b6       	in	r0, 0x3f	; 63
    27cc:	0f 92       	push	r0
    27ce:	11 24       	eor	r1, r1
    27d0:	2f 93       	push	r18
    27d2:	3f 93       	push	r19
    27d4:	4f 93       	push	r20
    27d6:	5f 93       	push	r21
    27d8:	6f 93       	push	r22
    27da:	7f 93       	push	r23
    27dc:	8f 93       	push	r24
    27de:	9f 93       	push	r25
    27e0:	af 93       	push	r26
    27e2:	bf 93       	push	r27
    27e4:	ef 93       	push	r30
    27e6:	ff 93       	push	r31
    27e8:	df 93       	push	r29
    27ea:	cf 93       	push	r28
    27ec:	cd b7       	in	r28, 0x3d	; 61
    27ee:	de b7       	in	r29, 0x3e	; 62
	if (Gptr3 != '\0')
    27f0:	80 91 88 01 	lds	r24, 0x0188
    27f4:	90 91 89 01 	lds	r25, 0x0189
    27f8:	00 97       	sbiw	r24, 0x00	; 0
    27fa:	29 f0       	breq	.+10     	; 0x2806 <__vector_10+0x40>
		Gptr3();
    27fc:	e0 91 88 01 	lds	r30, 0x0188
    2800:	f0 91 89 01 	lds	r31, 0x0189
    2804:	09 95       	icall
}
    2806:	cf 91       	pop	r28
    2808:	df 91       	pop	r29
    280a:	ff 91       	pop	r31
    280c:	ef 91       	pop	r30
    280e:	bf 91       	pop	r27
    2810:	af 91       	pop	r26
    2812:	9f 91       	pop	r25
    2814:	8f 91       	pop	r24
    2816:	7f 91       	pop	r23
    2818:	6f 91       	pop	r22
    281a:	5f 91       	pop	r21
    281c:	4f 91       	pop	r20
    281e:	3f 91       	pop	r19
    2820:	2f 91       	pop	r18
    2822:	0f 90       	pop	r0
    2824:	0f be       	out	0x3f, r0	; 63
    2826:	0f 90       	pop	r0
    2828:	1f 90       	pop	r1
    282a:	18 95       	reti

0000282c <MCAL_Interrupt_u8SetRegister>:

void (*Gptr0)(void)= '\0' ;
void (*Gptr1)(void)= '\0' ;
void (*Gptr2)(void)= '\0' ;

void MCAL_Interrupt_u8SetRegister(u8 Loc_u8PortID, u8 Loc_u8PortValue) {
    282c:	df 93       	push	r29
    282e:	cf 93       	push	r28
    2830:	00 d0       	rcall	.+0      	; 0x2832 <MCAL_Interrupt_u8SetRegister+0x6>
    2832:	cd b7       	in	r28, 0x3d	; 61
    2834:	de b7       	in	r29, 0x3e	; 62
    2836:	89 83       	std	Y+1, r24	; 0x01
    2838:	6a 83       	std	Y+2, r22	; 0x02
	if (Loc_u8PortValue == PORT_OUTPUT) {
    283a:	8a 81       	ldd	r24, Y+2	; 0x02
    283c:	8f 3f       	cpi	r24, 0xFF	; 255
    283e:	09 f5       	brne	.+66     	; 0x2882 <MCAL_Interrupt_u8SetRegister+0x56>
		if (Loc_u8PortID == Sreg) {
    2840:	89 81       	ldd	r24, Y+1	; 0x01
    2842:	88 23       	and	r24, r24
    2844:	29 f4       	brne	.+10     	; 0x2850 <MCAL_Interrupt_u8SetRegister+0x24>
			SREG = PORT_OUTPUT;
    2846:	ef e5       	ldi	r30, 0x5F	; 95
    2848:	f0 e0       	ldi	r31, 0x00	; 0
    284a:	8f ef       	ldi	r24, 0xFF	; 255
    284c:	80 83       	st	Z, r24
    284e:	57 c0       	rjmp	.+174    	; 0x28fe <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Gicr) {
    2850:	89 81       	ldd	r24, Y+1	; 0x01
    2852:	81 30       	cpi	r24, 0x01	; 1
    2854:	29 f4       	brne	.+10     	; 0x2860 <MCAL_Interrupt_u8SetRegister+0x34>
			GICR = PORT_OUTPUT;
    2856:	eb e5       	ldi	r30, 0x5B	; 91
    2858:	f0 e0       	ldi	r31, 0x00	; 0
    285a:	8f ef       	ldi	r24, 0xFF	; 255
    285c:	80 83       	st	Z, r24
    285e:	4f c0       	rjmp	.+158    	; 0x28fe <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Mcucr) {
    2860:	89 81       	ldd	r24, Y+1	; 0x01
    2862:	82 30       	cpi	r24, 0x02	; 2
    2864:	29 f4       	brne	.+10     	; 0x2870 <MCAL_Interrupt_u8SetRegister+0x44>
			MCUCR = PORT_OUTPUT;
    2866:	e5 e5       	ldi	r30, 0x55	; 85
    2868:	f0 e0       	ldi	r31, 0x00	; 0
    286a:	8f ef       	ldi	r24, 0xFF	; 255
    286c:	80 83       	st	Z, r24
    286e:	47 c0       	rjmp	.+142    	; 0x28fe <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Mcucsr) {
    2870:	89 81       	ldd	r24, Y+1	; 0x01
    2872:	83 30       	cpi	r24, 0x03	; 3
    2874:	09 f0       	breq	.+2      	; 0x2878 <MCAL_Interrupt_u8SetRegister+0x4c>
    2876:	43 c0       	rjmp	.+134    	; 0x28fe <MCAL_Interrupt_u8SetRegister+0xd2>
			MCUCSR = PORT_OUTPUT;
    2878:	e4 e5       	ldi	r30, 0x54	; 84
    287a:	f0 e0       	ldi	r31, 0x00	; 0
    287c:	8f ef       	ldi	r24, 0xFF	; 255
    287e:	80 83       	st	Z, r24
    2880:	3e c0       	rjmp	.+124    	; 0x28fe <MCAL_Interrupt_u8SetRegister+0xd2>
		} else {
			//Do Nothing
		}
	} else if (Loc_u8PortValue == PORT_INPUT) {
    2882:	8a 81       	ldd	r24, Y+2	; 0x02
    2884:	88 23       	and	r24, r24
    2886:	e1 f4       	brne	.+56     	; 0x28c0 <MCAL_Interrupt_u8SetRegister+0x94>
		if (Loc_u8PortID == Sreg) {
    2888:	89 81       	ldd	r24, Y+1	; 0x01
    288a:	88 23       	and	r24, r24
    288c:	21 f4       	brne	.+8      	; 0x2896 <MCAL_Interrupt_u8SetRegister+0x6a>
			SREG = PORT_INPUT;
    288e:	ef e5       	ldi	r30, 0x5F	; 95
    2890:	f0 e0       	ldi	r31, 0x00	; 0
    2892:	10 82       	st	Z, r1
    2894:	34 c0       	rjmp	.+104    	; 0x28fe <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Gicr) {
    2896:	89 81       	ldd	r24, Y+1	; 0x01
    2898:	81 30       	cpi	r24, 0x01	; 1
    289a:	21 f4       	brne	.+8      	; 0x28a4 <MCAL_Interrupt_u8SetRegister+0x78>
			GICR = PORT_INPUT;
    289c:	eb e5       	ldi	r30, 0x5B	; 91
    289e:	f0 e0       	ldi	r31, 0x00	; 0
    28a0:	10 82       	st	Z, r1
    28a2:	2d c0       	rjmp	.+90     	; 0x28fe <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Mcucr) {
    28a4:	89 81       	ldd	r24, Y+1	; 0x01
    28a6:	82 30       	cpi	r24, 0x02	; 2
    28a8:	21 f4       	brne	.+8      	; 0x28b2 <MCAL_Interrupt_u8SetRegister+0x86>
			MCUCR = PORT_INPUT;
    28aa:	e5 e5       	ldi	r30, 0x55	; 85
    28ac:	f0 e0       	ldi	r31, 0x00	; 0
    28ae:	10 82       	st	Z, r1
    28b0:	26 c0       	rjmp	.+76     	; 0x28fe <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Mcucsr) {
    28b2:	89 81       	ldd	r24, Y+1	; 0x01
    28b4:	83 30       	cpi	r24, 0x03	; 3
    28b6:	19 f5       	brne	.+70     	; 0x28fe <MCAL_Interrupt_u8SetRegister+0xd2>
			MCUCSR = PORT_INPUT;
    28b8:	e4 e5       	ldi	r30, 0x54	; 84
    28ba:	f0 e0       	ldi	r31, 0x00	; 0
    28bc:	10 82       	st	Z, r1
    28be:	1f c0       	rjmp	.+62     	; 0x28fe <MCAL_Interrupt_u8SetRegister+0xd2>
		} else {
			//Do Nothing
		}
	} else {
		if (Loc_u8PortID == Sreg) {
    28c0:	89 81       	ldd	r24, Y+1	; 0x01
    28c2:	88 23       	and	r24, r24
    28c4:	29 f4       	brne	.+10     	; 0x28d0 <MCAL_Interrupt_u8SetRegister+0xa4>
			SREG = Loc_u8PortValue;
    28c6:	ef e5       	ldi	r30, 0x5F	; 95
    28c8:	f0 e0       	ldi	r31, 0x00	; 0
    28ca:	8a 81       	ldd	r24, Y+2	; 0x02
    28cc:	80 83       	st	Z, r24
    28ce:	17 c0       	rjmp	.+46     	; 0x28fe <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Gicr) {
    28d0:	89 81       	ldd	r24, Y+1	; 0x01
    28d2:	81 30       	cpi	r24, 0x01	; 1
    28d4:	29 f4       	brne	.+10     	; 0x28e0 <MCAL_Interrupt_u8SetRegister+0xb4>
			GICR = Loc_u8PortValue;
    28d6:	eb e5       	ldi	r30, 0x5B	; 91
    28d8:	f0 e0       	ldi	r31, 0x00	; 0
    28da:	8a 81       	ldd	r24, Y+2	; 0x02
    28dc:	80 83       	st	Z, r24
    28de:	0f c0       	rjmp	.+30     	; 0x28fe <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Mcucr) {
    28e0:	89 81       	ldd	r24, Y+1	; 0x01
    28e2:	82 30       	cpi	r24, 0x02	; 2
    28e4:	29 f4       	brne	.+10     	; 0x28f0 <MCAL_Interrupt_u8SetRegister+0xc4>
			MCUCR = Loc_u8PortValue;
    28e6:	e5 e5       	ldi	r30, 0x55	; 85
    28e8:	f0 e0       	ldi	r31, 0x00	; 0
    28ea:	8a 81       	ldd	r24, Y+2	; 0x02
    28ec:	80 83       	st	Z, r24
    28ee:	07 c0       	rjmp	.+14     	; 0x28fe <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Mcucsr) {
    28f0:	89 81       	ldd	r24, Y+1	; 0x01
    28f2:	83 30       	cpi	r24, 0x03	; 3
    28f4:	21 f4       	brne	.+8      	; 0x28fe <MCAL_Interrupt_u8SetRegister+0xd2>
			MCUCSR = Loc_u8PortValue;
    28f6:	e4 e5       	ldi	r30, 0x54	; 84
    28f8:	f0 e0       	ldi	r31, 0x00	; 0
    28fa:	8a 81       	ldd	r24, Y+2	; 0x02
    28fc:	80 83       	st	Z, r24
		}
	}
}
    28fe:	0f 90       	pop	r0
    2900:	0f 90       	pop	r0
    2902:	cf 91       	pop	r28
    2904:	df 91       	pop	r29
    2906:	08 95       	ret

00002908 <MCAL_Interrupt_u8SetRegisterPin>:

void MCAL_Interrupt_u8SetRegisterPin(u8 Loc_u8PortID, u8 Loc_u8PinID,
		u8 Loc_u8PinValue) {
    2908:	df 93       	push	r29
    290a:	cf 93       	push	r28
    290c:	00 d0       	rcall	.+0      	; 0x290e <MCAL_Interrupt_u8SetRegisterPin+0x6>
    290e:	0f 92       	push	r0
    2910:	cd b7       	in	r28, 0x3d	; 61
    2912:	de b7       	in	r29, 0x3e	; 62
    2914:	89 83       	std	Y+1, r24	; 0x01
    2916:	6a 83       	std	Y+2, r22	; 0x02
    2918:	4b 83       	std	Y+3, r20	; 0x03
	if (Loc_u8PinValue == Pin_High) {
    291a:	8b 81       	ldd	r24, Y+3	; 0x03
    291c:	81 30       	cpi	r24, 0x01	; 1
    291e:	09 f0       	breq	.+2      	; 0x2922 <MCAL_Interrupt_u8SetRegisterPin+0x1a>
    2920:	5d c0       	rjmp	.+186    	; 0x29dc <MCAL_Interrupt_u8SetRegisterPin+0xd4>
		if (Loc_u8PortID == Sreg) {
    2922:	89 81       	ldd	r24, Y+1	; 0x01
    2924:	88 23       	and	r24, r24
    2926:	a1 f4       	brne	.+40     	; 0x2950 <MCAL_Interrupt_u8SetRegisterPin+0x48>
			SET_BIT(SREG, Loc_u8PinID);
    2928:	af e5       	ldi	r26, 0x5F	; 95
    292a:	b0 e0       	ldi	r27, 0x00	; 0
    292c:	ef e5       	ldi	r30, 0x5F	; 95
    292e:	f0 e0       	ldi	r31, 0x00	; 0
    2930:	80 81       	ld	r24, Z
    2932:	48 2f       	mov	r20, r24
    2934:	8a 81       	ldd	r24, Y+2	; 0x02
    2936:	28 2f       	mov	r18, r24
    2938:	30 e0       	ldi	r19, 0x00	; 0
    293a:	81 e0       	ldi	r24, 0x01	; 1
    293c:	90 e0       	ldi	r25, 0x00	; 0
    293e:	02 2e       	mov	r0, r18
    2940:	02 c0       	rjmp	.+4      	; 0x2946 <MCAL_Interrupt_u8SetRegisterPin+0x3e>
    2942:	88 0f       	add	r24, r24
    2944:	99 1f       	adc	r25, r25
    2946:	0a 94       	dec	r0
    2948:	e2 f7       	brpl	.-8      	; 0x2942 <MCAL_Interrupt_u8SetRegisterPin+0x3a>
    294a:	84 2b       	or	r24, r20
    294c:	8c 93       	st	X, r24
    294e:	a9 c0       	rjmp	.+338    	; 0x2aa2 <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		} else if (Loc_u8PortID == Gicr) {
    2950:	89 81       	ldd	r24, Y+1	; 0x01
    2952:	81 30       	cpi	r24, 0x01	; 1
    2954:	a1 f4       	brne	.+40     	; 0x297e <MCAL_Interrupt_u8SetRegisterPin+0x76>
			SET_BIT(GICR, Loc_u8PinID);
    2956:	ab e5       	ldi	r26, 0x5B	; 91
    2958:	b0 e0       	ldi	r27, 0x00	; 0
    295a:	eb e5       	ldi	r30, 0x5B	; 91
    295c:	f0 e0       	ldi	r31, 0x00	; 0
    295e:	80 81       	ld	r24, Z
    2960:	48 2f       	mov	r20, r24
    2962:	8a 81       	ldd	r24, Y+2	; 0x02
    2964:	28 2f       	mov	r18, r24
    2966:	30 e0       	ldi	r19, 0x00	; 0
    2968:	81 e0       	ldi	r24, 0x01	; 1
    296a:	90 e0       	ldi	r25, 0x00	; 0
    296c:	02 2e       	mov	r0, r18
    296e:	02 c0       	rjmp	.+4      	; 0x2974 <MCAL_Interrupt_u8SetRegisterPin+0x6c>
    2970:	88 0f       	add	r24, r24
    2972:	99 1f       	adc	r25, r25
    2974:	0a 94       	dec	r0
    2976:	e2 f7       	brpl	.-8      	; 0x2970 <MCAL_Interrupt_u8SetRegisterPin+0x68>
    2978:	84 2b       	or	r24, r20
    297a:	8c 93       	st	X, r24
    297c:	92 c0       	rjmp	.+292    	; 0x2aa2 <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		} else if (Loc_u8PortID == Mcucr) {
    297e:	89 81       	ldd	r24, Y+1	; 0x01
    2980:	82 30       	cpi	r24, 0x02	; 2
    2982:	a1 f4       	brne	.+40     	; 0x29ac <MCAL_Interrupt_u8SetRegisterPin+0xa4>
			SET_BIT(MCUCR, Loc_u8PinID);
    2984:	a5 e5       	ldi	r26, 0x55	; 85
    2986:	b0 e0       	ldi	r27, 0x00	; 0
    2988:	e5 e5       	ldi	r30, 0x55	; 85
    298a:	f0 e0       	ldi	r31, 0x00	; 0
    298c:	80 81       	ld	r24, Z
    298e:	48 2f       	mov	r20, r24
    2990:	8a 81       	ldd	r24, Y+2	; 0x02
    2992:	28 2f       	mov	r18, r24
    2994:	30 e0       	ldi	r19, 0x00	; 0
    2996:	81 e0       	ldi	r24, 0x01	; 1
    2998:	90 e0       	ldi	r25, 0x00	; 0
    299a:	02 2e       	mov	r0, r18
    299c:	02 c0       	rjmp	.+4      	; 0x29a2 <MCAL_Interrupt_u8SetRegisterPin+0x9a>
    299e:	88 0f       	add	r24, r24
    29a0:	99 1f       	adc	r25, r25
    29a2:	0a 94       	dec	r0
    29a4:	e2 f7       	brpl	.-8      	; 0x299e <MCAL_Interrupt_u8SetRegisterPin+0x96>
    29a6:	84 2b       	or	r24, r20
    29a8:	8c 93       	st	X, r24
    29aa:	7b c0       	rjmp	.+246    	; 0x2aa2 <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		} else if (Loc_u8PortID == Mcucsr) {
    29ac:	89 81       	ldd	r24, Y+1	; 0x01
    29ae:	83 30       	cpi	r24, 0x03	; 3
    29b0:	09 f0       	breq	.+2      	; 0x29b4 <MCAL_Interrupt_u8SetRegisterPin+0xac>
    29b2:	77 c0       	rjmp	.+238    	; 0x2aa2 <MCAL_Interrupt_u8SetRegisterPin+0x19a>
			SET_BIT(MCUCSR, Loc_u8PinID);
    29b4:	a4 e5       	ldi	r26, 0x54	; 84
    29b6:	b0 e0       	ldi	r27, 0x00	; 0
    29b8:	e4 e5       	ldi	r30, 0x54	; 84
    29ba:	f0 e0       	ldi	r31, 0x00	; 0
    29bc:	80 81       	ld	r24, Z
    29be:	48 2f       	mov	r20, r24
    29c0:	8a 81       	ldd	r24, Y+2	; 0x02
    29c2:	28 2f       	mov	r18, r24
    29c4:	30 e0       	ldi	r19, 0x00	; 0
    29c6:	81 e0       	ldi	r24, 0x01	; 1
    29c8:	90 e0       	ldi	r25, 0x00	; 0
    29ca:	02 2e       	mov	r0, r18
    29cc:	02 c0       	rjmp	.+4      	; 0x29d2 <MCAL_Interrupt_u8SetRegisterPin+0xca>
    29ce:	88 0f       	add	r24, r24
    29d0:	99 1f       	adc	r25, r25
    29d2:	0a 94       	dec	r0
    29d4:	e2 f7       	brpl	.-8      	; 0x29ce <MCAL_Interrupt_u8SetRegisterPin+0xc6>
    29d6:	84 2b       	or	r24, r20
    29d8:	8c 93       	st	X, r24
    29da:	63 c0       	rjmp	.+198    	; 0x2aa2 <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		} else {
			//Do Nothing
		}
	} else if (Loc_u8PinValue == Pin_Low) {
    29dc:	8b 81       	ldd	r24, Y+3	; 0x03
    29de:	88 23       	and	r24, r24
    29e0:	09 f0       	breq	.+2      	; 0x29e4 <MCAL_Interrupt_u8SetRegisterPin+0xdc>
    29e2:	5f c0       	rjmp	.+190    	; 0x2aa2 <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		if (Loc_u8PortID == Sreg) {
    29e4:	89 81       	ldd	r24, Y+1	; 0x01
    29e6:	88 23       	and	r24, r24
    29e8:	a9 f4       	brne	.+42     	; 0x2a14 <MCAL_Interrupt_u8SetRegisterPin+0x10c>
			CLR_BIT(SREG, Loc_u8PinID);
    29ea:	af e5       	ldi	r26, 0x5F	; 95
    29ec:	b0 e0       	ldi	r27, 0x00	; 0
    29ee:	ef e5       	ldi	r30, 0x5F	; 95
    29f0:	f0 e0       	ldi	r31, 0x00	; 0
    29f2:	80 81       	ld	r24, Z
    29f4:	48 2f       	mov	r20, r24
    29f6:	8a 81       	ldd	r24, Y+2	; 0x02
    29f8:	28 2f       	mov	r18, r24
    29fa:	30 e0       	ldi	r19, 0x00	; 0
    29fc:	81 e0       	ldi	r24, 0x01	; 1
    29fe:	90 e0       	ldi	r25, 0x00	; 0
    2a00:	02 2e       	mov	r0, r18
    2a02:	02 c0       	rjmp	.+4      	; 0x2a08 <MCAL_Interrupt_u8SetRegisterPin+0x100>
    2a04:	88 0f       	add	r24, r24
    2a06:	99 1f       	adc	r25, r25
    2a08:	0a 94       	dec	r0
    2a0a:	e2 f7       	brpl	.-8      	; 0x2a04 <MCAL_Interrupt_u8SetRegisterPin+0xfc>
    2a0c:	80 95       	com	r24
    2a0e:	84 23       	and	r24, r20
    2a10:	8c 93       	st	X, r24
    2a12:	47 c0       	rjmp	.+142    	; 0x2aa2 <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		} else if (Loc_u8PortID == Gicr) {
    2a14:	89 81       	ldd	r24, Y+1	; 0x01
    2a16:	81 30       	cpi	r24, 0x01	; 1
    2a18:	a9 f4       	brne	.+42     	; 0x2a44 <MCAL_Interrupt_u8SetRegisterPin+0x13c>
			CLR_BIT(GICR, Loc_u8PinID);
    2a1a:	ab e5       	ldi	r26, 0x5B	; 91
    2a1c:	b0 e0       	ldi	r27, 0x00	; 0
    2a1e:	eb e5       	ldi	r30, 0x5B	; 91
    2a20:	f0 e0       	ldi	r31, 0x00	; 0
    2a22:	80 81       	ld	r24, Z
    2a24:	48 2f       	mov	r20, r24
    2a26:	8a 81       	ldd	r24, Y+2	; 0x02
    2a28:	28 2f       	mov	r18, r24
    2a2a:	30 e0       	ldi	r19, 0x00	; 0
    2a2c:	81 e0       	ldi	r24, 0x01	; 1
    2a2e:	90 e0       	ldi	r25, 0x00	; 0
    2a30:	02 2e       	mov	r0, r18
    2a32:	02 c0       	rjmp	.+4      	; 0x2a38 <MCAL_Interrupt_u8SetRegisterPin+0x130>
    2a34:	88 0f       	add	r24, r24
    2a36:	99 1f       	adc	r25, r25
    2a38:	0a 94       	dec	r0
    2a3a:	e2 f7       	brpl	.-8      	; 0x2a34 <MCAL_Interrupt_u8SetRegisterPin+0x12c>
    2a3c:	80 95       	com	r24
    2a3e:	84 23       	and	r24, r20
    2a40:	8c 93       	st	X, r24
    2a42:	2f c0       	rjmp	.+94     	; 0x2aa2 <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		} else if (Loc_u8PortID == Mcucr) {
    2a44:	89 81       	ldd	r24, Y+1	; 0x01
    2a46:	82 30       	cpi	r24, 0x02	; 2
    2a48:	a9 f4       	brne	.+42     	; 0x2a74 <MCAL_Interrupt_u8SetRegisterPin+0x16c>
			CLR_BIT(MCUCR, Loc_u8PinID);
    2a4a:	a5 e5       	ldi	r26, 0x55	; 85
    2a4c:	b0 e0       	ldi	r27, 0x00	; 0
    2a4e:	e5 e5       	ldi	r30, 0x55	; 85
    2a50:	f0 e0       	ldi	r31, 0x00	; 0
    2a52:	80 81       	ld	r24, Z
    2a54:	48 2f       	mov	r20, r24
    2a56:	8a 81       	ldd	r24, Y+2	; 0x02
    2a58:	28 2f       	mov	r18, r24
    2a5a:	30 e0       	ldi	r19, 0x00	; 0
    2a5c:	81 e0       	ldi	r24, 0x01	; 1
    2a5e:	90 e0       	ldi	r25, 0x00	; 0
    2a60:	02 2e       	mov	r0, r18
    2a62:	02 c0       	rjmp	.+4      	; 0x2a68 <MCAL_Interrupt_u8SetRegisterPin+0x160>
    2a64:	88 0f       	add	r24, r24
    2a66:	99 1f       	adc	r25, r25
    2a68:	0a 94       	dec	r0
    2a6a:	e2 f7       	brpl	.-8      	; 0x2a64 <MCAL_Interrupt_u8SetRegisterPin+0x15c>
    2a6c:	80 95       	com	r24
    2a6e:	84 23       	and	r24, r20
    2a70:	8c 93       	st	X, r24
    2a72:	17 c0       	rjmp	.+46     	; 0x2aa2 <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		} else if (Loc_u8PortID == Mcucsr) {
    2a74:	89 81       	ldd	r24, Y+1	; 0x01
    2a76:	83 30       	cpi	r24, 0x03	; 3
    2a78:	a1 f4       	brne	.+40     	; 0x2aa2 <MCAL_Interrupt_u8SetRegisterPin+0x19a>
			CLR_BIT(MCUCSR, Loc_u8PinID);
    2a7a:	a4 e5       	ldi	r26, 0x54	; 84
    2a7c:	b0 e0       	ldi	r27, 0x00	; 0
    2a7e:	e4 e5       	ldi	r30, 0x54	; 84
    2a80:	f0 e0       	ldi	r31, 0x00	; 0
    2a82:	80 81       	ld	r24, Z
    2a84:	48 2f       	mov	r20, r24
    2a86:	8a 81       	ldd	r24, Y+2	; 0x02
    2a88:	28 2f       	mov	r18, r24
    2a8a:	30 e0       	ldi	r19, 0x00	; 0
    2a8c:	81 e0       	ldi	r24, 0x01	; 1
    2a8e:	90 e0       	ldi	r25, 0x00	; 0
    2a90:	02 2e       	mov	r0, r18
    2a92:	02 c0       	rjmp	.+4      	; 0x2a98 <MCAL_Interrupt_u8SetRegisterPin+0x190>
    2a94:	88 0f       	add	r24, r24
    2a96:	99 1f       	adc	r25, r25
    2a98:	0a 94       	dec	r0
    2a9a:	e2 f7       	brpl	.-8      	; 0x2a94 <MCAL_Interrupt_u8SetRegisterPin+0x18c>
    2a9c:	80 95       	com	r24
    2a9e:	84 23       	and	r24, r20
    2aa0:	8c 93       	st	X, r24
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
}
    2aa2:	0f 90       	pop	r0
    2aa4:	0f 90       	pop	r0
    2aa6:	0f 90       	pop	r0
    2aa8:	cf 91       	pop	r28
    2aaa:	df 91       	pop	r29
    2aac:	08 95       	ret

00002aae <MCAL_Interrupt_EXIT_CallBack_0>:

void MCAL_Interrupt_EXIT_CallBack_0(void (*ptr)(void)) {
    2aae:	df 93       	push	r29
    2ab0:	cf 93       	push	r28
    2ab2:	00 d0       	rcall	.+0      	; 0x2ab4 <MCAL_Interrupt_EXIT_CallBack_0+0x6>
    2ab4:	cd b7       	in	r28, 0x3d	; 61
    2ab6:	de b7       	in	r29, 0x3e	; 62
    2ab8:	9a 83       	std	Y+2, r25	; 0x02
    2aba:	89 83       	std	Y+1, r24	; 0x01
	if (ptr != '\0')
    2abc:	89 81       	ldd	r24, Y+1	; 0x01
    2abe:	9a 81       	ldd	r25, Y+2	; 0x02
    2ac0:	00 97       	sbiw	r24, 0x00	; 0
    2ac2:	31 f0       	breq	.+12     	; 0x2ad0 <MCAL_Interrupt_EXIT_CallBack_0+0x22>
		Gptr0 = ptr;
    2ac4:	89 81       	ldd	r24, Y+1	; 0x01
    2ac6:	9a 81       	ldd	r25, Y+2	; 0x02
    2ac8:	90 93 8f 01 	sts	0x018F, r25
    2acc:	80 93 8e 01 	sts	0x018E, r24
}
    2ad0:	0f 90       	pop	r0
    2ad2:	0f 90       	pop	r0
    2ad4:	cf 91       	pop	r28
    2ad6:	df 91       	pop	r29
    2ad8:	08 95       	ret

00002ada <MCAL_Interrupt_EXIT_CallBack_1>:
void MCAL_Interrupt_EXIT_CallBack_1(void (*ptr)(void)) {
    2ada:	df 93       	push	r29
    2adc:	cf 93       	push	r28
    2ade:	00 d0       	rcall	.+0      	; 0x2ae0 <MCAL_Interrupt_EXIT_CallBack_1+0x6>
    2ae0:	cd b7       	in	r28, 0x3d	; 61
    2ae2:	de b7       	in	r29, 0x3e	; 62
    2ae4:	9a 83       	std	Y+2, r25	; 0x02
    2ae6:	89 83       	std	Y+1, r24	; 0x01
	if (ptr != '\0')
    2ae8:	89 81       	ldd	r24, Y+1	; 0x01
    2aea:	9a 81       	ldd	r25, Y+2	; 0x02
    2aec:	00 97       	sbiw	r24, 0x00	; 0
    2aee:	31 f0       	breq	.+12     	; 0x2afc <MCAL_Interrupt_EXIT_CallBack_1+0x22>
		Gptr1 = ptr;
    2af0:	89 81       	ldd	r24, Y+1	; 0x01
    2af2:	9a 81       	ldd	r25, Y+2	; 0x02
    2af4:	90 93 91 01 	sts	0x0191, r25
    2af8:	80 93 90 01 	sts	0x0190, r24
}
    2afc:	0f 90       	pop	r0
    2afe:	0f 90       	pop	r0
    2b00:	cf 91       	pop	r28
    2b02:	df 91       	pop	r29
    2b04:	08 95       	ret

00002b06 <MCAL_Interrupt_EXIT_CallBack_2>:
void MCAL_Interrupt_EXIT_CallBack_2(void (*ptr)(void)) {
    2b06:	df 93       	push	r29
    2b08:	cf 93       	push	r28
    2b0a:	00 d0       	rcall	.+0      	; 0x2b0c <MCAL_Interrupt_EXIT_CallBack_2+0x6>
    2b0c:	cd b7       	in	r28, 0x3d	; 61
    2b0e:	de b7       	in	r29, 0x3e	; 62
    2b10:	9a 83       	std	Y+2, r25	; 0x02
    2b12:	89 83       	std	Y+1, r24	; 0x01
	if (ptr != '\0')
    2b14:	89 81       	ldd	r24, Y+1	; 0x01
    2b16:	9a 81       	ldd	r25, Y+2	; 0x02
    2b18:	00 97       	sbiw	r24, 0x00	; 0
    2b1a:	31 f0       	breq	.+12     	; 0x2b28 <MCAL_Interrupt_EXIT_CallBack_2+0x22>
		Gptr2 = ptr;
    2b1c:	89 81       	ldd	r24, Y+1	; 0x01
    2b1e:	9a 81       	ldd	r25, Y+2	; 0x02
    2b20:	90 93 93 01 	sts	0x0193, r25
    2b24:	80 93 92 01 	sts	0x0192, r24
}
    2b28:	0f 90       	pop	r0
    2b2a:	0f 90       	pop	r0
    2b2c:	cf 91       	pop	r28
    2b2e:	df 91       	pop	r29
    2b30:	08 95       	ret

00002b32 <MCAL_Interrupt_EnableGIE>:

void MCAL_Interrupt_EnableGIE(u8 Loc_u8value) {
    2b32:	df 93       	push	r29
    2b34:	cf 93       	push	r28
    2b36:	0f 92       	push	r0
    2b38:	cd b7       	in	r28, 0x3d	; 61
    2b3a:	de b7       	in	r29, 0x3e	; 62
    2b3c:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8value == Enable) {
    2b3e:	89 81       	ldd	r24, Y+1	; 0x01
    2b40:	81 30       	cpi	r24, 0x01	; 1
    2b42:	31 f4       	brne	.+12     	; 0x2b50 <MCAL_Interrupt_EnableGIE+0x1e>
		MCAL_Interrupt_u8SetRegisterPin(Sreg, SREG_Pin, Pin_High);
    2b44:	80 e0       	ldi	r24, 0x00	; 0
    2b46:	67 e0       	ldi	r22, 0x07	; 7
    2b48:	41 e0       	ldi	r20, 0x01	; 1
    2b4a:	0e 94 84 14 	call	0x2908	; 0x2908 <MCAL_Interrupt_u8SetRegisterPin>
    2b4e:	08 c0       	rjmp	.+16     	; 0x2b60 <MCAL_Interrupt_EnableGIE+0x2e>
	} else if (Loc_u8value == Disable) {
    2b50:	89 81       	ldd	r24, Y+1	; 0x01
    2b52:	88 23       	and	r24, r24
    2b54:	29 f4       	brne	.+10     	; 0x2b60 <MCAL_Interrupt_EnableGIE+0x2e>
		MCAL_Interrupt_u8SetRegisterPin(Sreg, SREG_Pin, Pin_Low);
    2b56:	80 e0       	ldi	r24, 0x00	; 0
    2b58:	67 e0       	ldi	r22, 0x07	; 7
    2b5a:	40 e0       	ldi	r20, 0x00	; 0
    2b5c:	0e 94 84 14 	call	0x2908	; 0x2908 <MCAL_Interrupt_u8SetRegisterPin>
	}
}
    2b60:	0f 90       	pop	r0
    2b62:	cf 91       	pop	r28
    2b64:	df 91       	pop	r29
    2b66:	08 95       	ret

00002b68 <MCAL_Interrupt_InterruptRisingInit>:

void MCAL_Interrupt_InterruptRisingInit() {
    2b68:	df 93       	push	r29
    2b6a:	cf 93       	push	r28
    2b6c:	cd b7       	in	r28, 0x3d	; 61
    2b6e:	de b7       	in	r29, 0x3e	; 62
	MCAL_Interrupt_u8SetRegisterPin(Gicr, GICR_Pin6, Pin_High);
    2b70:	81 e0       	ldi	r24, 0x01	; 1
    2b72:	66 e0       	ldi	r22, 0x06	; 6
    2b74:	41 e0       	ldi	r20, 0x01	; 1
    2b76:	0e 94 84 14 	call	0x2908	; 0x2908 <MCAL_Interrupt_u8SetRegisterPin>
	MCAL_Interrupt_u8SetRegisterPin(Mcucr,MCUCR_Pin0 , Pin_High);
    2b7a:	82 e0       	ldi	r24, 0x02	; 2
    2b7c:	60 e0       	ldi	r22, 0x00	; 0
    2b7e:	41 e0       	ldi	r20, 0x01	; 1
    2b80:	0e 94 84 14 	call	0x2908	; 0x2908 <MCAL_Interrupt_u8SetRegisterPin>
	MCAL_Interrupt_u8SetRegisterPin(Mcucr,MCUCR_Pin1 , Pin_High);
    2b84:	82 e0       	ldi	r24, 0x02	; 2
    2b86:	61 e0       	ldi	r22, 0x01	; 1
    2b88:	41 e0       	ldi	r20, 0x01	; 1
    2b8a:	0e 94 84 14 	call	0x2908	; 0x2908 <MCAL_Interrupt_u8SetRegisterPin>
}
    2b8e:	cf 91       	pop	r28
    2b90:	df 91       	pop	r29
    2b92:	08 95       	ret

00002b94 <MCAL_Interrupt_InterruptFallingInit>:
void MCAL_Interrupt_InterruptFallingInit() {
    2b94:	df 93       	push	r29
    2b96:	cf 93       	push	r28
    2b98:	cd b7       	in	r28, 0x3d	; 61
    2b9a:	de b7       	in	r29, 0x3e	; 62
	MCAL_Interrupt_u8SetRegisterPin(Gicr, GICR_Pin6, Pin_High);
    2b9c:	81 e0       	ldi	r24, 0x01	; 1
    2b9e:	66 e0       	ldi	r22, 0x06	; 6
    2ba0:	41 e0       	ldi	r20, 0x01	; 1
    2ba2:	0e 94 84 14 	call	0x2908	; 0x2908 <MCAL_Interrupt_u8SetRegisterPin>
	MCAL_Interrupt_u8SetRegisterPin(Mcucr,MCUCR_Pin0 , Pin_Low);
    2ba6:	82 e0       	ldi	r24, 0x02	; 2
    2ba8:	60 e0       	ldi	r22, 0x00	; 0
    2baa:	40 e0       	ldi	r20, 0x00	; 0
    2bac:	0e 94 84 14 	call	0x2908	; 0x2908 <MCAL_Interrupt_u8SetRegisterPin>
	MCAL_Interrupt_u8SetRegisterPin(Mcucr,MCUCR_Pin1 , Pin_High);
    2bb0:	82 e0       	ldi	r24, 0x02	; 2
    2bb2:	61 e0       	ldi	r22, 0x01	; 1
    2bb4:	41 e0       	ldi	r20, 0x01	; 1
    2bb6:	0e 94 84 14 	call	0x2908	; 0x2908 <MCAL_Interrupt_u8SetRegisterPin>
}
    2bba:	cf 91       	pop	r28
    2bbc:	df 91       	pop	r29
    2bbe:	08 95       	ret

00002bc0 <__vector_1>:

ISR(VECT_INT0) {
    2bc0:	1f 92       	push	r1
    2bc2:	0f 92       	push	r0
    2bc4:	0f b6       	in	r0, 0x3f	; 63
    2bc6:	0f 92       	push	r0
    2bc8:	11 24       	eor	r1, r1
    2bca:	2f 93       	push	r18
    2bcc:	3f 93       	push	r19
    2bce:	4f 93       	push	r20
    2bd0:	5f 93       	push	r21
    2bd2:	6f 93       	push	r22
    2bd4:	7f 93       	push	r23
    2bd6:	8f 93       	push	r24
    2bd8:	9f 93       	push	r25
    2bda:	af 93       	push	r26
    2bdc:	bf 93       	push	r27
    2bde:	ef 93       	push	r30
    2be0:	ff 93       	push	r31
    2be2:	df 93       	push	r29
    2be4:	cf 93       	push	r28
    2be6:	cd b7       	in	r28, 0x3d	; 61
    2be8:	de b7       	in	r29, 0x3e	; 62
	if (Gptr0 != '\0')
    2bea:	80 91 8e 01 	lds	r24, 0x018E
    2bee:	90 91 8f 01 	lds	r25, 0x018F
    2bf2:	00 97       	sbiw	r24, 0x00	; 0
    2bf4:	29 f0       	breq	.+10     	; 0x2c00 <__vector_1+0x40>
		Gptr0();
    2bf6:	e0 91 8e 01 	lds	r30, 0x018E
    2bfa:	f0 91 8f 01 	lds	r31, 0x018F
    2bfe:	09 95       	icall
}
    2c00:	cf 91       	pop	r28
    2c02:	df 91       	pop	r29
    2c04:	ff 91       	pop	r31
    2c06:	ef 91       	pop	r30
    2c08:	bf 91       	pop	r27
    2c0a:	af 91       	pop	r26
    2c0c:	9f 91       	pop	r25
    2c0e:	8f 91       	pop	r24
    2c10:	7f 91       	pop	r23
    2c12:	6f 91       	pop	r22
    2c14:	5f 91       	pop	r21
    2c16:	4f 91       	pop	r20
    2c18:	3f 91       	pop	r19
    2c1a:	2f 91       	pop	r18
    2c1c:	0f 90       	pop	r0
    2c1e:	0f be       	out	0x3f, r0	; 63
    2c20:	0f 90       	pop	r0
    2c22:	1f 90       	pop	r1
    2c24:	18 95       	reti

00002c26 <__vector_2>:
ISR(VECT_INT1) {
    2c26:	1f 92       	push	r1
    2c28:	0f 92       	push	r0
    2c2a:	0f b6       	in	r0, 0x3f	; 63
    2c2c:	0f 92       	push	r0
    2c2e:	11 24       	eor	r1, r1
    2c30:	2f 93       	push	r18
    2c32:	3f 93       	push	r19
    2c34:	4f 93       	push	r20
    2c36:	5f 93       	push	r21
    2c38:	6f 93       	push	r22
    2c3a:	7f 93       	push	r23
    2c3c:	8f 93       	push	r24
    2c3e:	9f 93       	push	r25
    2c40:	af 93       	push	r26
    2c42:	bf 93       	push	r27
    2c44:	ef 93       	push	r30
    2c46:	ff 93       	push	r31
    2c48:	df 93       	push	r29
    2c4a:	cf 93       	push	r28
    2c4c:	cd b7       	in	r28, 0x3d	; 61
    2c4e:	de b7       	in	r29, 0x3e	; 62
	if (Gptr1 != '\0')
    2c50:	80 91 90 01 	lds	r24, 0x0190
    2c54:	90 91 91 01 	lds	r25, 0x0191
    2c58:	00 97       	sbiw	r24, 0x00	; 0
    2c5a:	29 f0       	breq	.+10     	; 0x2c66 <__vector_2+0x40>
		Gptr1();
    2c5c:	e0 91 90 01 	lds	r30, 0x0190
    2c60:	f0 91 91 01 	lds	r31, 0x0191
    2c64:	09 95       	icall
}
    2c66:	cf 91       	pop	r28
    2c68:	df 91       	pop	r29
    2c6a:	ff 91       	pop	r31
    2c6c:	ef 91       	pop	r30
    2c6e:	bf 91       	pop	r27
    2c70:	af 91       	pop	r26
    2c72:	9f 91       	pop	r25
    2c74:	8f 91       	pop	r24
    2c76:	7f 91       	pop	r23
    2c78:	6f 91       	pop	r22
    2c7a:	5f 91       	pop	r21
    2c7c:	4f 91       	pop	r20
    2c7e:	3f 91       	pop	r19
    2c80:	2f 91       	pop	r18
    2c82:	0f 90       	pop	r0
    2c84:	0f be       	out	0x3f, r0	; 63
    2c86:	0f 90       	pop	r0
    2c88:	1f 90       	pop	r1
    2c8a:	18 95       	reti

00002c8c <__vector_3>:
ISR(VECT_INT2) {
    2c8c:	1f 92       	push	r1
    2c8e:	0f 92       	push	r0
    2c90:	0f b6       	in	r0, 0x3f	; 63
    2c92:	0f 92       	push	r0
    2c94:	11 24       	eor	r1, r1
    2c96:	2f 93       	push	r18
    2c98:	3f 93       	push	r19
    2c9a:	4f 93       	push	r20
    2c9c:	5f 93       	push	r21
    2c9e:	6f 93       	push	r22
    2ca0:	7f 93       	push	r23
    2ca2:	8f 93       	push	r24
    2ca4:	9f 93       	push	r25
    2ca6:	af 93       	push	r26
    2ca8:	bf 93       	push	r27
    2caa:	ef 93       	push	r30
    2cac:	ff 93       	push	r31
    2cae:	df 93       	push	r29
    2cb0:	cf 93       	push	r28
    2cb2:	cd b7       	in	r28, 0x3d	; 61
    2cb4:	de b7       	in	r29, 0x3e	; 62
	if (Gptr2 != '\0')
    2cb6:	80 91 92 01 	lds	r24, 0x0192
    2cba:	90 91 93 01 	lds	r25, 0x0193
    2cbe:	00 97       	sbiw	r24, 0x00	; 0
    2cc0:	29 f0       	breq	.+10     	; 0x2ccc <__vector_3+0x40>
		Gptr2();
    2cc2:	e0 91 92 01 	lds	r30, 0x0192
    2cc6:	f0 91 93 01 	lds	r31, 0x0193
    2cca:	09 95       	icall
}
    2ccc:	cf 91       	pop	r28
    2cce:	df 91       	pop	r29
    2cd0:	ff 91       	pop	r31
    2cd2:	ef 91       	pop	r30
    2cd4:	bf 91       	pop	r27
    2cd6:	af 91       	pop	r26
    2cd8:	9f 91       	pop	r25
    2cda:	8f 91       	pop	r24
    2cdc:	7f 91       	pop	r23
    2cde:	6f 91       	pop	r22
    2ce0:	5f 91       	pop	r21
    2ce2:	4f 91       	pop	r20
    2ce4:	3f 91       	pop	r19
    2ce6:	2f 91       	pop	r18
    2ce8:	0f 90       	pop	r0
    2cea:	0f be       	out	0x3f, r0	; 63
    2cec:	0f 90       	pop	r0
    2cee:	1f 90       	pop	r1
    2cf0:	18 95       	reti

00002cf2 <MCAL_DIO_u8SetPortDirection>:
 *      Author: Mohamed
 */

#include "DIO.h"

STD_Type MCAL_DIO_u8SetPortDirection(u8 Loc_u8PortID, u8 Loc_u8PortDirection) {
    2cf2:	df 93       	push	r29
    2cf4:	cf 93       	push	r28
    2cf6:	00 d0       	rcall	.+0      	; 0x2cf8 <MCAL_DIO_u8SetPortDirection+0x6>
    2cf8:	0f 92       	push	r0
    2cfa:	cd b7       	in	r28, 0x3d	; 61
    2cfc:	de b7       	in	r29, 0x3e	; 62
    2cfe:	8a 83       	std	Y+2, r24	; 0x02
    2d00:	6b 83       	std	Y+3, r22	; 0x03
	u8 Loc_u8Return_Value = E_NOT_OK;
    2d02:	81 e0       	ldi	r24, 0x01	; 1
    2d04:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD && Loc_u8PortDirection <= PORT_OUTPUT) {
    2d06:	8a 81       	ldd	r24, Y+2	; 0x02
    2d08:	84 30       	cpi	r24, 0x04	; 4
    2d0a:	08 f0       	brcs	.+2      	; 0x2d0e <MCAL_DIO_u8SetPortDirection+0x1c>
    2d0c:	6e c0       	rjmp	.+220    	; 0x2dea <MCAL_DIO_u8SetPortDirection+0xf8>
		if (Loc_u8PortDirection == PORT_OUTPUT) {
    2d0e:	8b 81       	ldd	r24, Y+3	; 0x03
    2d10:	8f 3f       	cpi	r24, 0xFF	; 255
    2d12:	29 f5       	brne	.+74     	; 0x2d5e <MCAL_DIO_u8SetPortDirection+0x6c>
			if (Loc_u8PortID == PortA) {
    2d14:	8a 81       	ldd	r24, Y+2	; 0x02
    2d16:	88 23       	and	r24, r24
    2d18:	31 f4       	brne	.+12     	; 0x2d26 <MCAL_DIO_u8SetPortDirection+0x34>
				DDRA = PORT_OUTPUT;
    2d1a:	ea e3       	ldi	r30, 0x3A	; 58
    2d1c:	f0 e0       	ldi	r31, 0x00	; 0
    2d1e:	8f ef       	ldi	r24, 0xFF	; 255
    2d20:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    2d22:	19 82       	std	Y+1, r1	; 0x01
    2d24:	62 c0       	rjmp	.+196    	; 0x2dea <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortB) {
    2d26:	8a 81       	ldd	r24, Y+2	; 0x02
    2d28:	81 30       	cpi	r24, 0x01	; 1
    2d2a:	31 f4       	brne	.+12     	; 0x2d38 <MCAL_DIO_u8SetPortDirection+0x46>
				DDRB = PORT_OUTPUT;
    2d2c:	e7 e3       	ldi	r30, 0x37	; 55
    2d2e:	f0 e0       	ldi	r31, 0x00	; 0
    2d30:	8f ef       	ldi	r24, 0xFF	; 255
    2d32:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    2d34:	19 82       	std	Y+1, r1	; 0x01
    2d36:	59 c0       	rjmp	.+178    	; 0x2dea <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortC) {
    2d38:	8a 81       	ldd	r24, Y+2	; 0x02
    2d3a:	82 30       	cpi	r24, 0x02	; 2
    2d3c:	31 f4       	brne	.+12     	; 0x2d4a <MCAL_DIO_u8SetPortDirection+0x58>
				DDRC = PORT_OUTPUT;
    2d3e:	e4 e3       	ldi	r30, 0x34	; 52
    2d40:	f0 e0       	ldi	r31, 0x00	; 0
    2d42:	8f ef       	ldi	r24, 0xFF	; 255
    2d44:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    2d46:	19 82       	std	Y+1, r1	; 0x01
    2d48:	50 c0       	rjmp	.+160    	; 0x2dea <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortD) {
    2d4a:	8a 81       	ldd	r24, Y+2	; 0x02
    2d4c:	83 30       	cpi	r24, 0x03	; 3
    2d4e:	09 f0       	breq	.+2      	; 0x2d52 <MCAL_DIO_u8SetPortDirection+0x60>
    2d50:	4c c0       	rjmp	.+152    	; 0x2dea <MCAL_DIO_u8SetPortDirection+0xf8>
				DDRD = PORT_OUTPUT;
    2d52:	e1 e3       	ldi	r30, 0x31	; 49
    2d54:	f0 e0       	ldi	r31, 0x00	; 0
    2d56:	8f ef       	ldi	r24, 0xFF	; 255
    2d58:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    2d5a:	19 82       	std	Y+1, r1	; 0x01
    2d5c:	46 c0       	rjmp	.+140    	; 0x2dea <MCAL_DIO_u8SetPortDirection+0xf8>
			} else {
				//Do Nothing
			}
		} else if (Loc_u8PortDirection == PORT_INPUT) {
    2d5e:	8b 81       	ldd	r24, Y+3	; 0x03
    2d60:	88 23       	and	r24, r24
    2d62:	01 f5       	brne	.+64     	; 0x2da4 <MCAL_DIO_u8SetPortDirection+0xb2>
			if (Loc_u8PortID == PortA) {
    2d64:	8a 81       	ldd	r24, Y+2	; 0x02
    2d66:	88 23       	and	r24, r24
    2d68:	29 f4       	brne	.+10     	; 0x2d74 <MCAL_DIO_u8SetPortDirection+0x82>
				DDRA = PORT_INPUT;
    2d6a:	ea e3       	ldi	r30, 0x3A	; 58
    2d6c:	f0 e0       	ldi	r31, 0x00	; 0
    2d6e:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    2d70:	19 82       	std	Y+1, r1	; 0x01
    2d72:	3b c0       	rjmp	.+118    	; 0x2dea <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortB) {
    2d74:	8a 81       	ldd	r24, Y+2	; 0x02
    2d76:	81 30       	cpi	r24, 0x01	; 1
    2d78:	29 f4       	brne	.+10     	; 0x2d84 <MCAL_DIO_u8SetPortDirection+0x92>
				DDRB = PORT_INPUT;
    2d7a:	e7 e3       	ldi	r30, 0x37	; 55
    2d7c:	f0 e0       	ldi	r31, 0x00	; 0
    2d7e:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    2d80:	19 82       	std	Y+1, r1	; 0x01
    2d82:	33 c0       	rjmp	.+102    	; 0x2dea <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortC) {
    2d84:	8a 81       	ldd	r24, Y+2	; 0x02
    2d86:	82 30       	cpi	r24, 0x02	; 2
    2d88:	29 f4       	brne	.+10     	; 0x2d94 <MCAL_DIO_u8SetPortDirection+0xa2>
				DDRC = PORT_INPUT;
    2d8a:	e4 e3       	ldi	r30, 0x34	; 52
    2d8c:	f0 e0       	ldi	r31, 0x00	; 0
    2d8e:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    2d90:	19 82       	std	Y+1, r1	; 0x01
    2d92:	2b c0       	rjmp	.+86     	; 0x2dea <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortD) {
    2d94:	8a 81       	ldd	r24, Y+2	; 0x02
    2d96:	83 30       	cpi	r24, 0x03	; 3
    2d98:	41 f5       	brne	.+80     	; 0x2dea <MCAL_DIO_u8SetPortDirection+0xf8>
				DDRD = PORT_INPUT;
    2d9a:	e1 e3       	ldi	r30, 0x31	; 49
    2d9c:	f0 e0       	ldi	r31, 0x00	; 0
    2d9e:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    2da0:	19 82       	std	Y+1, r1	; 0x01
    2da2:	23 c0       	rjmp	.+70     	; 0x2dea <MCAL_DIO_u8SetPortDirection+0xf8>
			} else {
				//Do Nothing
			}
		} else {
			if (Loc_u8PortID == PortA) {
    2da4:	8a 81       	ldd	r24, Y+2	; 0x02
    2da6:	88 23       	and	r24, r24
    2da8:	31 f4       	brne	.+12     	; 0x2db6 <MCAL_DIO_u8SetPortDirection+0xc4>
				DDRA = Loc_u8PortDirection;
    2daa:	ea e3       	ldi	r30, 0x3A	; 58
    2dac:	f0 e0       	ldi	r31, 0x00	; 0
    2dae:	8b 81       	ldd	r24, Y+3	; 0x03
    2db0:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    2db2:	19 82       	std	Y+1, r1	; 0x01
    2db4:	1a c0       	rjmp	.+52     	; 0x2dea <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortB) {
    2db6:	8a 81       	ldd	r24, Y+2	; 0x02
    2db8:	81 30       	cpi	r24, 0x01	; 1
    2dba:	31 f4       	brne	.+12     	; 0x2dc8 <MCAL_DIO_u8SetPortDirection+0xd6>
				DDRB = Loc_u8PortDirection;
    2dbc:	e7 e3       	ldi	r30, 0x37	; 55
    2dbe:	f0 e0       	ldi	r31, 0x00	; 0
    2dc0:	8b 81       	ldd	r24, Y+3	; 0x03
    2dc2:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    2dc4:	19 82       	std	Y+1, r1	; 0x01
    2dc6:	11 c0       	rjmp	.+34     	; 0x2dea <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortC) {
    2dc8:	8a 81       	ldd	r24, Y+2	; 0x02
    2dca:	82 30       	cpi	r24, 0x02	; 2
    2dcc:	31 f4       	brne	.+12     	; 0x2dda <MCAL_DIO_u8SetPortDirection+0xe8>
				DDRC = Loc_u8PortDirection;
    2dce:	e4 e3       	ldi	r30, 0x34	; 52
    2dd0:	f0 e0       	ldi	r31, 0x00	; 0
    2dd2:	8b 81       	ldd	r24, Y+3	; 0x03
    2dd4:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    2dd6:	19 82       	std	Y+1, r1	; 0x01
    2dd8:	08 c0       	rjmp	.+16     	; 0x2dea <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortD) {
    2dda:	8a 81       	ldd	r24, Y+2	; 0x02
    2ddc:	83 30       	cpi	r24, 0x03	; 3
    2dde:	29 f4       	brne	.+10     	; 0x2dea <MCAL_DIO_u8SetPortDirection+0xf8>
				DDRD = Loc_u8PortDirection;
    2de0:	e1 e3       	ldi	r30, 0x31	; 49
    2de2:	f0 e0       	ldi	r31, 0x00	; 0
    2de4:	8b 81       	ldd	r24, Y+3	; 0x03
    2de6:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    2de8:	19 82       	std	Y+1, r1	; 0x01
			}
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    2dea:	89 81       	ldd	r24, Y+1	; 0x01
}
    2dec:	0f 90       	pop	r0
    2dee:	0f 90       	pop	r0
    2df0:	0f 90       	pop	r0
    2df2:	cf 91       	pop	r28
    2df4:	df 91       	pop	r29
    2df6:	08 95       	ret

00002df8 <MCAL_DIO_u8SetPinDirection>:

STD_Type MCAL_DIO_u8SetPinDirection(u8 Loc_u8PortID, u8 Loc_u8PinID,
		u8 Loc_u8PinDirection) {
    2df8:	df 93       	push	r29
    2dfa:	cf 93       	push	r28
    2dfc:	00 d0       	rcall	.+0      	; 0x2dfe <MCAL_DIO_u8SetPinDirection+0x6>
    2dfe:	00 d0       	rcall	.+0      	; 0x2e00 <MCAL_DIO_u8SetPinDirection+0x8>
    2e00:	cd b7       	in	r28, 0x3d	; 61
    2e02:	de b7       	in	r29, 0x3e	; 62
    2e04:	8a 83       	std	Y+2, r24	; 0x02
    2e06:	6b 83       	std	Y+3, r22	; 0x03
    2e08:	4c 83       	std	Y+4, r20	; 0x04
	u8 Loc_u8Return_Value = E_NOT_OK;
    2e0a:	81 e0       	ldi	r24, 0x01	; 1
    2e0c:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD && Loc_u8PinID <= Num_Of_Pins
    2e0e:	8a 81       	ldd	r24, Y+2	; 0x02
    2e10:	84 30       	cpi	r24, 0x04	; 4
    2e12:	08 f0       	brcs	.+2      	; 0x2e16 <MCAL_DIO_u8SetPinDirection+0x1e>
    2e14:	d4 c0       	rjmp	.+424    	; 0x2fbe <MCAL_DIO_u8SetPinDirection+0x1c6>
    2e16:	8b 81       	ldd	r24, Y+3	; 0x03
    2e18:	88 30       	cpi	r24, 0x08	; 8
    2e1a:	08 f0       	brcs	.+2      	; 0x2e1e <MCAL_DIO_u8SetPinDirection+0x26>
    2e1c:	d0 c0       	rjmp	.+416    	; 0x2fbe <MCAL_DIO_u8SetPinDirection+0x1c6>
    2e1e:	8c 81       	ldd	r24, Y+4	; 0x04
    2e20:	82 30       	cpi	r24, 0x02	; 2
    2e22:	08 f0       	brcs	.+2      	; 0x2e26 <MCAL_DIO_u8SetPinDirection+0x2e>
    2e24:	cc c0       	rjmp	.+408    	; 0x2fbe <MCAL_DIO_u8SetPinDirection+0x1c6>
			&& Loc_u8PinDirection <= Pin_High) {
		if (Loc_u8PinDirection == Pin_High) {
    2e26:	8c 81       	ldd	r24, Y+4	; 0x04
    2e28:	81 30       	cpi	r24, 0x01	; 1
    2e2a:	09 f0       	breq	.+2      	; 0x2e2e <MCAL_DIO_u8SetPinDirection+0x36>
    2e2c:	61 c0       	rjmp	.+194    	; 0x2ef0 <MCAL_DIO_u8SetPinDirection+0xf8>
			if (Loc_u8PortID == PortA) {
    2e2e:	8a 81       	ldd	r24, Y+2	; 0x02
    2e30:	88 23       	and	r24, r24
    2e32:	a9 f4       	brne	.+42     	; 0x2e5e <MCAL_DIO_u8SetPinDirection+0x66>
				SET_BIT(DDRA, Loc_u8PinID);
    2e34:	aa e3       	ldi	r26, 0x3A	; 58
    2e36:	b0 e0       	ldi	r27, 0x00	; 0
    2e38:	ea e3       	ldi	r30, 0x3A	; 58
    2e3a:	f0 e0       	ldi	r31, 0x00	; 0
    2e3c:	80 81       	ld	r24, Z
    2e3e:	48 2f       	mov	r20, r24
    2e40:	8b 81       	ldd	r24, Y+3	; 0x03
    2e42:	28 2f       	mov	r18, r24
    2e44:	30 e0       	ldi	r19, 0x00	; 0
    2e46:	81 e0       	ldi	r24, 0x01	; 1
    2e48:	90 e0       	ldi	r25, 0x00	; 0
    2e4a:	02 2e       	mov	r0, r18
    2e4c:	02 c0       	rjmp	.+4      	; 0x2e52 <MCAL_DIO_u8SetPinDirection+0x5a>
    2e4e:	88 0f       	add	r24, r24
    2e50:	99 1f       	adc	r25, r25
    2e52:	0a 94       	dec	r0
    2e54:	e2 f7       	brpl	.-8      	; 0x2e4e <MCAL_DIO_u8SetPinDirection+0x56>
    2e56:	84 2b       	or	r24, r20
    2e58:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2e5a:	19 82       	std	Y+1, r1	; 0x01
    2e5c:	b0 c0       	rjmp	.+352    	; 0x2fbe <MCAL_DIO_u8SetPinDirection+0x1c6>
			} else if (Loc_u8PortID == PortB) {
    2e5e:	8a 81       	ldd	r24, Y+2	; 0x02
    2e60:	81 30       	cpi	r24, 0x01	; 1
    2e62:	a9 f4       	brne	.+42     	; 0x2e8e <MCAL_DIO_u8SetPinDirection+0x96>
				SET_BIT(DDRB, Loc_u8PinID);
    2e64:	a7 e3       	ldi	r26, 0x37	; 55
    2e66:	b0 e0       	ldi	r27, 0x00	; 0
    2e68:	e7 e3       	ldi	r30, 0x37	; 55
    2e6a:	f0 e0       	ldi	r31, 0x00	; 0
    2e6c:	80 81       	ld	r24, Z
    2e6e:	48 2f       	mov	r20, r24
    2e70:	8b 81       	ldd	r24, Y+3	; 0x03
    2e72:	28 2f       	mov	r18, r24
    2e74:	30 e0       	ldi	r19, 0x00	; 0
    2e76:	81 e0       	ldi	r24, 0x01	; 1
    2e78:	90 e0       	ldi	r25, 0x00	; 0
    2e7a:	02 2e       	mov	r0, r18
    2e7c:	02 c0       	rjmp	.+4      	; 0x2e82 <MCAL_DIO_u8SetPinDirection+0x8a>
    2e7e:	88 0f       	add	r24, r24
    2e80:	99 1f       	adc	r25, r25
    2e82:	0a 94       	dec	r0
    2e84:	e2 f7       	brpl	.-8      	; 0x2e7e <MCAL_DIO_u8SetPinDirection+0x86>
    2e86:	84 2b       	or	r24, r20
    2e88:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2e8a:	19 82       	std	Y+1, r1	; 0x01
    2e8c:	98 c0       	rjmp	.+304    	; 0x2fbe <MCAL_DIO_u8SetPinDirection+0x1c6>
			} else if (Loc_u8PortID == PortC) {
    2e8e:	8a 81       	ldd	r24, Y+2	; 0x02
    2e90:	82 30       	cpi	r24, 0x02	; 2
    2e92:	a9 f4       	brne	.+42     	; 0x2ebe <MCAL_DIO_u8SetPinDirection+0xc6>
				SET_BIT(DDRC, Loc_u8PinID);
    2e94:	a4 e3       	ldi	r26, 0x34	; 52
    2e96:	b0 e0       	ldi	r27, 0x00	; 0
    2e98:	e4 e3       	ldi	r30, 0x34	; 52
    2e9a:	f0 e0       	ldi	r31, 0x00	; 0
    2e9c:	80 81       	ld	r24, Z
    2e9e:	48 2f       	mov	r20, r24
    2ea0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ea2:	28 2f       	mov	r18, r24
    2ea4:	30 e0       	ldi	r19, 0x00	; 0
    2ea6:	81 e0       	ldi	r24, 0x01	; 1
    2ea8:	90 e0       	ldi	r25, 0x00	; 0
    2eaa:	02 2e       	mov	r0, r18
    2eac:	02 c0       	rjmp	.+4      	; 0x2eb2 <MCAL_DIO_u8SetPinDirection+0xba>
    2eae:	88 0f       	add	r24, r24
    2eb0:	99 1f       	adc	r25, r25
    2eb2:	0a 94       	dec	r0
    2eb4:	e2 f7       	brpl	.-8      	; 0x2eae <MCAL_DIO_u8SetPinDirection+0xb6>
    2eb6:	84 2b       	or	r24, r20
    2eb8:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2eba:	19 82       	std	Y+1, r1	; 0x01
    2ebc:	80 c0       	rjmp	.+256    	; 0x2fbe <MCAL_DIO_u8SetPinDirection+0x1c6>
			} else if (Loc_u8PortID == PortD) {
    2ebe:	8a 81       	ldd	r24, Y+2	; 0x02
    2ec0:	83 30       	cpi	r24, 0x03	; 3
    2ec2:	09 f0       	breq	.+2      	; 0x2ec6 <MCAL_DIO_u8SetPinDirection+0xce>
    2ec4:	7c c0       	rjmp	.+248    	; 0x2fbe <MCAL_DIO_u8SetPinDirection+0x1c6>
				SET_BIT(DDRD, Loc_u8PinID);
    2ec6:	a1 e3       	ldi	r26, 0x31	; 49
    2ec8:	b0 e0       	ldi	r27, 0x00	; 0
    2eca:	e1 e3       	ldi	r30, 0x31	; 49
    2ecc:	f0 e0       	ldi	r31, 0x00	; 0
    2ece:	80 81       	ld	r24, Z
    2ed0:	48 2f       	mov	r20, r24
    2ed2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ed4:	28 2f       	mov	r18, r24
    2ed6:	30 e0       	ldi	r19, 0x00	; 0
    2ed8:	81 e0       	ldi	r24, 0x01	; 1
    2eda:	90 e0       	ldi	r25, 0x00	; 0
    2edc:	02 2e       	mov	r0, r18
    2ede:	02 c0       	rjmp	.+4      	; 0x2ee4 <MCAL_DIO_u8SetPinDirection+0xec>
    2ee0:	88 0f       	add	r24, r24
    2ee2:	99 1f       	adc	r25, r25
    2ee4:	0a 94       	dec	r0
    2ee6:	e2 f7       	brpl	.-8      	; 0x2ee0 <MCAL_DIO_u8SetPinDirection+0xe8>
    2ee8:	84 2b       	or	r24, r20
    2eea:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2eec:	19 82       	std	Y+1, r1	; 0x01
    2eee:	67 c0       	rjmp	.+206    	; 0x2fbe <MCAL_DIO_u8SetPinDirection+0x1c6>
			} else {
				//Do Nothing
			}
		} else if (Loc_u8PinDirection == Pin_Low) {
    2ef0:	8c 81       	ldd	r24, Y+4	; 0x04
    2ef2:	88 23       	and	r24, r24
    2ef4:	09 f0       	breq	.+2      	; 0x2ef8 <MCAL_DIO_u8SetPinDirection+0x100>
    2ef6:	63 c0       	rjmp	.+198    	; 0x2fbe <MCAL_DIO_u8SetPinDirection+0x1c6>
			if (Loc_u8PortID == PortA) {
    2ef8:	8a 81       	ldd	r24, Y+2	; 0x02
    2efa:	88 23       	and	r24, r24
    2efc:	b1 f4       	brne	.+44     	; 0x2f2a <MCAL_DIO_u8SetPinDirection+0x132>
				CLR_BIT(DDRA, Loc_u8PinID);
    2efe:	aa e3       	ldi	r26, 0x3A	; 58
    2f00:	b0 e0       	ldi	r27, 0x00	; 0
    2f02:	ea e3       	ldi	r30, 0x3A	; 58
    2f04:	f0 e0       	ldi	r31, 0x00	; 0
    2f06:	80 81       	ld	r24, Z
    2f08:	48 2f       	mov	r20, r24
    2f0a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f0c:	28 2f       	mov	r18, r24
    2f0e:	30 e0       	ldi	r19, 0x00	; 0
    2f10:	81 e0       	ldi	r24, 0x01	; 1
    2f12:	90 e0       	ldi	r25, 0x00	; 0
    2f14:	02 2e       	mov	r0, r18
    2f16:	02 c0       	rjmp	.+4      	; 0x2f1c <MCAL_DIO_u8SetPinDirection+0x124>
    2f18:	88 0f       	add	r24, r24
    2f1a:	99 1f       	adc	r25, r25
    2f1c:	0a 94       	dec	r0
    2f1e:	e2 f7       	brpl	.-8      	; 0x2f18 <MCAL_DIO_u8SetPinDirection+0x120>
    2f20:	80 95       	com	r24
    2f22:	84 23       	and	r24, r20
    2f24:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2f26:	19 82       	std	Y+1, r1	; 0x01
    2f28:	4a c0       	rjmp	.+148    	; 0x2fbe <MCAL_DIO_u8SetPinDirection+0x1c6>
			} else if (Loc_u8PortID == PortB) {
    2f2a:	8a 81       	ldd	r24, Y+2	; 0x02
    2f2c:	81 30       	cpi	r24, 0x01	; 1
    2f2e:	b1 f4       	brne	.+44     	; 0x2f5c <MCAL_DIO_u8SetPinDirection+0x164>
				CLR_BIT(DDRB, Loc_u8PinID);
    2f30:	a7 e3       	ldi	r26, 0x37	; 55
    2f32:	b0 e0       	ldi	r27, 0x00	; 0
    2f34:	e7 e3       	ldi	r30, 0x37	; 55
    2f36:	f0 e0       	ldi	r31, 0x00	; 0
    2f38:	80 81       	ld	r24, Z
    2f3a:	48 2f       	mov	r20, r24
    2f3c:	8b 81       	ldd	r24, Y+3	; 0x03
    2f3e:	28 2f       	mov	r18, r24
    2f40:	30 e0       	ldi	r19, 0x00	; 0
    2f42:	81 e0       	ldi	r24, 0x01	; 1
    2f44:	90 e0       	ldi	r25, 0x00	; 0
    2f46:	02 2e       	mov	r0, r18
    2f48:	02 c0       	rjmp	.+4      	; 0x2f4e <MCAL_DIO_u8SetPinDirection+0x156>
    2f4a:	88 0f       	add	r24, r24
    2f4c:	99 1f       	adc	r25, r25
    2f4e:	0a 94       	dec	r0
    2f50:	e2 f7       	brpl	.-8      	; 0x2f4a <MCAL_DIO_u8SetPinDirection+0x152>
    2f52:	80 95       	com	r24
    2f54:	84 23       	and	r24, r20
    2f56:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2f58:	19 82       	std	Y+1, r1	; 0x01
    2f5a:	31 c0       	rjmp	.+98     	; 0x2fbe <MCAL_DIO_u8SetPinDirection+0x1c6>
			} else if (Loc_u8PortID == PortC) {
    2f5c:	8a 81       	ldd	r24, Y+2	; 0x02
    2f5e:	82 30       	cpi	r24, 0x02	; 2
    2f60:	b1 f4       	brne	.+44     	; 0x2f8e <MCAL_DIO_u8SetPinDirection+0x196>
				CLR_BIT(DDRC, Loc_u8PinID);
    2f62:	a4 e3       	ldi	r26, 0x34	; 52
    2f64:	b0 e0       	ldi	r27, 0x00	; 0
    2f66:	e4 e3       	ldi	r30, 0x34	; 52
    2f68:	f0 e0       	ldi	r31, 0x00	; 0
    2f6a:	80 81       	ld	r24, Z
    2f6c:	48 2f       	mov	r20, r24
    2f6e:	8b 81       	ldd	r24, Y+3	; 0x03
    2f70:	28 2f       	mov	r18, r24
    2f72:	30 e0       	ldi	r19, 0x00	; 0
    2f74:	81 e0       	ldi	r24, 0x01	; 1
    2f76:	90 e0       	ldi	r25, 0x00	; 0
    2f78:	02 2e       	mov	r0, r18
    2f7a:	02 c0       	rjmp	.+4      	; 0x2f80 <MCAL_DIO_u8SetPinDirection+0x188>
    2f7c:	88 0f       	add	r24, r24
    2f7e:	99 1f       	adc	r25, r25
    2f80:	0a 94       	dec	r0
    2f82:	e2 f7       	brpl	.-8      	; 0x2f7c <MCAL_DIO_u8SetPinDirection+0x184>
    2f84:	80 95       	com	r24
    2f86:	84 23       	and	r24, r20
    2f88:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2f8a:	19 82       	std	Y+1, r1	; 0x01
    2f8c:	18 c0       	rjmp	.+48     	; 0x2fbe <MCAL_DIO_u8SetPinDirection+0x1c6>
			} else if (Loc_u8PortID == PortD) {
    2f8e:	8a 81       	ldd	r24, Y+2	; 0x02
    2f90:	83 30       	cpi	r24, 0x03	; 3
    2f92:	a9 f4       	brne	.+42     	; 0x2fbe <MCAL_DIO_u8SetPinDirection+0x1c6>
				CLR_BIT(DDRD, Loc_u8PinID);
    2f94:	a1 e3       	ldi	r26, 0x31	; 49
    2f96:	b0 e0       	ldi	r27, 0x00	; 0
    2f98:	e1 e3       	ldi	r30, 0x31	; 49
    2f9a:	f0 e0       	ldi	r31, 0x00	; 0
    2f9c:	80 81       	ld	r24, Z
    2f9e:	48 2f       	mov	r20, r24
    2fa0:	8b 81       	ldd	r24, Y+3	; 0x03
    2fa2:	28 2f       	mov	r18, r24
    2fa4:	30 e0       	ldi	r19, 0x00	; 0
    2fa6:	81 e0       	ldi	r24, 0x01	; 1
    2fa8:	90 e0       	ldi	r25, 0x00	; 0
    2faa:	02 2e       	mov	r0, r18
    2fac:	02 c0       	rjmp	.+4      	; 0x2fb2 <MCAL_DIO_u8SetPinDirection+0x1ba>
    2fae:	88 0f       	add	r24, r24
    2fb0:	99 1f       	adc	r25, r25
    2fb2:	0a 94       	dec	r0
    2fb4:	e2 f7       	brpl	.-8      	; 0x2fae <MCAL_DIO_u8SetPinDirection+0x1b6>
    2fb6:	80 95       	com	r24
    2fb8:	84 23       	and	r24, r20
    2fba:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2fbc:	19 82       	std	Y+1, r1	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    2fbe:	89 81       	ldd	r24, Y+1	; 0x01

}
    2fc0:	0f 90       	pop	r0
    2fc2:	0f 90       	pop	r0
    2fc4:	0f 90       	pop	r0
    2fc6:	0f 90       	pop	r0
    2fc8:	cf 91       	pop	r28
    2fca:	df 91       	pop	r29
    2fcc:	08 95       	ret

00002fce <MCAL_DIO_u8SetPortValue>:

STD_Type MCAL_DIO_u8SetPortValue(u8 Loc_u8PortID, u8 Loc_u8PortValue) {
    2fce:	df 93       	push	r29
    2fd0:	cf 93       	push	r28
    2fd2:	00 d0       	rcall	.+0      	; 0x2fd4 <MCAL_DIO_u8SetPortValue+0x6>
    2fd4:	0f 92       	push	r0
    2fd6:	cd b7       	in	r28, 0x3d	; 61
    2fd8:	de b7       	in	r29, 0x3e	; 62
    2fda:	8a 83       	std	Y+2, r24	; 0x02
    2fdc:	6b 83       	std	Y+3, r22	; 0x03
	u8 Loc_u8Return_Value = E_NOT_OK;
    2fde:	81 e0       	ldi	r24, 0x01	; 1
    2fe0:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD && Loc_u8PortValue <= PORT_OUTPUT) {
    2fe2:	8a 81       	ldd	r24, Y+2	; 0x02
    2fe4:	84 30       	cpi	r24, 0x04	; 4
    2fe6:	08 f0       	brcs	.+2      	; 0x2fea <MCAL_DIO_u8SetPortValue+0x1c>
    2fe8:	6e c0       	rjmp	.+220    	; 0x30c6 <MCAL_DIO_u8SetPortValue+0xf8>
		if (Loc_u8PortValue == PORT_OUTPUT) {
    2fea:	8b 81       	ldd	r24, Y+3	; 0x03
    2fec:	8f 3f       	cpi	r24, 0xFF	; 255
    2fee:	29 f5       	brne	.+74     	; 0x303a <MCAL_DIO_u8SetPortValue+0x6c>
			if (Loc_u8PortID == PortA) {
    2ff0:	8a 81       	ldd	r24, Y+2	; 0x02
    2ff2:	88 23       	and	r24, r24
    2ff4:	31 f4       	brne	.+12     	; 0x3002 <MCAL_DIO_u8SetPortValue+0x34>
				PORTA = PORT_OUTPUT;
    2ff6:	eb e3       	ldi	r30, 0x3B	; 59
    2ff8:	f0 e0       	ldi	r31, 0x00	; 0
    2ffa:	8f ef       	ldi	r24, 0xFF	; 255
    2ffc:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    2ffe:	19 82       	std	Y+1, r1	; 0x01
    3000:	62 c0       	rjmp	.+196    	; 0x30c6 <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortB) {
    3002:	8a 81       	ldd	r24, Y+2	; 0x02
    3004:	81 30       	cpi	r24, 0x01	; 1
    3006:	31 f4       	brne	.+12     	; 0x3014 <MCAL_DIO_u8SetPortValue+0x46>
				PORTB = PORT_OUTPUT;
    3008:	e8 e3       	ldi	r30, 0x38	; 56
    300a:	f0 e0       	ldi	r31, 0x00	; 0
    300c:	8f ef       	ldi	r24, 0xFF	; 255
    300e:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    3010:	19 82       	std	Y+1, r1	; 0x01
    3012:	59 c0       	rjmp	.+178    	; 0x30c6 <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortC) {
    3014:	8a 81       	ldd	r24, Y+2	; 0x02
    3016:	82 30       	cpi	r24, 0x02	; 2
    3018:	31 f4       	brne	.+12     	; 0x3026 <MCAL_DIO_u8SetPortValue+0x58>
				PORTC = PORT_OUTPUT;
    301a:	e5 e3       	ldi	r30, 0x35	; 53
    301c:	f0 e0       	ldi	r31, 0x00	; 0
    301e:	8f ef       	ldi	r24, 0xFF	; 255
    3020:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    3022:	19 82       	std	Y+1, r1	; 0x01
    3024:	50 c0       	rjmp	.+160    	; 0x30c6 <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortD) {
    3026:	8a 81       	ldd	r24, Y+2	; 0x02
    3028:	83 30       	cpi	r24, 0x03	; 3
    302a:	09 f0       	breq	.+2      	; 0x302e <MCAL_DIO_u8SetPortValue+0x60>
    302c:	4c c0       	rjmp	.+152    	; 0x30c6 <MCAL_DIO_u8SetPortValue+0xf8>
				PORTD = PORT_OUTPUT;
    302e:	e2 e3       	ldi	r30, 0x32	; 50
    3030:	f0 e0       	ldi	r31, 0x00	; 0
    3032:	8f ef       	ldi	r24, 0xFF	; 255
    3034:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    3036:	19 82       	std	Y+1, r1	; 0x01
    3038:	46 c0       	rjmp	.+140    	; 0x30c6 <MCAL_DIO_u8SetPortValue+0xf8>
			} else {
				//Do Nothing
			}
		} else if (Loc_u8PortValue == PORT_INPUT) {
    303a:	8b 81       	ldd	r24, Y+3	; 0x03
    303c:	88 23       	and	r24, r24
    303e:	01 f5       	brne	.+64     	; 0x3080 <MCAL_DIO_u8SetPortValue+0xb2>
			if (Loc_u8PortID == PortA) {
    3040:	8a 81       	ldd	r24, Y+2	; 0x02
    3042:	88 23       	and	r24, r24
    3044:	29 f4       	brne	.+10     	; 0x3050 <MCAL_DIO_u8SetPortValue+0x82>
				PORTA = PORT_INPUT;
    3046:	eb e3       	ldi	r30, 0x3B	; 59
    3048:	f0 e0       	ldi	r31, 0x00	; 0
    304a:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    304c:	19 82       	std	Y+1, r1	; 0x01
    304e:	3b c0       	rjmp	.+118    	; 0x30c6 <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortB) {
    3050:	8a 81       	ldd	r24, Y+2	; 0x02
    3052:	81 30       	cpi	r24, 0x01	; 1
    3054:	29 f4       	brne	.+10     	; 0x3060 <MCAL_DIO_u8SetPortValue+0x92>
				PORTB = PORT_INPUT;
    3056:	e8 e3       	ldi	r30, 0x38	; 56
    3058:	f0 e0       	ldi	r31, 0x00	; 0
    305a:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    305c:	19 82       	std	Y+1, r1	; 0x01
    305e:	33 c0       	rjmp	.+102    	; 0x30c6 <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortC) {
    3060:	8a 81       	ldd	r24, Y+2	; 0x02
    3062:	82 30       	cpi	r24, 0x02	; 2
    3064:	29 f4       	brne	.+10     	; 0x3070 <MCAL_DIO_u8SetPortValue+0xa2>
				PORTC = PORT_INPUT;
    3066:	e5 e3       	ldi	r30, 0x35	; 53
    3068:	f0 e0       	ldi	r31, 0x00	; 0
    306a:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    306c:	19 82       	std	Y+1, r1	; 0x01
    306e:	2b c0       	rjmp	.+86     	; 0x30c6 <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortD) {
    3070:	8a 81       	ldd	r24, Y+2	; 0x02
    3072:	83 30       	cpi	r24, 0x03	; 3
    3074:	41 f5       	brne	.+80     	; 0x30c6 <MCAL_DIO_u8SetPortValue+0xf8>
				PORTD = PORT_INPUT;
    3076:	e2 e3       	ldi	r30, 0x32	; 50
    3078:	f0 e0       	ldi	r31, 0x00	; 0
    307a:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    307c:	19 82       	std	Y+1, r1	; 0x01
    307e:	23 c0       	rjmp	.+70     	; 0x30c6 <MCAL_DIO_u8SetPortValue+0xf8>
			} else {
				//Do Nothing
			}
		} else {
			if (Loc_u8PortID == PortA) {
    3080:	8a 81       	ldd	r24, Y+2	; 0x02
    3082:	88 23       	and	r24, r24
    3084:	31 f4       	brne	.+12     	; 0x3092 <MCAL_DIO_u8SetPortValue+0xc4>
				PORTA = Loc_u8PortValue;
    3086:	eb e3       	ldi	r30, 0x3B	; 59
    3088:	f0 e0       	ldi	r31, 0x00	; 0
    308a:	8b 81       	ldd	r24, Y+3	; 0x03
    308c:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    308e:	19 82       	std	Y+1, r1	; 0x01
    3090:	1a c0       	rjmp	.+52     	; 0x30c6 <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortB) {
    3092:	8a 81       	ldd	r24, Y+2	; 0x02
    3094:	81 30       	cpi	r24, 0x01	; 1
    3096:	31 f4       	brne	.+12     	; 0x30a4 <MCAL_DIO_u8SetPortValue+0xd6>
				PORTB = Loc_u8PortValue;
    3098:	e8 e3       	ldi	r30, 0x38	; 56
    309a:	f0 e0       	ldi	r31, 0x00	; 0
    309c:	8b 81       	ldd	r24, Y+3	; 0x03
    309e:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    30a0:	19 82       	std	Y+1, r1	; 0x01
    30a2:	11 c0       	rjmp	.+34     	; 0x30c6 <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortC) {
    30a4:	8a 81       	ldd	r24, Y+2	; 0x02
    30a6:	82 30       	cpi	r24, 0x02	; 2
    30a8:	31 f4       	brne	.+12     	; 0x30b6 <MCAL_DIO_u8SetPortValue+0xe8>
				PORTC = Loc_u8PortValue;
    30aa:	e5 e3       	ldi	r30, 0x35	; 53
    30ac:	f0 e0       	ldi	r31, 0x00	; 0
    30ae:	8b 81       	ldd	r24, Y+3	; 0x03
    30b0:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    30b2:	19 82       	std	Y+1, r1	; 0x01
    30b4:	08 c0       	rjmp	.+16     	; 0x30c6 <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortD) {
    30b6:	8a 81       	ldd	r24, Y+2	; 0x02
    30b8:	83 30       	cpi	r24, 0x03	; 3
    30ba:	29 f4       	brne	.+10     	; 0x30c6 <MCAL_DIO_u8SetPortValue+0xf8>
				PORTD = Loc_u8PortValue;
    30bc:	e2 e3       	ldi	r30, 0x32	; 50
    30be:	f0 e0       	ldi	r31, 0x00	; 0
    30c0:	8b 81       	ldd	r24, Y+3	; 0x03
    30c2:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    30c4:	19 82       	std	Y+1, r1	; 0x01
			}
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    30c6:	89 81       	ldd	r24, Y+1	; 0x01
}
    30c8:	0f 90       	pop	r0
    30ca:	0f 90       	pop	r0
    30cc:	0f 90       	pop	r0
    30ce:	cf 91       	pop	r28
    30d0:	df 91       	pop	r29
    30d2:	08 95       	ret

000030d4 <MCAL_DIO_u8SetPinValue>:

STD_Type MCAL_DIO_u8SetPinValue(u8 Loc_u8PortID, u8 Loc_u8PinID,
		u8 Loc_u8PinValue) {
    30d4:	df 93       	push	r29
    30d6:	cf 93       	push	r28
    30d8:	00 d0       	rcall	.+0      	; 0x30da <MCAL_DIO_u8SetPinValue+0x6>
    30da:	00 d0       	rcall	.+0      	; 0x30dc <MCAL_DIO_u8SetPinValue+0x8>
    30dc:	cd b7       	in	r28, 0x3d	; 61
    30de:	de b7       	in	r29, 0x3e	; 62
    30e0:	8a 83       	std	Y+2, r24	; 0x02
    30e2:	6b 83       	std	Y+3, r22	; 0x03
    30e4:	4c 83       	std	Y+4, r20	; 0x04
	u8 Loc_u8Return_Value = E_NOT_OK;
    30e6:	81 e0       	ldi	r24, 0x01	; 1
    30e8:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD && Loc_u8PinID <= Num_Of_Pins
    30ea:	8a 81       	ldd	r24, Y+2	; 0x02
    30ec:	84 30       	cpi	r24, 0x04	; 4
    30ee:	08 f0       	brcs	.+2      	; 0x30f2 <MCAL_DIO_u8SetPinValue+0x1e>
    30f0:	d4 c0       	rjmp	.+424    	; 0x329a <MCAL_DIO_u8SetPinValue+0x1c6>
    30f2:	8b 81       	ldd	r24, Y+3	; 0x03
    30f4:	88 30       	cpi	r24, 0x08	; 8
    30f6:	08 f0       	brcs	.+2      	; 0x30fa <MCAL_DIO_u8SetPinValue+0x26>
    30f8:	d0 c0       	rjmp	.+416    	; 0x329a <MCAL_DIO_u8SetPinValue+0x1c6>
    30fa:	8c 81       	ldd	r24, Y+4	; 0x04
    30fc:	82 30       	cpi	r24, 0x02	; 2
    30fe:	08 f0       	brcs	.+2      	; 0x3102 <MCAL_DIO_u8SetPinValue+0x2e>
    3100:	cc c0       	rjmp	.+408    	; 0x329a <MCAL_DIO_u8SetPinValue+0x1c6>
			&& Loc_u8PinValue <= Pin_High) {
		if (Loc_u8PinValue == Pin_High) {
    3102:	8c 81       	ldd	r24, Y+4	; 0x04
    3104:	81 30       	cpi	r24, 0x01	; 1
    3106:	09 f0       	breq	.+2      	; 0x310a <MCAL_DIO_u8SetPinValue+0x36>
    3108:	61 c0       	rjmp	.+194    	; 0x31cc <MCAL_DIO_u8SetPinValue+0xf8>
			if (Loc_u8PortID == PortA) {
    310a:	8a 81       	ldd	r24, Y+2	; 0x02
    310c:	88 23       	and	r24, r24
    310e:	a9 f4       	brne	.+42     	; 0x313a <MCAL_DIO_u8SetPinValue+0x66>
				SET_BIT(PORTA, Loc_u8PinID);
    3110:	ab e3       	ldi	r26, 0x3B	; 59
    3112:	b0 e0       	ldi	r27, 0x00	; 0
    3114:	eb e3       	ldi	r30, 0x3B	; 59
    3116:	f0 e0       	ldi	r31, 0x00	; 0
    3118:	80 81       	ld	r24, Z
    311a:	48 2f       	mov	r20, r24
    311c:	8b 81       	ldd	r24, Y+3	; 0x03
    311e:	28 2f       	mov	r18, r24
    3120:	30 e0       	ldi	r19, 0x00	; 0
    3122:	81 e0       	ldi	r24, 0x01	; 1
    3124:	90 e0       	ldi	r25, 0x00	; 0
    3126:	02 2e       	mov	r0, r18
    3128:	02 c0       	rjmp	.+4      	; 0x312e <MCAL_DIO_u8SetPinValue+0x5a>
    312a:	88 0f       	add	r24, r24
    312c:	99 1f       	adc	r25, r25
    312e:	0a 94       	dec	r0
    3130:	e2 f7       	brpl	.-8      	; 0x312a <MCAL_DIO_u8SetPinValue+0x56>
    3132:	84 2b       	or	r24, r20
    3134:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    3136:	19 82       	std	Y+1, r1	; 0x01
    3138:	b0 c0       	rjmp	.+352    	; 0x329a <MCAL_DIO_u8SetPinValue+0x1c6>
			} else if (Loc_u8PortID == PortB) {
    313a:	8a 81       	ldd	r24, Y+2	; 0x02
    313c:	81 30       	cpi	r24, 0x01	; 1
    313e:	a9 f4       	brne	.+42     	; 0x316a <MCAL_DIO_u8SetPinValue+0x96>
				SET_BIT(PORTB, Loc_u8PinID);
    3140:	a8 e3       	ldi	r26, 0x38	; 56
    3142:	b0 e0       	ldi	r27, 0x00	; 0
    3144:	e8 e3       	ldi	r30, 0x38	; 56
    3146:	f0 e0       	ldi	r31, 0x00	; 0
    3148:	80 81       	ld	r24, Z
    314a:	48 2f       	mov	r20, r24
    314c:	8b 81       	ldd	r24, Y+3	; 0x03
    314e:	28 2f       	mov	r18, r24
    3150:	30 e0       	ldi	r19, 0x00	; 0
    3152:	81 e0       	ldi	r24, 0x01	; 1
    3154:	90 e0       	ldi	r25, 0x00	; 0
    3156:	02 2e       	mov	r0, r18
    3158:	02 c0       	rjmp	.+4      	; 0x315e <MCAL_DIO_u8SetPinValue+0x8a>
    315a:	88 0f       	add	r24, r24
    315c:	99 1f       	adc	r25, r25
    315e:	0a 94       	dec	r0
    3160:	e2 f7       	brpl	.-8      	; 0x315a <MCAL_DIO_u8SetPinValue+0x86>
    3162:	84 2b       	or	r24, r20
    3164:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    3166:	19 82       	std	Y+1, r1	; 0x01
    3168:	98 c0       	rjmp	.+304    	; 0x329a <MCAL_DIO_u8SetPinValue+0x1c6>
			} else if (Loc_u8PortID == PortC) {
    316a:	8a 81       	ldd	r24, Y+2	; 0x02
    316c:	82 30       	cpi	r24, 0x02	; 2
    316e:	a9 f4       	brne	.+42     	; 0x319a <MCAL_DIO_u8SetPinValue+0xc6>
				SET_BIT(PORTC, Loc_u8PinID);
    3170:	a5 e3       	ldi	r26, 0x35	; 53
    3172:	b0 e0       	ldi	r27, 0x00	; 0
    3174:	e5 e3       	ldi	r30, 0x35	; 53
    3176:	f0 e0       	ldi	r31, 0x00	; 0
    3178:	80 81       	ld	r24, Z
    317a:	48 2f       	mov	r20, r24
    317c:	8b 81       	ldd	r24, Y+3	; 0x03
    317e:	28 2f       	mov	r18, r24
    3180:	30 e0       	ldi	r19, 0x00	; 0
    3182:	81 e0       	ldi	r24, 0x01	; 1
    3184:	90 e0       	ldi	r25, 0x00	; 0
    3186:	02 2e       	mov	r0, r18
    3188:	02 c0       	rjmp	.+4      	; 0x318e <MCAL_DIO_u8SetPinValue+0xba>
    318a:	88 0f       	add	r24, r24
    318c:	99 1f       	adc	r25, r25
    318e:	0a 94       	dec	r0
    3190:	e2 f7       	brpl	.-8      	; 0x318a <MCAL_DIO_u8SetPinValue+0xb6>
    3192:	84 2b       	or	r24, r20
    3194:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    3196:	19 82       	std	Y+1, r1	; 0x01
    3198:	80 c0       	rjmp	.+256    	; 0x329a <MCAL_DIO_u8SetPinValue+0x1c6>
			} else if (Loc_u8PortID == PortD) {
    319a:	8a 81       	ldd	r24, Y+2	; 0x02
    319c:	83 30       	cpi	r24, 0x03	; 3
    319e:	09 f0       	breq	.+2      	; 0x31a2 <MCAL_DIO_u8SetPinValue+0xce>
    31a0:	7c c0       	rjmp	.+248    	; 0x329a <MCAL_DIO_u8SetPinValue+0x1c6>
				SET_BIT(PORTD, Loc_u8PinID);
    31a2:	a2 e3       	ldi	r26, 0x32	; 50
    31a4:	b0 e0       	ldi	r27, 0x00	; 0
    31a6:	e2 e3       	ldi	r30, 0x32	; 50
    31a8:	f0 e0       	ldi	r31, 0x00	; 0
    31aa:	80 81       	ld	r24, Z
    31ac:	48 2f       	mov	r20, r24
    31ae:	8b 81       	ldd	r24, Y+3	; 0x03
    31b0:	28 2f       	mov	r18, r24
    31b2:	30 e0       	ldi	r19, 0x00	; 0
    31b4:	81 e0       	ldi	r24, 0x01	; 1
    31b6:	90 e0       	ldi	r25, 0x00	; 0
    31b8:	02 2e       	mov	r0, r18
    31ba:	02 c0       	rjmp	.+4      	; 0x31c0 <MCAL_DIO_u8SetPinValue+0xec>
    31bc:	88 0f       	add	r24, r24
    31be:	99 1f       	adc	r25, r25
    31c0:	0a 94       	dec	r0
    31c2:	e2 f7       	brpl	.-8      	; 0x31bc <MCAL_DIO_u8SetPinValue+0xe8>
    31c4:	84 2b       	or	r24, r20
    31c6:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    31c8:	19 82       	std	Y+1, r1	; 0x01
    31ca:	67 c0       	rjmp	.+206    	; 0x329a <MCAL_DIO_u8SetPinValue+0x1c6>
			} else {
				//Do Nothing
			}
		} else if (Loc_u8PinValue == Pin_Low) {
    31cc:	8c 81       	ldd	r24, Y+4	; 0x04
    31ce:	88 23       	and	r24, r24
    31d0:	09 f0       	breq	.+2      	; 0x31d4 <MCAL_DIO_u8SetPinValue+0x100>
    31d2:	63 c0       	rjmp	.+198    	; 0x329a <MCAL_DIO_u8SetPinValue+0x1c6>
			if (Loc_u8PortID == PortA) {
    31d4:	8a 81       	ldd	r24, Y+2	; 0x02
    31d6:	88 23       	and	r24, r24
    31d8:	b1 f4       	brne	.+44     	; 0x3206 <MCAL_DIO_u8SetPinValue+0x132>
				CLR_BIT(PORTA, Loc_u8PinID);
    31da:	ab e3       	ldi	r26, 0x3B	; 59
    31dc:	b0 e0       	ldi	r27, 0x00	; 0
    31de:	eb e3       	ldi	r30, 0x3B	; 59
    31e0:	f0 e0       	ldi	r31, 0x00	; 0
    31e2:	80 81       	ld	r24, Z
    31e4:	48 2f       	mov	r20, r24
    31e6:	8b 81       	ldd	r24, Y+3	; 0x03
    31e8:	28 2f       	mov	r18, r24
    31ea:	30 e0       	ldi	r19, 0x00	; 0
    31ec:	81 e0       	ldi	r24, 0x01	; 1
    31ee:	90 e0       	ldi	r25, 0x00	; 0
    31f0:	02 2e       	mov	r0, r18
    31f2:	02 c0       	rjmp	.+4      	; 0x31f8 <MCAL_DIO_u8SetPinValue+0x124>
    31f4:	88 0f       	add	r24, r24
    31f6:	99 1f       	adc	r25, r25
    31f8:	0a 94       	dec	r0
    31fa:	e2 f7       	brpl	.-8      	; 0x31f4 <MCAL_DIO_u8SetPinValue+0x120>
    31fc:	80 95       	com	r24
    31fe:	84 23       	and	r24, r20
    3200:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    3202:	19 82       	std	Y+1, r1	; 0x01
    3204:	4a c0       	rjmp	.+148    	; 0x329a <MCAL_DIO_u8SetPinValue+0x1c6>
			} else if (Loc_u8PortID == PortB) {
    3206:	8a 81       	ldd	r24, Y+2	; 0x02
    3208:	81 30       	cpi	r24, 0x01	; 1
    320a:	b1 f4       	brne	.+44     	; 0x3238 <MCAL_DIO_u8SetPinValue+0x164>
				CLR_BIT(PORTB, Loc_u8PinID);
    320c:	a8 e3       	ldi	r26, 0x38	; 56
    320e:	b0 e0       	ldi	r27, 0x00	; 0
    3210:	e8 e3       	ldi	r30, 0x38	; 56
    3212:	f0 e0       	ldi	r31, 0x00	; 0
    3214:	80 81       	ld	r24, Z
    3216:	48 2f       	mov	r20, r24
    3218:	8b 81       	ldd	r24, Y+3	; 0x03
    321a:	28 2f       	mov	r18, r24
    321c:	30 e0       	ldi	r19, 0x00	; 0
    321e:	81 e0       	ldi	r24, 0x01	; 1
    3220:	90 e0       	ldi	r25, 0x00	; 0
    3222:	02 2e       	mov	r0, r18
    3224:	02 c0       	rjmp	.+4      	; 0x322a <MCAL_DIO_u8SetPinValue+0x156>
    3226:	88 0f       	add	r24, r24
    3228:	99 1f       	adc	r25, r25
    322a:	0a 94       	dec	r0
    322c:	e2 f7       	brpl	.-8      	; 0x3226 <MCAL_DIO_u8SetPinValue+0x152>
    322e:	80 95       	com	r24
    3230:	84 23       	and	r24, r20
    3232:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    3234:	19 82       	std	Y+1, r1	; 0x01
    3236:	31 c0       	rjmp	.+98     	; 0x329a <MCAL_DIO_u8SetPinValue+0x1c6>
			} else if (Loc_u8PortID == PortC) {
    3238:	8a 81       	ldd	r24, Y+2	; 0x02
    323a:	82 30       	cpi	r24, 0x02	; 2
    323c:	b1 f4       	brne	.+44     	; 0x326a <MCAL_DIO_u8SetPinValue+0x196>
				CLR_BIT(PORTC, Loc_u8PinID);
    323e:	a5 e3       	ldi	r26, 0x35	; 53
    3240:	b0 e0       	ldi	r27, 0x00	; 0
    3242:	e5 e3       	ldi	r30, 0x35	; 53
    3244:	f0 e0       	ldi	r31, 0x00	; 0
    3246:	80 81       	ld	r24, Z
    3248:	48 2f       	mov	r20, r24
    324a:	8b 81       	ldd	r24, Y+3	; 0x03
    324c:	28 2f       	mov	r18, r24
    324e:	30 e0       	ldi	r19, 0x00	; 0
    3250:	81 e0       	ldi	r24, 0x01	; 1
    3252:	90 e0       	ldi	r25, 0x00	; 0
    3254:	02 2e       	mov	r0, r18
    3256:	02 c0       	rjmp	.+4      	; 0x325c <MCAL_DIO_u8SetPinValue+0x188>
    3258:	88 0f       	add	r24, r24
    325a:	99 1f       	adc	r25, r25
    325c:	0a 94       	dec	r0
    325e:	e2 f7       	brpl	.-8      	; 0x3258 <MCAL_DIO_u8SetPinValue+0x184>
    3260:	80 95       	com	r24
    3262:	84 23       	and	r24, r20
    3264:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    3266:	19 82       	std	Y+1, r1	; 0x01
    3268:	18 c0       	rjmp	.+48     	; 0x329a <MCAL_DIO_u8SetPinValue+0x1c6>
			} else if (Loc_u8PortID == PortD) {
    326a:	8a 81       	ldd	r24, Y+2	; 0x02
    326c:	83 30       	cpi	r24, 0x03	; 3
    326e:	a9 f4       	brne	.+42     	; 0x329a <MCAL_DIO_u8SetPinValue+0x1c6>
				CLR_BIT(PORTD, Loc_u8PinID);
    3270:	a2 e3       	ldi	r26, 0x32	; 50
    3272:	b0 e0       	ldi	r27, 0x00	; 0
    3274:	e2 e3       	ldi	r30, 0x32	; 50
    3276:	f0 e0       	ldi	r31, 0x00	; 0
    3278:	80 81       	ld	r24, Z
    327a:	48 2f       	mov	r20, r24
    327c:	8b 81       	ldd	r24, Y+3	; 0x03
    327e:	28 2f       	mov	r18, r24
    3280:	30 e0       	ldi	r19, 0x00	; 0
    3282:	81 e0       	ldi	r24, 0x01	; 1
    3284:	90 e0       	ldi	r25, 0x00	; 0
    3286:	02 2e       	mov	r0, r18
    3288:	02 c0       	rjmp	.+4      	; 0x328e <MCAL_DIO_u8SetPinValue+0x1ba>
    328a:	88 0f       	add	r24, r24
    328c:	99 1f       	adc	r25, r25
    328e:	0a 94       	dec	r0
    3290:	e2 f7       	brpl	.-8      	; 0x328a <MCAL_DIO_u8SetPinValue+0x1b6>
    3292:	80 95       	com	r24
    3294:	84 23       	and	r24, r20
    3296:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    3298:	19 82       	std	Y+1, r1	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    329a:	89 81       	ldd	r24, Y+1	; 0x01

}
    329c:	0f 90       	pop	r0
    329e:	0f 90       	pop	r0
    32a0:	0f 90       	pop	r0
    32a2:	0f 90       	pop	r0
    32a4:	cf 91       	pop	r28
    32a6:	df 91       	pop	r29
    32a8:	08 95       	ret

000032aa <MCAL_DIO_u8SGetPortValue>:

STD_Type MCAL_DIO_u8SGetPortValue(u8 Loc_u8PortID, u8* Loc_u8PortValue) {
    32aa:	df 93       	push	r29
    32ac:	cf 93       	push	r28
    32ae:	00 d0       	rcall	.+0      	; 0x32b0 <MCAL_DIO_u8SGetPortValue+0x6>
    32b0:	00 d0       	rcall	.+0      	; 0x32b2 <MCAL_DIO_u8SGetPortValue+0x8>
    32b2:	cd b7       	in	r28, 0x3d	; 61
    32b4:	de b7       	in	r29, 0x3e	; 62
    32b6:	8a 83       	std	Y+2, r24	; 0x02
    32b8:	7c 83       	std	Y+4, r23	; 0x04
    32ba:	6b 83       	std	Y+3, r22	; 0x03
	u8 Loc_u8Return_Value = E_NOT_OK;
    32bc:	81 e0       	ldi	r24, 0x01	; 1
    32be:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD) {
    32c0:	8a 81       	ldd	r24, Y+2	; 0x02
    32c2:	84 30       	cpi	r24, 0x04	; 4
    32c4:	58 f5       	brcc	.+86     	; 0x331c <MCAL_DIO_u8SGetPortValue+0x72>
		if (Loc_u8PortID == PortA) {
    32c6:	8a 81       	ldd	r24, Y+2	; 0x02
    32c8:	88 23       	and	r24, r24
    32ca:	41 f4       	brne	.+16     	; 0x32dc <MCAL_DIO_u8SGetPortValue+0x32>
			*Loc_u8PortValue = PORTA;
    32cc:	eb e3       	ldi	r30, 0x3B	; 59
    32ce:	f0 e0       	ldi	r31, 0x00	; 0
    32d0:	80 81       	ld	r24, Z
    32d2:	eb 81       	ldd	r30, Y+3	; 0x03
    32d4:	fc 81       	ldd	r31, Y+4	; 0x04
    32d6:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    32d8:	19 82       	std	Y+1, r1	; 0x01
    32da:	20 c0       	rjmp	.+64     	; 0x331c <MCAL_DIO_u8SGetPortValue+0x72>
		} else if (Loc_u8PortID == PortB) {
    32dc:	8a 81       	ldd	r24, Y+2	; 0x02
    32de:	81 30       	cpi	r24, 0x01	; 1
    32e0:	41 f4       	brne	.+16     	; 0x32f2 <MCAL_DIO_u8SGetPortValue+0x48>
			*Loc_u8PortValue = PORTB;
    32e2:	e8 e3       	ldi	r30, 0x38	; 56
    32e4:	f0 e0       	ldi	r31, 0x00	; 0
    32e6:	80 81       	ld	r24, Z
    32e8:	eb 81       	ldd	r30, Y+3	; 0x03
    32ea:	fc 81       	ldd	r31, Y+4	; 0x04
    32ec:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    32ee:	19 82       	std	Y+1, r1	; 0x01
    32f0:	15 c0       	rjmp	.+42     	; 0x331c <MCAL_DIO_u8SGetPortValue+0x72>
		} else if (Loc_u8PortID == PortC) {
    32f2:	8a 81       	ldd	r24, Y+2	; 0x02
    32f4:	82 30       	cpi	r24, 0x02	; 2
    32f6:	41 f4       	brne	.+16     	; 0x3308 <MCAL_DIO_u8SGetPortValue+0x5e>
			*Loc_u8PortValue = PORTC;
    32f8:	e5 e3       	ldi	r30, 0x35	; 53
    32fa:	f0 e0       	ldi	r31, 0x00	; 0
    32fc:	80 81       	ld	r24, Z
    32fe:	eb 81       	ldd	r30, Y+3	; 0x03
    3300:	fc 81       	ldd	r31, Y+4	; 0x04
    3302:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    3304:	19 82       	std	Y+1, r1	; 0x01
    3306:	0a c0       	rjmp	.+20     	; 0x331c <MCAL_DIO_u8SGetPortValue+0x72>
		} else if (Loc_u8PortID == PortD) {
    3308:	8a 81       	ldd	r24, Y+2	; 0x02
    330a:	83 30       	cpi	r24, 0x03	; 3
    330c:	39 f4       	brne	.+14     	; 0x331c <MCAL_DIO_u8SGetPortValue+0x72>
			*Loc_u8PortValue = PORTD;
    330e:	e2 e3       	ldi	r30, 0x32	; 50
    3310:	f0 e0       	ldi	r31, 0x00	; 0
    3312:	80 81       	ld	r24, Z
    3314:	eb 81       	ldd	r30, Y+3	; 0x03
    3316:	fc 81       	ldd	r31, Y+4	; 0x04
    3318:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    331a:	19 82       	std	Y+1, r1	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    331c:	89 81       	ldd	r24, Y+1	; 0x01
}
    331e:	0f 90       	pop	r0
    3320:	0f 90       	pop	r0
    3322:	0f 90       	pop	r0
    3324:	0f 90       	pop	r0
    3326:	cf 91       	pop	r28
    3328:	df 91       	pop	r29
    332a:	08 95       	ret

0000332c <MCAL_DIO_u8GetPinValue>:

STD_Type MCAL_DIO_u8GetPinValue(u8 Loc_u8PortID, u8 Loc_u8PinID,
		u8* Loc_u8PinValue) {
    332c:	df 93       	push	r29
    332e:	cf 93       	push	r28
    3330:	00 d0       	rcall	.+0      	; 0x3332 <MCAL_DIO_u8GetPinValue+0x6>
    3332:	00 d0       	rcall	.+0      	; 0x3334 <MCAL_DIO_u8GetPinValue+0x8>
    3334:	0f 92       	push	r0
    3336:	cd b7       	in	r28, 0x3d	; 61
    3338:	de b7       	in	r29, 0x3e	; 62
    333a:	8a 83       	std	Y+2, r24	; 0x02
    333c:	6b 83       	std	Y+3, r22	; 0x03
    333e:	5d 83       	std	Y+5, r21	; 0x05
    3340:	4c 83       	std	Y+4, r20	; 0x04
	u8 Loc_u8Return_Value = E_NOT_OK;
    3342:	81 e0       	ldi	r24, 0x01	; 1
    3344:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD && Loc_u8PinID <= Num_Of_Pins) {
    3346:	8a 81       	ldd	r24, Y+2	; 0x02
    3348:	84 30       	cpi	r24, 0x04	; 4
    334a:	08 f0       	brcs	.+2      	; 0x334e <MCAL_DIO_u8GetPinValue+0x22>
    334c:	63 c0       	rjmp	.+198    	; 0x3414 <MCAL_DIO_u8GetPinValue+0xe8>
    334e:	8b 81       	ldd	r24, Y+3	; 0x03
    3350:	88 30       	cpi	r24, 0x08	; 8
    3352:	08 f0       	brcs	.+2      	; 0x3356 <MCAL_DIO_u8GetPinValue+0x2a>
    3354:	5f c0       	rjmp	.+190    	; 0x3414 <MCAL_DIO_u8GetPinValue+0xe8>
		if (Loc_u8PortID == PortA) {
    3356:	8a 81       	ldd	r24, Y+2	; 0x02
    3358:	88 23       	and	r24, r24
    335a:	a9 f4       	brne	.+42     	; 0x3386 <MCAL_DIO_u8GetPinValue+0x5a>
			*Loc_u8PinValue = GET_BIT(PINA, Loc_u8PinID);
    335c:	e9 e3       	ldi	r30, 0x39	; 57
    335e:	f0 e0       	ldi	r31, 0x00	; 0
    3360:	80 81       	ld	r24, Z
    3362:	28 2f       	mov	r18, r24
    3364:	30 e0       	ldi	r19, 0x00	; 0
    3366:	8b 81       	ldd	r24, Y+3	; 0x03
    3368:	88 2f       	mov	r24, r24
    336a:	90 e0       	ldi	r25, 0x00	; 0
    336c:	a9 01       	movw	r20, r18
    336e:	02 c0       	rjmp	.+4      	; 0x3374 <MCAL_DIO_u8GetPinValue+0x48>
    3370:	55 95       	asr	r21
    3372:	47 95       	ror	r20
    3374:	8a 95       	dec	r24
    3376:	e2 f7       	brpl	.-8      	; 0x3370 <MCAL_DIO_u8GetPinValue+0x44>
    3378:	ca 01       	movw	r24, r20
    337a:	81 70       	andi	r24, 0x01	; 1
    337c:	ec 81       	ldd	r30, Y+4	; 0x04
    337e:	fd 81       	ldd	r31, Y+5	; 0x05
    3380:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    3382:	19 82       	std	Y+1, r1	; 0x01
    3384:	47 c0       	rjmp	.+142    	; 0x3414 <MCAL_DIO_u8GetPinValue+0xe8>
		} else if (Loc_u8PortID == PortB) {
    3386:	8a 81       	ldd	r24, Y+2	; 0x02
    3388:	81 30       	cpi	r24, 0x01	; 1
    338a:	a9 f4       	brne	.+42     	; 0x33b6 <MCAL_DIO_u8GetPinValue+0x8a>
			*Loc_u8PinValue = GET_BIT(PINB, Loc_u8PinID);
    338c:	e6 e3       	ldi	r30, 0x36	; 54
    338e:	f0 e0       	ldi	r31, 0x00	; 0
    3390:	80 81       	ld	r24, Z
    3392:	28 2f       	mov	r18, r24
    3394:	30 e0       	ldi	r19, 0x00	; 0
    3396:	8b 81       	ldd	r24, Y+3	; 0x03
    3398:	88 2f       	mov	r24, r24
    339a:	90 e0       	ldi	r25, 0x00	; 0
    339c:	a9 01       	movw	r20, r18
    339e:	02 c0       	rjmp	.+4      	; 0x33a4 <MCAL_DIO_u8GetPinValue+0x78>
    33a0:	55 95       	asr	r21
    33a2:	47 95       	ror	r20
    33a4:	8a 95       	dec	r24
    33a6:	e2 f7       	brpl	.-8      	; 0x33a0 <MCAL_DIO_u8GetPinValue+0x74>
    33a8:	ca 01       	movw	r24, r20
    33aa:	81 70       	andi	r24, 0x01	; 1
    33ac:	ec 81       	ldd	r30, Y+4	; 0x04
    33ae:	fd 81       	ldd	r31, Y+5	; 0x05
    33b0:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    33b2:	19 82       	std	Y+1, r1	; 0x01
    33b4:	2f c0       	rjmp	.+94     	; 0x3414 <MCAL_DIO_u8GetPinValue+0xe8>
		} else if (Loc_u8PortID == PortC) {
    33b6:	8a 81       	ldd	r24, Y+2	; 0x02
    33b8:	82 30       	cpi	r24, 0x02	; 2
    33ba:	a9 f4       	brne	.+42     	; 0x33e6 <MCAL_DIO_u8GetPinValue+0xba>
			*Loc_u8PinValue = GET_BIT(PINC, Loc_u8PinID);
    33bc:	e3 e3       	ldi	r30, 0x33	; 51
    33be:	f0 e0       	ldi	r31, 0x00	; 0
    33c0:	80 81       	ld	r24, Z
    33c2:	28 2f       	mov	r18, r24
    33c4:	30 e0       	ldi	r19, 0x00	; 0
    33c6:	8b 81       	ldd	r24, Y+3	; 0x03
    33c8:	88 2f       	mov	r24, r24
    33ca:	90 e0       	ldi	r25, 0x00	; 0
    33cc:	a9 01       	movw	r20, r18
    33ce:	02 c0       	rjmp	.+4      	; 0x33d4 <MCAL_DIO_u8GetPinValue+0xa8>
    33d0:	55 95       	asr	r21
    33d2:	47 95       	ror	r20
    33d4:	8a 95       	dec	r24
    33d6:	e2 f7       	brpl	.-8      	; 0x33d0 <MCAL_DIO_u8GetPinValue+0xa4>
    33d8:	ca 01       	movw	r24, r20
    33da:	81 70       	andi	r24, 0x01	; 1
    33dc:	ec 81       	ldd	r30, Y+4	; 0x04
    33de:	fd 81       	ldd	r31, Y+5	; 0x05
    33e0:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    33e2:	19 82       	std	Y+1, r1	; 0x01
    33e4:	17 c0       	rjmp	.+46     	; 0x3414 <MCAL_DIO_u8GetPinValue+0xe8>
		} else if (Loc_u8PortID == PortD) {
    33e6:	8a 81       	ldd	r24, Y+2	; 0x02
    33e8:	83 30       	cpi	r24, 0x03	; 3
    33ea:	a1 f4       	brne	.+40     	; 0x3414 <MCAL_DIO_u8GetPinValue+0xe8>
			*Loc_u8PinValue = GET_BIT(PIND, Loc_u8PinID);
    33ec:	e0 e3       	ldi	r30, 0x30	; 48
    33ee:	f0 e0       	ldi	r31, 0x00	; 0
    33f0:	80 81       	ld	r24, Z
    33f2:	28 2f       	mov	r18, r24
    33f4:	30 e0       	ldi	r19, 0x00	; 0
    33f6:	8b 81       	ldd	r24, Y+3	; 0x03
    33f8:	88 2f       	mov	r24, r24
    33fa:	90 e0       	ldi	r25, 0x00	; 0
    33fc:	a9 01       	movw	r20, r18
    33fe:	02 c0       	rjmp	.+4      	; 0x3404 <MCAL_DIO_u8GetPinValue+0xd8>
    3400:	55 95       	asr	r21
    3402:	47 95       	ror	r20
    3404:	8a 95       	dec	r24
    3406:	e2 f7       	brpl	.-8      	; 0x3400 <MCAL_DIO_u8GetPinValue+0xd4>
    3408:	ca 01       	movw	r24, r20
    340a:	81 70       	andi	r24, 0x01	; 1
    340c:	ec 81       	ldd	r30, Y+4	; 0x04
    340e:	fd 81       	ldd	r31, Y+5	; 0x05
    3410:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    3412:	19 82       	std	Y+1, r1	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    3414:	89 81       	ldd	r24, Y+1	; 0x01
}
    3416:	0f 90       	pop	r0
    3418:	0f 90       	pop	r0
    341a:	0f 90       	pop	r0
    341c:	0f 90       	pop	r0
    341e:	0f 90       	pop	r0
    3420:	cf 91       	pop	r28
    3422:	df 91       	pop	r29
    3424:	08 95       	ret

00003426 <MCAL_DIO_u8TogglePortValue>:

STD_Type MCAL_DIO_u8TogglePortValue(u8 Loc_u8PortID) {
    3426:	df 93       	push	r29
    3428:	cf 93       	push	r28
    342a:	00 d0       	rcall	.+0      	; 0x342c <MCAL_DIO_u8TogglePortValue+0x6>
    342c:	cd b7       	in	r28, 0x3d	; 61
    342e:	de b7       	in	r29, 0x3e	; 62
    3430:	8a 83       	std	Y+2, r24	; 0x02
	u8 Loc_u8Return_Value = E_NOT_OK;
    3432:	81 e0       	ldi	r24, 0x01	; 1
    3434:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD) {
    3436:	8a 81       	ldd	r24, Y+2	; 0x02
    3438:	84 30       	cpi	r24, 0x04	; 4
    343a:	78 f5       	brcc	.+94     	; 0x349a <MCAL_DIO_u8TogglePortValue+0x74>
		if (Loc_u8PortID == PortA) {
    343c:	8a 81       	ldd	r24, Y+2	; 0x02
    343e:	88 23       	and	r24, r24
    3440:	49 f4       	brne	.+18     	; 0x3454 <MCAL_DIO_u8TogglePortValue+0x2e>
			PORTA = ~PORTA;
    3442:	ab e3       	ldi	r26, 0x3B	; 59
    3444:	b0 e0       	ldi	r27, 0x00	; 0
    3446:	eb e3       	ldi	r30, 0x3B	; 59
    3448:	f0 e0       	ldi	r31, 0x00	; 0
    344a:	80 81       	ld	r24, Z
    344c:	80 95       	com	r24
    344e:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    3450:	19 82       	std	Y+1, r1	; 0x01
    3452:	23 c0       	rjmp	.+70     	; 0x349a <MCAL_DIO_u8TogglePortValue+0x74>
		} else if (Loc_u8PortID == PortB) {
    3454:	8a 81       	ldd	r24, Y+2	; 0x02
    3456:	81 30       	cpi	r24, 0x01	; 1
    3458:	49 f4       	brne	.+18     	; 0x346c <MCAL_DIO_u8TogglePortValue+0x46>
			PORTB = ~PORTB;
    345a:	a8 e3       	ldi	r26, 0x38	; 56
    345c:	b0 e0       	ldi	r27, 0x00	; 0
    345e:	e8 e3       	ldi	r30, 0x38	; 56
    3460:	f0 e0       	ldi	r31, 0x00	; 0
    3462:	80 81       	ld	r24, Z
    3464:	80 95       	com	r24
    3466:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    3468:	19 82       	std	Y+1, r1	; 0x01
    346a:	17 c0       	rjmp	.+46     	; 0x349a <MCAL_DIO_u8TogglePortValue+0x74>
		} else if (Loc_u8PortID == PortC) {
    346c:	8a 81       	ldd	r24, Y+2	; 0x02
    346e:	82 30       	cpi	r24, 0x02	; 2
    3470:	49 f4       	brne	.+18     	; 0x3484 <MCAL_DIO_u8TogglePortValue+0x5e>
			PORTC = ~PORTC;
    3472:	a5 e3       	ldi	r26, 0x35	; 53
    3474:	b0 e0       	ldi	r27, 0x00	; 0
    3476:	e5 e3       	ldi	r30, 0x35	; 53
    3478:	f0 e0       	ldi	r31, 0x00	; 0
    347a:	80 81       	ld	r24, Z
    347c:	80 95       	com	r24
    347e:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    3480:	19 82       	std	Y+1, r1	; 0x01
    3482:	0b c0       	rjmp	.+22     	; 0x349a <MCAL_DIO_u8TogglePortValue+0x74>
		} else if (Loc_u8PortID == PortD) {
    3484:	8a 81       	ldd	r24, Y+2	; 0x02
    3486:	83 30       	cpi	r24, 0x03	; 3
    3488:	41 f4       	brne	.+16     	; 0x349a <MCAL_DIO_u8TogglePortValue+0x74>
			PORTD = ~PORTD;
    348a:	a2 e3       	ldi	r26, 0x32	; 50
    348c:	b0 e0       	ldi	r27, 0x00	; 0
    348e:	e2 e3       	ldi	r30, 0x32	; 50
    3490:	f0 e0       	ldi	r31, 0x00	; 0
    3492:	80 81       	ld	r24, Z
    3494:	80 95       	com	r24
    3496:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    3498:	19 82       	std	Y+1, r1	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    349a:	89 81       	ldd	r24, Y+1	; 0x01
}
    349c:	0f 90       	pop	r0
    349e:	0f 90       	pop	r0
    34a0:	cf 91       	pop	r28
    34a2:	df 91       	pop	r29
    34a4:	08 95       	ret

000034a6 <MCAL_DIO_u8TogglePinValue>:

STD_Type MCAL_DIO_u8TogglePinValue(u8 Loc_u8PortID, u8 Loc_u8PinID) {
    34a6:	df 93       	push	r29
    34a8:	cf 93       	push	r28
    34aa:	00 d0       	rcall	.+0      	; 0x34ac <MCAL_DIO_u8TogglePinValue+0x6>
    34ac:	0f 92       	push	r0
    34ae:	cd b7       	in	r28, 0x3d	; 61
    34b0:	de b7       	in	r29, 0x3e	; 62
    34b2:	8a 83       	std	Y+2, r24	; 0x02
    34b4:	6b 83       	std	Y+3, r22	; 0x03
	u8 Loc_u8Return_Value = E_NOT_OK;
    34b6:	81 e0       	ldi	r24, 0x01	; 1
    34b8:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD && Loc_u8PinID <= Num_Of_Pins) {
    34ba:	8a 81       	ldd	r24, Y+2	; 0x02
    34bc:	84 30       	cpi	r24, 0x04	; 4
    34be:	08 f0       	brcs	.+2      	; 0x34c2 <MCAL_DIO_u8TogglePinValue+0x1c>
    34c0:	63 c0       	rjmp	.+198    	; 0x3588 <MCAL_DIO_u8TogglePinValue+0xe2>
    34c2:	8b 81       	ldd	r24, Y+3	; 0x03
    34c4:	88 30       	cpi	r24, 0x08	; 8
    34c6:	08 f0       	brcs	.+2      	; 0x34ca <MCAL_DIO_u8TogglePinValue+0x24>
    34c8:	5f c0       	rjmp	.+190    	; 0x3588 <MCAL_DIO_u8TogglePinValue+0xe2>
		if (Loc_u8PortID == PortA) {
    34ca:	8a 81       	ldd	r24, Y+2	; 0x02
    34cc:	88 23       	and	r24, r24
    34ce:	a9 f4       	brne	.+42     	; 0x34fa <MCAL_DIO_u8TogglePinValue+0x54>
			TOGGLE_BIT(PORTA, Loc_u8PinID);
    34d0:	ab e3       	ldi	r26, 0x3B	; 59
    34d2:	b0 e0       	ldi	r27, 0x00	; 0
    34d4:	eb e3       	ldi	r30, 0x3B	; 59
    34d6:	f0 e0       	ldi	r31, 0x00	; 0
    34d8:	80 81       	ld	r24, Z
    34da:	48 2f       	mov	r20, r24
    34dc:	8b 81       	ldd	r24, Y+3	; 0x03
    34de:	28 2f       	mov	r18, r24
    34e0:	30 e0       	ldi	r19, 0x00	; 0
    34e2:	81 e0       	ldi	r24, 0x01	; 1
    34e4:	90 e0       	ldi	r25, 0x00	; 0
    34e6:	02 2e       	mov	r0, r18
    34e8:	02 c0       	rjmp	.+4      	; 0x34ee <MCAL_DIO_u8TogglePinValue+0x48>
    34ea:	88 0f       	add	r24, r24
    34ec:	99 1f       	adc	r25, r25
    34ee:	0a 94       	dec	r0
    34f0:	e2 f7       	brpl	.-8      	; 0x34ea <MCAL_DIO_u8TogglePinValue+0x44>
    34f2:	84 27       	eor	r24, r20
    34f4:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    34f6:	19 82       	std	Y+1, r1	; 0x01
    34f8:	47 c0       	rjmp	.+142    	; 0x3588 <MCAL_DIO_u8TogglePinValue+0xe2>
		} else if (Loc_u8PortID == PortB) {
    34fa:	8a 81       	ldd	r24, Y+2	; 0x02
    34fc:	81 30       	cpi	r24, 0x01	; 1
    34fe:	a9 f4       	brne	.+42     	; 0x352a <MCAL_DIO_u8TogglePinValue+0x84>
			TOGGLE_BIT(PORTB, Loc_u8PinID);
    3500:	a8 e3       	ldi	r26, 0x38	; 56
    3502:	b0 e0       	ldi	r27, 0x00	; 0
    3504:	e8 e3       	ldi	r30, 0x38	; 56
    3506:	f0 e0       	ldi	r31, 0x00	; 0
    3508:	80 81       	ld	r24, Z
    350a:	48 2f       	mov	r20, r24
    350c:	8b 81       	ldd	r24, Y+3	; 0x03
    350e:	28 2f       	mov	r18, r24
    3510:	30 e0       	ldi	r19, 0x00	; 0
    3512:	81 e0       	ldi	r24, 0x01	; 1
    3514:	90 e0       	ldi	r25, 0x00	; 0
    3516:	02 2e       	mov	r0, r18
    3518:	02 c0       	rjmp	.+4      	; 0x351e <MCAL_DIO_u8TogglePinValue+0x78>
    351a:	88 0f       	add	r24, r24
    351c:	99 1f       	adc	r25, r25
    351e:	0a 94       	dec	r0
    3520:	e2 f7       	brpl	.-8      	; 0x351a <MCAL_DIO_u8TogglePinValue+0x74>
    3522:	84 27       	eor	r24, r20
    3524:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    3526:	19 82       	std	Y+1, r1	; 0x01
    3528:	2f c0       	rjmp	.+94     	; 0x3588 <MCAL_DIO_u8TogglePinValue+0xe2>
		} else if (Loc_u8PortID == PortC) {
    352a:	8a 81       	ldd	r24, Y+2	; 0x02
    352c:	82 30       	cpi	r24, 0x02	; 2
    352e:	a9 f4       	brne	.+42     	; 0x355a <MCAL_DIO_u8TogglePinValue+0xb4>
			TOGGLE_BIT(PORTC, Loc_u8PinID);
    3530:	a5 e3       	ldi	r26, 0x35	; 53
    3532:	b0 e0       	ldi	r27, 0x00	; 0
    3534:	e5 e3       	ldi	r30, 0x35	; 53
    3536:	f0 e0       	ldi	r31, 0x00	; 0
    3538:	80 81       	ld	r24, Z
    353a:	48 2f       	mov	r20, r24
    353c:	8b 81       	ldd	r24, Y+3	; 0x03
    353e:	28 2f       	mov	r18, r24
    3540:	30 e0       	ldi	r19, 0x00	; 0
    3542:	81 e0       	ldi	r24, 0x01	; 1
    3544:	90 e0       	ldi	r25, 0x00	; 0
    3546:	02 2e       	mov	r0, r18
    3548:	02 c0       	rjmp	.+4      	; 0x354e <MCAL_DIO_u8TogglePinValue+0xa8>
    354a:	88 0f       	add	r24, r24
    354c:	99 1f       	adc	r25, r25
    354e:	0a 94       	dec	r0
    3550:	e2 f7       	brpl	.-8      	; 0x354a <MCAL_DIO_u8TogglePinValue+0xa4>
    3552:	84 27       	eor	r24, r20
    3554:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    3556:	19 82       	std	Y+1, r1	; 0x01
    3558:	17 c0       	rjmp	.+46     	; 0x3588 <MCAL_DIO_u8TogglePinValue+0xe2>
		} else if (Loc_u8PortID == PortD) {
    355a:	8a 81       	ldd	r24, Y+2	; 0x02
    355c:	83 30       	cpi	r24, 0x03	; 3
    355e:	a1 f4       	brne	.+40     	; 0x3588 <MCAL_DIO_u8TogglePinValue+0xe2>
			TOGGLE_BIT(PORTD, Loc_u8PinID);
    3560:	a2 e3       	ldi	r26, 0x32	; 50
    3562:	b0 e0       	ldi	r27, 0x00	; 0
    3564:	e2 e3       	ldi	r30, 0x32	; 50
    3566:	f0 e0       	ldi	r31, 0x00	; 0
    3568:	80 81       	ld	r24, Z
    356a:	48 2f       	mov	r20, r24
    356c:	8b 81       	ldd	r24, Y+3	; 0x03
    356e:	28 2f       	mov	r18, r24
    3570:	30 e0       	ldi	r19, 0x00	; 0
    3572:	81 e0       	ldi	r24, 0x01	; 1
    3574:	90 e0       	ldi	r25, 0x00	; 0
    3576:	02 2e       	mov	r0, r18
    3578:	02 c0       	rjmp	.+4      	; 0x357e <MCAL_DIO_u8TogglePinValue+0xd8>
    357a:	88 0f       	add	r24, r24
    357c:	99 1f       	adc	r25, r25
    357e:	0a 94       	dec	r0
    3580:	e2 f7       	brpl	.-8      	; 0x357a <MCAL_DIO_u8TogglePinValue+0xd4>
    3582:	84 27       	eor	r24, r20
    3584:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    3586:	19 82       	std	Y+1, r1	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    3588:	89 81       	ldd	r24, Y+1	; 0x01
}
    358a:	0f 90       	pop	r0
    358c:	0f 90       	pop	r0
    358e:	0f 90       	pop	r0
    3590:	cf 91       	pop	r28
    3592:	df 91       	pop	r29
    3594:	08 95       	ret

00003596 <HAL_Ultrasonic_Sensor_voidInit>:
volatile f32 Glob_f32Distance = NUM0;
volatile u16 Glob_u16StartTime = NUM0, Glob_u16EndTime = NUM0, Glob_u16TimeDiff = NUM0;
volatile u16 Glob_u16OvfCounterStart, Glob_16OvfCounterEnd;
extern volatile u16 Glob_u16OvfCounter;

void HAL_Ultrasonic_Sensor_voidInit(void) {
    3596:	df 93       	push	r29
    3598:	cf 93       	push	r28
    359a:	cd b7       	in	r28, 0x3d	; 61
    359c:	de b7       	in	r29, 0x3e	; 62
	MCAL_DIO_u8SetPinDirection(ECHO_PORT, ECHO_PIN, Pin_Low);      //
    359e:	83 e0       	ldi	r24, 0x03	; 3
    35a0:	62 e0       	ldi	r22, 0x02	; 2
    35a2:	40 e0       	ldi	r20, 0x00	; 0
    35a4:	0e 94 fc 16 	call	0x2df8	; 0x2df8 <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(TRIG_PORT, TRIG_PIN, Pin_High);  //  trigger
    35a8:	83 e0       	ldi	r24, 0x03	; 3
    35aa:	66 e0       	ldi	r22, 0x06	; 6
    35ac:	41 e0       	ldi	r20, 0x01	; 1
    35ae:	0e 94 fc 16 	call	0x2df8	; 0x2df8 <MCAL_DIO_u8SetPinDirection>
	MCAL_Interrupt_EXIT_CallBack_0(HAL_Ultrasonic_Sensor_voidInterrupt); // external interrupt call back
    35b2:	89 e6       	ldi	r24, 0x69	; 105
    35b4:	9c e1       	ldi	r25, 0x1C	; 28
    35b6:	0e 94 57 15 	call	0x2aae	; 0x2aae <MCAL_Interrupt_EXIT_CallBack_0>
	SET_BIT(SREG,Pin7);
    35ba:	af e5       	ldi	r26, 0x5F	; 95
    35bc:	b0 e0       	ldi	r27, 0x00	; 0
    35be:	ef e5       	ldi	r30, 0x5F	; 95
    35c0:	f0 e0       	ldi	r31, 0x00	; 0
    35c2:	80 81       	ld	r24, Z
    35c4:	80 68       	ori	r24, 0x80	; 128
    35c6:	8c 93       	st	X, r24
	MCAL_Timer0_Init(Normal_Mode,Prescaller_64,'\0');
    35c8:	80 e0       	ldi	r24, 0x00	; 0
    35ca:	63 e0       	ldi	r22, 0x03	; 3
    35cc:	40 e0       	ldi	r20, 0x00	; 0
    35ce:	0e 94 97 10 	call	0x212e	; 0x212e <MCAL_Timer0_Init>
	MCAL_Timer0_SetPreloadValue(113);
    35d2:	81 e7       	ldi	r24, 0x71	; 113
    35d4:	0e 94 5e 12 	call	0x24bc	; 0x24bc <MCAL_Timer0_SetPreloadValue>
}
    35d8:	cf 91       	pop	r28
    35da:	df 91       	pop	r29
    35dc:	08 95       	ret

000035de <HAL_Ultrasonic_Sensor_voidTrigger>:

void HAL_Ultrasonic_Sensor_voidTrigger(void) {
    35de:	df 93       	push	r29
    35e0:	cf 93       	push	r28
    35e2:	cd b7       	in	r28, 0x3d	; 61
    35e4:	de b7       	in	r29, 0x3e	; 62
    35e6:	68 97       	sbiw	r28, 0x18	; 24
    35e8:	0f b6       	in	r0, 0x3f	; 63
    35ea:	f8 94       	cli
    35ec:	de bf       	out	0x3e, r29	; 62
    35ee:	0f be       	out	0x3f, r0	; 63
    35f0:	cd bf       	out	0x3d, r28	; 61
	MCAL_DIO_u8SetPinValue(TRIG_PORT, TRIG_PIN, Pin_High);    // high
    35f2:	83 e0       	ldi	r24, 0x03	; 3
    35f4:	66 e0       	ldi	r22, 0x06	; 6
    35f6:	41 e0       	ldi	r20, 0x01	; 1
    35f8:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <MCAL_DIO_u8SetPinValue>
    35fc:	80 e0       	ldi	r24, 0x00	; 0
    35fe:	90 e0       	ldi	r25, 0x00	; 0
    3600:	a0 e2       	ldi	r26, 0x20	; 32
    3602:	b1 e4       	ldi	r27, 0x41	; 65
    3604:	8d 8b       	std	Y+21, r24	; 0x15
    3606:	9e 8b       	std	Y+22, r25	; 0x16
    3608:	af 8b       	std	Y+23, r26	; 0x17
    360a:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    360c:	6d 89       	ldd	r22, Y+21	; 0x15
    360e:	7e 89       	ldd	r23, Y+22	; 0x16
    3610:	8f 89       	ldd	r24, Y+23	; 0x17
    3612:	98 8d       	ldd	r25, Y+24	; 0x18
    3614:	2b ea       	ldi	r18, 0xAB	; 171
    3616:	3a ea       	ldi	r19, 0xAA	; 170
    3618:	4a ea       	ldi	r20, 0xAA	; 170
    361a:	50 e4       	ldi	r21, 0x40	; 64
    361c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3620:	dc 01       	movw	r26, r24
    3622:	cb 01       	movw	r24, r22
    3624:	89 8b       	std	Y+17, r24	; 0x11
    3626:	9a 8b       	std	Y+18, r25	; 0x12
    3628:	ab 8b       	std	Y+19, r26	; 0x13
    362a:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    362c:	69 89       	ldd	r22, Y+17	; 0x11
    362e:	7a 89       	ldd	r23, Y+18	; 0x12
    3630:	8b 89       	ldd	r24, Y+19	; 0x13
    3632:	9c 89       	ldd	r25, Y+20	; 0x14
    3634:	20 e0       	ldi	r18, 0x00	; 0
    3636:	30 e0       	ldi	r19, 0x00	; 0
    3638:	40 e8       	ldi	r20, 0x80	; 128
    363a:	5f e3       	ldi	r21, 0x3F	; 63
    363c:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3640:	88 23       	and	r24, r24
    3642:	1c f4       	brge	.+6      	; 0x364a <HAL_Ultrasonic_Sensor_voidTrigger+0x6c>
		__ticks = 1;
    3644:	81 e0       	ldi	r24, 0x01	; 1
    3646:	88 8b       	std	Y+16, r24	; 0x10
    3648:	91 c0       	rjmp	.+290    	; 0x376c <HAL_Ultrasonic_Sensor_voidTrigger+0x18e>
	else if (__tmp > 255)
    364a:	69 89       	ldd	r22, Y+17	; 0x11
    364c:	7a 89       	ldd	r23, Y+18	; 0x12
    364e:	8b 89       	ldd	r24, Y+19	; 0x13
    3650:	9c 89       	ldd	r25, Y+20	; 0x14
    3652:	20 e0       	ldi	r18, 0x00	; 0
    3654:	30 e0       	ldi	r19, 0x00	; 0
    3656:	4f e7       	ldi	r20, 0x7F	; 127
    3658:	53 e4       	ldi	r21, 0x43	; 67
    365a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    365e:	18 16       	cp	r1, r24
    3660:	0c f0       	brlt	.+2      	; 0x3664 <HAL_Ultrasonic_Sensor_voidTrigger+0x86>
    3662:	7b c0       	rjmp	.+246    	; 0x375a <HAL_Ultrasonic_Sensor_voidTrigger+0x17c>
	{
		_delay_ms(__us / 1000.0);
    3664:	6d 89       	ldd	r22, Y+21	; 0x15
    3666:	7e 89       	ldd	r23, Y+22	; 0x16
    3668:	8f 89       	ldd	r24, Y+23	; 0x17
    366a:	98 8d       	ldd	r25, Y+24	; 0x18
    366c:	20 e0       	ldi	r18, 0x00	; 0
    366e:	30 e0       	ldi	r19, 0x00	; 0
    3670:	4a e7       	ldi	r20, 0x7A	; 122
    3672:	54 e4       	ldi	r21, 0x44	; 68
    3674:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    3678:	dc 01       	movw	r26, r24
    367a:	cb 01       	movw	r24, r22
    367c:	8c 87       	std	Y+12, r24	; 0x0c
    367e:	9d 87       	std	Y+13, r25	; 0x0d
    3680:	ae 87       	std	Y+14, r26	; 0x0e
    3682:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3684:	6c 85       	ldd	r22, Y+12	; 0x0c
    3686:	7d 85       	ldd	r23, Y+13	; 0x0d
    3688:	8e 85       	ldd	r24, Y+14	; 0x0e
    368a:	9f 85       	ldd	r25, Y+15	; 0x0f
    368c:	20 e0       	ldi	r18, 0x00	; 0
    368e:	30 e0       	ldi	r19, 0x00	; 0
    3690:	4a e7       	ldi	r20, 0x7A	; 122
    3692:	55 e4       	ldi	r21, 0x45	; 69
    3694:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3698:	dc 01       	movw	r26, r24
    369a:	cb 01       	movw	r24, r22
    369c:	88 87       	std	Y+8, r24	; 0x08
    369e:	99 87       	std	Y+9, r25	; 0x09
    36a0:	aa 87       	std	Y+10, r26	; 0x0a
    36a2:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    36a4:	68 85       	ldd	r22, Y+8	; 0x08
    36a6:	79 85       	ldd	r23, Y+9	; 0x09
    36a8:	8a 85       	ldd	r24, Y+10	; 0x0a
    36aa:	9b 85       	ldd	r25, Y+11	; 0x0b
    36ac:	20 e0       	ldi	r18, 0x00	; 0
    36ae:	30 e0       	ldi	r19, 0x00	; 0
    36b0:	40 e8       	ldi	r20, 0x80	; 128
    36b2:	5f e3       	ldi	r21, 0x3F	; 63
    36b4:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    36b8:	88 23       	and	r24, r24
    36ba:	2c f4       	brge	.+10     	; 0x36c6 <HAL_Ultrasonic_Sensor_voidTrigger+0xe8>
		__ticks = 1;
    36bc:	81 e0       	ldi	r24, 0x01	; 1
    36be:	90 e0       	ldi	r25, 0x00	; 0
    36c0:	9f 83       	std	Y+7, r25	; 0x07
    36c2:	8e 83       	std	Y+6, r24	; 0x06
    36c4:	3f c0       	rjmp	.+126    	; 0x3744 <HAL_Ultrasonic_Sensor_voidTrigger+0x166>
	else if (__tmp > 65535)
    36c6:	68 85       	ldd	r22, Y+8	; 0x08
    36c8:	79 85       	ldd	r23, Y+9	; 0x09
    36ca:	8a 85       	ldd	r24, Y+10	; 0x0a
    36cc:	9b 85       	ldd	r25, Y+11	; 0x0b
    36ce:	20 e0       	ldi	r18, 0x00	; 0
    36d0:	3f ef       	ldi	r19, 0xFF	; 255
    36d2:	4f e7       	ldi	r20, 0x7F	; 127
    36d4:	57 e4       	ldi	r21, 0x47	; 71
    36d6:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    36da:	18 16       	cp	r1, r24
    36dc:	4c f5       	brge	.+82     	; 0x3730 <HAL_Ultrasonic_Sensor_voidTrigger+0x152>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    36de:	6c 85       	ldd	r22, Y+12	; 0x0c
    36e0:	7d 85       	ldd	r23, Y+13	; 0x0d
    36e2:	8e 85       	ldd	r24, Y+14	; 0x0e
    36e4:	9f 85       	ldd	r25, Y+15	; 0x0f
    36e6:	20 e0       	ldi	r18, 0x00	; 0
    36e8:	30 e0       	ldi	r19, 0x00	; 0
    36ea:	40 e2       	ldi	r20, 0x20	; 32
    36ec:	51 e4       	ldi	r21, 0x41	; 65
    36ee:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    36f2:	dc 01       	movw	r26, r24
    36f4:	cb 01       	movw	r24, r22
    36f6:	bc 01       	movw	r22, r24
    36f8:	cd 01       	movw	r24, r26
    36fa:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    36fe:	dc 01       	movw	r26, r24
    3700:	cb 01       	movw	r24, r22
    3702:	9f 83       	std	Y+7, r25	; 0x07
    3704:	8e 83       	std	Y+6, r24	; 0x06
    3706:	0f c0       	rjmp	.+30     	; 0x3726 <HAL_Ultrasonic_Sensor_voidTrigger+0x148>
    3708:	80 e9       	ldi	r24, 0x90	; 144
    370a:	91 e0       	ldi	r25, 0x01	; 1
    370c:	9d 83       	std	Y+5, r25	; 0x05
    370e:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3710:	8c 81       	ldd	r24, Y+4	; 0x04
    3712:	9d 81       	ldd	r25, Y+5	; 0x05
    3714:	01 97       	sbiw	r24, 0x01	; 1
    3716:	f1 f7       	brne	.-4      	; 0x3714 <HAL_Ultrasonic_Sensor_voidTrigger+0x136>
    3718:	9d 83       	std	Y+5, r25	; 0x05
    371a:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    371c:	8e 81       	ldd	r24, Y+6	; 0x06
    371e:	9f 81       	ldd	r25, Y+7	; 0x07
    3720:	01 97       	sbiw	r24, 0x01	; 1
    3722:	9f 83       	std	Y+7, r25	; 0x07
    3724:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3726:	8e 81       	ldd	r24, Y+6	; 0x06
    3728:	9f 81       	ldd	r25, Y+7	; 0x07
    372a:	00 97       	sbiw	r24, 0x00	; 0
    372c:	69 f7       	brne	.-38     	; 0x3708 <HAL_Ultrasonic_Sensor_voidTrigger+0x12a>
    372e:	24 c0       	rjmp	.+72     	; 0x3778 <HAL_Ultrasonic_Sensor_voidTrigger+0x19a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3730:	68 85       	ldd	r22, Y+8	; 0x08
    3732:	79 85       	ldd	r23, Y+9	; 0x09
    3734:	8a 85       	ldd	r24, Y+10	; 0x0a
    3736:	9b 85       	ldd	r25, Y+11	; 0x0b
    3738:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    373c:	dc 01       	movw	r26, r24
    373e:	cb 01       	movw	r24, r22
    3740:	9f 83       	std	Y+7, r25	; 0x07
    3742:	8e 83       	std	Y+6, r24	; 0x06
    3744:	8e 81       	ldd	r24, Y+6	; 0x06
    3746:	9f 81       	ldd	r25, Y+7	; 0x07
    3748:	9b 83       	std	Y+3, r25	; 0x03
    374a:	8a 83       	std	Y+2, r24	; 0x02
    374c:	8a 81       	ldd	r24, Y+2	; 0x02
    374e:	9b 81       	ldd	r25, Y+3	; 0x03
    3750:	01 97       	sbiw	r24, 0x01	; 1
    3752:	f1 f7       	brne	.-4      	; 0x3750 <HAL_Ultrasonic_Sensor_voidTrigger+0x172>
    3754:	9b 83       	std	Y+3, r25	; 0x03
    3756:	8a 83       	std	Y+2, r24	; 0x02
    3758:	0f c0       	rjmp	.+30     	; 0x3778 <HAL_Ultrasonic_Sensor_voidTrigger+0x19a>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    375a:	69 89       	ldd	r22, Y+17	; 0x11
    375c:	7a 89       	ldd	r23, Y+18	; 0x12
    375e:	8b 89       	ldd	r24, Y+19	; 0x13
    3760:	9c 89       	ldd	r25, Y+20	; 0x14
    3762:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3766:	dc 01       	movw	r26, r24
    3768:	cb 01       	movw	r24, r22
    376a:	88 8b       	std	Y+16, r24	; 0x10
    376c:	88 89       	ldd	r24, Y+16	; 0x10
    376e:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3770:	89 81       	ldd	r24, Y+1	; 0x01
    3772:	8a 95       	dec	r24
    3774:	f1 f7       	brne	.-4      	; 0x3772 <HAL_Ultrasonic_Sensor_voidTrigger+0x194>
    3776:	89 83       	std	Y+1, r24	; 0x01
	_delay_us(10);                                            // 10 micro seconds delay
	MCAL_DIO_u8SetPinValue(TRIG_PORT, TRIG_PIN, Pin_Low);     // low
    3778:	83 e0       	ldi	r24, 0x03	; 3
    377a:	66 e0       	ldi	r22, 0x06	; 6
    377c:	40 e0       	ldi	r20, 0x00	; 0
    377e:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <MCAL_DIO_u8SetPinValue>
}
    3782:	68 96       	adiw	r28, 0x18	; 24
    3784:	0f b6       	in	r0, 0x3f	; 63
    3786:	f8 94       	cli
    3788:	de bf       	out	0x3e, r29	; 62
    378a:	0f be       	out	0x3f, r0	; 63
    378c:	cd bf       	out	0x3d, r28	; 61
    378e:	cf 91       	pop	r28
    3790:	df 91       	pop	r29
    3792:	08 95       	ret

00003794 <HAL_Ultrasonic_Sensor_voidCalcDistancse>:

void HAL_Ultrasonic_Sensor_voidCalcDistancse(f32* returned_distance) {
    3794:	df 93       	push	r29
    3796:	cf 93       	push	r28
    3798:	cd b7       	in	r28, 0x3d	; 61
    379a:	de b7       	in	r29, 0x3e	; 62
    379c:	60 97       	sbiw	r28, 0x10	; 16
    379e:	0f b6       	in	r0, 0x3f	; 63
    37a0:	f8 94       	cli
    37a2:	de bf       	out	0x3e, r29	; 62
    37a4:	0f be       	out	0x3f, r0	; 63
    37a6:	cd bf       	out	0x3d, r28	; 61
    37a8:	98 8b       	std	Y+16, r25	; 0x10
    37aa:	8f 87       	std	Y+15, r24	; 0x0f
	HAL_Ultrasonic_Sensor_voidTrigger();                                  // send trigger
    37ac:	0e 94 ef 1a 	call	0x35de	; 0x35de <HAL_Ultrasonic_Sensor_voidTrigger>
	MCAL_Interrupt_InterruptRisingInit();
    37b0:	0e 94 b4 15 	call	0x2b68	; 0x2b68 <MCAL_Interrupt_InterruptRisingInit>
    37b4:	80 e0       	ldi	r24, 0x00	; 0
    37b6:	90 e0       	ldi	r25, 0x00	; 0
    37b8:	a8 e4       	ldi	r26, 0x48	; 72
    37ba:	b2 e4       	ldi	r27, 0x42	; 66
    37bc:	8b 87       	std	Y+11, r24	; 0x0b
    37be:	9c 87       	std	Y+12, r25	; 0x0c
    37c0:	ad 87       	std	Y+13, r26	; 0x0d
    37c2:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    37c4:	6b 85       	ldd	r22, Y+11	; 0x0b
    37c6:	7c 85       	ldd	r23, Y+12	; 0x0c
    37c8:	8d 85       	ldd	r24, Y+13	; 0x0d
    37ca:	9e 85       	ldd	r25, Y+14	; 0x0e
    37cc:	20 e0       	ldi	r18, 0x00	; 0
    37ce:	30 e0       	ldi	r19, 0x00	; 0
    37d0:	4a e7       	ldi	r20, 0x7A	; 122
    37d2:	55 e4       	ldi	r21, 0x45	; 69
    37d4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    37d8:	dc 01       	movw	r26, r24
    37da:	cb 01       	movw	r24, r22
    37dc:	8f 83       	std	Y+7, r24	; 0x07
    37de:	98 87       	std	Y+8, r25	; 0x08
    37e0:	a9 87       	std	Y+9, r26	; 0x09
    37e2:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    37e4:	6f 81       	ldd	r22, Y+7	; 0x07
    37e6:	78 85       	ldd	r23, Y+8	; 0x08
    37e8:	89 85       	ldd	r24, Y+9	; 0x09
    37ea:	9a 85       	ldd	r25, Y+10	; 0x0a
    37ec:	20 e0       	ldi	r18, 0x00	; 0
    37ee:	30 e0       	ldi	r19, 0x00	; 0
    37f0:	40 e8       	ldi	r20, 0x80	; 128
    37f2:	5f e3       	ldi	r21, 0x3F	; 63
    37f4:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    37f8:	88 23       	and	r24, r24
    37fa:	2c f4       	brge	.+10     	; 0x3806 <HAL_Ultrasonic_Sensor_voidCalcDistancse+0x72>
		__ticks = 1;
    37fc:	81 e0       	ldi	r24, 0x01	; 1
    37fe:	90 e0       	ldi	r25, 0x00	; 0
    3800:	9e 83       	std	Y+6, r25	; 0x06
    3802:	8d 83       	std	Y+5, r24	; 0x05
    3804:	3f c0       	rjmp	.+126    	; 0x3884 <HAL_Ultrasonic_Sensor_voidCalcDistancse+0xf0>
	else if (__tmp > 65535)
    3806:	6f 81       	ldd	r22, Y+7	; 0x07
    3808:	78 85       	ldd	r23, Y+8	; 0x08
    380a:	89 85       	ldd	r24, Y+9	; 0x09
    380c:	9a 85       	ldd	r25, Y+10	; 0x0a
    380e:	20 e0       	ldi	r18, 0x00	; 0
    3810:	3f ef       	ldi	r19, 0xFF	; 255
    3812:	4f e7       	ldi	r20, 0x7F	; 127
    3814:	57 e4       	ldi	r21, 0x47	; 71
    3816:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    381a:	18 16       	cp	r1, r24
    381c:	4c f5       	brge	.+82     	; 0x3870 <HAL_Ultrasonic_Sensor_voidCalcDistancse+0xdc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    381e:	6b 85       	ldd	r22, Y+11	; 0x0b
    3820:	7c 85       	ldd	r23, Y+12	; 0x0c
    3822:	8d 85       	ldd	r24, Y+13	; 0x0d
    3824:	9e 85       	ldd	r25, Y+14	; 0x0e
    3826:	20 e0       	ldi	r18, 0x00	; 0
    3828:	30 e0       	ldi	r19, 0x00	; 0
    382a:	40 e2       	ldi	r20, 0x20	; 32
    382c:	51 e4       	ldi	r21, 0x41	; 65
    382e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3832:	dc 01       	movw	r26, r24
    3834:	cb 01       	movw	r24, r22
    3836:	bc 01       	movw	r22, r24
    3838:	cd 01       	movw	r24, r26
    383a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    383e:	dc 01       	movw	r26, r24
    3840:	cb 01       	movw	r24, r22
    3842:	9e 83       	std	Y+6, r25	; 0x06
    3844:	8d 83       	std	Y+5, r24	; 0x05
    3846:	0f c0       	rjmp	.+30     	; 0x3866 <HAL_Ultrasonic_Sensor_voidCalcDistancse+0xd2>
    3848:	80 e9       	ldi	r24, 0x90	; 144
    384a:	91 e0       	ldi	r25, 0x01	; 1
    384c:	9c 83       	std	Y+4, r25	; 0x04
    384e:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3850:	8b 81       	ldd	r24, Y+3	; 0x03
    3852:	9c 81       	ldd	r25, Y+4	; 0x04
    3854:	01 97       	sbiw	r24, 0x01	; 1
    3856:	f1 f7       	brne	.-4      	; 0x3854 <HAL_Ultrasonic_Sensor_voidCalcDistancse+0xc0>
    3858:	9c 83       	std	Y+4, r25	; 0x04
    385a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    385c:	8d 81       	ldd	r24, Y+5	; 0x05
    385e:	9e 81       	ldd	r25, Y+6	; 0x06
    3860:	01 97       	sbiw	r24, 0x01	; 1
    3862:	9e 83       	std	Y+6, r25	; 0x06
    3864:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3866:	8d 81       	ldd	r24, Y+5	; 0x05
    3868:	9e 81       	ldd	r25, Y+6	; 0x06
    386a:	00 97       	sbiw	r24, 0x00	; 0
    386c:	69 f7       	brne	.-38     	; 0x3848 <HAL_Ultrasonic_Sensor_voidCalcDistancse+0xb4>
    386e:	14 c0       	rjmp	.+40     	; 0x3898 <HAL_Ultrasonic_Sensor_voidCalcDistancse+0x104>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3870:	6f 81       	ldd	r22, Y+7	; 0x07
    3872:	78 85       	ldd	r23, Y+8	; 0x08
    3874:	89 85       	ldd	r24, Y+9	; 0x09
    3876:	9a 85       	ldd	r25, Y+10	; 0x0a
    3878:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    387c:	dc 01       	movw	r26, r24
    387e:	cb 01       	movw	r24, r22
    3880:	9e 83       	std	Y+6, r25	; 0x06
    3882:	8d 83       	std	Y+5, r24	; 0x05
    3884:	8d 81       	ldd	r24, Y+5	; 0x05
    3886:	9e 81       	ldd	r25, Y+6	; 0x06
    3888:	9a 83       	std	Y+2, r25	; 0x02
    388a:	89 83       	std	Y+1, r24	; 0x01
    388c:	89 81       	ldd	r24, Y+1	; 0x01
    388e:	9a 81       	ldd	r25, Y+2	; 0x02
    3890:	01 97       	sbiw	r24, 0x01	; 1
    3892:	f1 f7       	brne	.-4      	; 0x3890 <HAL_Ultrasonic_Sensor_voidCalcDistancse+0xfc>
    3894:	9a 83       	std	Y+2, r25	; 0x02
    3896:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(50);                                            // stability delay
	*returned_distance = Glob_f32Distance*2;                           // get the distance
    3898:	20 91 94 01 	lds	r18, 0x0194
    389c:	30 91 95 01 	lds	r19, 0x0195
    38a0:	40 91 96 01 	lds	r20, 0x0196
    38a4:	50 91 97 01 	lds	r21, 0x0197
    38a8:	ca 01       	movw	r24, r20
    38aa:	b9 01       	movw	r22, r18
    38ac:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <__addsf3>
    38b0:	dc 01       	movw	r26, r24
    38b2:	cb 01       	movw	r24, r22
    38b4:	ef 85       	ldd	r30, Y+15	; 0x0f
    38b6:	f8 89       	ldd	r31, Y+16	; 0x10
    38b8:	80 83       	st	Z, r24
    38ba:	91 83       	std	Z+1, r25	; 0x01
    38bc:	a2 83       	std	Z+2, r26	; 0x02
    38be:	b3 83       	std	Z+3, r27	; 0x03
}
    38c0:	60 96       	adiw	r28, 0x10	; 16
    38c2:	0f b6       	in	r0, 0x3f	; 63
    38c4:	f8 94       	cli
    38c6:	de bf       	out	0x3e, r29	; 62
    38c8:	0f be       	out	0x3f, r0	; 63
    38ca:	cd bf       	out	0x3d, r28	; 61
    38cc:	cf 91       	pop	r28
    38ce:	df 91       	pop	r29
    38d0:	08 95       	ret

000038d2 <HAL_Ultrasonic_Sensor_voidInterrupt>:
void HAL_Ultrasonic_Sensor_voidInterrupt(void)                                     // call back function
{
    38d2:	df 93       	push	r29
    38d4:	cf 93       	push	r28
    38d6:	cd b7       	in	r28, 0x3d	; 61
    38d8:	de b7       	in	r29, 0x3e	; 62

	if (Glob_u8Counter <= 2)          // check for counter status
    38da:	80 91 6d 01 	lds	r24, 0x016D
    38de:	83 30       	cpi	r24, 0x03	; 3
    38e0:	08 f0       	brcs	.+2      	; 0x38e4 <HAL_Ultrasonic_Sensor_voidInterrupt+0x12>
    38e2:	75 c0       	rjmp	.+234    	; 0x39ce <HAL_Ultrasonic_Sensor_voidInterrupt+0xfc>
			{
		if (Glob_u8Counter == NUM1)      // check if it is the first entry
    38e4:	80 91 6d 01 	lds	r24, 0x016D
    38e8:	81 30       	cpi	r24, 0x01	; 1
    38ea:	a1 f4       	brne	.+40     	; 0x3914 <HAL_Ultrasonic_Sensor_voidInterrupt+0x42>
		{
			// store the start time value
			Glob_u16StartTime = TCNT0;
    38ec:	e2 e5       	ldi	r30, 0x52	; 82
    38ee:	f0 e0       	ldi	r31, 0x00	; 0
    38f0:	80 81       	ld	r24, Z
    38f2:	88 2f       	mov	r24, r24
    38f4:	90 e0       	ldi	r25, 0x00	; 0
    38f6:	90 93 99 01 	sts	0x0199, r25
    38fa:	80 93 98 01 	sts	0x0198, r24

			// store number of OVFs at the start of the signal
			Glob_u16OvfCounterStart = Glob_u16OvfCounter;
    38fe:	80 91 86 01 	lds	r24, 0x0186
    3902:	90 91 87 01 	lds	r25, 0x0187
    3906:	90 93 41 06 	sts	0x0641, r25
    390a:	80 93 40 06 	sts	0x0640, r24

			// at the first entry  we change the capture edge to falling edge to capture echo signal
			MCAL_Interrupt_InterruptFallingInit();
    390e:	0e 94 ca 15 	call	0x2b94	; 0x2b94 <MCAL_Interrupt_InterruptFallingInit>
    3912:	58 c0       	rjmp	.+176    	; 0x39c4 <HAL_Ultrasonic_Sensor_voidInterrupt+0xf2>
		}

		else if (Glob_u8Counter == 2) // check if it's the second entry
    3914:	80 91 6d 01 	lds	r24, 0x016D
    3918:	82 30       	cpi	r24, 0x02	; 2
    391a:	09 f0       	breq	.+2      	; 0x391e <HAL_Ultrasonic_Sensor_voidInterrupt+0x4c>
    391c:	53 c0       	rjmp	.+166    	; 0x39c4 <HAL_Ultrasonic_Sensor_voidInterrupt+0xf2>
				{
			//store end time value
			Glob_u16EndTime = TCNT0;
    391e:	e2 e5       	ldi	r30, 0x52	; 82
    3920:	f0 e0       	ldi	r31, 0x00	; 0
    3922:	80 81       	ld	r24, Z
    3924:	88 2f       	mov	r24, r24
    3926:	90 e0       	ldi	r25, 0x00	; 0
    3928:	90 93 9b 01 	sts	0x019B, r25
    392c:	80 93 9a 01 	sts	0x019A, r24

			//store number of OVFs at the end of signal
			Glob_16OvfCounterEnd = Glob_u16OvfCounter;
    3930:	80 91 86 01 	lds	r24, 0x0186
    3934:	90 91 87 01 	lds	r25, 0x0187
    3938:	90 93 3f 06 	sts	0x063F, r25
    393c:	80 93 3e 06 	sts	0x063E, r24

			//calculate the time difference between start and end
			Glob_u16TimeDiff = (Glob_u16EndTime + (256 * Glob_16OvfCounterEnd))
    3940:	80 91 3e 06 	lds	r24, 0x063E
    3944:	90 91 3f 06 	lds	r25, 0x063F
    3948:	38 2f       	mov	r19, r24
    394a:	22 27       	eor	r18, r18
    394c:	80 91 9a 01 	lds	r24, 0x019A
    3950:	90 91 9b 01 	lds	r25, 0x019B
    3954:	a9 01       	movw	r20, r18
    3956:	48 0f       	add	r20, r24
    3958:	59 1f       	adc	r21, r25
    395a:	80 91 40 06 	lds	r24, 0x0640
    395e:	90 91 41 06 	lds	r25, 0x0641
    3962:	38 2f       	mov	r19, r24
    3964:	22 27       	eor	r18, r18
    3966:	80 91 98 01 	lds	r24, 0x0198
    396a:	90 91 99 01 	lds	r25, 0x0199
    396e:	82 0f       	add	r24, r18
    3970:	93 1f       	adc	r25, r19
    3972:	9a 01       	movw	r18, r20
    3974:	28 1b       	sub	r18, r24
    3976:	39 0b       	sbc	r19, r25
    3978:	c9 01       	movw	r24, r18
    397a:	90 93 9d 01 	sts	0x019D, r25
    397e:	80 93 9c 01 	sts	0x019C, r24
					- (Glob_u16StartTime + (256 * Glob_u16OvfCounterStart));

			//calculate the distance
			Glob_f32Distance = Glob_u16TimeDiff * 0.068; //     f32 ton=(h(64/16000000))/2 >>     distance=ton34000;
    3982:	80 91 9c 01 	lds	r24, 0x019C
    3986:	90 91 9d 01 	lds	r25, 0x019D
    398a:	cc 01       	movw	r24, r24
    398c:	a0 e0       	ldi	r26, 0x00	; 0
    398e:	b0 e0       	ldi	r27, 0x00	; 0
    3990:	bc 01       	movw	r22, r24
    3992:	cd 01       	movw	r24, r26
    3994:	0e 94 37 05 	call	0xa6e	; 0xa6e <__floatunsisf>
    3998:	dc 01       	movw	r26, r24
    399a:	cb 01       	movw	r24, r22
    399c:	bc 01       	movw	r22, r24
    399e:	cd 01       	movw	r24, r26
    39a0:	26 e9       	ldi	r18, 0x96	; 150
    39a2:	33 e4       	ldi	r19, 0x43	; 67
    39a4:	4b e8       	ldi	r20, 0x8B	; 139
    39a6:	5d e3       	ldi	r21, 0x3D	; 61
    39a8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    39ac:	dc 01       	movw	r26, r24
    39ae:	cb 01       	movw	r24, r22
    39b0:	80 93 94 01 	sts	0x0194, r24
    39b4:	90 93 95 01 	sts	0x0195, r25
    39b8:	a0 93 96 01 	sts	0x0196, r26
    39bc:	b0 93 97 01 	sts	0x0197, r27

			//reset the counter to calculate new signal
			Glob_u8Counter = NUM0;
    39c0:	10 92 6d 01 	sts	0x016D, r1

		}

		//increase the counter to sync with the entry state
		Glob_u8Counter++;
    39c4:	80 91 6d 01 	lds	r24, 0x016D
    39c8:	8f 5f       	subi	r24, 0xFF	; 255
    39ca:	80 93 6d 01 	sts	0x016D, r24
	}

}
    39ce:	cf 91       	pop	r28
    39d0:	df 91       	pop	r29
    39d2:	08 95       	ret

000039d4 <HAL_SM_voidSMInit>:
 *
 *  Created on: Oct 29, 2023
 *      Author: TOP_WORLD
 */
#include "Servo_Motor.h"
void HAL_SM_voidSMInit(void) {
    39d4:	df 93       	push	r29
    39d6:	cf 93       	push	r28
    39d8:	cd b7       	in	r28, 0x3d	; 61
    39da:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(DDRD,Pin7);
    39dc:	a1 e3       	ldi	r26, 0x31	; 49
    39de:	b0 e0       	ldi	r27, 0x00	; 0
    39e0:	e1 e3       	ldi	r30, 0x31	; 49
    39e2:	f0 e0       	ldi	r31, 0x00	; 0
    39e4:	80 81       	ld	r24, Z
    39e6:	80 68       	ori	r24, 0x80	; 128
    39e8:	8c 93       	st	X, r24
}
    39ea:	cf 91       	pop	r28
    39ec:	df 91       	pop	r29
    39ee:	08 95       	ret

000039f0 <HAL_SM_voidSMSetAngle>:
void HAL_SM_voidSMSetAngle(u8 LOC_u8Angle) {
    39f0:	df 93       	push	r29
    39f2:	cf 93       	push	r28
    39f4:	cd b7       	in	r28, 0x3d	; 61
    39f6:	de b7       	in	r29, 0x3e	; 62
    39f8:	e5 97       	sbiw	r28, 0x35	; 53
    39fa:	0f b6       	in	r0, 0x3f	; 63
    39fc:	f8 94       	cli
    39fe:	de bf       	out	0x3e, r29	; 62
    3a00:	0f be       	out	0x3f, r0	; 63
    3a02:	cd bf       	out	0x3d, r28	; 61
    3a04:	8d ab       	std	Y+53, r24	; 0x35
	u16 LOC_u16Time=(32.0/3)*(LOC_u8Angle-90)+1100;
    3a06:	8d a9       	ldd	r24, Y+53	; 0x35
    3a08:	88 2f       	mov	r24, r24
    3a0a:	90 e0       	ldi	r25, 0x00	; 0
    3a0c:	8a 55       	subi	r24, 0x5A	; 90
    3a0e:	90 40       	sbci	r25, 0x00	; 0
    3a10:	aa 27       	eor	r26, r26
    3a12:	97 fd       	sbrc	r25, 7
    3a14:	a0 95       	com	r26
    3a16:	ba 2f       	mov	r27, r26
    3a18:	bc 01       	movw	r22, r24
    3a1a:	cd 01       	movw	r24, r26
    3a1c:	0e 94 85 04 	call	0x90a	; 0x90a <__floatsisf>
    3a20:	dc 01       	movw	r26, r24
    3a22:	cb 01       	movw	r24, r22
    3a24:	bc 01       	movw	r22, r24
    3a26:	cd 01       	movw	r24, r26
    3a28:	2b ea       	ldi	r18, 0xAB	; 171
    3a2a:	3a ea       	ldi	r19, 0xAA	; 170
    3a2c:	4a e2       	ldi	r20, 0x2A	; 42
    3a2e:	51 e4       	ldi	r21, 0x41	; 65
    3a30:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3a34:	dc 01       	movw	r26, r24
    3a36:	cb 01       	movw	r24, r22
    3a38:	bc 01       	movw	r22, r24
    3a3a:	cd 01       	movw	r24, r26
    3a3c:	20 e0       	ldi	r18, 0x00	; 0
    3a3e:	30 e8       	ldi	r19, 0x80	; 128
    3a40:	49 e8       	ldi	r20, 0x89	; 137
    3a42:	54 e4       	ldi	r21, 0x44	; 68
    3a44:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <__addsf3>
    3a48:	dc 01       	movw	r26, r24
    3a4a:	cb 01       	movw	r24, r22
    3a4c:	bc 01       	movw	r22, r24
    3a4e:	cd 01       	movw	r24, r26
    3a50:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3a54:	dc 01       	movw	r26, r24
    3a56:	cb 01       	movw	r24, r22
    3a58:	9c ab       	std	Y+52, r25	; 0x34
    3a5a:	8b ab       	std	Y+51, r24	; 0x33
	u16 LOC_u16OffTime=(20000-LOC_u16Time);
    3a5c:	20 e2       	ldi	r18, 0x20	; 32
    3a5e:	3e e4       	ldi	r19, 0x4E	; 78
    3a60:	8b a9       	ldd	r24, Y+51	; 0x33
    3a62:	9c a9       	ldd	r25, Y+52	; 0x34
    3a64:	a9 01       	movw	r20, r18
    3a66:	48 1b       	sub	r20, r24
    3a68:	59 0b       	sbc	r21, r25
    3a6a:	ca 01       	movw	r24, r20
    3a6c:	9a ab       	std	Y+50, r25	; 0x32
    3a6e:	89 ab       	std	Y+49, r24	; 0x31
	if (LOC_u8Angle <= MAX_ANGLE && LOC_u8Angle >= MIN_ANGLE) {
    3a70:	8d a9       	ldd	r24, Y+53	; 0x35
    3a72:	88 2f       	mov	r24, r24
    3a74:	90 e0       	ldi	r25, 0x00	; 0
    3a76:	aa 27       	eor	r26, r26
    3a78:	97 fd       	sbrc	r25, 7
    3a7a:	a0 95       	com	r26
    3a7c:	ba 2f       	mov	r27, r26
    3a7e:	bc 01       	movw	r22, r24
    3a80:	cd 01       	movw	r24, r26
    3a82:	0e 94 85 04 	call	0x90a	; 0x90a <__floatsisf>
    3a86:	dc 01       	movw	r26, r24
    3a88:	cb 01       	movw	r24, r22
    3a8a:	bc 01       	movw	r22, r24
    3a8c:	cd 01       	movw	r24, r26
    3a8e:	20 e0       	ldi	r18, 0x00	; 0
    3a90:	30 e0       	ldi	r19, 0x00	; 0
    3a92:	44 e3       	ldi	r20, 0x34	; 52
    3a94:	53 e4       	ldi	r21, 0x43	; 67
    3a96:	0e 94 55 04 	call	0x8aa	; 0x8aa <__lesf2>
    3a9a:	18 16       	cp	r1, r24
    3a9c:	0c f4       	brge	.+2      	; 0x3aa0 <HAL_SM_voidSMSetAngle+0xb0>
    3a9e:	98 c1       	rjmp	.+816    	; 0x3dd0 <HAL_SM_voidSMSetAngle+0x3e0>
		SET_BIT(PORTD,Pin7);
    3aa0:	a2 e3       	ldi	r26, 0x32	; 50
    3aa2:	b0 e0       	ldi	r27, 0x00	; 0
    3aa4:	e2 e3       	ldi	r30, 0x32	; 50
    3aa6:	f0 e0       	ldi	r31, 0x00	; 0
    3aa8:	80 81       	ld	r24, Z
    3aaa:	80 68       	ori	r24, 0x80	; 128
    3aac:	8c 93       	st	X, r24
		_delay_us(LOC_u16Time);
    3aae:	8b a9       	ldd	r24, Y+51	; 0x33
    3ab0:	9c a9       	ldd	r25, Y+52	; 0x34
    3ab2:	cc 01       	movw	r24, r24
    3ab4:	a0 e0       	ldi	r26, 0x00	; 0
    3ab6:	b0 e0       	ldi	r27, 0x00	; 0
    3ab8:	bc 01       	movw	r22, r24
    3aba:	cd 01       	movw	r24, r26
    3abc:	0e 94 37 05 	call	0xa6e	; 0xa6e <__floatunsisf>
    3ac0:	dc 01       	movw	r26, r24
    3ac2:	cb 01       	movw	r24, r22
    3ac4:	8d a7       	std	Y+45, r24	; 0x2d
    3ac6:	9e a7       	std	Y+46, r25	; 0x2e
    3ac8:	af a7       	std	Y+47, r26	; 0x2f
    3aca:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    3acc:	6d a5       	ldd	r22, Y+45	; 0x2d
    3ace:	7e a5       	ldd	r23, Y+46	; 0x2e
    3ad0:	8f a5       	ldd	r24, Y+47	; 0x2f
    3ad2:	98 a9       	ldd	r25, Y+48	; 0x30
    3ad4:	2b ea       	ldi	r18, 0xAB	; 171
    3ad6:	3a ea       	ldi	r19, 0xAA	; 170
    3ad8:	4a ea       	ldi	r20, 0xAA	; 170
    3ada:	50 e4       	ldi	r21, 0x40	; 64
    3adc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3ae0:	dc 01       	movw	r26, r24
    3ae2:	cb 01       	movw	r24, r22
    3ae4:	89 a7       	std	Y+41, r24	; 0x29
    3ae6:	9a a7       	std	Y+42, r25	; 0x2a
    3ae8:	ab a7       	std	Y+43, r26	; 0x2b
    3aea:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    3aec:	69 a5       	ldd	r22, Y+41	; 0x29
    3aee:	7a a5       	ldd	r23, Y+42	; 0x2a
    3af0:	8b a5       	ldd	r24, Y+43	; 0x2b
    3af2:	9c a5       	ldd	r25, Y+44	; 0x2c
    3af4:	20 e0       	ldi	r18, 0x00	; 0
    3af6:	30 e0       	ldi	r19, 0x00	; 0
    3af8:	40 e8       	ldi	r20, 0x80	; 128
    3afa:	5f e3       	ldi	r21, 0x3F	; 63
    3afc:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3b00:	88 23       	and	r24, r24
    3b02:	1c f4       	brge	.+6      	; 0x3b0a <HAL_SM_voidSMSetAngle+0x11a>
		__ticks = 1;
    3b04:	81 e0       	ldi	r24, 0x01	; 1
    3b06:	88 a7       	std	Y+40, r24	; 0x28
    3b08:	91 c0       	rjmp	.+290    	; 0x3c2c <HAL_SM_voidSMSetAngle+0x23c>
	else if (__tmp > 255)
    3b0a:	69 a5       	ldd	r22, Y+41	; 0x29
    3b0c:	7a a5       	ldd	r23, Y+42	; 0x2a
    3b0e:	8b a5       	ldd	r24, Y+43	; 0x2b
    3b10:	9c a5       	ldd	r25, Y+44	; 0x2c
    3b12:	20 e0       	ldi	r18, 0x00	; 0
    3b14:	30 e0       	ldi	r19, 0x00	; 0
    3b16:	4f e7       	ldi	r20, 0x7F	; 127
    3b18:	53 e4       	ldi	r21, 0x43	; 67
    3b1a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3b1e:	18 16       	cp	r1, r24
    3b20:	0c f0       	brlt	.+2      	; 0x3b24 <HAL_SM_voidSMSetAngle+0x134>
    3b22:	7b c0       	rjmp	.+246    	; 0x3c1a <HAL_SM_voidSMSetAngle+0x22a>
	{
		_delay_ms(__us / 1000.0);
    3b24:	6d a5       	ldd	r22, Y+45	; 0x2d
    3b26:	7e a5       	ldd	r23, Y+46	; 0x2e
    3b28:	8f a5       	ldd	r24, Y+47	; 0x2f
    3b2a:	98 a9       	ldd	r25, Y+48	; 0x30
    3b2c:	20 e0       	ldi	r18, 0x00	; 0
    3b2e:	30 e0       	ldi	r19, 0x00	; 0
    3b30:	4a e7       	ldi	r20, 0x7A	; 122
    3b32:	54 e4       	ldi	r21, 0x44	; 68
    3b34:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    3b38:	dc 01       	movw	r26, r24
    3b3a:	cb 01       	movw	r24, r22
    3b3c:	8c a3       	std	Y+36, r24	; 0x24
    3b3e:	9d a3       	std	Y+37, r25	; 0x25
    3b40:	ae a3       	std	Y+38, r26	; 0x26
    3b42:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3b44:	6c a1       	ldd	r22, Y+36	; 0x24
    3b46:	7d a1       	ldd	r23, Y+37	; 0x25
    3b48:	8e a1       	ldd	r24, Y+38	; 0x26
    3b4a:	9f a1       	ldd	r25, Y+39	; 0x27
    3b4c:	20 e0       	ldi	r18, 0x00	; 0
    3b4e:	30 e0       	ldi	r19, 0x00	; 0
    3b50:	4a e7       	ldi	r20, 0x7A	; 122
    3b52:	55 e4       	ldi	r21, 0x45	; 69
    3b54:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3b58:	dc 01       	movw	r26, r24
    3b5a:	cb 01       	movw	r24, r22
    3b5c:	88 a3       	std	Y+32, r24	; 0x20
    3b5e:	99 a3       	std	Y+33, r25	; 0x21
    3b60:	aa a3       	std	Y+34, r26	; 0x22
    3b62:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    3b64:	68 a1       	ldd	r22, Y+32	; 0x20
    3b66:	79 a1       	ldd	r23, Y+33	; 0x21
    3b68:	8a a1       	ldd	r24, Y+34	; 0x22
    3b6a:	9b a1       	ldd	r25, Y+35	; 0x23
    3b6c:	20 e0       	ldi	r18, 0x00	; 0
    3b6e:	30 e0       	ldi	r19, 0x00	; 0
    3b70:	40 e8       	ldi	r20, 0x80	; 128
    3b72:	5f e3       	ldi	r21, 0x3F	; 63
    3b74:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3b78:	88 23       	and	r24, r24
    3b7a:	2c f4       	brge	.+10     	; 0x3b86 <HAL_SM_voidSMSetAngle+0x196>
		__ticks = 1;
    3b7c:	81 e0       	ldi	r24, 0x01	; 1
    3b7e:	90 e0       	ldi	r25, 0x00	; 0
    3b80:	9f 8f       	std	Y+31, r25	; 0x1f
    3b82:	8e 8f       	std	Y+30, r24	; 0x1e
    3b84:	3f c0       	rjmp	.+126    	; 0x3c04 <HAL_SM_voidSMSetAngle+0x214>
	else if (__tmp > 65535)
    3b86:	68 a1       	ldd	r22, Y+32	; 0x20
    3b88:	79 a1       	ldd	r23, Y+33	; 0x21
    3b8a:	8a a1       	ldd	r24, Y+34	; 0x22
    3b8c:	9b a1       	ldd	r25, Y+35	; 0x23
    3b8e:	20 e0       	ldi	r18, 0x00	; 0
    3b90:	3f ef       	ldi	r19, 0xFF	; 255
    3b92:	4f e7       	ldi	r20, 0x7F	; 127
    3b94:	57 e4       	ldi	r21, 0x47	; 71
    3b96:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3b9a:	18 16       	cp	r1, r24
    3b9c:	4c f5       	brge	.+82     	; 0x3bf0 <HAL_SM_voidSMSetAngle+0x200>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3b9e:	6c a1       	ldd	r22, Y+36	; 0x24
    3ba0:	7d a1       	ldd	r23, Y+37	; 0x25
    3ba2:	8e a1       	ldd	r24, Y+38	; 0x26
    3ba4:	9f a1       	ldd	r25, Y+39	; 0x27
    3ba6:	20 e0       	ldi	r18, 0x00	; 0
    3ba8:	30 e0       	ldi	r19, 0x00	; 0
    3baa:	40 e2       	ldi	r20, 0x20	; 32
    3bac:	51 e4       	ldi	r21, 0x41	; 65
    3bae:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3bb2:	dc 01       	movw	r26, r24
    3bb4:	cb 01       	movw	r24, r22
    3bb6:	bc 01       	movw	r22, r24
    3bb8:	cd 01       	movw	r24, r26
    3bba:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3bbe:	dc 01       	movw	r26, r24
    3bc0:	cb 01       	movw	r24, r22
    3bc2:	9f 8f       	std	Y+31, r25	; 0x1f
    3bc4:	8e 8f       	std	Y+30, r24	; 0x1e
    3bc6:	0f c0       	rjmp	.+30     	; 0x3be6 <HAL_SM_voidSMSetAngle+0x1f6>
    3bc8:	80 e9       	ldi	r24, 0x90	; 144
    3bca:	91 e0       	ldi	r25, 0x01	; 1
    3bcc:	9d 8f       	std	Y+29, r25	; 0x1d
    3bce:	8c 8f       	std	Y+28, r24	; 0x1c
    3bd0:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3bd2:	9d 8d       	ldd	r25, Y+29	; 0x1d
    3bd4:	01 97       	sbiw	r24, 0x01	; 1
    3bd6:	f1 f7       	brne	.-4      	; 0x3bd4 <HAL_SM_voidSMSetAngle+0x1e4>
    3bd8:	9d 8f       	std	Y+29, r25	; 0x1d
    3bda:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3bdc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3bde:	9f 8d       	ldd	r25, Y+31	; 0x1f
    3be0:	01 97       	sbiw	r24, 0x01	; 1
    3be2:	9f 8f       	std	Y+31, r25	; 0x1f
    3be4:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3be6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3be8:	9f 8d       	ldd	r25, Y+31	; 0x1f
    3bea:	00 97       	sbiw	r24, 0x00	; 0
    3bec:	69 f7       	brne	.-38     	; 0x3bc8 <HAL_SM_voidSMSetAngle+0x1d8>
    3bee:	24 c0       	rjmp	.+72     	; 0x3c38 <HAL_SM_voidSMSetAngle+0x248>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3bf0:	68 a1       	ldd	r22, Y+32	; 0x20
    3bf2:	79 a1       	ldd	r23, Y+33	; 0x21
    3bf4:	8a a1       	ldd	r24, Y+34	; 0x22
    3bf6:	9b a1       	ldd	r25, Y+35	; 0x23
    3bf8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3bfc:	dc 01       	movw	r26, r24
    3bfe:	cb 01       	movw	r24, r22
    3c00:	9f 8f       	std	Y+31, r25	; 0x1f
    3c02:	8e 8f       	std	Y+30, r24	; 0x1e
    3c04:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3c06:	9f 8d       	ldd	r25, Y+31	; 0x1f
    3c08:	9b 8f       	std	Y+27, r25	; 0x1b
    3c0a:	8a 8f       	std	Y+26, r24	; 0x1a
    3c0c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3c0e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3c10:	01 97       	sbiw	r24, 0x01	; 1
    3c12:	f1 f7       	brne	.-4      	; 0x3c10 <HAL_SM_voidSMSetAngle+0x220>
    3c14:	9b 8f       	std	Y+27, r25	; 0x1b
    3c16:	8a 8f       	std	Y+26, r24	; 0x1a
    3c18:	0f c0       	rjmp	.+30     	; 0x3c38 <HAL_SM_voidSMSetAngle+0x248>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3c1a:	69 a5       	ldd	r22, Y+41	; 0x29
    3c1c:	7a a5       	ldd	r23, Y+42	; 0x2a
    3c1e:	8b a5       	ldd	r24, Y+43	; 0x2b
    3c20:	9c a5       	ldd	r25, Y+44	; 0x2c
    3c22:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3c26:	dc 01       	movw	r26, r24
    3c28:	cb 01       	movw	r24, r22
    3c2a:	88 a7       	std	Y+40, r24	; 0x28
    3c2c:	88 a5       	ldd	r24, Y+40	; 0x28
    3c2e:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3c30:	89 8d       	ldd	r24, Y+25	; 0x19
    3c32:	8a 95       	dec	r24
    3c34:	f1 f7       	brne	.-4      	; 0x3c32 <HAL_SM_voidSMSetAngle+0x242>
    3c36:	89 8f       	std	Y+25, r24	; 0x19
		CLR_BIT(PORTD,Pin7);
    3c38:	a2 e3       	ldi	r26, 0x32	; 50
    3c3a:	b0 e0       	ldi	r27, 0x00	; 0
    3c3c:	e2 e3       	ldi	r30, 0x32	; 50
    3c3e:	f0 e0       	ldi	r31, 0x00	; 0
    3c40:	80 81       	ld	r24, Z
    3c42:	8f 77       	andi	r24, 0x7F	; 127
    3c44:	8c 93       	st	X, r24
		_delay_us(LOC_u16OffTime);
    3c46:	89 a9       	ldd	r24, Y+49	; 0x31
    3c48:	9a a9       	ldd	r25, Y+50	; 0x32
    3c4a:	cc 01       	movw	r24, r24
    3c4c:	a0 e0       	ldi	r26, 0x00	; 0
    3c4e:	b0 e0       	ldi	r27, 0x00	; 0
    3c50:	bc 01       	movw	r22, r24
    3c52:	cd 01       	movw	r24, r26
    3c54:	0e 94 37 05 	call	0xa6e	; 0xa6e <__floatunsisf>
    3c58:	dc 01       	movw	r26, r24
    3c5a:	cb 01       	movw	r24, r22
    3c5c:	8d 8b       	std	Y+21, r24	; 0x15
    3c5e:	9e 8b       	std	Y+22, r25	; 0x16
    3c60:	af 8b       	std	Y+23, r26	; 0x17
    3c62:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    3c64:	6d 89       	ldd	r22, Y+21	; 0x15
    3c66:	7e 89       	ldd	r23, Y+22	; 0x16
    3c68:	8f 89       	ldd	r24, Y+23	; 0x17
    3c6a:	98 8d       	ldd	r25, Y+24	; 0x18
    3c6c:	2b ea       	ldi	r18, 0xAB	; 171
    3c6e:	3a ea       	ldi	r19, 0xAA	; 170
    3c70:	4a ea       	ldi	r20, 0xAA	; 170
    3c72:	50 e4       	ldi	r21, 0x40	; 64
    3c74:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3c78:	dc 01       	movw	r26, r24
    3c7a:	cb 01       	movw	r24, r22
    3c7c:	89 8b       	std	Y+17, r24	; 0x11
    3c7e:	9a 8b       	std	Y+18, r25	; 0x12
    3c80:	ab 8b       	std	Y+19, r26	; 0x13
    3c82:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    3c84:	69 89       	ldd	r22, Y+17	; 0x11
    3c86:	7a 89       	ldd	r23, Y+18	; 0x12
    3c88:	8b 89       	ldd	r24, Y+19	; 0x13
    3c8a:	9c 89       	ldd	r25, Y+20	; 0x14
    3c8c:	20 e0       	ldi	r18, 0x00	; 0
    3c8e:	30 e0       	ldi	r19, 0x00	; 0
    3c90:	40 e8       	ldi	r20, 0x80	; 128
    3c92:	5f e3       	ldi	r21, 0x3F	; 63
    3c94:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3c98:	88 23       	and	r24, r24
    3c9a:	1c f4       	brge	.+6      	; 0x3ca2 <HAL_SM_voidSMSetAngle+0x2b2>
		__ticks = 1;
    3c9c:	81 e0       	ldi	r24, 0x01	; 1
    3c9e:	88 8b       	std	Y+16, r24	; 0x10
    3ca0:	91 c0       	rjmp	.+290    	; 0x3dc4 <HAL_SM_voidSMSetAngle+0x3d4>
	else if (__tmp > 255)
    3ca2:	69 89       	ldd	r22, Y+17	; 0x11
    3ca4:	7a 89       	ldd	r23, Y+18	; 0x12
    3ca6:	8b 89       	ldd	r24, Y+19	; 0x13
    3ca8:	9c 89       	ldd	r25, Y+20	; 0x14
    3caa:	20 e0       	ldi	r18, 0x00	; 0
    3cac:	30 e0       	ldi	r19, 0x00	; 0
    3cae:	4f e7       	ldi	r20, 0x7F	; 127
    3cb0:	53 e4       	ldi	r21, 0x43	; 67
    3cb2:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3cb6:	18 16       	cp	r1, r24
    3cb8:	0c f0       	brlt	.+2      	; 0x3cbc <HAL_SM_voidSMSetAngle+0x2cc>
    3cba:	7b c0       	rjmp	.+246    	; 0x3db2 <HAL_SM_voidSMSetAngle+0x3c2>
	{
		_delay_ms(__us / 1000.0);
    3cbc:	6d 89       	ldd	r22, Y+21	; 0x15
    3cbe:	7e 89       	ldd	r23, Y+22	; 0x16
    3cc0:	8f 89       	ldd	r24, Y+23	; 0x17
    3cc2:	98 8d       	ldd	r25, Y+24	; 0x18
    3cc4:	20 e0       	ldi	r18, 0x00	; 0
    3cc6:	30 e0       	ldi	r19, 0x00	; 0
    3cc8:	4a e7       	ldi	r20, 0x7A	; 122
    3cca:	54 e4       	ldi	r21, 0x44	; 68
    3ccc:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    3cd0:	dc 01       	movw	r26, r24
    3cd2:	cb 01       	movw	r24, r22
    3cd4:	8c 87       	std	Y+12, r24	; 0x0c
    3cd6:	9d 87       	std	Y+13, r25	; 0x0d
    3cd8:	ae 87       	std	Y+14, r26	; 0x0e
    3cda:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3cdc:	6c 85       	ldd	r22, Y+12	; 0x0c
    3cde:	7d 85       	ldd	r23, Y+13	; 0x0d
    3ce0:	8e 85       	ldd	r24, Y+14	; 0x0e
    3ce2:	9f 85       	ldd	r25, Y+15	; 0x0f
    3ce4:	20 e0       	ldi	r18, 0x00	; 0
    3ce6:	30 e0       	ldi	r19, 0x00	; 0
    3ce8:	4a e7       	ldi	r20, 0x7A	; 122
    3cea:	55 e4       	ldi	r21, 0x45	; 69
    3cec:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3cf0:	dc 01       	movw	r26, r24
    3cf2:	cb 01       	movw	r24, r22
    3cf4:	88 87       	std	Y+8, r24	; 0x08
    3cf6:	99 87       	std	Y+9, r25	; 0x09
    3cf8:	aa 87       	std	Y+10, r26	; 0x0a
    3cfa:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    3cfc:	68 85       	ldd	r22, Y+8	; 0x08
    3cfe:	79 85       	ldd	r23, Y+9	; 0x09
    3d00:	8a 85       	ldd	r24, Y+10	; 0x0a
    3d02:	9b 85       	ldd	r25, Y+11	; 0x0b
    3d04:	20 e0       	ldi	r18, 0x00	; 0
    3d06:	30 e0       	ldi	r19, 0x00	; 0
    3d08:	40 e8       	ldi	r20, 0x80	; 128
    3d0a:	5f e3       	ldi	r21, 0x3F	; 63
    3d0c:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3d10:	88 23       	and	r24, r24
    3d12:	2c f4       	brge	.+10     	; 0x3d1e <HAL_SM_voidSMSetAngle+0x32e>
		__ticks = 1;
    3d14:	81 e0       	ldi	r24, 0x01	; 1
    3d16:	90 e0       	ldi	r25, 0x00	; 0
    3d18:	9f 83       	std	Y+7, r25	; 0x07
    3d1a:	8e 83       	std	Y+6, r24	; 0x06
    3d1c:	3f c0       	rjmp	.+126    	; 0x3d9c <HAL_SM_voidSMSetAngle+0x3ac>
	else if (__tmp > 65535)
    3d1e:	68 85       	ldd	r22, Y+8	; 0x08
    3d20:	79 85       	ldd	r23, Y+9	; 0x09
    3d22:	8a 85       	ldd	r24, Y+10	; 0x0a
    3d24:	9b 85       	ldd	r25, Y+11	; 0x0b
    3d26:	20 e0       	ldi	r18, 0x00	; 0
    3d28:	3f ef       	ldi	r19, 0xFF	; 255
    3d2a:	4f e7       	ldi	r20, 0x7F	; 127
    3d2c:	57 e4       	ldi	r21, 0x47	; 71
    3d2e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3d32:	18 16       	cp	r1, r24
    3d34:	4c f5       	brge	.+82     	; 0x3d88 <HAL_SM_voidSMSetAngle+0x398>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3d36:	6c 85       	ldd	r22, Y+12	; 0x0c
    3d38:	7d 85       	ldd	r23, Y+13	; 0x0d
    3d3a:	8e 85       	ldd	r24, Y+14	; 0x0e
    3d3c:	9f 85       	ldd	r25, Y+15	; 0x0f
    3d3e:	20 e0       	ldi	r18, 0x00	; 0
    3d40:	30 e0       	ldi	r19, 0x00	; 0
    3d42:	40 e2       	ldi	r20, 0x20	; 32
    3d44:	51 e4       	ldi	r21, 0x41	; 65
    3d46:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3d4a:	dc 01       	movw	r26, r24
    3d4c:	cb 01       	movw	r24, r22
    3d4e:	bc 01       	movw	r22, r24
    3d50:	cd 01       	movw	r24, r26
    3d52:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3d56:	dc 01       	movw	r26, r24
    3d58:	cb 01       	movw	r24, r22
    3d5a:	9f 83       	std	Y+7, r25	; 0x07
    3d5c:	8e 83       	std	Y+6, r24	; 0x06
    3d5e:	0f c0       	rjmp	.+30     	; 0x3d7e <HAL_SM_voidSMSetAngle+0x38e>
    3d60:	80 e9       	ldi	r24, 0x90	; 144
    3d62:	91 e0       	ldi	r25, 0x01	; 1
    3d64:	9d 83       	std	Y+5, r25	; 0x05
    3d66:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3d68:	8c 81       	ldd	r24, Y+4	; 0x04
    3d6a:	9d 81       	ldd	r25, Y+5	; 0x05
    3d6c:	01 97       	sbiw	r24, 0x01	; 1
    3d6e:	f1 f7       	brne	.-4      	; 0x3d6c <HAL_SM_voidSMSetAngle+0x37c>
    3d70:	9d 83       	std	Y+5, r25	; 0x05
    3d72:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3d74:	8e 81       	ldd	r24, Y+6	; 0x06
    3d76:	9f 81       	ldd	r25, Y+7	; 0x07
    3d78:	01 97       	sbiw	r24, 0x01	; 1
    3d7a:	9f 83       	std	Y+7, r25	; 0x07
    3d7c:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3d7e:	8e 81       	ldd	r24, Y+6	; 0x06
    3d80:	9f 81       	ldd	r25, Y+7	; 0x07
    3d82:	00 97       	sbiw	r24, 0x00	; 0
    3d84:	69 f7       	brne	.-38     	; 0x3d60 <HAL_SM_voidSMSetAngle+0x370>
    3d86:	24 c0       	rjmp	.+72     	; 0x3dd0 <HAL_SM_voidSMSetAngle+0x3e0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3d88:	68 85       	ldd	r22, Y+8	; 0x08
    3d8a:	79 85       	ldd	r23, Y+9	; 0x09
    3d8c:	8a 85       	ldd	r24, Y+10	; 0x0a
    3d8e:	9b 85       	ldd	r25, Y+11	; 0x0b
    3d90:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3d94:	dc 01       	movw	r26, r24
    3d96:	cb 01       	movw	r24, r22
    3d98:	9f 83       	std	Y+7, r25	; 0x07
    3d9a:	8e 83       	std	Y+6, r24	; 0x06
    3d9c:	8e 81       	ldd	r24, Y+6	; 0x06
    3d9e:	9f 81       	ldd	r25, Y+7	; 0x07
    3da0:	9b 83       	std	Y+3, r25	; 0x03
    3da2:	8a 83       	std	Y+2, r24	; 0x02
    3da4:	8a 81       	ldd	r24, Y+2	; 0x02
    3da6:	9b 81       	ldd	r25, Y+3	; 0x03
    3da8:	01 97       	sbiw	r24, 0x01	; 1
    3daa:	f1 f7       	brne	.-4      	; 0x3da8 <HAL_SM_voidSMSetAngle+0x3b8>
    3dac:	9b 83       	std	Y+3, r25	; 0x03
    3dae:	8a 83       	std	Y+2, r24	; 0x02
    3db0:	0f c0       	rjmp	.+30     	; 0x3dd0 <HAL_SM_voidSMSetAngle+0x3e0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3db2:	69 89       	ldd	r22, Y+17	; 0x11
    3db4:	7a 89       	ldd	r23, Y+18	; 0x12
    3db6:	8b 89       	ldd	r24, Y+19	; 0x13
    3db8:	9c 89       	ldd	r25, Y+20	; 0x14
    3dba:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3dbe:	dc 01       	movw	r26, r24
    3dc0:	cb 01       	movw	r24, r22
    3dc2:	88 8b       	std	Y+16, r24	; 0x10
    3dc4:	88 89       	ldd	r24, Y+16	; 0x10
    3dc6:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3dc8:	89 81       	ldd	r24, Y+1	; 0x01
    3dca:	8a 95       	dec	r24
    3dcc:	f1 f7       	brne	.-4      	; 0x3dca <HAL_SM_voidSMSetAngle+0x3da>
    3dce:	89 83       	std	Y+1, r24	; 0x01
	} else {
		//NOTHING
	}
}
    3dd0:	e5 96       	adiw	r28, 0x35	; 53
    3dd2:	0f b6       	in	r0, 0x3f	; 63
    3dd4:	f8 94       	cli
    3dd6:	de bf       	out	0x3e, r29	; 62
    3dd8:	0f be       	out	0x3f, r0	; 63
    3dda:	cd bf       	out	0x3d, r28	; 61
    3ddc:	cf 91       	pop	r28
    3dde:	df 91       	pop	r29
    3de0:	08 95       	ret

00003de2 <HAL_LED_u8LedInit>:
 *  Created on: Sep 25, 2023
 *      Author: Mohamed
 */
#include "LED.h"

STD_Type HAL_LED_u8LedInit(u8 Loc_u8LEDPortID, u8 Loc_u8LEDPinID) {
    3de2:	df 93       	push	r29
    3de4:	cf 93       	push	r28
    3de6:	00 d0       	rcall	.+0      	; 0x3de8 <HAL_LED_u8LedInit+0x6>
    3de8:	0f 92       	push	r0
    3dea:	cd b7       	in	r28, 0x3d	; 61
    3dec:	de b7       	in	r29, 0x3e	; 62
    3dee:	8a 83       	std	Y+2, r24	; 0x02
    3df0:	6b 83       	std	Y+3, r22	; 0x03
	u8 Loc_u8Return_Value = E_NOT_OK;
    3df2:	81 e0       	ldi	r24, 0x01	; 1
    3df4:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8LEDPortID <= PortD && Loc_u8LEDPinID <= Num_Of_Pins) {
    3df6:	8a 81       	ldd	r24, Y+2	; 0x02
    3df8:	84 30       	cpi	r24, 0x04	; 4
    3dfa:	48 f4       	brcc	.+18     	; 0x3e0e <HAL_LED_u8LedInit+0x2c>
    3dfc:	8b 81       	ldd	r24, Y+3	; 0x03
    3dfe:	88 30       	cpi	r24, 0x08	; 8
    3e00:	30 f4       	brcc	.+12     	; 0x3e0e <HAL_LED_u8LedInit+0x2c>
		Loc_u8Return_Value = MCAL_DIO_u8SetPinDirection(Loc_u8LEDPortID,
    3e02:	8a 81       	ldd	r24, Y+2	; 0x02
    3e04:	6b 81       	ldd	r22, Y+3	; 0x03
    3e06:	41 e0       	ldi	r20, 0x01	; 1
    3e08:	0e 94 fc 16 	call	0x2df8	; 0x2df8 <MCAL_DIO_u8SetPinDirection>
    3e0c:	89 83       	std	Y+1, r24	; 0x01
				Loc_u8LEDPinID, Pin_High);
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    3e0e:	89 81       	ldd	r24, Y+1	; 0x01
}
    3e10:	0f 90       	pop	r0
    3e12:	0f 90       	pop	r0
    3e14:	0f 90       	pop	r0
    3e16:	cf 91       	pop	r28
    3e18:	df 91       	pop	r29
    3e1a:	08 95       	ret

00003e1c <HAL_LED_u8LedMode>:

STD_Type HAL_LED_u8LedMode(u8 Loc_u8LEDPortID, u8 Loc_u8LEDPinID,
		u8 Loc_u8LEDMode) {
    3e1c:	df 93       	push	r29
    3e1e:	cf 93       	push	r28
    3e20:	00 d0       	rcall	.+0      	; 0x3e22 <HAL_LED_u8LedMode+0x6>
    3e22:	00 d0       	rcall	.+0      	; 0x3e24 <HAL_LED_u8LedMode+0x8>
    3e24:	cd b7       	in	r28, 0x3d	; 61
    3e26:	de b7       	in	r29, 0x3e	; 62
    3e28:	8a 83       	std	Y+2, r24	; 0x02
    3e2a:	6b 83       	std	Y+3, r22	; 0x03
    3e2c:	4c 83       	std	Y+4, r20	; 0x04
	u8 Loc_u8Return_Value = E_NOT_OK;
    3e2e:	81 e0       	ldi	r24, 0x01	; 1
    3e30:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8LEDPortID <= PortD && Loc_u8LEDPinID <= Num_Of_Pins
    3e32:	8a 81       	ldd	r24, Y+2	; 0x02
    3e34:	84 30       	cpi	r24, 0x04	; 4
    3e36:	10 f5       	brcc	.+68     	; 0x3e7c <HAL_LED_u8LedMode+0x60>
    3e38:	8b 81       	ldd	r24, Y+3	; 0x03
    3e3a:	88 30       	cpi	r24, 0x08	; 8
    3e3c:	f8 f4       	brcc	.+62     	; 0x3e7c <HAL_LED_u8LedMode+0x60>
    3e3e:	8c 81       	ldd	r24, Y+4	; 0x04
    3e40:	83 30       	cpi	r24, 0x03	; 3
    3e42:	e0 f4       	brcc	.+56     	; 0x3e7c <HAL_LED_u8LedMode+0x60>
			&& Loc_u8LEDMode <= LED_TOG) {
		if (Loc_u8LEDMode == LED_ON) {
    3e44:	8c 81       	ldd	r24, Y+4	; 0x04
    3e46:	81 30       	cpi	r24, 0x01	; 1
    3e48:	39 f4       	brne	.+14     	; 0x3e58 <HAL_LED_u8LedMode+0x3c>
			Loc_u8Return_Value = MCAL_DIO_u8SetPinValue(Loc_u8LEDPortID,
    3e4a:	8a 81       	ldd	r24, Y+2	; 0x02
    3e4c:	6b 81       	ldd	r22, Y+3	; 0x03
    3e4e:	41 e0       	ldi	r20, 0x01	; 1
    3e50:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <MCAL_DIO_u8SetPinValue>
    3e54:	89 83       	std	Y+1, r24	; 0x01
    3e56:	12 c0       	rjmp	.+36     	; 0x3e7c <HAL_LED_u8LedMode+0x60>
					Loc_u8LEDPinID, Pin_High);
		} else if (Loc_u8LEDMode == LED_OFF) {
    3e58:	8c 81       	ldd	r24, Y+4	; 0x04
    3e5a:	88 23       	and	r24, r24
    3e5c:	39 f4       	brne	.+14     	; 0x3e6c <HAL_LED_u8LedMode+0x50>
			Loc_u8Return_Value = MCAL_DIO_u8SetPinValue(Loc_u8LEDPortID,
    3e5e:	8a 81       	ldd	r24, Y+2	; 0x02
    3e60:	6b 81       	ldd	r22, Y+3	; 0x03
    3e62:	40 e0       	ldi	r20, 0x00	; 0
    3e64:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <MCAL_DIO_u8SetPinValue>
    3e68:	89 83       	std	Y+1, r24	; 0x01
    3e6a:	08 c0       	rjmp	.+16     	; 0x3e7c <HAL_LED_u8LedMode+0x60>
					Loc_u8LEDPinID, Pin_Low);
		} else if (Loc_u8LEDMode == LED_TOG) {
    3e6c:	8c 81       	ldd	r24, Y+4	; 0x04
    3e6e:	82 30       	cpi	r24, 0x02	; 2
    3e70:	29 f4       	brne	.+10     	; 0x3e7c <HAL_LED_u8LedMode+0x60>
			Loc_u8Return_Value = MCAL_DIO_u8TogglePinValue(Loc_u8LEDPortID,
    3e72:	8a 81       	ldd	r24, Y+2	; 0x02
    3e74:	6b 81       	ldd	r22, Y+3	; 0x03
    3e76:	0e 94 53 1a 	call	0x34a6	; 0x34a6 <MCAL_DIO_u8TogglePinValue>
    3e7a:	89 83       	std	Y+1, r24	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    3e7c:	89 81       	ldd	r24, Y+1	; 0x01
}
    3e7e:	0f 90       	pop	r0
    3e80:	0f 90       	pop	r0
    3e82:	0f 90       	pop	r0
    3e84:	0f 90       	pop	r0
    3e86:	cf 91       	pop	r28
    3e88:	df 91       	pop	r29
    3e8a:	08 95       	ret

00003e8c <HAL_void_H_BridgeInit>:
 *      Author: Mohamed
 */

#include "H_Bridge.h"

void HAL_void_H_BridgeInit() {
    3e8c:	df 93       	push	r29
    3e8e:	cf 93       	push	r28
    3e90:	cd b7       	in	r28, 0x3d	; 61
    3e92:	de b7       	in	r29, 0x3e	; 62
	MCAL_DIO_u8SetPinDirection(PortD, Pin4, Pin_High);
    3e94:	83 e0       	ldi	r24, 0x03	; 3
    3e96:	64 e0       	ldi	r22, 0x04	; 4
    3e98:	41 e0       	ldi	r20, 0x01	; 1
    3e9a:	0e 94 fc 16 	call	0x2df8	; 0x2df8 <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(PortD, Pin5, Pin_High);
    3e9e:	83 e0       	ldi	r24, 0x03	; 3
    3ea0:	65 e0       	ldi	r22, 0x05	; 5
    3ea2:	41 e0       	ldi	r20, 0x01	; 1
    3ea4:	0e 94 fc 16 	call	0x2df8	; 0x2df8 <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(PortC, 3, Pin_High);
    3ea8:	82 e0       	ldi	r24, 0x02	; 2
    3eaa:	63 e0       	ldi	r22, 0x03	; 3
    3eac:	41 e0       	ldi	r20, 0x01	; 1
    3eae:	0e 94 fc 16 	call	0x2df8	; 0x2df8 <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(PortC, 4, Pin_High);
    3eb2:	82 e0       	ldi	r24, 0x02	; 2
    3eb4:	64 e0       	ldi	r22, 0x04	; 4
    3eb6:	41 e0       	ldi	r20, 0x01	; 1
    3eb8:	0e 94 fc 16 	call	0x2df8	; 0x2df8 <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(PortC, 5, Pin_High);
    3ebc:	82 e0       	ldi	r24, 0x02	; 2
    3ebe:	65 e0       	ldi	r22, 0x05	; 5
    3ec0:	41 e0       	ldi	r20, 0x01	; 1
    3ec2:	0e 94 fc 16 	call	0x2df8	; 0x2df8 <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(PortC, 6, Pin_High);
    3ec6:	82 e0       	ldi	r24, 0x02	; 2
    3ec8:	66 e0       	ldi	r22, 0x06	; 6
    3eca:	41 e0       	ldi	r20, 0x01	; 1
    3ecc:	0e 94 fc 16 	call	0x2df8	; 0x2df8 <MCAL_DIO_u8SetPinDirection>
}
    3ed0:	cf 91       	pop	r28
    3ed2:	df 91       	pop	r29
    3ed4:	08 95       	ret

00003ed6 <HAL_void_H_BridgeCW>:

void HAL_void_H_BridgeCW(u8 copy_u8_speed) {
    3ed6:	df 93       	push	r29
    3ed8:	cf 93       	push	r28
    3eda:	0f 92       	push	r0
    3edc:	cd b7       	in	r28, 0x3d	; 61
    3ede:	de b7       	in	r29, 0x3e	; 62
    3ee0:	89 83       	std	Y+1, r24	; 0x01
	MCAL_T1_FPWM_10bitRES(CHENNEL_B, copy_u8_speed);
    3ee2:	81 e0       	ldi	r24, 0x01	; 1
    3ee4:	69 81       	ldd	r22, Y+1	; 0x01
    3ee6:	0e 94 20 10 	call	0x2040	; 0x2040 <MCAL_T1_FPWM_10bitRES>
	MCAL_T1_FPWM_10bitRES(CHENNEL_A, copy_u8_speed);
    3eea:	80 e0       	ldi	r24, 0x00	; 0
    3eec:	69 81       	ldd	r22, Y+1	; 0x01
    3eee:	0e 94 20 10 	call	0x2040	; 0x2040 <MCAL_T1_FPWM_10bitRES>
	MCAL_DIO_u8SetPinValue(PortC, Pin3, Pin_Low);
    3ef2:	82 e0       	ldi	r24, 0x02	; 2
    3ef4:	63 e0       	ldi	r22, 0x03	; 3
    3ef6:	40 e0       	ldi	r20, 0x00	; 0
    3ef8:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin4, Pin_Low);
    3efc:	82 e0       	ldi	r24, 0x02	; 2
    3efe:	64 e0       	ldi	r22, 0x04	; 4
    3f00:	40 e0       	ldi	r20, 0x00	; 0
    3f02:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin5, Pin_Low);
    3f06:	82 e0       	ldi	r24, 0x02	; 2
    3f08:	65 e0       	ldi	r22, 0x05	; 5
    3f0a:	40 e0       	ldi	r20, 0x00	; 0
    3f0c:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin6, Pin_High);
    3f10:	82 e0       	ldi	r24, 0x02	; 2
    3f12:	66 e0       	ldi	r22, 0x06	; 6
    3f14:	41 e0       	ldi	r20, 0x01	; 1
    3f16:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <MCAL_DIO_u8SetPinValue>
}
    3f1a:	0f 90       	pop	r0
    3f1c:	cf 91       	pop	r28
    3f1e:	df 91       	pop	r29
    3f20:	08 95       	ret

00003f22 <HAL_void_H_BridgeFR>:
void HAL_void_H_BridgeFR() {
    3f22:	df 93       	push	r29
    3f24:	cf 93       	push	r28
    3f26:	cd b7       	in	r28, 0x3d	; 61
    3f28:	de b7       	in	r29, 0x3e	; 62
	MCAL_T1_FPWM_10bitRES(CHENNEL_B, 70);
    3f2a:	81 e0       	ldi	r24, 0x01	; 1
    3f2c:	66 e4       	ldi	r22, 0x46	; 70
    3f2e:	0e 94 20 10 	call	0x2040	; 0x2040 <MCAL_T1_FPWM_10bitRES>
	MCAL_T1_FPWM_10bitRES(CHENNEL_A, 99);
    3f32:	80 e0       	ldi	r24, 0x00	; 0
    3f34:	63 e6       	ldi	r22, 0x63	; 99
    3f36:	0e 94 20 10 	call	0x2040	; 0x2040 <MCAL_T1_FPWM_10bitRES>
	MCAL_DIO_u8SetPinValue(PortC, Pin3, Pin_High);
    3f3a:	82 e0       	ldi	r24, 0x02	; 2
    3f3c:	63 e0       	ldi	r22, 0x03	; 3
    3f3e:	41 e0       	ldi	r20, 0x01	; 1
    3f40:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin4, Pin_Low);
    3f44:	82 e0       	ldi	r24, 0x02	; 2
    3f46:	64 e0       	ldi	r22, 0x04	; 4
    3f48:	40 e0       	ldi	r20, 0x00	; 0
    3f4a:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin5, Pin_Low);
    3f4e:	82 e0       	ldi	r24, 0x02	; 2
    3f50:	65 e0       	ldi	r22, 0x05	; 5
    3f52:	40 e0       	ldi	r20, 0x00	; 0
    3f54:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin6, Pin_High);
    3f58:	82 e0       	ldi	r24, 0x02	; 2
    3f5a:	66 e0       	ldi	r22, 0x06	; 6
    3f5c:	41 e0       	ldi	r20, 0x01	; 1
    3f5e:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <MCAL_DIO_u8SetPinValue>
}
    3f62:	cf 91       	pop	r28
    3f64:	df 91       	pop	r29
    3f66:	08 95       	ret

00003f68 <HAL_void_H_BridgeFront>:
void HAL_void_H_BridgeFront(u8 copy_u8_speed) {
    3f68:	df 93       	push	r29
    3f6a:	cf 93       	push	r28
    3f6c:	0f 92       	push	r0
    3f6e:	cd b7       	in	r28, 0x3d	; 61
    3f70:	de b7       	in	r29, 0x3e	; 62
    3f72:	89 83       	std	Y+1, r24	; 0x01
	MCAL_T1_FPWM_10bitRES(CHENNEL_A, copy_u8_speed);
    3f74:	80 e0       	ldi	r24, 0x00	; 0
    3f76:	69 81       	ldd	r22, Y+1	; 0x01
    3f78:	0e 94 20 10 	call	0x2040	; 0x2040 <MCAL_T1_FPWM_10bitRES>
	MCAL_T1_FPWM_10bitRES(CHENNEL_B, copy_u8_speed);
    3f7c:	81 e0       	ldi	r24, 0x01	; 1
    3f7e:	69 81       	ldd	r22, Y+1	; 0x01
    3f80:	0e 94 20 10 	call	0x2040	; 0x2040 <MCAL_T1_FPWM_10bitRES>
//	MCAL_DIO_u8SetPinValue(PortD, Pin4, Pin_High);
//	MCAL_DIO_u8SetPinValue(PortD, Pin5, Pin_High);
	MCAL_DIO_u8SetPinValue(PortC, Pin3, Pin_High);
    3f84:	82 e0       	ldi	r24, 0x02	; 2
    3f86:	63 e0       	ldi	r22, 0x03	; 3
    3f88:	41 e0       	ldi	r20, 0x01	; 1
    3f8a:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin4, Pin_Low);
    3f8e:	82 e0       	ldi	r24, 0x02	; 2
    3f90:	64 e0       	ldi	r22, 0x04	; 4
    3f92:	40 e0       	ldi	r20, 0x00	; 0
    3f94:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin5, Pin_Low);
    3f98:	82 e0       	ldi	r24, 0x02	; 2
    3f9a:	65 e0       	ldi	r22, 0x05	; 5
    3f9c:	40 e0       	ldi	r20, 0x00	; 0
    3f9e:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin6, Pin_High);
    3fa2:	82 e0       	ldi	r24, 0x02	; 2
    3fa4:	66 e0       	ldi	r22, 0x06	; 6
    3fa6:	41 e0       	ldi	r20, 0x01	; 1
    3fa8:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <MCAL_DIO_u8SetPinValue>
}
    3fac:	0f 90       	pop	r0
    3fae:	cf 91       	pop	r28
    3fb0:	df 91       	pop	r29
    3fb2:	08 95       	ret

00003fb4 <HAL_void_H_BridgeBack>:
void HAL_void_H_BridgeBack(u8 copy_u8_speed) {
    3fb4:	df 93       	push	r29
    3fb6:	cf 93       	push	r28
    3fb8:	0f 92       	push	r0
    3fba:	cd b7       	in	r28, 0x3d	; 61
    3fbc:	de b7       	in	r29, 0x3e	; 62
    3fbe:	89 83       	std	Y+1, r24	; 0x01
	MCAL_T1_FPWM_10bitRES(CHENNEL_B, copy_u8_speed);
    3fc0:	81 e0       	ldi	r24, 0x01	; 1
    3fc2:	69 81       	ldd	r22, Y+1	; 0x01
    3fc4:	0e 94 20 10 	call	0x2040	; 0x2040 <MCAL_T1_FPWM_10bitRES>
	MCAL_T1_FPWM_10bitRES(CHENNEL_A, copy_u8_speed);
    3fc8:	80 e0       	ldi	r24, 0x00	; 0
    3fca:	69 81       	ldd	r22, Y+1	; 0x01
    3fcc:	0e 94 20 10 	call	0x2040	; 0x2040 <MCAL_T1_FPWM_10bitRES>
	MCAL_DIO_u8SetPinValue(PortC, Pin3, Pin_Low);
    3fd0:	82 e0       	ldi	r24, 0x02	; 2
    3fd2:	63 e0       	ldi	r22, 0x03	; 3
    3fd4:	40 e0       	ldi	r20, 0x00	; 0
    3fd6:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin4, Pin_High);
    3fda:	82 e0       	ldi	r24, 0x02	; 2
    3fdc:	64 e0       	ldi	r22, 0x04	; 4
    3fde:	41 e0       	ldi	r20, 0x01	; 1
    3fe0:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin5, Pin_High);
    3fe4:	82 e0       	ldi	r24, 0x02	; 2
    3fe6:	65 e0       	ldi	r22, 0x05	; 5
    3fe8:	41 e0       	ldi	r20, 0x01	; 1
    3fea:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin6, Pin_Low);
    3fee:	82 e0       	ldi	r24, 0x02	; 2
    3ff0:	66 e0       	ldi	r22, 0x06	; 6
    3ff2:	40 e0       	ldi	r20, 0x00	; 0
    3ff4:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <MCAL_DIO_u8SetPinValue>
}
    3ff8:	0f 90       	pop	r0
    3ffa:	cf 91       	pop	r28
    3ffc:	df 91       	pop	r29
    3ffe:	08 95       	ret

00004000 <HAL_void_H_BridgeCCW>:
void HAL_void_H_BridgeCCW(u8 copy_u8_speed) {
    4000:	df 93       	push	r29
    4002:	cf 93       	push	r28
    4004:	0f 92       	push	r0
    4006:	cd b7       	in	r28, 0x3d	; 61
    4008:	de b7       	in	r29, 0x3e	; 62
    400a:	89 83       	std	Y+1, r24	; 0x01
	MCAL_T1_FPWM_10bitRES(CHENNEL_B, copy_u8_speed);
    400c:	81 e0       	ldi	r24, 0x01	; 1
    400e:	69 81       	ldd	r22, Y+1	; 0x01
    4010:	0e 94 20 10 	call	0x2040	; 0x2040 <MCAL_T1_FPWM_10bitRES>
	MCAL_T1_FPWM_10bitRES(CHENNEL_A, copy_u8_speed);
    4014:	80 e0       	ldi	r24, 0x00	; 0
    4016:	69 81       	ldd	r22, Y+1	; 0x01
    4018:	0e 94 20 10 	call	0x2040	; 0x2040 <MCAL_T1_FPWM_10bitRES>
	MCAL_DIO_u8SetPinValue(PortC, Pin3, Pin_High);
    401c:	82 e0       	ldi	r24, 0x02	; 2
    401e:	63 e0       	ldi	r22, 0x03	; 3
    4020:	41 e0       	ldi	r20, 0x01	; 1
    4022:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin4, Pin_Low);
    4026:	82 e0       	ldi	r24, 0x02	; 2
    4028:	64 e0       	ldi	r22, 0x04	; 4
    402a:	40 e0       	ldi	r20, 0x00	; 0
    402c:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin5, Pin_Low);
    4030:	82 e0       	ldi	r24, 0x02	; 2
    4032:	65 e0       	ldi	r22, 0x05	; 5
    4034:	40 e0       	ldi	r20, 0x00	; 0
    4036:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin6, Pin_Low);
    403a:	82 e0       	ldi	r24, 0x02	; 2
    403c:	66 e0       	ldi	r22, 0x06	; 6
    403e:	40 e0       	ldi	r20, 0x00	; 0
    4040:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <MCAL_DIO_u8SetPinValue>
}
    4044:	0f 90       	pop	r0
    4046:	cf 91       	pop	r28
    4048:	df 91       	pop	r29
    404a:	08 95       	ret

0000404c <HAL_void_H_BridgeStop>:

void HAL_void_H_BridgeStop(u8 copy_u8_speed) {
    404c:	df 93       	push	r29
    404e:	cf 93       	push	r28
    4050:	0f 92       	push	r0
    4052:	cd b7       	in	r28, 0x3d	; 61
    4054:	de b7       	in	r29, 0x3e	; 62
    4056:	89 83       	std	Y+1, r24	; 0x01
	MCAL_T1_FPWM_10bitRES(CHENNEL_B, copy_u8_speed);
    4058:	81 e0       	ldi	r24, 0x01	; 1
    405a:	69 81       	ldd	r22, Y+1	; 0x01
    405c:	0e 94 20 10 	call	0x2040	; 0x2040 <MCAL_T1_FPWM_10bitRES>
	MCAL_T1_FPWM_10bitRES(CHENNEL_A, copy_u8_speed);
    4060:	80 e0       	ldi	r24, 0x00	; 0
    4062:	69 81       	ldd	r22, Y+1	; 0x01
    4064:	0e 94 20 10 	call	0x2040	; 0x2040 <MCAL_T1_FPWM_10bitRES>
	MCAL_DIO_u8SetPinValue(PortC, Pin3, Pin_Low);
    4068:	82 e0       	ldi	r24, 0x02	; 2
    406a:	63 e0       	ldi	r22, 0x03	; 3
    406c:	40 e0       	ldi	r20, 0x00	; 0
    406e:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin4, Pin_Low);
    4072:	82 e0       	ldi	r24, 0x02	; 2
    4074:	64 e0       	ldi	r22, 0x04	; 4
    4076:	40 e0       	ldi	r20, 0x00	; 0
    4078:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin5, Pin_Low);
    407c:	82 e0       	ldi	r24, 0x02	; 2
    407e:	65 e0       	ldi	r22, 0x05	; 5
    4080:	40 e0       	ldi	r20, 0x00	; 0
    4082:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin6, Pin_Low);
    4086:	82 e0       	ldi	r24, 0x02	; 2
    4088:	66 e0       	ldi	r22, 0x06	; 6
    408a:	40 e0       	ldi	r20, 0x00	; 0
    408c:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <MCAL_DIO_u8SetPinValue>
}
    4090:	0f 90       	pop	r0
    4092:	cf 91       	pop	r28
    4094:	df 91       	pop	r29
    4096:	08 95       	ret

00004098 <HAL_Buzzer_u8BuzzerInit>:
 *      Author: Mohamed
 */

#include "Buzzer.h"

STD_Type HAL_Buzzer_u8BuzzerInit(u8 Loc_u8BuzzerPortID, u8 Loc_u8BuzzerPinID) {
    4098:	df 93       	push	r29
    409a:	cf 93       	push	r28
    409c:	00 d0       	rcall	.+0      	; 0x409e <HAL_Buzzer_u8BuzzerInit+0x6>
    409e:	0f 92       	push	r0
    40a0:	cd b7       	in	r28, 0x3d	; 61
    40a2:	de b7       	in	r29, 0x3e	; 62
    40a4:	8a 83       	std	Y+2, r24	; 0x02
    40a6:	6b 83       	std	Y+3, r22	; 0x03
	u8 Loc_u8Return_Value = E_NOT_OK;
    40a8:	81 e0       	ldi	r24, 0x01	; 1
    40aa:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8BuzzerPortID <= PortD && Loc_u8BuzzerPinID <= Num_Of_Pins) {
    40ac:	8a 81       	ldd	r24, Y+2	; 0x02
    40ae:	84 30       	cpi	r24, 0x04	; 4
    40b0:	48 f4       	brcc	.+18     	; 0x40c4 <HAL_Buzzer_u8BuzzerInit+0x2c>
    40b2:	8b 81       	ldd	r24, Y+3	; 0x03
    40b4:	88 30       	cpi	r24, 0x08	; 8
    40b6:	30 f4       	brcc	.+12     	; 0x40c4 <HAL_Buzzer_u8BuzzerInit+0x2c>
		Loc_u8Return_Value=Loc_u8Return_Value = MCAL_DIO_u8SetPinDirection(Loc_u8BuzzerPortID,
    40b8:	8a 81       	ldd	r24, Y+2	; 0x02
    40ba:	6b 81       	ldd	r22, Y+3	; 0x03
    40bc:	41 e0       	ldi	r20, 0x01	; 1
    40be:	0e 94 fc 16 	call	0x2df8	; 0x2df8 <MCAL_DIO_u8SetPinDirection>
    40c2:	89 83       	std	Y+1, r24	; 0x01
				Loc_u8BuzzerPinID, Pin_High);
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    40c4:	89 81       	ldd	r24, Y+1	; 0x01
}
    40c6:	0f 90       	pop	r0
    40c8:	0f 90       	pop	r0
    40ca:	0f 90       	pop	r0
    40cc:	cf 91       	pop	r28
    40ce:	df 91       	pop	r29
    40d0:	08 95       	ret

000040d2 <HAL_Buzzer_u8BuzzerMode>:

STD_Type HAL_Buzzer_u8BuzzerMode(u8 Loc_u8BuzzerPortID, u8 Loc_u8BuzzerPinID,
		u8 Loc_u8BuzzerMode) {
    40d2:	df 93       	push	r29
    40d4:	cf 93       	push	r28
    40d6:	00 d0       	rcall	.+0      	; 0x40d8 <HAL_Buzzer_u8BuzzerMode+0x6>
    40d8:	00 d0       	rcall	.+0      	; 0x40da <HAL_Buzzer_u8BuzzerMode+0x8>
    40da:	cd b7       	in	r28, 0x3d	; 61
    40dc:	de b7       	in	r29, 0x3e	; 62
    40de:	8a 83       	std	Y+2, r24	; 0x02
    40e0:	6b 83       	std	Y+3, r22	; 0x03
    40e2:	4c 83       	std	Y+4, r20	; 0x04
	u8 Loc_u8Return_Value = E_NOT_OK;
    40e4:	81 e0       	ldi	r24, 0x01	; 1
    40e6:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8BuzzerPortID <= PortD && Loc_u8BuzzerPinID <= Num_Of_Pins
    40e8:	8a 81       	ldd	r24, Y+2	; 0x02
    40ea:	84 30       	cpi	r24, 0x04	; 4
    40ec:	10 f5       	brcc	.+68     	; 0x4132 <HAL_Buzzer_u8BuzzerMode+0x60>
    40ee:	8b 81       	ldd	r24, Y+3	; 0x03
    40f0:	88 30       	cpi	r24, 0x08	; 8
    40f2:	f8 f4       	brcc	.+62     	; 0x4132 <HAL_Buzzer_u8BuzzerMode+0x60>
    40f4:	8c 81       	ldd	r24, Y+4	; 0x04
    40f6:	83 30       	cpi	r24, 0x03	; 3
    40f8:	e0 f4       	brcc	.+56     	; 0x4132 <HAL_Buzzer_u8BuzzerMode+0x60>
			&& Loc_u8BuzzerMode <= Buzzer_TOG) {
		if (Loc_u8BuzzerMode == Buzzer_ON) {
    40fa:	8c 81       	ldd	r24, Y+4	; 0x04
    40fc:	81 30       	cpi	r24, 0x01	; 1
    40fe:	39 f4       	brne	.+14     	; 0x410e <HAL_Buzzer_u8BuzzerMode+0x3c>
			Loc_u8Return_Value=MCAL_DIO_u8SetPinValue(Loc_u8BuzzerPortID, Loc_u8BuzzerPinID, Pin_High);
    4100:	8a 81       	ldd	r24, Y+2	; 0x02
    4102:	6b 81       	ldd	r22, Y+3	; 0x03
    4104:	41 e0       	ldi	r20, 0x01	; 1
    4106:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <MCAL_DIO_u8SetPinValue>
    410a:	89 83       	std	Y+1, r24	; 0x01
    410c:	12 c0       	rjmp	.+36     	; 0x4132 <HAL_Buzzer_u8BuzzerMode+0x60>
		} else if (Loc_u8BuzzerMode == Buzzer_OFF) {
    410e:	8c 81       	ldd	r24, Y+4	; 0x04
    4110:	88 23       	and	r24, r24
    4112:	39 f4       	brne	.+14     	; 0x4122 <HAL_Buzzer_u8BuzzerMode+0x50>
			Loc_u8Return_Value=MCAL_DIO_u8SetPinValue(Loc_u8BuzzerPortID, Loc_u8BuzzerPinID, Pin_Low);
    4114:	8a 81       	ldd	r24, Y+2	; 0x02
    4116:	6b 81       	ldd	r22, Y+3	; 0x03
    4118:	40 e0       	ldi	r20, 0x00	; 0
    411a:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <MCAL_DIO_u8SetPinValue>
    411e:	89 83       	std	Y+1, r24	; 0x01
    4120:	08 c0       	rjmp	.+16     	; 0x4132 <HAL_Buzzer_u8BuzzerMode+0x60>
		} else if (Loc_u8BuzzerMode == Buzzer_TOG) {
    4122:	8c 81       	ldd	r24, Y+4	; 0x04
    4124:	82 30       	cpi	r24, 0x02	; 2
    4126:	29 f4       	brne	.+10     	; 0x4132 <HAL_Buzzer_u8BuzzerMode+0x60>
			Loc_u8Return_Value=MCAL_DIO_u8TogglePinValue(Loc_u8BuzzerPortID,Loc_u8BuzzerPinID);
    4128:	8a 81       	ldd	r24, Y+2	; 0x02
    412a:	6b 81       	ldd	r22, Y+3	; 0x03
    412c:	0e 94 53 1a 	call	0x34a6	; 0x34a6 <MCAL_DIO_u8TogglePinValue>
    4130:	89 83       	std	Y+1, r24	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    4132:	89 81       	ldd	r24, Y+1	; 0x01
}
    4134:	0f 90       	pop	r0
    4136:	0f 90       	pop	r0
    4138:	0f 90       	pop	r0
    413a:	0f 90       	pop	r0
    413c:	cf 91       	pop	r28
    413e:	df 91       	pop	r29
    4140:	08 95       	ret

00004142 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    4142:	df 93       	push	r29
    4144:	cf 93       	push	r28
    4146:	cd b7       	in	r28, 0x3d	; 61
    4148:	de b7       	in	r29, 0x3e	; 62
    414a:	2e 97       	sbiw	r28, 0x0e	; 14
    414c:	0f b6       	in	r0, 0x3f	; 63
    414e:	f8 94       	cli
    4150:	de bf       	out	0x3e, r29	; 62
    4152:	0f be       	out	0x3f, r0	; 63
    4154:	cd bf       	out	0x3d, r28	; 61
    4156:	9e 87       	std	Y+14, r25	; 0x0e
    4158:	8d 87       	std	Y+13, r24	; 0x0d
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    415a:	1e 82       	std	Y+6, r1	; 0x06
    415c:	1d 82       	std	Y+5, r1	; 0x05

	vTaskSuspendAll();
    415e:	0e 94 65 2b 	call	0x56ca	; 0x56ca <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    4162:	80 91 9e 01 	lds	r24, 0x019E
    4166:	88 23       	and	r24, r24
    4168:	29 f4       	brne	.+10     	; 0x4174 <pvPortMalloc+0x32>
		{
			prvHeapInit();
    416a:	0e 94 08 22 	call	0x4410	; 0x4410 <prvHeapInit>
			xHeapHasBeenInitialised = pdTRUE;
    416e:	81 e0       	ldi	r24, 0x01	; 1
    4170:	80 93 9e 01 	sts	0x019E, r24
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    4174:	8d 85       	ldd	r24, Y+13	; 0x0d
    4176:	9e 85       	ldd	r25, Y+14	; 0x0e
    4178:	00 97       	sbiw	r24, 0x00	; 0
    417a:	51 f0       	breq	.+20     	; 0x4190 <pvPortMalloc+0x4e>
		{
			xWantedSize += heapSTRUCT_SIZE;
    417c:	80 91 81 01 	lds	r24, 0x0181
    4180:	90 91 82 01 	lds	r25, 0x0182
    4184:	2d 85       	ldd	r18, Y+13	; 0x0d
    4186:	3e 85       	ldd	r19, Y+14	; 0x0e
    4188:	82 0f       	add	r24, r18
    418a:	93 1f       	adc	r25, r19
    418c:	9e 87       	std	Y+14, r25	; 0x0e
    418e:	8d 87       	std	Y+13, r24	; 0x0d
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
    4190:	8d 85       	ldd	r24, Y+13	; 0x0d
    4192:	9e 85       	ldd	r25, Y+14	; 0x0e
    4194:	00 97       	sbiw	r24, 0x00	; 0
    4196:	09 f4       	brne	.+2      	; 0x419a <pvPortMalloc+0x58>
    4198:	af c0       	rjmp	.+350    	; 0x42f8 <pvPortMalloc+0x1b6>
    419a:	8d 85       	ldd	r24, Y+13	; 0x0d
    419c:	9e 85       	ldd	r25, Y+14	; 0x0e
    419e:	23 e0       	ldi	r18, 0x03	; 3
    41a0:	87 3e       	cpi	r24, 0xE7	; 231
    41a2:	92 07       	cpc	r25, r18
    41a4:	08 f0       	brcs	.+2      	; 0x41a8 <pvPortMalloc+0x66>
    41a6:	a8 c0       	rjmp	.+336    	; 0x42f8 <pvPortMalloc+0x1b6>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    41a8:	87 e8       	ldi	r24, 0x87	; 135
    41aa:	95 e0       	ldi	r25, 0x05	; 5
    41ac:	9a 87       	std	Y+10, r25	; 0x0a
    41ae:	89 87       	std	Y+9, r24	; 0x09
			pxBlock = xStart.pxNextFreeBlock;
    41b0:	80 91 87 05 	lds	r24, 0x0587
    41b4:	90 91 88 05 	lds	r25, 0x0588
    41b8:	9c 87       	std	Y+12, r25	; 0x0c
    41ba:	8b 87       	std	Y+11, r24	; 0x0b
    41bc:	0a c0       	rjmp	.+20     	; 0x41d2 <pvPortMalloc+0x90>
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
			{
				pxPreviousBlock = pxBlock;
    41be:	8b 85       	ldd	r24, Y+11	; 0x0b
    41c0:	9c 85       	ldd	r25, Y+12	; 0x0c
    41c2:	9a 87       	std	Y+10, r25	; 0x0a
    41c4:	89 87       	std	Y+9, r24	; 0x09
				pxBlock = pxBlock->pxNextFreeBlock;
    41c6:	eb 85       	ldd	r30, Y+11	; 0x0b
    41c8:	fc 85       	ldd	r31, Y+12	; 0x0c
    41ca:	80 81       	ld	r24, Z
    41cc:	91 81       	ldd	r25, Z+1	; 0x01
    41ce:	9c 87       	std	Y+12, r25	; 0x0c
    41d0:	8b 87       	std	Y+11, r24	; 0x0b
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    41d2:	eb 85       	ldd	r30, Y+11	; 0x0b
    41d4:	fc 85       	ldd	r31, Y+12	; 0x0c
    41d6:	22 81       	ldd	r18, Z+2	; 0x02
    41d8:	33 81       	ldd	r19, Z+3	; 0x03
    41da:	8d 85       	ldd	r24, Y+13	; 0x0d
    41dc:	9e 85       	ldd	r25, Y+14	; 0x0e
    41de:	28 17       	cp	r18, r24
    41e0:	39 07       	cpc	r19, r25
    41e2:	30 f4       	brcc	.+12     	; 0x41f0 <pvPortMalloc+0xae>
    41e4:	eb 85       	ldd	r30, Y+11	; 0x0b
    41e6:	fc 85       	ldd	r31, Y+12	; 0x0c
    41e8:	80 81       	ld	r24, Z
    41ea:	91 81       	ldd	r25, Z+1	; 0x01
    41ec:	00 97       	sbiw	r24, 0x00	; 0
    41ee:	39 f7       	brne	.-50     	; 0x41be <pvPortMalloc+0x7c>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    41f0:	8b 85       	ldd	r24, Y+11	; 0x0b
    41f2:	9c 85       	ldd	r25, Y+12	; 0x0c
    41f4:	45 e0       	ldi	r20, 0x05	; 5
    41f6:	8b 38       	cpi	r24, 0x8B	; 139
    41f8:	94 07       	cpc	r25, r20
    41fa:	09 f4       	brne	.+2      	; 0x41fe <pvPortMalloc+0xbc>
    41fc:	7d c0       	rjmp	.+250    	; 0x42f8 <pvPortMalloc+0x1b6>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    41fe:	e9 85       	ldd	r30, Y+9	; 0x09
    4200:	fa 85       	ldd	r31, Y+10	; 0x0a
    4202:	20 81       	ld	r18, Z
    4204:	31 81       	ldd	r19, Z+1	; 0x01
    4206:	80 91 81 01 	lds	r24, 0x0181
    420a:	90 91 82 01 	lds	r25, 0x0182
    420e:	82 0f       	add	r24, r18
    4210:	93 1f       	adc	r25, r19
    4212:	9e 83       	std	Y+6, r25	; 0x06
    4214:	8d 83       	std	Y+5, r24	; 0x05

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    4216:	eb 85       	ldd	r30, Y+11	; 0x0b
    4218:	fc 85       	ldd	r31, Y+12	; 0x0c
    421a:	80 81       	ld	r24, Z
    421c:	91 81       	ldd	r25, Z+1	; 0x01
    421e:	e9 85       	ldd	r30, Y+9	; 0x09
    4220:	fa 85       	ldd	r31, Y+10	; 0x0a
    4222:	91 83       	std	Z+1, r25	; 0x01
    4224:	80 83       	st	Z, r24

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    4226:	eb 85       	ldd	r30, Y+11	; 0x0b
    4228:	fc 85       	ldd	r31, Y+12	; 0x0c
    422a:	22 81       	ldd	r18, Z+2	; 0x02
    422c:	33 81       	ldd	r19, Z+3	; 0x03
    422e:	8d 85       	ldd	r24, Y+13	; 0x0d
    4230:	9e 85       	ldd	r25, Y+14	; 0x0e
    4232:	28 1b       	sub	r18, r24
    4234:	39 0b       	sbc	r19, r25
    4236:	80 91 81 01 	lds	r24, 0x0181
    423a:	90 91 82 01 	lds	r25, 0x0182
    423e:	88 0f       	add	r24, r24
    4240:	99 1f       	adc	r25, r25
    4242:	82 17       	cp	r24, r18
    4244:	93 07       	cpc	r25, r19
    4246:	08 f0       	brcs	.+2      	; 0x424a <pvPortMalloc+0x108>
    4248:	47 c0       	rjmp	.+142    	; 0x42d8 <pvPortMalloc+0x196>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    424a:	2b 85       	ldd	r18, Y+11	; 0x0b
    424c:	3c 85       	ldd	r19, Y+12	; 0x0c
    424e:	8d 85       	ldd	r24, Y+13	; 0x0d
    4250:	9e 85       	ldd	r25, Y+14	; 0x0e
    4252:	82 0f       	add	r24, r18
    4254:	93 1f       	adc	r25, r19
    4256:	98 87       	std	Y+8, r25	; 0x08
    4258:	8f 83       	std	Y+7, r24	; 0x07

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    425a:	eb 85       	ldd	r30, Y+11	; 0x0b
    425c:	fc 85       	ldd	r31, Y+12	; 0x0c
    425e:	22 81       	ldd	r18, Z+2	; 0x02
    4260:	33 81       	ldd	r19, Z+3	; 0x03
    4262:	8d 85       	ldd	r24, Y+13	; 0x0d
    4264:	9e 85       	ldd	r25, Y+14	; 0x0e
    4266:	a9 01       	movw	r20, r18
    4268:	48 1b       	sub	r20, r24
    426a:	59 0b       	sbc	r21, r25
    426c:	ca 01       	movw	r24, r20
    426e:	ef 81       	ldd	r30, Y+7	; 0x07
    4270:	f8 85       	ldd	r31, Y+8	; 0x08
    4272:	93 83       	std	Z+3, r25	; 0x03
    4274:	82 83       	std	Z+2, r24	; 0x02
					pxBlock->xBlockSize = xWantedSize;
    4276:	eb 85       	ldd	r30, Y+11	; 0x0b
    4278:	fc 85       	ldd	r31, Y+12	; 0x0c
    427a:	8d 85       	ldd	r24, Y+13	; 0x0d
    427c:	9e 85       	ldd	r25, Y+14	; 0x0e
    427e:	93 83       	std	Z+3, r25	; 0x03
    4280:	82 83       	std	Z+2, r24	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    4282:	ef 81       	ldd	r30, Y+7	; 0x07
    4284:	f8 85       	ldd	r31, Y+8	; 0x08
    4286:	82 81       	ldd	r24, Z+2	; 0x02
    4288:	93 81       	ldd	r25, Z+3	; 0x03
    428a:	9a 83       	std	Y+2, r25	; 0x02
    428c:	89 83       	std	Y+1, r24	; 0x01
    428e:	87 e8       	ldi	r24, 0x87	; 135
    4290:	95 e0       	ldi	r25, 0x05	; 5
    4292:	9c 83       	std	Y+4, r25	; 0x04
    4294:	8b 83       	std	Y+3, r24	; 0x03
    4296:	06 c0       	rjmp	.+12     	; 0x42a4 <pvPortMalloc+0x162>
    4298:	eb 81       	ldd	r30, Y+3	; 0x03
    429a:	fc 81       	ldd	r31, Y+4	; 0x04
    429c:	80 81       	ld	r24, Z
    429e:	91 81       	ldd	r25, Z+1	; 0x01
    42a0:	9c 83       	std	Y+4, r25	; 0x04
    42a2:	8b 83       	std	Y+3, r24	; 0x03
    42a4:	eb 81       	ldd	r30, Y+3	; 0x03
    42a6:	fc 81       	ldd	r31, Y+4	; 0x04
    42a8:	01 90       	ld	r0, Z+
    42aa:	f0 81       	ld	r31, Z
    42ac:	e0 2d       	mov	r30, r0
    42ae:	22 81       	ldd	r18, Z+2	; 0x02
    42b0:	33 81       	ldd	r19, Z+3	; 0x03
    42b2:	89 81       	ldd	r24, Y+1	; 0x01
    42b4:	9a 81       	ldd	r25, Y+2	; 0x02
    42b6:	28 17       	cp	r18, r24
    42b8:	39 07       	cpc	r19, r25
    42ba:	70 f3       	brcs	.-36     	; 0x4298 <pvPortMalloc+0x156>
    42bc:	eb 81       	ldd	r30, Y+3	; 0x03
    42be:	fc 81       	ldd	r31, Y+4	; 0x04
    42c0:	80 81       	ld	r24, Z
    42c2:	91 81       	ldd	r25, Z+1	; 0x01
    42c4:	ef 81       	ldd	r30, Y+7	; 0x07
    42c6:	f8 85       	ldd	r31, Y+8	; 0x08
    42c8:	91 83       	std	Z+1, r25	; 0x01
    42ca:	80 83       	st	Z, r24
    42cc:	eb 81       	ldd	r30, Y+3	; 0x03
    42ce:	fc 81       	ldd	r31, Y+4	; 0x04
    42d0:	8f 81       	ldd	r24, Y+7	; 0x07
    42d2:	98 85       	ldd	r25, Y+8	; 0x08
    42d4:	91 83       	std	Z+1, r25	; 0x01
    42d6:	80 83       	st	Z, r24
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
    42d8:	20 91 6e 01 	lds	r18, 0x016E
    42dc:	30 91 6f 01 	lds	r19, 0x016F
    42e0:	eb 85       	ldd	r30, Y+11	; 0x0b
    42e2:	fc 85       	ldd	r31, Y+12	; 0x0c
    42e4:	82 81       	ldd	r24, Z+2	; 0x02
    42e6:	93 81       	ldd	r25, Z+3	; 0x03
    42e8:	a9 01       	movw	r20, r18
    42ea:	48 1b       	sub	r20, r24
    42ec:	59 0b       	sbc	r21, r25
    42ee:	ca 01       	movw	r24, r20
    42f0:	90 93 6f 01 	sts	0x016F, r25
    42f4:	80 93 6e 01 	sts	0x016E, r24
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    42f8:	0e 94 71 2b 	call	0x56e2	; 0x56e2 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    42fc:	8d 81       	ldd	r24, Y+5	; 0x05
    42fe:	9e 81       	ldd	r25, Y+6	; 0x06
}
    4300:	2e 96       	adiw	r28, 0x0e	; 14
    4302:	0f b6       	in	r0, 0x3f	; 63
    4304:	f8 94       	cli
    4306:	de bf       	out	0x3e, r29	; 62
    4308:	0f be       	out	0x3f, r0	; 63
    430a:	cd bf       	out	0x3d, r28	; 61
    430c:	cf 91       	pop	r28
    430e:	df 91       	pop	r29
    4310:	08 95       	ret

00004312 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    4312:	df 93       	push	r29
    4314:	cf 93       	push	r28
    4316:	cd b7       	in	r28, 0x3d	; 61
    4318:	de b7       	in	r29, 0x3e	; 62
    431a:	2a 97       	sbiw	r28, 0x0a	; 10
    431c:	0f b6       	in	r0, 0x3f	; 63
    431e:	f8 94       	cli
    4320:	de bf       	out	0x3e, r29	; 62
    4322:	0f be       	out	0x3f, r0	; 63
    4324:	cd bf       	out	0x3d, r28	; 61
    4326:	9a 87       	std	Y+10, r25	; 0x0a
    4328:	89 87       	std	Y+9, r24	; 0x09
uint8_t *puc = ( uint8_t * ) pv;
    432a:	89 85       	ldd	r24, Y+9	; 0x09
    432c:	9a 85       	ldd	r25, Y+10	; 0x0a
    432e:	98 87       	std	Y+8, r25	; 0x08
    4330:	8f 83       	std	Y+7, r24	; 0x07
BlockLink_t *pxLink;

	if( pv != NULL )
    4332:	89 85       	ldd	r24, Y+9	; 0x09
    4334:	9a 85       	ldd	r25, Y+10	; 0x0a
    4336:	00 97       	sbiw	r24, 0x00	; 0
    4338:	09 f4       	brne	.+2      	; 0x433c <vPortFree+0x2a>
    433a:	4f c0       	rjmp	.+158    	; 0x43da <vPortFree+0xc8>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    433c:	80 91 81 01 	lds	r24, 0x0181
    4340:	90 91 82 01 	lds	r25, 0x0182
    4344:	22 27       	eor	r18, r18
    4346:	33 27       	eor	r19, r19
    4348:	28 1b       	sub	r18, r24
    434a:	39 0b       	sbc	r19, r25
    434c:	8f 81       	ldd	r24, Y+7	; 0x07
    434e:	98 85       	ldd	r25, Y+8	; 0x08
    4350:	82 0f       	add	r24, r18
    4352:	93 1f       	adc	r25, r19
    4354:	98 87       	std	Y+8, r25	; 0x08
    4356:	8f 83       	std	Y+7, r24	; 0x07

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;
    4358:	8f 81       	ldd	r24, Y+7	; 0x07
    435a:	98 85       	ldd	r25, Y+8	; 0x08
    435c:	9e 83       	std	Y+6, r25	; 0x06
    435e:	8d 83       	std	Y+5, r24	; 0x05

		vTaskSuspendAll();
    4360:	0e 94 65 2b 	call	0x56ca	; 0x56ca <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    4364:	ed 81       	ldd	r30, Y+5	; 0x05
    4366:	fe 81       	ldd	r31, Y+6	; 0x06
    4368:	82 81       	ldd	r24, Z+2	; 0x02
    436a:	93 81       	ldd	r25, Z+3	; 0x03
    436c:	9a 83       	std	Y+2, r25	; 0x02
    436e:	89 83       	std	Y+1, r24	; 0x01
    4370:	87 e8       	ldi	r24, 0x87	; 135
    4372:	95 e0       	ldi	r25, 0x05	; 5
    4374:	9c 83       	std	Y+4, r25	; 0x04
    4376:	8b 83       	std	Y+3, r24	; 0x03
    4378:	06 c0       	rjmp	.+12     	; 0x4386 <vPortFree+0x74>
    437a:	eb 81       	ldd	r30, Y+3	; 0x03
    437c:	fc 81       	ldd	r31, Y+4	; 0x04
    437e:	80 81       	ld	r24, Z
    4380:	91 81       	ldd	r25, Z+1	; 0x01
    4382:	9c 83       	std	Y+4, r25	; 0x04
    4384:	8b 83       	std	Y+3, r24	; 0x03
    4386:	eb 81       	ldd	r30, Y+3	; 0x03
    4388:	fc 81       	ldd	r31, Y+4	; 0x04
    438a:	01 90       	ld	r0, Z+
    438c:	f0 81       	ld	r31, Z
    438e:	e0 2d       	mov	r30, r0
    4390:	22 81       	ldd	r18, Z+2	; 0x02
    4392:	33 81       	ldd	r19, Z+3	; 0x03
    4394:	89 81       	ldd	r24, Y+1	; 0x01
    4396:	9a 81       	ldd	r25, Y+2	; 0x02
    4398:	28 17       	cp	r18, r24
    439a:	39 07       	cpc	r19, r25
    439c:	70 f3       	brcs	.-36     	; 0x437a <vPortFree+0x68>
    439e:	eb 81       	ldd	r30, Y+3	; 0x03
    43a0:	fc 81       	ldd	r31, Y+4	; 0x04
    43a2:	80 81       	ld	r24, Z
    43a4:	91 81       	ldd	r25, Z+1	; 0x01
    43a6:	ed 81       	ldd	r30, Y+5	; 0x05
    43a8:	fe 81       	ldd	r31, Y+6	; 0x06
    43aa:	91 83       	std	Z+1, r25	; 0x01
    43ac:	80 83       	st	Z, r24
    43ae:	eb 81       	ldd	r30, Y+3	; 0x03
    43b0:	fc 81       	ldd	r31, Y+4	; 0x04
    43b2:	8d 81       	ldd	r24, Y+5	; 0x05
    43b4:	9e 81       	ldd	r25, Y+6	; 0x06
    43b6:	91 83       	std	Z+1, r25	; 0x01
    43b8:	80 83       	st	Z, r24
			xFreeBytesRemaining += pxLink->xBlockSize;
    43ba:	ed 81       	ldd	r30, Y+5	; 0x05
    43bc:	fe 81       	ldd	r31, Y+6	; 0x06
    43be:	22 81       	ldd	r18, Z+2	; 0x02
    43c0:	33 81       	ldd	r19, Z+3	; 0x03
    43c2:	80 91 6e 01 	lds	r24, 0x016E
    43c6:	90 91 6f 01 	lds	r25, 0x016F
    43ca:	82 0f       	add	r24, r18
    43cc:	93 1f       	adc	r25, r19
    43ce:	90 93 6f 01 	sts	0x016F, r25
    43d2:	80 93 6e 01 	sts	0x016E, r24
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
    43d6:	0e 94 71 2b 	call	0x56e2	; 0x56e2 <xTaskResumeAll>
	}
}
    43da:	2a 96       	adiw	r28, 0x0a	; 10
    43dc:	0f b6       	in	r0, 0x3f	; 63
    43de:	f8 94       	cli
    43e0:	de bf       	out	0x3e, r29	; 62
    43e2:	0f be       	out	0x3f, r0	; 63
    43e4:	cd bf       	out	0x3d, r28	; 61
    43e6:	cf 91       	pop	r28
    43e8:	df 91       	pop	r29
    43ea:	08 95       	ret

000043ec <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    43ec:	df 93       	push	r29
    43ee:	cf 93       	push	r28
    43f0:	cd b7       	in	r28, 0x3d	; 61
    43f2:	de b7       	in	r29, 0x3e	; 62
	return xFreeBytesRemaining;
    43f4:	80 91 6e 01 	lds	r24, 0x016E
    43f8:	90 91 6f 01 	lds	r25, 0x016F
}
    43fc:	cf 91       	pop	r28
    43fe:	df 91       	pop	r29
    4400:	08 95       	ret

00004402 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    4402:	df 93       	push	r29
    4404:	cf 93       	push	r28
    4406:	cd b7       	in	r28, 0x3d	; 61
    4408:	de b7       	in	r29, 0x3e	; 62
	/* This just exists to keep the linker quiet. */
}
    440a:	cf 91       	pop	r28
    440c:	df 91       	pop	r29
    440e:	08 95       	ret

00004410 <prvHeapInit>:
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
    4410:	df 93       	push	r29
    4412:	cf 93       	push	r28
    4414:	00 d0       	rcall	.+0      	; 0x4416 <prvHeapInit+0x6>
    4416:	00 d0       	rcall	.+0      	; 0x4418 <prvHeapInit+0x8>
    4418:	cd b7       	in	r28, 0x3d	; 61
    441a:	de b7       	in	r29, 0x3e	; 62
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    441c:	80 ea       	ldi	r24, 0xA0	; 160
    441e:	91 e0       	ldi	r25, 0x01	; 1
    4420:	9a 83       	std	Y+2, r25	; 0x02
    4422:	89 83       	std	Y+1, r24	; 0x01

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    4424:	89 81       	ldd	r24, Y+1	; 0x01
    4426:	9a 81       	ldd	r25, Y+2	; 0x02
    4428:	90 93 88 05 	sts	0x0588, r25
    442c:	80 93 87 05 	sts	0x0587, r24
	xStart.xBlockSize = ( size_t ) 0;
    4430:	10 92 8a 05 	sts	0x058A, r1
    4434:	10 92 89 05 	sts	0x0589, r1

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
    4438:	87 ee       	ldi	r24, 0xE7	; 231
    443a:	93 e0       	ldi	r25, 0x03	; 3
    443c:	90 93 8e 05 	sts	0x058E, r25
    4440:	80 93 8d 05 	sts	0x058D, r24
	xEnd.pxNextFreeBlock = NULL;
    4444:	10 92 8c 05 	sts	0x058C, r1
    4448:	10 92 8b 05 	sts	0x058B, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
    444c:	89 81       	ldd	r24, Y+1	; 0x01
    444e:	9a 81       	ldd	r25, Y+2	; 0x02
    4450:	9c 83       	std	Y+4, r25	; 0x04
    4452:	8b 83       	std	Y+3, r24	; 0x03
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
    4454:	eb 81       	ldd	r30, Y+3	; 0x03
    4456:	fc 81       	ldd	r31, Y+4	; 0x04
    4458:	87 ee       	ldi	r24, 0xE7	; 231
    445a:	93 e0       	ldi	r25, 0x03	; 3
    445c:	93 83       	std	Z+3, r25	; 0x03
    445e:	82 83       	std	Z+2, r24	; 0x02
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
    4460:	eb 81       	ldd	r30, Y+3	; 0x03
    4462:	fc 81       	ldd	r31, Y+4	; 0x04
    4464:	8b e8       	ldi	r24, 0x8B	; 139
    4466:	95 e0       	ldi	r25, 0x05	; 5
    4468:	91 83       	std	Z+1, r25	; 0x01
    446a:	80 83       	st	Z, r24
}
    446c:	0f 90       	pop	r0
    446e:	0f 90       	pop	r0
    4470:	0f 90       	pop	r0
    4472:	0f 90       	pop	r0
    4474:	cf 91       	pop	r28
    4476:	df 91       	pop	r29
    4478:	08 95       	ret

0000447a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    447a:	df 93       	push	r29
    447c:	cf 93       	push	r28
    447e:	00 d0       	rcall	.+0      	; 0x4480 <vListInitialise+0x6>
    4480:	cd b7       	in	r28, 0x3d	; 61
    4482:	de b7       	in	r29, 0x3e	; 62
    4484:	9a 83       	std	Y+2, r25	; 0x02
    4486:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    4488:	89 81       	ldd	r24, Y+1	; 0x01
    448a:	9a 81       	ldd	r25, Y+2	; 0x02
    448c:	03 96       	adiw	r24, 0x03	; 3
    448e:	e9 81       	ldd	r30, Y+1	; 0x01
    4490:	fa 81       	ldd	r31, Y+2	; 0x02
    4492:	92 83       	std	Z+2, r25	; 0x02
    4494:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    4496:	e9 81       	ldd	r30, Y+1	; 0x01
    4498:	fa 81       	ldd	r31, Y+2	; 0x02
    449a:	8f ef       	ldi	r24, 0xFF	; 255
    449c:	9f ef       	ldi	r25, 0xFF	; 255
    449e:	94 83       	std	Z+4, r25	; 0x04
    44a0:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    44a2:	89 81       	ldd	r24, Y+1	; 0x01
    44a4:	9a 81       	ldd	r25, Y+2	; 0x02
    44a6:	03 96       	adiw	r24, 0x03	; 3
    44a8:	e9 81       	ldd	r30, Y+1	; 0x01
    44aa:	fa 81       	ldd	r31, Y+2	; 0x02
    44ac:	96 83       	std	Z+6, r25	; 0x06
    44ae:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    44b0:	89 81       	ldd	r24, Y+1	; 0x01
    44b2:	9a 81       	ldd	r25, Y+2	; 0x02
    44b4:	03 96       	adiw	r24, 0x03	; 3
    44b6:	e9 81       	ldd	r30, Y+1	; 0x01
    44b8:	fa 81       	ldd	r31, Y+2	; 0x02
    44ba:	90 87       	std	Z+8, r25	; 0x08
    44bc:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    44be:	e9 81       	ldd	r30, Y+1	; 0x01
    44c0:	fa 81       	ldd	r31, Y+2	; 0x02
    44c2:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    44c4:	0f 90       	pop	r0
    44c6:	0f 90       	pop	r0
    44c8:	cf 91       	pop	r28
    44ca:	df 91       	pop	r29
    44cc:	08 95       	ret

000044ce <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    44ce:	df 93       	push	r29
    44d0:	cf 93       	push	r28
    44d2:	00 d0       	rcall	.+0      	; 0x44d4 <vListInitialiseItem+0x6>
    44d4:	cd b7       	in	r28, 0x3d	; 61
    44d6:	de b7       	in	r29, 0x3e	; 62
    44d8:	9a 83       	std	Y+2, r25	; 0x02
    44da:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    44dc:	e9 81       	ldd	r30, Y+1	; 0x01
    44de:	fa 81       	ldd	r31, Y+2	; 0x02
    44e0:	11 86       	std	Z+9, r1	; 0x09
    44e2:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    44e4:	0f 90       	pop	r0
    44e6:	0f 90       	pop	r0
    44e8:	cf 91       	pop	r28
    44ea:	df 91       	pop	r29
    44ec:	08 95       	ret

000044ee <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    44ee:	df 93       	push	r29
    44f0:	cf 93       	push	r28
    44f2:	00 d0       	rcall	.+0      	; 0x44f4 <vListInsertEnd+0x6>
    44f4:	00 d0       	rcall	.+0      	; 0x44f6 <vListInsertEnd+0x8>
    44f6:	00 d0       	rcall	.+0      	; 0x44f8 <vListInsertEnd+0xa>
    44f8:	cd b7       	in	r28, 0x3d	; 61
    44fa:	de b7       	in	r29, 0x3e	; 62
    44fc:	9c 83       	std	Y+4, r25	; 0x04
    44fe:	8b 83       	std	Y+3, r24	; 0x03
    4500:	7e 83       	std	Y+6, r23	; 0x06
    4502:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    4504:	eb 81       	ldd	r30, Y+3	; 0x03
    4506:	fc 81       	ldd	r31, Y+4	; 0x04
    4508:	81 81       	ldd	r24, Z+1	; 0x01
    450a:	92 81       	ldd	r25, Z+2	; 0x02
    450c:	9a 83       	std	Y+2, r25	; 0x02
    450e:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    4510:	ed 81       	ldd	r30, Y+5	; 0x05
    4512:	fe 81       	ldd	r31, Y+6	; 0x06
    4514:	89 81       	ldd	r24, Y+1	; 0x01
    4516:	9a 81       	ldd	r25, Y+2	; 0x02
    4518:	93 83       	std	Z+3, r25	; 0x03
    451a:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    451c:	e9 81       	ldd	r30, Y+1	; 0x01
    451e:	fa 81       	ldd	r31, Y+2	; 0x02
    4520:	84 81       	ldd	r24, Z+4	; 0x04
    4522:	95 81       	ldd	r25, Z+5	; 0x05
    4524:	ed 81       	ldd	r30, Y+5	; 0x05
    4526:	fe 81       	ldd	r31, Y+6	; 0x06
    4528:	95 83       	std	Z+5, r25	; 0x05
    452a:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    452c:	e9 81       	ldd	r30, Y+1	; 0x01
    452e:	fa 81       	ldd	r31, Y+2	; 0x02
    4530:	04 80       	ldd	r0, Z+4	; 0x04
    4532:	f5 81       	ldd	r31, Z+5	; 0x05
    4534:	e0 2d       	mov	r30, r0
    4536:	8d 81       	ldd	r24, Y+5	; 0x05
    4538:	9e 81       	ldd	r25, Y+6	; 0x06
    453a:	93 83       	std	Z+3, r25	; 0x03
    453c:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    453e:	e9 81       	ldd	r30, Y+1	; 0x01
    4540:	fa 81       	ldd	r31, Y+2	; 0x02
    4542:	8d 81       	ldd	r24, Y+5	; 0x05
    4544:	9e 81       	ldd	r25, Y+6	; 0x06
    4546:	95 83       	std	Z+5, r25	; 0x05
    4548:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    454a:	ed 81       	ldd	r30, Y+5	; 0x05
    454c:	fe 81       	ldd	r31, Y+6	; 0x06
    454e:	8b 81       	ldd	r24, Y+3	; 0x03
    4550:	9c 81       	ldd	r25, Y+4	; 0x04
    4552:	91 87       	std	Z+9, r25	; 0x09
    4554:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    4556:	eb 81       	ldd	r30, Y+3	; 0x03
    4558:	fc 81       	ldd	r31, Y+4	; 0x04
    455a:	80 81       	ld	r24, Z
    455c:	8f 5f       	subi	r24, 0xFF	; 255
    455e:	eb 81       	ldd	r30, Y+3	; 0x03
    4560:	fc 81       	ldd	r31, Y+4	; 0x04
    4562:	80 83       	st	Z, r24
}
    4564:	26 96       	adiw	r28, 0x06	; 6
    4566:	0f b6       	in	r0, 0x3f	; 63
    4568:	f8 94       	cli
    456a:	de bf       	out	0x3e, r29	; 62
    456c:	0f be       	out	0x3f, r0	; 63
    456e:	cd bf       	out	0x3d, r28	; 61
    4570:	cf 91       	pop	r28
    4572:	df 91       	pop	r29
    4574:	08 95       	ret

00004576 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    4576:	df 93       	push	r29
    4578:	cf 93       	push	r28
    457a:	cd b7       	in	r28, 0x3d	; 61
    457c:	de b7       	in	r29, 0x3e	; 62
    457e:	28 97       	sbiw	r28, 0x08	; 8
    4580:	0f b6       	in	r0, 0x3f	; 63
    4582:	f8 94       	cli
    4584:	de bf       	out	0x3e, r29	; 62
    4586:	0f be       	out	0x3f, r0	; 63
    4588:	cd bf       	out	0x3d, r28	; 61
    458a:	9e 83       	std	Y+6, r25	; 0x06
    458c:	8d 83       	std	Y+5, r24	; 0x05
    458e:	78 87       	std	Y+8, r23	; 0x08
    4590:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    4592:	ef 81       	ldd	r30, Y+7	; 0x07
    4594:	f8 85       	ldd	r31, Y+8	; 0x08
    4596:	80 81       	ld	r24, Z
    4598:	91 81       	ldd	r25, Z+1	; 0x01
    459a:	9a 83       	std	Y+2, r25	; 0x02
    459c:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    459e:	89 81       	ldd	r24, Y+1	; 0x01
    45a0:	9a 81       	ldd	r25, Y+2	; 0x02
    45a2:	2f ef       	ldi	r18, 0xFF	; 255
    45a4:	8f 3f       	cpi	r24, 0xFF	; 255
    45a6:	92 07       	cpc	r25, r18
    45a8:	39 f4       	brne	.+14     	; 0x45b8 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    45aa:	ed 81       	ldd	r30, Y+5	; 0x05
    45ac:	fe 81       	ldd	r31, Y+6	; 0x06
    45ae:	87 81       	ldd	r24, Z+7	; 0x07
    45b0:	90 85       	ldd	r25, Z+8	; 0x08
    45b2:	9c 83       	std	Y+4, r25	; 0x04
    45b4:	8b 83       	std	Y+3, r24	; 0x03
    45b6:	18 c0       	rjmp	.+48     	; 0x45e8 <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    45b8:	8d 81       	ldd	r24, Y+5	; 0x05
    45ba:	9e 81       	ldd	r25, Y+6	; 0x06
    45bc:	03 96       	adiw	r24, 0x03	; 3
    45be:	9c 83       	std	Y+4, r25	; 0x04
    45c0:	8b 83       	std	Y+3, r24	; 0x03
    45c2:	06 c0       	rjmp	.+12     	; 0x45d0 <vListInsert+0x5a>
    45c4:	eb 81       	ldd	r30, Y+3	; 0x03
    45c6:	fc 81       	ldd	r31, Y+4	; 0x04
    45c8:	82 81       	ldd	r24, Z+2	; 0x02
    45ca:	93 81       	ldd	r25, Z+3	; 0x03
    45cc:	9c 83       	std	Y+4, r25	; 0x04
    45ce:	8b 83       	std	Y+3, r24	; 0x03
    45d0:	eb 81       	ldd	r30, Y+3	; 0x03
    45d2:	fc 81       	ldd	r31, Y+4	; 0x04
    45d4:	02 80       	ldd	r0, Z+2	; 0x02
    45d6:	f3 81       	ldd	r31, Z+3	; 0x03
    45d8:	e0 2d       	mov	r30, r0
    45da:	20 81       	ld	r18, Z
    45dc:	31 81       	ldd	r19, Z+1	; 0x01
    45de:	89 81       	ldd	r24, Y+1	; 0x01
    45e0:	9a 81       	ldd	r25, Y+2	; 0x02
    45e2:	82 17       	cp	r24, r18
    45e4:	93 07       	cpc	r25, r19
    45e6:	70 f7       	brcc	.-36     	; 0x45c4 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    45e8:	eb 81       	ldd	r30, Y+3	; 0x03
    45ea:	fc 81       	ldd	r31, Y+4	; 0x04
    45ec:	82 81       	ldd	r24, Z+2	; 0x02
    45ee:	93 81       	ldd	r25, Z+3	; 0x03
    45f0:	ef 81       	ldd	r30, Y+7	; 0x07
    45f2:	f8 85       	ldd	r31, Y+8	; 0x08
    45f4:	93 83       	std	Z+3, r25	; 0x03
    45f6:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    45f8:	ef 81       	ldd	r30, Y+7	; 0x07
    45fa:	f8 85       	ldd	r31, Y+8	; 0x08
    45fc:	02 80       	ldd	r0, Z+2	; 0x02
    45fe:	f3 81       	ldd	r31, Z+3	; 0x03
    4600:	e0 2d       	mov	r30, r0
    4602:	8f 81       	ldd	r24, Y+7	; 0x07
    4604:	98 85       	ldd	r25, Y+8	; 0x08
    4606:	95 83       	std	Z+5, r25	; 0x05
    4608:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    460a:	ef 81       	ldd	r30, Y+7	; 0x07
    460c:	f8 85       	ldd	r31, Y+8	; 0x08
    460e:	8b 81       	ldd	r24, Y+3	; 0x03
    4610:	9c 81       	ldd	r25, Y+4	; 0x04
    4612:	95 83       	std	Z+5, r25	; 0x05
    4614:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    4616:	eb 81       	ldd	r30, Y+3	; 0x03
    4618:	fc 81       	ldd	r31, Y+4	; 0x04
    461a:	8f 81       	ldd	r24, Y+7	; 0x07
    461c:	98 85       	ldd	r25, Y+8	; 0x08
    461e:	93 83       	std	Z+3, r25	; 0x03
    4620:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    4622:	ef 81       	ldd	r30, Y+7	; 0x07
    4624:	f8 85       	ldd	r31, Y+8	; 0x08
    4626:	8d 81       	ldd	r24, Y+5	; 0x05
    4628:	9e 81       	ldd	r25, Y+6	; 0x06
    462a:	91 87       	std	Z+9, r25	; 0x09
    462c:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    462e:	ed 81       	ldd	r30, Y+5	; 0x05
    4630:	fe 81       	ldd	r31, Y+6	; 0x06
    4632:	80 81       	ld	r24, Z
    4634:	8f 5f       	subi	r24, 0xFF	; 255
    4636:	ed 81       	ldd	r30, Y+5	; 0x05
    4638:	fe 81       	ldd	r31, Y+6	; 0x06
    463a:	80 83       	st	Z, r24
}
    463c:	28 96       	adiw	r28, 0x08	; 8
    463e:	0f b6       	in	r0, 0x3f	; 63
    4640:	f8 94       	cli
    4642:	de bf       	out	0x3e, r29	; 62
    4644:	0f be       	out	0x3f, r0	; 63
    4646:	cd bf       	out	0x3d, r28	; 61
    4648:	cf 91       	pop	r28
    464a:	df 91       	pop	r29
    464c:	08 95       	ret

0000464e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    464e:	df 93       	push	r29
    4650:	cf 93       	push	r28
    4652:	00 d0       	rcall	.+0      	; 0x4654 <uxListRemove+0x6>
    4654:	00 d0       	rcall	.+0      	; 0x4656 <uxListRemove+0x8>
    4656:	cd b7       	in	r28, 0x3d	; 61
    4658:	de b7       	in	r29, 0x3e	; 62
    465a:	9c 83       	std	Y+4, r25	; 0x04
    465c:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    465e:	eb 81       	ldd	r30, Y+3	; 0x03
    4660:	fc 81       	ldd	r31, Y+4	; 0x04
    4662:	80 85       	ldd	r24, Z+8	; 0x08
    4664:	91 85       	ldd	r25, Z+9	; 0x09
    4666:	9a 83       	std	Y+2, r25	; 0x02
    4668:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    466a:	eb 81       	ldd	r30, Y+3	; 0x03
    466c:	fc 81       	ldd	r31, Y+4	; 0x04
    466e:	a2 81       	ldd	r26, Z+2	; 0x02
    4670:	b3 81       	ldd	r27, Z+3	; 0x03
    4672:	eb 81       	ldd	r30, Y+3	; 0x03
    4674:	fc 81       	ldd	r31, Y+4	; 0x04
    4676:	84 81       	ldd	r24, Z+4	; 0x04
    4678:	95 81       	ldd	r25, Z+5	; 0x05
    467a:	15 96       	adiw	r26, 0x05	; 5
    467c:	9c 93       	st	X, r25
    467e:	8e 93       	st	-X, r24
    4680:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    4682:	eb 81       	ldd	r30, Y+3	; 0x03
    4684:	fc 81       	ldd	r31, Y+4	; 0x04
    4686:	a4 81       	ldd	r26, Z+4	; 0x04
    4688:	b5 81       	ldd	r27, Z+5	; 0x05
    468a:	eb 81       	ldd	r30, Y+3	; 0x03
    468c:	fc 81       	ldd	r31, Y+4	; 0x04
    468e:	82 81       	ldd	r24, Z+2	; 0x02
    4690:	93 81       	ldd	r25, Z+3	; 0x03
    4692:	13 96       	adiw	r26, 0x03	; 3
    4694:	9c 93       	st	X, r25
    4696:	8e 93       	st	-X, r24
    4698:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    469a:	e9 81       	ldd	r30, Y+1	; 0x01
    469c:	fa 81       	ldd	r31, Y+2	; 0x02
    469e:	21 81       	ldd	r18, Z+1	; 0x01
    46a0:	32 81       	ldd	r19, Z+2	; 0x02
    46a2:	8b 81       	ldd	r24, Y+3	; 0x03
    46a4:	9c 81       	ldd	r25, Y+4	; 0x04
    46a6:	28 17       	cp	r18, r24
    46a8:	39 07       	cpc	r19, r25
    46aa:	41 f4       	brne	.+16     	; 0x46bc <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    46ac:	eb 81       	ldd	r30, Y+3	; 0x03
    46ae:	fc 81       	ldd	r31, Y+4	; 0x04
    46b0:	84 81       	ldd	r24, Z+4	; 0x04
    46b2:	95 81       	ldd	r25, Z+5	; 0x05
    46b4:	e9 81       	ldd	r30, Y+1	; 0x01
    46b6:	fa 81       	ldd	r31, Y+2	; 0x02
    46b8:	92 83       	std	Z+2, r25	; 0x02
    46ba:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    46bc:	eb 81       	ldd	r30, Y+3	; 0x03
    46be:	fc 81       	ldd	r31, Y+4	; 0x04
    46c0:	11 86       	std	Z+9, r1	; 0x09
    46c2:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    46c4:	e9 81       	ldd	r30, Y+1	; 0x01
    46c6:	fa 81       	ldd	r31, Y+2	; 0x02
    46c8:	80 81       	ld	r24, Z
    46ca:	81 50       	subi	r24, 0x01	; 1
    46cc:	e9 81       	ldd	r30, Y+1	; 0x01
    46ce:	fa 81       	ldd	r31, Y+2	; 0x02
    46d0:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    46d2:	e9 81       	ldd	r30, Y+1	; 0x01
    46d4:	fa 81       	ldd	r31, Y+2	; 0x02
    46d6:	80 81       	ld	r24, Z
}
    46d8:	0f 90       	pop	r0
    46da:	0f 90       	pop	r0
    46dc:	0f 90       	pop	r0
    46de:	0f 90       	pop	r0
    46e0:	cf 91       	pop	r28
    46e2:	df 91       	pop	r29
    46e4:	08 95       	ret

000046e6 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    46e6:	df 93       	push	r29
    46e8:	cf 93       	push	r28
    46ea:	cd b7       	in	r28, 0x3d	; 61
    46ec:	de b7       	in	r29, 0x3e	; 62
    46ee:	28 97       	sbiw	r28, 0x08	; 8
    46f0:	0f b6       	in	r0, 0x3f	; 63
    46f2:	f8 94       	cli
    46f4:	de bf       	out	0x3e, r29	; 62
    46f6:	0f be       	out	0x3f, r0	; 63
    46f8:	cd bf       	out	0x3d, r28	; 61
    46fa:	9c 83       	std	Y+4, r25	; 0x04
    46fc:	8b 83       	std	Y+3, r24	; 0x03
    46fe:	7e 83       	std	Y+6, r23	; 0x06
    4700:	6d 83       	std	Y+5, r22	; 0x05
    4702:	58 87       	std	Y+8, r21	; 0x08
    4704:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    4706:	eb 81       	ldd	r30, Y+3	; 0x03
    4708:	fc 81       	ldd	r31, Y+4	; 0x04
    470a:	81 e1       	ldi	r24, 0x11	; 17
    470c:	80 83       	st	Z, r24
	pxTopOfStack--;
    470e:	8b 81       	ldd	r24, Y+3	; 0x03
    4710:	9c 81       	ldd	r25, Y+4	; 0x04
    4712:	01 97       	sbiw	r24, 0x01	; 1
    4714:	9c 83       	std	Y+4, r25	; 0x04
    4716:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    4718:	eb 81       	ldd	r30, Y+3	; 0x03
    471a:	fc 81       	ldd	r31, Y+4	; 0x04
    471c:	82 e2       	ldi	r24, 0x22	; 34
    471e:	80 83       	st	Z, r24
	pxTopOfStack--;
    4720:	8b 81       	ldd	r24, Y+3	; 0x03
    4722:	9c 81       	ldd	r25, Y+4	; 0x04
    4724:	01 97       	sbiw	r24, 0x01	; 1
    4726:	9c 83       	std	Y+4, r25	; 0x04
    4728:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    472a:	eb 81       	ldd	r30, Y+3	; 0x03
    472c:	fc 81       	ldd	r31, Y+4	; 0x04
    472e:	83 e3       	ldi	r24, 0x33	; 51
    4730:	80 83       	st	Z, r24
	pxTopOfStack--;
    4732:	8b 81       	ldd	r24, Y+3	; 0x03
    4734:	9c 81       	ldd	r25, Y+4	; 0x04
    4736:	01 97       	sbiw	r24, 0x01	; 1
    4738:	9c 83       	std	Y+4, r25	; 0x04
    473a:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    473c:	8d 81       	ldd	r24, Y+5	; 0x05
    473e:	9e 81       	ldd	r25, Y+6	; 0x06
    4740:	9a 83       	std	Y+2, r25	; 0x02
    4742:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    4744:	89 81       	ldd	r24, Y+1	; 0x01
    4746:	eb 81       	ldd	r30, Y+3	; 0x03
    4748:	fc 81       	ldd	r31, Y+4	; 0x04
    474a:	80 83       	st	Z, r24
	pxTopOfStack--;
    474c:	8b 81       	ldd	r24, Y+3	; 0x03
    474e:	9c 81       	ldd	r25, Y+4	; 0x04
    4750:	01 97       	sbiw	r24, 0x01	; 1
    4752:	9c 83       	std	Y+4, r25	; 0x04
    4754:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    4756:	89 81       	ldd	r24, Y+1	; 0x01
    4758:	9a 81       	ldd	r25, Y+2	; 0x02
    475a:	89 2f       	mov	r24, r25
    475c:	99 27       	eor	r25, r25
    475e:	9a 83       	std	Y+2, r25	; 0x02
    4760:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    4762:	89 81       	ldd	r24, Y+1	; 0x01
    4764:	eb 81       	ldd	r30, Y+3	; 0x03
    4766:	fc 81       	ldd	r31, Y+4	; 0x04
    4768:	80 83       	st	Z, r24
	pxTopOfStack--;
    476a:	8b 81       	ldd	r24, Y+3	; 0x03
    476c:	9c 81       	ldd	r25, Y+4	; 0x04
    476e:	01 97       	sbiw	r24, 0x01	; 1
    4770:	9c 83       	std	Y+4, r25	; 0x04
    4772:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    4774:	eb 81       	ldd	r30, Y+3	; 0x03
    4776:	fc 81       	ldd	r31, Y+4	; 0x04
    4778:	10 82       	st	Z, r1
	pxTopOfStack--;
    477a:	8b 81       	ldd	r24, Y+3	; 0x03
    477c:	9c 81       	ldd	r25, Y+4	; 0x04
    477e:	01 97       	sbiw	r24, 0x01	; 1
    4780:	9c 83       	std	Y+4, r25	; 0x04
    4782:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    4784:	eb 81       	ldd	r30, Y+3	; 0x03
    4786:	fc 81       	ldd	r31, Y+4	; 0x04
    4788:	80 e8       	ldi	r24, 0x80	; 128
    478a:	80 83       	st	Z, r24
	pxTopOfStack--;
    478c:	8b 81       	ldd	r24, Y+3	; 0x03
    478e:	9c 81       	ldd	r25, Y+4	; 0x04
    4790:	01 97       	sbiw	r24, 0x01	; 1
    4792:	9c 83       	std	Y+4, r25	; 0x04
    4794:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    4796:	eb 81       	ldd	r30, Y+3	; 0x03
    4798:	fc 81       	ldd	r31, Y+4	; 0x04
    479a:	10 82       	st	Z, r1
	pxTopOfStack--;
    479c:	8b 81       	ldd	r24, Y+3	; 0x03
    479e:	9c 81       	ldd	r25, Y+4	; 0x04
    47a0:	01 97       	sbiw	r24, 0x01	; 1
    47a2:	9c 83       	std	Y+4, r25	; 0x04
    47a4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    47a6:	eb 81       	ldd	r30, Y+3	; 0x03
    47a8:	fc 81       	ldd	r31, Y+4	; 0x04
    47aa:	82 e0       	ldi	r24, 0x02	; 2
    47ac:	80 83       	st	Z, r24
	pxTopOfStack--;
    47ae:	8b 81       	ldd	r24, Y+3	; 0x03
    47b0:	9c 81       	ldd	r25, Y+4	; 0x04
    47b2:	01 97       	sbiw	r24, 0x01	; 1
    47b4:	9c 83       	std	Y+4, r25	; 0x04
    47b6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    47b8:	eb 81       	ldd	r30, Y+3	; 0x03
    47ba:	fc 81       	ldd	r31, Y+4	; 0x04
    47bc:	83 e0       	ldi	r24, 0x03	; 3
    47be:	80 83       	st	Z, r24
	pxTopOfStack--;
    47c0:	8b 81       	ldd	r24, Y+3	; 0x03
    47c2:	9c 81       	ldd	r25, Y+4	; 0x04
    47c4:	01 97       	sbiw	r24, 0x01	; 1
    47c6:	9c 83       	std	Y+4, r25	; 0x04
    47c8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    47ca:	eb 81       	ldd	r30, Y+3	; 0x03
    47cc:	fc 81       	ldd	r31, Y+4	; 0x04
    47ce:	84 e0       	ldi	r24, 0x04	; 4
    47d0:	80 83       	st	Z, r24
	pxTopOfStack--;
    47d2:	8b 81       	ldd	r24, Y+3	; 0x03
    47d4:	9c 81       	ldd	r25, Y+4	; 0x04
    47d6:	01 97       	sbiw	r24, 0x01	; 1
    47d8:	9c 83       	std	Y+4, r25	; 0x04
    47da:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    47dc:	eb 81       	ldd	r30, Y+3	; 0x03
    47de:	fc 81       	ldd	r31, Y+4	; 0x04
    47e0:	85 e0       	ldi	r24, 0x05	; 5
    47e2:	80 83       	st	Z, r24
	pxTopOfStack--;
    47e4:	8b 81       	ldd	r24, Y+3	; 0x03
    47e6:	9c 81       	ldd	r25, Y+4	; 0x04
    47e8:	01 97       	sbiw	r24, 0x01	; 1
    47ea:	9c 83       	std	Y+4, r25	; 0x04
    47ec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    47ee:	eb 81       	ldd	r30, Y+3	; 0x03
    47f0:	fc 81       	ldd	r31, Y+4	; 0x04
    47f2:	86 e0       	ldi	r24, 0x06	; 6
    47f4:	80 83       	st	Z, r24
	pxTopOfStack--;
    47f6:	8b 81       	ldd	r24, Y+3	; 0x03
    47f8:	9c 81       	ldd	r25, Y+4	; 0x04
    47fa:	01 97       	sbiw	r24, 0x01	; 1
    47fc:	9c 83       	std	Y+4, r25	; 0x04
    47fe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    4800:	eb 81       	ldd	r30, Y+3	; 0x03
    4802:	fc 81       	ldd	r31, Y+4	; 0x04
    4804:	87 e0       	ldi	r24, 0x07	; 7
    4806:	80 83       	st	Z, r24
	pxTopOfStack--;
    4808:	8b 81       	ldd	r24, Y+3	; 0x03
    480a:	9c 81       	ldd	r25, Y+4	; 0x04
    480c:	01 97       	sbiw	r24, 0x01	; 1
    480e:	9c 83       	std	Y+4, r25	; 0x04
    4810:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    4812:	eb 81       	ldd	r30, Y+3	; 0x03
    4814:	fc 81       	ldd	r31, Y+4	; 0x04
    4816:	88 e0       	ldi	r24, 0x08	; 8
    4818:	80 83       	st	Z, r24
	pxTopOfStack--;
    481a:	8b 81       	ldd	r24, Y+3	; 0x03
    481c:	9c 81       	ldd	r25, Y+4	; 0x04
    481e:	01 97       	sbiw	r24, 0x01	; 1
    4820:	9c 83       	std	Y+4, r25	; 0x04
    4822:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    4824:	eb 81       	ldd	r30, Y+3	; 0x03
    4826:	fc 81       	ldd	r31, Y+4	; 0x04
    4828:	89 e0       	ldi	r24, 0x09	; 9
    482a:	80 83       	st	Z, r24
	pxTopOfStack--;
    482c:	8b 81       	ldd	r24, Y+3	; 0x03
    482e:	9c 81       	ldd	r25, Y+4	; 0x04
    4830:	01 97       	sbiw	r24, 0x01	; 1
    4832:	9c 83       	std	Y+4, r25	; 0x04
    4834:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    4836:	eb 81       	ldd	r30, Y+3	; 0x03
    4838:	fc 81       	ldd	r31, Y+4	; 0x04
    483a:	80 e1       	ldi	r24, 0x10	; 16
    483c:	80 83       	st	Z, r24
	pxTopOfStack--;
    483e:	8b 81       	ldd	r24, Y+3	; 0x03
    4840:	9c 81       	ldd	r25, Y+4	; 0x04
    4842:	01 97       	sbiw	r24, 0x01	; 1
    4844:	9c 83       	std	Y+4, r25	; 0x04
    4846:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    4848:	eb 81       	ldd	r30, Y+3	; 0x03
    484a:	fc 81       	ldd	r31, Y+4	; 0x04
    484c:	81 e1       	ldi	r24, 0x11	; 17
    484e:	80 83       	st	Z, r24
	pxTopOfStack--;
    4850:	8b 81       	ldd	r24, Y+3	; 0x03
    4852:	9c 81       	ldd	r25, Y+4	; 0x04
    4854:	01 97       	sbiw	r24, 0x01	; 1
    4856:	9c 83       	std	Y+4, r25	; 0x04
    4858:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    485a:	eb 81       	ldd	r30, Y+3	; 0x03
    485c:	fc 81       	ldd	r31, Y+4	; 0x04
    485e:	82 e1       	ldi	r24, 0x12	; 18
    4860:	80 83       	st	Z, r24
	pxTopOfStack--;
    4862:	8b 81       	ldd	r24, Y+3	; 0x03
    4864:	9c 81       	ldd	r25, Y+4	; 0x04
    4866:	01 97       	sbiw	r24, 0x01	; 1
    4868:	9c 83       	std	Y+4, r25	; 0x04
    486a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    486c:	eb 81       	ldd	r30, Y+3	; 0x03
    486e:	fc 81       	ldd	r31, Y+4	; 0x04
    4870:	83 e1       	ldi	r24, 0x13	; 19
    4872:	80 83       	st	Z, r24
	pxTopOfStack--;
    4874:	8b 81       	ldd	r24, Y+3	; 0x03
    4876:	9c 81       	ldd	r25, Y+4	; 0x04
    4878:	01 97       	sbiw	r24, 0x01	; 1
    487a:	9c 83       	std	Y+4, r25	; 0x04
    487c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    487e:	eb 81       	ldd	r30, Y+3	; 0x03
    4880:	fc 81       	ldd	r31, Y+4	; 0x04
    4882:	84 e1       	ldi	r24, 0x14	; 20
    4884:	80 83       	st	Z, r24
	pxTopOfStack--;
    4886:	8b 81       	ldd	r24, Y+3	; 0x03
    4888:	9c 81       	ldd	r25, Y+4	; 0x04
    488a:	01 97       	sbiw	r24, 0x01	; 1
    488c:	9c 83       	std	Y+4, r25	; 0x04
    488e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    4890:	eb 81       	ldd	r30, Y+3	; 0x03
    4892:	fc 81       	ldd	r31, Y+4	; 0x04
    4894:	85 e1       	ldi	r24, 0x15	; 21
    4896:	80 83       	st	Z, r24
	pxTopOfStack--;
    4898:	8b 81       	ldd	r24, Y+3	; 0x03
    489a:	9c 81       	ldd	r25, Y+4	; 0x04
    489c:	01 97       	sbiw	r24, 0x01	; 1
    489e:	9c 83       	std	Y+4, r25	; 0x04
    48a0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    48a2:	eb 81       	ldd	r30, Y+3	; 0x03
    48a4:	fc 81       	ldd	r31, Y+4	; 0x04
    48a6:	86 e1       	ldi	r24, 0x16	; 22
    48a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    48aa:	8b 81       	ldd	r24, Y+3	; 0x03
    48ac:	9c 81       	ldd	r25, Y+4	; 0x04
    48ae:	01 97       	sbiw	r24, 0x01	; 1
    48b0:	9c 83       	std	Y+4, r25	; 0x04
    48b2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    48b4:	eb 81       	ldd	r30, Y+3	; 0x03
    48b6:	fc 81       	ldd	r31, Y+4	; 0x04
    48b8:	87 e1       	ldi	r24, 0x17	; 23
    48ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    48bc:	8b 81       	ldd	r24, Y+3	; 0x03
    48be:	9c 81       	ldd	r25, Y+4	; 0x04
    48c0:	01 97       	sbiw	r24, 0x01	; 1
    48c2:	9c 83       	std	Y+4, r25	; 0x04
    48c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    48c6:	eb 81       	ldd	r30, Y+3	; 0x03
    48c8:	fc 81       	ldd	r31, Y+4	; 0x04
    48ca:	88 e1       	ldi	r24, 0x18	; 24
    48cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    48ce:	8b 81       	ldd	r24, Y+3	; 0x03
    48d0:	9c 81       	ldd	r25, Y+4	; 0x04
    48d2:	01 97       	sbiw	r24, 0x01	; 1
    48d4:	9c 83       	std	Y+4, r25	; 0x04
    48d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    48d8:	eb 81       	ldd	r30, Y+3	; 0x03
    48da:	fc 81       	ldd	r31, Y+4	; 0x04
    48dc:	89 e1       	ldi	r24, 0x19	; 25
    48de:	80 83       	st	Z, r24
	pxTopOfStack--;
    48e0:	8b 81       	ldd	r24, Y+3	; 0x03
    48e2:	9c 81       	ldd	r25, Y+4	; 0x04
    48e4:	01 97       	sbiw	r24, 0x01	; 1
    48e6:	9c 83       	std	Y+4, r25	; 0x04
    48e8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    48ea:	eb 81       	ldd	r30, Y+3	; 0x03
    48ec:	fc 81       	ldd	r31, Y+4	; 0x04
    48ee:	80 e2       	ldi	r24, 0x20	; 32
    48f0:	80 83       	st	Z, r24
	pxTopOfStack--;
    48f2:	8b 81       	ldd	r24, Y+3	; 0x03
    48f4:	9c 81       	ldd	r25, Y+4	; 0x04
    48f6:	01 97       	sbiw	r24, 0x01	; 1
    48f8:	9c 83       	std	Y+4, r25	; 0x04
    48fa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    48fc:	eb 81       	ldd	r30, Y+3	; 0x03
    48fe:	fc 81       	ldd	r31, Y+4	; 0x04
    4900:	81 e2       	ldi	r24, 0x21	; 33
    4902:	80 83       	st	Z, r24
	pxTopOfStack--;
    4904:	8b 81       	ldd	r24, Y+3	; 0x03
    4906:	9c 81       	ldd	r25, Y+4	; 0x04
    4908:	01 97       	sbiw	r24, 0x01	; 1
    490a:	9c 83       	std	Y+4, r25	; 0x04
    490c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    490e:	eb 81       	ldd	r30, Y+3	; 0x03
    4910:	fc 81       	ldd	r31, Y+4	; 0x04
    4912:	82 e2       	ldi	r24, 0x22	; 34
    4914:	80 83       	st	Z, r24
	pxTopOfStack--;
    4916:	8b 81       	ldd	r24, Y+3	; 0x03
    4918:	9c 81       	ldd	r25, Y+4	; 0x04
    491a:	01 97       	sbiw	r24, 0x01	; 1
    491c:	9c 83       	std	Y+4, r25	; 0x04
    491e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    4920:	eb 81       	ldd	r30, Y+3	; 0x03
    4922:	fc 81       	ldd	r31, Y+4	; 0x04
    4924:	83 e2       	ldi	r24, 0x23	; 35
    4926:	80 83       	st	Z, r24
	pxTopOfStack--;
    4928:	8b 81       	ldd	r24, Y+3	; 0x03
    492a:	9c 81       	ldd	r25, Y+4	; 0x04
    492c:	01 97       	sbiw	r24, 0x01	; 1
    492e:	9c 83       	std	Y+4, r25	; 0x04
    4930:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    4932:	8f 81       	ldd	r24, Y+7	; 0x07
    4934:	98 85       	ldd	r25, Y+8	; 0x08
    4936:	9a 83       	std	Y+2, r25	; 0x02
    4938:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    493a:	89 81       	ldd	r24, Y+1	; 0x01
    493c:	eb 81       	ldd	r30, Y+3	; 0x03
    493e:	fc 81       	ldd	r31, Y+4	; 0x04
    4940:	80 83       	st	Z, r24
	pxTopOfStack--;
    4942:	8b 81       	ldd	r24, Y+3	; 0x03
    4944:	9c 81       	ldd	r25, Y+4	; 0x04
    4946:	01 97       	sbiw	r24, 0x01	; 1
    4948:	9c 83       	std	Y+4, r25	; 0x04
    494a:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    494c:	89 81       	ldd	r24, Y+1	; 0x01
    494e:	9a 81       	ldd	r25, Y+2	; 0x02
    4950:	89 2f       	mov	r24, r25
    4952:	99 27       	eor	r25, r25
    4954:	9a 83       	std	Y+2, r25	; 0x02
    4956:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    4958:	89 81       	ldd	r24, Y+1	; 0x01
    495a:	eb 81       	ldd	r30, Y+3	; 0x03
    495c:	fc 81       	ldd	r31, Y+4	; 0x04
    495e:	80 83       	st	Z, r24
	pxTopOfStack--;
    4960:	8b 81       	ldd	r24, Y+3	; 0x03
    4962:	9c 81       	ldd	r25, Y+4	; 0x04
    4964:	01 97       	sbiw	r24, 0x01	; 1
    4966:	9c 83       	std	Y+4, r25	; 0x04
    4968:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    496a:	eb 81       	ldd	r30, Y+3	; 0x03
    496c:	fc 81       	ldd	r31, Y+4	; 0x04
    496e:	86 e2       	ldi	r24, 0x26	; 38
    4970:	80 83       	st	Z, r24
	pxTopOfStack--;
    4972:	8b 81       	ldd	r24, Y+3	; 0x03
    4974:	9c 81       	ldd	r25, Y+4	; 0x04
    4976:	01 97       	sbiw	r24, 0x01	; 1
    4978:	9c 83       	std	Y+4, r25	; 0x04
    497a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    497c:	eb 81       	ldd	r30, Y+3	; 0x03
    497e:	fc 81       	ldd	r31, Y+4	; 0x04
    4980:	87 e2       	ldi	r24, 0x27	; 39
    4982:	80 83       	st	Z, r24
	pxTopOfStack--;
    4984:	8b 81       	ldd	r24, Y+3	; 0x03
    4986:	9c 81       	ldd	r25, Y+4	; 0x04
    4988:	01 97       	sbiw	r24, 0x01	; 1
    498a:	9c 83       	std	Y+4, r25	; 0x04
    498c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    498e:	eb 81       	ldd	r30, Y+3	; 0x03
    4990:	fc 81       	ldd	r31, Y+4	; 0x04
    4992:	88 e2       	ldi	r24, 0x28	; 40
    4994:	80 83       	st	Z, r24
	pxTopOfStack--;
    4996:	8b 81       	ldd	r24, Y+3	; 0x03
    4998:	9c 81       	ldd	r25, Y+4	; 0x04
    499a:	01 97       	sbiw	r24, 0x01	; 1
    499c:	9c 83       	std	Y+4, r25	; 0x04
    499e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    49a0:	eb 81       	ldd	r30, Y+3	; 0x03
    49a2:	fc 81       	ldd	r31, Y+4	; 0x04
    49a4:	89 e2       	ldi	r24, 0x29	; 41
    49a6:	80 83       	st	Z, r24
	pxTopOfStack--;
    49a8:	8b 81       	ldd	r24, Y+3	; 0x03
    49aa:	9c 81       	ldd	r25, Y+4	; 0x04
    49ac:	01 97       	sbiw	r24, 0x01	; 1
    49ae:	9c 83       	std	Y+4, r25	; 0x04
    49b0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    49b2:	eb 81       	ldd	r30, Y+3	; 0x03
    49b4:	fc 81       	ldd	r31, Y+4	; 0x04
    49b6:	80 e3       	ldi	r24, 0x30	; 48
    49b8:	80 83       	st	Z, r24
	pxTopOfStack--;
    49ba:	8b 81       	ldd	r24, Y+3	; 0x03
    49bc:	9c 81       	ldd	r25, Y+4	; 0x04
    49be:	01 97       	sbiw	r24, 0x01	; 1
    49c0:	9c 83       	std	Y+4, r25	; 0x04
    49c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    49c4:	eb 81       	ldd	r30, Y+3	; 0x03
    49c6:	fc 81       	ldd	r31, Y+4	; 0x04
    49c8:	81 e3       	ldi	r24, 0x31	; 49
    49ca:	80 83       	st	Z, r24
	pxTopOfStack--;
    49cc:	8b 81       	ldd	r24, Y+3	; 0x03
    49ce:	9c 81       	ldd	r25, Y+4	; 0x04
    49d0:	01 97       	sbiw	r24, 0x01	; 1
    49d2:	9c 83       	std	Y+4, r25	; 0x04
    49d4:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    49d6:	8b 81       	ldd	r24, Y+3	; 0x03
    49d8:	9c 81       	ldd	r25, Y+4	; 0x04
}
    49da:	28 96       	adiw	r28, 0x08	; 8
    49dc:	0f b6       	in	r0, 0x3f	; 63
    49de:	f8 94       	cli
    49e0:	de bf       	out	0x3e, r29	; 62
    49e2:	0f be       	out	0x3f, r0	; 63
    49e4:	cd bf       	out	0x3d, r28	; 61
    49e6:	cf 91       	pop	r28
    49e8:	df 91       	pop	r29
    49ea:	08 95       	ret

000049ec <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    49ec:	df 93       	push	r29
    49ee:	cf 93       	push	r28
    49f0:	cd b7       	in	r28, 0x3d	; 61
    49f2:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    49f4:	0e 94 e8 25 	call	0x4bd0	; 0x4bd0 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    49f8:	a0 91 8f 05 	lds	r26, 0x058F
    49fc:	b0 91 90 05 	lds	r27, 0x0590
    4a00:	cd 91       	ld	r28, X+
    4a02:	cd bf       	out	0x3d, r28	; 61
    4a04:	dd 91       	ld	r29, X+
    4a06:	de bf       	out	0x3e, r29	; 62
    4a08:	ff 91       	pop	r31
    4a0a:	ef 91       	pop	r30
    4a0c:	df 91       	pop	r29
    4a0e:	cf 91       	pop	r28
    4a10:	bf 91       	pop	r27
    4a12:	af 91       	pop	r26
    4a14:	9f 91       	pop	r25
    4a16:	8f 91       	pop	r24
    4a18:	7f 91       	pop	r23
    4a1a:	6f 91       	pop	r22
    4a1c:	5f 91       	pop	r21
    4a1e:	4f 91       	pop	r20
    4a20:	3f 91       	pop	r19
    4a22:	2f 91       	pop	r18
    4a24:	1f 91       	pop	r17
    4a26:	0f 91       	pop	r16
    4a28:	ff 90       	pop	r15
    4a2a:	ef 90       	pop	r14
    4a2c:	df 90       	pop	r13
    4a2e:	cf 90       	pop	r12
    4a30:	bf 90       	pop	r11
    4a32:	af 90       	pop	r10
    4a34:	9f 90       	pop	r9
    4a36:	8f 90       	pop	r8
    4a38:	7f 90       	pop	r7
    4a3a:	6f 90       	pop	r6
    4a3c:	5f 90       	pop	r5
    4a3e:	4f 90       	pop	r4
    4a40:	3f 90       	pop	r3
    4a42:	2f 90       	pop	r2
    4a44:	1f 90       	pop	r1
    4a46:	0f 90       	pop	r0
    4a48:	0f be       	out	0x3f, r0	; 63
    4a4a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    4a4c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    4a4e:	81 e0       	ldi	r24, 0x01	; 1
}
    4a50:	cf 91       	pop	r28
    4a52:	df 91       	pop	r29
    4a54:	08 95       	ret

00004a56 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    4a56:	df 93       	push	r29
    4a58:	cf 93       	push	r28
    4a5a:	cd b7       	in	r28, 0x3d	; 61
    4a5c:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    4a5e:	cf 91       	pop	r28
    4a60:	df 91       	pop	r29
    4a62:	08 95       	ret

00004a64 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    4a64:	0f 92       	push	r0
    4a66:	0f b6       	in	r0, 0x3f	; 63
    4a68:	f8 94       	cli
    4a6a:	0f 92       	push	r0
    4a6c:	1f 92       	push	r1
    4a6e:	11 24       	eor	r1, r1
    4a70:	2f 92       	push	r2
    4a72:	3f 92       	push	r3
    4a74:	4f 92       	push	r4
    4a76:	5f 92       	push	r5
    4a78:	6f 92       	push	r6
    4a7a:	7f 92       	push	r7
    4a7c:	8f 92       	push	r8
    4a7e:	9f 92       	push	r9
    4a80:	af 92       	push	r10
    4a82:	bf 92       	push	r11
    4a84:	cf 92       	push	r12
    4a86:	df 92       	push	r13
    4a88:	ef 92       	push	r14
    4a8a:	ff 92       	push	r15
    4a8c:	0f 93       	push	r16
    4a8e:	1f 93       	push	r17
    4a90:	2f 93       	push	r18
    4a92:	3f 93       	push	r19
    4a94:	4f 93       	push	r20
    4a96:	5f 93       	push	r21
    4a98:	6f 93       	push	r22
    4a9a:	7f 93       	push	r23
    4a9c:	8f 93       	push	r24
    4a9e:	9f 93       	push	r25
    4aa0:	af 93       	push	r26
    4aa2:	bf 93       	push	r27
    4aa4:	cf 93       	push	r28
    4aa6:	df 93       	push	r29
    4aa8:	ef 93       	push	r30
    4aaa:	ff 93       	push	r31
    4aac:	a0 91 8f 05 	lds	r26, 0x058F
    4ab0:	b0 91 90 05 	lds	r27, 0x0590
    4ab4:	0d b6       	in	r0, 0x3d	; 61
    4ab6:	0d 92       	st	X+, r0
    4ab8:	0e b6       	in	r0, 0x3e	; 62
    4aba:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    4abc:	0e 94 2d 2d 	call	0x5a5a	; 0x5a5a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    4ac0:	a0 91 8f 05 	lds	r26, 0x058F
    4ac4:	b0 91 90 05 	lds	r27, 0x0590
    4ac8:	cd 91       	ld	r28, X+
    4aca:	cd bf       	out	0x3d, r28	; 61
    4acc:	dd 91       	ld	r29, X+
    4ace:	de bf       	out	0x3e, r29	; 62
    4ad0:	ff 91       	pop	r31
    4ad2:	ef 91       	pop	r30
    4ad4:	df 91       	pop	r29
    4ad6:	cf 91       	pop	r28
    4ad8:	bf 91       	pop	r27
    4ada:	af 91       	pop	r26
    4adc:	9f 91       	pop	r25
    4ade:	8f 91       	pop	r24
    4ae0:	7f 91       	pop	r23
    4ae2:	6f 91       	pop	r22
    4ae4:	5f 91       	pop	r21
    4ae6:	4f 91       	pop	r20
    4ae8:	3f 91       	pop	r19
    4aea:	2f 91       	pop	r18
    4aec:	1f 91       	pop	r17
    4aee:	0f 91       	pop	r16
    4af0:	ff 90       	pop	r15
    4af2:	ef 90       	pop	r14
    4af4:	df 90       	pop	r13
    4af6:	cf 90       	pop	r12
    4af8:	bf 90       	pop	r11
    4afa:	af 90       	pop	r10
    4afc:	9f 90       	pop	r9
    4afe:	8f 90       	pop	r8
    4b00:	7f 90       	pop	r7
    4b02:	6f 90       	pop	r6
    4b04:	5f 90       	pop	r5
    4b06:	4f 90       	pop	r4
    4b08:	3f 90       	pop	r3
    4b0a:	2f 90       	pop	r2
    4b0c:	1f 90       	pop	r1
    4b0e:	0f 90       	pop	r0
    4b10:	0f be       	out	0x3f, r0	; 63
    4b12:	0f 90       	pop	r0

	asm volatile ( "ret" );
    4b14:	08 95       	ret

00004b16 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    4b16:	0f 92       	push	r0
    4b18:	0f b6       	in	r0, 0x3f	; 63
    4b1a:	f8 94       	cli
    4b1c:	0f 92       	push	r0
    4b1e:	1f 92       	push	r1
    4b20:	11 24       	eor	r1, r1
    4b22:	2f 92       	push	r2
    4b24:	3f 92       	push	r3
    4b26:	4f 92       	push	r4
    4b28:	5f 92       	push	r5
    4b2a:	6f 92       	push	r6
    4b2c:	7f 92       	push	r7
    4b2e:	8f 92       	push	r8
    4b30:	9f 92       	push	r9
    4b32:	af 92       	push	r10
    4b34:	bf 92       	push	r11
    4b36:	cf 92       	push	r12
    4b38:	df 92       	push	r13
    4b3a:	ef 92       	push	r14
    4b3c:	ff 92       	push	r15
    4b3e:	0f 93       	push	r16
    4b40:	1f 93       	push	r17
    4b42:	2f 93       	push	r18
    4b44:	3f 93       	push	r19
    4b46:	4f 93       	push	r20
    4b48:	5f 93       	push	r21
    4b4a:	6f 93       	push	r22
    4b4c:	7f 93       	push	r23
    4b4e:	8f 93       	push	r24
    4b50:	9f 93       	push	r25
    4b52:	af 93       	push	r26
    4b54:	bf 93       	push	r27
    4b56:	cf 93       	push	r28
    4b58:	df 93       	push	r29
    4b5a:	ef 93       	push	r30
    4b5c:	ff 93       	push	r31
    4b5e:	a0 91 8f 05 	lds	r26, 0x058F
    4b62:	b0 91 90 05 	lds	r27, 0x0590
    4b66:	0d b6       	in	r0, 0x3d	; 61
    4b68:	0d 92       	st	X+, r0
    4b6a:	0e b6       	in	r0, 0x3e	; 62
    4b6c:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    4b6e:	0e 94 61 2c 	call	0x58c2	; 0x58c2 <xTaskIncrementTick>
    4b72:	88 23       	and	r24, r24
    4b74:	11 f0       	breq	.+4      	; 0x4b7a <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    4b76:	0e 94 2d 2d 	call	0x5a5a	; 0x5a5a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    4b7a:	a0 91 8f 05 	lds	r26, 0x058F
    4b7e:	b0 91 90 05 	lds	r27, 0x0590
    4b82:	cd 91       	ld	r28, X+
    4b84:	cd bf       	out	0x3d, r28	; 61
    4b86:	dd 91       	ld	r29, X+
    4b88:	de bf       	out	0x3e, r29	; 62
    4b8a:	ff 91       	pop	r31
    4b8c:	ef 91       	pop	r30
    4b8e:	df 91       	pop	r29
    4b90:	cf 91       	pop	r28
    4b92:	bf 91       	pop	r27
    4b94:	af 91       	pop	r26
    4b96:	9f 91       	pop	r25
    4b98:	8f 91       	pop	r24
    4b9a:	7f 91       	pop	r23
    4b9c:	6f 91       	pop	r22
    4b9e:	5f 91       	pop	r21
    4ba0:	4f 91       	pop	r20
    4ba2:	3f 91       	pop	r19
    4ba4:	2f 91       	pop	r18
    4ba6:	1f 91       	pop	r17
    4ba8:	0f 91       	pop	r16
    4baa:	ff 90       	pop	r15
    4bac:	ef 90       	pop	r14
    4bae:	df 90       	pop	r13
    4bb0:	cf 90       	pop	r12
    4bb2:	bf 90       	pop	r11
    4bb4:	af 90       	pop	r10
    4bb6:	9f 90       	pop	r9
    4bb8:	8f 90       	pop	r8
    4bba:	7f 90       	pop	r7
    4bbc:	6f 90       	pop	r6
    4bbe:	5f 90       	pop	r5
    4bc0:	4f 90       	pop	r4
    4bc2:	3f 90       	pop	r3
    4bc4:	2f 90       	pop	r2
    4bc6:	1f 90       	pop	r1
    4bc8:	0f 90       	pop	r0
    4bca:	0f be       	out	0x3f, r0	; 63
    4bcc:	0f 90       	pop	r0

	asm volatile ( "ret" );
    4bce:	08 95       	ret

00004bd0 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    4bd0:	df 93       	push	r29
    4bd2:	cf 93       	push	r28
    4bd4:	00 d0       	rcall	.+0      	; 0x4bd6 <prvSetupTimerInterrupt+0x6>
    4bd6:	00 d0       	rcall	.+0      	; 0x4bd8 <prvSetupTimerInterrupt+0x8>
    4bd8:	00 d0       	rcall	.+0      	; 0x4bda <prvSetupTimerInterrupt+0xa>
    4bda:	cd b7       	in	r28, 0x3d	; 61
    4bdc:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    4bde:	80 e8       	ldi	r24, 0x80	; 128
    4be0:	9e e3       	ldi	r25, 0x3E	; 62
    4be2:	a0 e0       	ldi	r26, 0x00	; 0
    4be4:	b0 e0       	ldi	r27, 0x00	; 0
    4be6:	8b 83       	std	Y+3, r24	; 0x03
    4be8:	9c 83       	std	Y+4, r25	; 0x04
    4bea:	ad 83       	std	Y+5, r26	; 0x05
    4bec:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    4bee:	8b 81       	ldd	r24, Y+3	; 0x03
    4bf0:	9c 81       	ldd	r25, Y+4	; 0x04
    4bf2:	ad 81       	ldd	r26, Y+5	; 0x05
    4bf4:	be 81       	ldd	r27, Y+6	; 0x06
    4bf6:	68 94       	set
    4bf8:	15 f8       	bld	r1, 5
    4bfa:	b6 95       	lsr	r27
    4bfc:	a7 95       	ror	r26
    4bfe:	97 95       	ror	r25
    4c00:	87 95       	ror	r24
    4c02:	16 94       	lsr	r1
    4c04:	d1 f7       	brne	.-12     	; 0x4bfa <prvSetupTimerInterrupt+0x2a>
    4c06:	8b 83       	std	Y+3, r24	; 0x03
    4c08:	9c 83       	std	Y+4, r25	; 0x04
    4c0a:	ad 83       	std	Y+5, r26	; 0x05
    4c0c:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    4c0e:	8b 81       	ldd	r24, Y+3	; 0x03
    4c10:	9c 81       	ldd	r25, Y+4	; 0x04
    4c12:	ad 81       	ldd	r26, Y+5	; 0x05
    4c14:	be 81       	ldd	r27, Y+6	; 0x06
    4c16:	01 97       	sbiw	r24, 0x01	; 1
    4c18:	a1 09       	sbc	r26, r1
    4c1a:	b1 09       	sbc	r27, r1
    4c1c:	8b 83       	std	Y+3, r24	; 0x03
    4c1e:	9c 83       	std	Y+4, r25	; 0x04
    4c20:	ad 83       	std	Y+5, r26	; 0x05
    4c22:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    4c24:	8b 81       	ldd	r24, Y+3	; 0x03
    4c26:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    4c28:	8b 81       	ldd	r24, Y+3	; 0x03
    4c2a:	9c 81       	ldd	r25, Y+4	; 0x04
    4c2c:	ad 81       	ldd	r26, Y+5	; 0x05
    4c2e:	be 81       	ldd	r27, Y+6	; 0x06
    4c30:	89 2f       	mov	r24, r25
    4c32:	9a 2f       	mov	r25, r26
    4c34:	ab 2f       	mov	r26, r27
    4c36:	bb 27       	eor	r27, r27
    4c38:	8b 83       	std	Y+3, r24	; 0x03
    4c3a:	9c 83       	std	Y+4, r25	; 0x04
    4c3c:	ad 83       	std	Y+5, r26	; 0x05
    4c3e:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    4c40:	8b 81       	ldd	r24, Y+3	; 0x03
    4c42:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    4c44:	eb e4       	ldi	r30, 0x4B	; 75
    4c46:	f0 e0       	ldi	r31, 0x00	; 0
    4c48:	8a 81       	ldd	r24, Y+2	; 0x02
    4c4a:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    4c4c:	ea e4       	ldi	r30, 0x4A	; 74
    4c4e:	f0 e0       	ldi	r31, 0x00	; 0
    4c50:	89 81       	ldd	r24, Y+1	; 0x01
    4c52:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    4c54:	8b e0       	ldi	r24, 0x0B	; 11
    4c56:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    4c58:	ee e4       	ldi	r30, 0x4E	; 78
    4c5a:	f0 e0       	ldi	r31, 0x00	; 0
    4c5c:	89 81       	ldd	r24, Y+1	; 0x01
    4c5e:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    4c60:	e9 e5       	ldi	r30, 0x59	; 89
    4c62:	f0 e0       	ldi	r31, 0x00	; 0
    4c64:	80 81       	ld	r24, Z
    4c66:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    4c68:	89 81       	ldd	r24, Y+1	; 0x01
    4c6a:	80 61       	ori	r24, 0x10	; 16
    4c6c:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    4c6e:	e9 e5       	ldi	r30, 0x59	; 89
    4c70:	f0 e0       	ldi	r31, 0x00	; 0
    4c72:	89 81       	ldd	r24, Y+1	; 0x01
    4c74:	80 83       	st	Z, r24
}
    4c76:	26 96       	adiw	r28, 0x06	; 6
    4c78:	0f b6       	in	r0, 0x3f	; 63
    4c7a:	f8 94       	cli
    4c7c:	de bf       	out	0x3e, r29	; 62
    4c7e:	0f be       	out	0x3f, r0	; 63
    4c80:	cd bf       	out	0x3d, r28	; 61
    4c82:	cf 91       	pop	r28
    4c84:	df 91       	pop	r29
    4c86:	08 95       	ret

00004c88 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    4c88:	0e 94 8b 25 	call	0x4b16	; 0x4b16 <vPortYieldFromTick>
		asm volatile ( "reti" );
    4c8c:	18 95       	reti

00004c8e <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    4c8e:	8f 92       	push	r8
    4c90:	9f 92       	push	r9
    4c92:	af 92       	push	r10
    4c94:	bf 92       	push	r11
    4c96:	cf 92       	push	r12
    4c98:	df 92       	push	r13
    4c9a:	ef 92       	push	r14
    4c9c:	ff 92       	push	r15
    4c9e:	0f 93       	push	r16
    4ca0:	1f 93       	push	r17
    4ca2:	df 93       	push	r29
    4ca4:	cf 93       	push	r28
    4ca6:	cd b7       	in	r28, 0x3d	; 61
    4ca8:	de b7       	in	r29, 0x3e	; 62
    4caa:	60 97       	sbiw	r28, 0x10	; 16
    4cac:	0f b6       	in	r0, 0x3f	; 63
    4cae:	f8 94       	cli
    4cb0:	de bf       	out	0x3e, r29	; 62
    4cb2:	0f be       	out	0x3f, r0	; 63
    4cb4:	cd bf       	out	0x3d, r28	; 61
    4cb6:	9f 83       	std	Y+7, r25	; 0x07
    4cb8:	8e 83       	std	Y+6, r24	; 0x06
    4cba:	79 87       	std	Y+9, r23	; 0x09
    4cbc:	68 87       	std	Y+8, r22	; 0x08
    4cbe:	5b 87       	std	Y+11, r21	; 0x0b
    4cc0:	4a 87       	std	Y+10, r20	; 0x0a
    4cc2:	3d 87       	std	Y+13, r19	; 0x0d
    4cc4:	2c 87       	std	Y+12, r18	; 0x0c
    4cc6:	0e 87       	std	Y+14, r16	; 0x0e
    4cc8:	f8 8a       	std	Y+16, r15	; 0x10
    4cca:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4ccc:	8a 85       	ldd	r24, Y+10	; 0x0a
    4cce:	9b 85       	ldd	r25, Y+11	; 0x0b
    4cd0:	0e 94 a1 20 	call	0x4142	; 0x4142 <pvPortMalloc>
    4cd4:	9a 83       	std	Y+2, r25	; 0x02
    4cd6:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    4cd8:	89 81       	ldd	r24, Y+1	; 0x01
    4cda:	9a 81       	ldd	r25, Y+2	; 0x02
    4cdc:	00 97       	sbiw	r24, 0x00	; 0
    4cde:	b1 f0       	breq	.+44     	; 0x4d0c <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    4ce0:	88 e2       	ldi	r24, 0x28	; 40
    4ce2:	90 e0       	ldi	r25, 0x00	; 0
    4ce4:	0e 94 a1 20 	call	0x4142	; 0x4142 <pvPortMalloc>
    4ce8:	9d 83       	std	Y+5, r25	; 0x05
    4cea:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    4cec:	8c 81       	ldd	r24, Y+4	; 0x04
    4cee:	9d 81       	ldd	r25, Y+5	; 0x05
    4cf0:	00 97       	sbiw	r24, 0x00	; 0
    4cf2:	39 f0       	breq	.+14     	; 0x4d02 <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    4cf4:	ec 81       	ldd	r30, Y+4	; 0x04
    4cf6:	fd 81       	ldd	r31, Y+5	; 0x05
    4cf8:	89 81       	ldd	r24, Y+1	; 0x01
    4cfa:	9a 81       	ldd	r25, Y+2	; 0x02
    4cfc:	90 8f       	std	Z+24, r25	; 0x18
    4cfe:	87 8b       	std	Z+23, r24	; 0x17
    4d00:	07 c0       	rjmp	.+14     	; 0x4d10 <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    4d02:	89 81       	ldd	r24, Y+1	; 0x01
    4d04:	9a 81       	ldd	r25, Y+2	; 0x02
    4d06:	0e 94 89 21 	call	0x4312	; 0x4312 <vPortFree>
    4d0a:	02 c0       	rjmp	.+4      	; 0x4d10 <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    4d0c:	1d 82       	std	Y+5, r1	; 0x05
    4d0e:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    4d10:	8c 81       	ldd	r24, Y+4	; 0x04
    4d12:	9d 81       	ldd	r25, Y+5	; 0x05
    4d14:	00 97       	sbiw	r24, 0x00	; 0
    4d16:	e9 f0       	breq	.+58     	; 0x4d52 <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    4d18:	8a 85       	ldd	r24, Y+10	; 0x0a
    4d1a:	9b 85       	ldd	r25, Y+11	; 0x0b
    4d1c:	9c 01       	movw	r18, r24
    4d1e:	40 e0       	ldi	r20, 0x00	; 0
    4d20:	50 e0       	ldi	r21, 0x00	; 0
    4d22:	8e 81       	ldd	r24, Y+6	; 0x06
    4d24:	9f 81       	ldd	r25, Y+7	; 0x07
    4d26:	68 85       	ldd	r22, Y+8	; 0x08
    4d28:	79 85       	ldd	r23, Y+9	; 0x09
    4d2a:	ec 85       	ldd	r30, Y+12	; 0x0c
    4d2c:	fd 85       	ldd	r31, Y+13	; 0x0d
    4d2e:	af 85       	ldd	r26, Y+15	; 0x0f
    4d30:	b8 89       	ldd	r27, Y+16	; 0x10
    4d32:	ac 80       	ldd	r10, Y+4	; 0x04
    4d34:	bd 80       	ldd	r11, Y+5	; 0x05
    4d36:	8f 01       	movw	r16, r30
    4d38:	ee 84       	ldd	r14, Y+14	; 0x0e
    4d3a:	6d 01       	movw	r12, r26
    4d3c:	88 24       	eor	r8, r8
    4d3e:	99 24       	eor	r9, r9
    4d40:	0e 94 bf 26 	call	0x4d7e	; 0x4d7e <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    4d44:	8c 81       	ldd	r24, Y+4	; 0x04
    4d46:	9d 81       	ldd	r25, Y+5	; 0x05
    4d48:	0e 94 7a 27 	call	0x4ef4	; 0x4ef4 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    4d4c:	81 e0       	ldi	r24, 0x01	; 1
    4d4e:	8b 83       	std	Y+3, r24	; 0x03
    4d50:	02 c0       	rjmp	.+4      	; 0x4d56 <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    4d52:	8f ef       	ldi	r24, 0xFF	; 255
    4d54:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    4d56:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    4d58:	60 96       	adiw	r28, 0x10	; 16
    4d5a:	0f b6       	in	r0, 0x3f	; 63
    4d5c:	f8 94       	cli
    4d5e:	de bf       	out	0x3e, r29	; 62
    4d60:	0f be       	out	0x3f, r0	; 63
    4d62:	cd bf       	out	0x3d, r28	; 61
    4d64:	cf 91       	pop	r28
    4d66:	df 91       	pop	r29
    4d68:	1f 91       	pop	r17
    4d6a:	0f 91       	pop	r16
    4d6c:	ff 90       	pop	r15
    4d6e:	ef 90       	pop	r14
    4d70:	df 90       	pop	r13
    4d72:	cf 90       	pop	r12
    4d74:	bf 90       	pop	r11
    4d76:	af 90       	pop	r10
    4d78:	9f 90       	pop	r9
    4d7a:	8f 90       	pop	r8
    4d7c:	08 95       	ret

00004d7e <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    4d7e:	8f 92       	push	r8
    4d80:	9f 92       	push	r9
    4d82:	af 92       	push	r10
    4d84:	bf 92       	push	r11
    4d86:	cf 92       	push	r12
    4d88:	df 92       	push	r13
    4d8a:	ef 92       	push	r14
    4d8c:	0f 93       	push	r16
    4d8e:	1f 93       	push	r17
    4d90:	df 93       	push	r29
    4d92:	cf 93       	push	r28
    4d94:	cd b7       	in	r28, 0x3d	; 61
    4d96:	de b7       	in	r29, 0x3e	; 62
    4d98:	64 97       	sbiw	r28, 0x14	; 20
    4d9a:	0f b6       	in	r0, 0x3f	; 63
    4d9c:	f8 94       	cli
    4d9e:	de bf       	out	0x3e, r29	; 62
    4da0:	0f be       	out	0x3f, r0	; 63
    4da2:	cd bf       	out	0x3d, r28	; 61
    4da4:	9d 83       	std	Y+5, r25	; 0x05
    4da6:	8c 83       	std	Y+4, r24	; 0x04
    4da8:	7f 83       	std	Y+7, r23	; 0x07
    4daa:	6e 83       	std	Y+6, r22	; 0x06
    4dac:	28 87       	std	Y+8, r18	; 0x08
    4dae:	39 87       	std	Y+9, r19	; 0x09
    4db0:	4a 87       	std	Y+10, r20	; 0x0a
    4db2:	5b 87       	std	Y+11, r21	; 0x0b
    4db4:	1d 87       	std	Y+13, r17	; 0x0d
    4db6:	0c 87       	std	Y+12, r16	; 0x0c
    4db8:	ee 86       	std	Y+14, r14	; 0x0e
    4dba:	d8 8a       	std	Y+16, r13	; 0x10
    4dbc:	cf 86       	std	Y+15, r12	; 0x0f
    4dbe:	ba 8a       	std	Y+18, r11	; 0x12
    4dc0:	a9 8a       	std	Y+17, r10	; 0x11
    4dc2:	9c 8a       	std	Y+20, r9	; 0x14
    4dc4:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    4dc6:	e9 89       	ldd	r30, Y+17	; 0x11
    4dc8:	fa 89       	ldd	r31, Y+18	; 0x12
    4dca:	27 89       	ldd	r18, Z+23	; 0x17
    4dcc:	30 8d       	ldd	r19, Z+24	; 0x18
    4dce:	88 85       	ldd	r24, Y+8	; 0x08
    4dd0:	99 85       	ldd	r25, Y+9	; 0x09
    4dd2:	01 97       	sbiw	r24, 0x01	; 1
    4dd4:	82 0f       	add	r24, r18
    4dd6:	93 1f       	adc	r25, r19
    4dd8:	9b 83       	std	Y+3, r25	; 0x03
    4dda:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4ddc:	19 82       	std	Y+1, r1	; 0x01
    4dde:	21 c0       	rjmp	.+66     	; 0x4e22 <prvInitialiseNewTask+0xa4>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    4de0:	89 81       	ldd	r24, Y+1	; 0x01
    4de2:	48 2f       	mov	r20, r24
    4de4:	50 e0       	ldi	r21, 0x00	; 0
    4de6:	89 81       	ldd	r24, Y+1	; 0x01
    4de8:	28 2f       	mov	r18, r24
    4dea:	30 e0       	ldi	r19, 0x00	; 0
    4dec:	8e 81       	ldd	r24, Y+6	; 0x06
    4dee:	9f 81       	ldd	r25, Y+7	; 0x07
    4df0:	fc 01       	movw	r30, r24
    4df2:	e2 0f       	add	r30, r18
    4df4:	f3 1f       	adc	r31, r19
    4df6:	20 81       	ld	r18, Z
    4df8:	89 89       	ldd	r24, Y+17	; 0x11
    4dfa:	9a 89       	ldd	r25, Y+18	; 0x12
    4dfc:	84 0f       	add	r24, r20
    4dfe:	95 1f       	adc	r25, r21
    4e00:	fc 01       	movw	r30, r24
    4e02:	79 96       	adiw	r30, 0x19	; 25
    4e04:	20 83       	st	Z, r18

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    4e06:	89 81       	ldd	r24, Y+1	; 0x01
    4e08:	28 2f       	mov	r18, r24
    4e0a:	30 e0       	ldi	r19, 0x00	; 0
    4e0c:	8e 81       	ldd	r24, Y+6	; 0x06
    4e0e:	9f 81       	ldd	r25, Y+7	; 0x07
    4e10:	fc 01       	movw	r30, r24
    4e12:	e2 0f       	add	r30, r18
    4e14:	f3 1f       	adc	r31, r19
    4e16:	80 81       	ld	r24, Z
    4e18:	88 23       	and	r24, r24
    4e1a:	31 f0       	breq	.+12     	; 0x4e28 <prvInitialiseNewTask+0xaa>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4e1c:	89 81       	ldd	r24, Y+1	; 0x01
    4e1e:	8f 5f       	subi	r24, 0xFF	; 255
    4e20:	89 83       	std	Y+1, r24	; 0x01
    4e22:	89 81       	ldd	r24, Y+1	; 0x01
    4e24:	88 30       	cpi	r24, 0x08	; 8
    4e26:	e0 f2       	brcs	.-72     	; 0x4de0 <prvInitialiseNewTask+0x62>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    4e28:	e9 89       	ldd	r30, Y+17	; 0x11
    4e2a:	fa 89       	ldd	r31, Y+18	; 0x12
    4e2c:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    4e2e:	8e 85       	ldd	r24, Y+14	; 0x0e
    4e30:	89 30       	cpi	r24, 0x09	; 9
    4e32:	10 f0       	brcs	.+4      	; 0x4e38 <prvInitialiseNewTask+0xba>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    4e34:	88 e0       	ldi	r24, 0x08	; 8
    4e36:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    4e38:	e9 89       	ldd	r30, Y+17	; 0x11
    4e3a:	fa 89       	ldd	r31, Y+18	; 0x12
    4e3c:	8e 85       	ldd	r24, Y+14	; 0x0e
    4e3e:	86 8b       	std	Z+22, r24	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    4e40:	e9 89       	ldd	r30, Y+17	; 0x11
    4e42:	fa 89       	ldd	r31, Y+18	; 0x12
    4e44:	8e 85       	ldd	r24, Y+14	; 0x0e
    4e46:	81 a3       	std	Z+33, r24	; 0x21
		pxNewTCB->uxMutexesHeld = 0;
    4e48:	e9 89       	ldd	r30, Y+17	; 0x11
    4e4a:	fa 89       	ldd	r31, Y+18	; 0x12
    4e4c:	12 a2       	std	Z+34, r1	; 0x22
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    4e4e:	89 89       	ldd	r24, Y+17	; 0x11
    4e50:	9a 89       	ldd	r25, Y+18	; 0x12
    4e52:	02 96       	adiw	r24, 0x02	; 2
    4e54:	0e 94 67 22 	call	0x44ce	; 0x44ce <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    4e58:	89 89       	ldd	r24, Y+17	; 0x11
    4e5a:	9a 89       	ldd	r25, Y+18	; 0x12
    4e5c:	0c 96       	adiw	r24, 0x0c	; 12
    4e5e:	0e 94 67 22 	call	0x44ce	; 0x44ce <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    4e62:	e9 89       	ldd	r30, Y+17	; 0x11
    4e64:	fa 89       	ldd	r31, Y+18	; 0x12
    4e66:	89 89       	ldd	r24, Y+17	; 0x11
    4e68:	9a 89       	ldd	r25, Y+18	; 0x12
    4e6a:	91 87       	std	Z+9, r25	; 0x09
    4e6c:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4e6e:	8e 85       	ldd	r24, Y+14	; 0x0e
    4e70:	28 2f       	mov	r18, r24
    4e72:	30 e0       	ldi	r19, 0x00	; 0
    4e74:	89 e0       	ldi	r24, 0x09	; 9
    4e76:	90 e0       	ldi	r25, 0x00	; 0
    4e78:	82 1b       	sub	r24, r18
    4e7a:	93 0b       	sbc	r25, r19
    4e7c:	e9 89       	ldd	r30, Y+17	; 0x11
    4e7e:	fa 89       	ldd	r31, Y+18	; 0x12
    4e80:	95 87       	std	Z+13, r25	; 0x0d
    4e82:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    4e84:	e9 89       	ldd	r30, Y+17	; 0x11
    4e86:	fa 89       	ldd	r31, Y+18	; 0x12
    4e88:	89 89       	ldd	r24, Y+17	; 0x11
    4e8a:	9a 89       	ldd	r25, Y+18	; 0x12
    4e8c:	93 8b       	std	Z+19, r25	; 0x13
    4e8e:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    4e90:	e9 89       	ldd	r30, Y+17	; 0x11
    4e92:	fa 89       	ldd	r31, Y+18	; 0x12
    4e94:	13 a2       	std	Z+35, r1	; 0x23
    4e96:	14 a2       	std	Z+36, r1	; 0x24
    4e98:	15 a2       	std	Z+37, r1	; 0x25
    4e9a:	16 a2       	std	Z+38, r1	; 0x26
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4e9c:	e9 89       	ldd	r30, Y+17	; 0x11
    4e9e:	fa 89       	ldd	r31, Y+18	; 0x12
    4ea0:	17 a2       	std	Z+39, r1	; 0x27
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    4ea2:	8a 81       	ldd	r24, Y+2	; 0x02
    4ea4:	9b 81       	ldd	r25, Y+3	; 0x03
    4ea6:	2c 81       	ldd	r18, Y+4	; 0x04
    4ea8:	3d 81       	ldd	r19, Y+5	; 0x05
    4eaa:	4c 85       	ldd	r20, Y+12	; 0x0c
    4eac:	5d 85       	ldd	r21, Y+13	; 0x0d
    4eae:	b9 01       	movw	r22, r18
    4eb0:	0e 94 73 23 	call	0x46e6	; 0x46e6 <pxPortInitialiseStack>
    4eb4:	e9 89       	ldd	r30, Y+17	; 0x11
    4eb6:	fa 89       	ldd	r31, Y+18	; 0x12
    4eb8:	91 83       	std	Z+1, r25	; 0x01
    4eba:	80 83       	st	Z, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
    4ebc:	8f 85       	ldd	r24, Y+15	; 0x0f
    4ebe:	98 89       	ldd	r25, Y+16	; 0x10
    4ec0:	00 97       	sbiw	r24, 0x00	; 0
    4ec2:	31 f0       	breq	.+12     	; 0x4ed0 <prvInitialiseNewTask+0x152>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    4ec4:	ef 85       	ldd	r30, Y+15	; 0x0f
    4ec6:	f8 89       	ldd	r31, Y+16	; 0x10
    4ec8:	89 89       	ldd	r24, Y+17	; 0x11
    4eca:	9a 89       	ldd	r25, Y+18	; 0x12
    4ecc:	91 83       	std	Z+1, r25	; 0x01
    4ece:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    4ed0:	64 96       	adiw	r28, 0x14	; 20
    4ed2:	0f b6       	in	r0, 0x3f	; 63
    4ed4:	f8 94       	cli
    4ed6:	de bf       	out	0x3e, r29	; 62
    4ed8:	0f be       	out	0x3f, r0	; 63
    4eda:	cd bf       	out	0x3d, r28	; 61
    4edc:	cf 91       	pop	r28
    4ede:	df 91       	pop	r29
    4ee0:	1f 91       	pop	r17
    4ee2:	0f 91       	pop	r16
    4ee4:	ef 90       	pop	r14
    4ee6:	df 90       	pop	r13
    4ee8:	cf 90       	pop	r12
    4eea:	bf 90       	pop	r11
    4eec:	af 90       	pop	r10
    4eee:	9f 90       	pop	r9
    4ef0:	8f 90       	pop	r8
    4ef2:	08 95       	ret

00004ef4 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    4ef4:	df 93       	push	r29
    4ef6:	cf 93       	push	r28
    4ef8:	00 d0       	rcall	.+0      	; 0x4efa <prvAddNewTaskToReadyList+0x6>
    4efa:	cd b7       	in	r28, 0x3d	; 61
    4efc:	de b7       	in	r29, 0x3e	; 62
    4efe:	9a 83       	std	Y+2, r25	; 0x02
    4f00:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    4f02:	0f b6       	in	r0, 0x3f	; 63
    4f04:	f8 94       	cli
    4f06:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    4f08:	80 91 92 05 	lds	r24, 0x0592
    4f0c:	8f 5f       	subi	r24, 0xFF	; 255
    4f0e:	80 93 92 05 	sts	0x0592, r24
		if( pxCurrentTCB == NULL )
    4f12:	80 91 8f 05 	lds	r24, 0x058F
    4f16:	90 91 90 05 	lds	r25, 0x0590
    4f1a:	00 97       	sbiw	r24, 0x00	; 0
    4f1c:	69 f4       	brne	.+26     	; 0x4f38 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    4f1e:	89 81       	ldd	r24, Y+1	; 0x01
    4f20:	9a 81       	ldd	r25, Y+2	; 0x02
    4f22:	90 93 90 05 	sts	0x0590, r25
    4f26:	80 93 8f 05 	sts	0x058F, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    4f2a:	80 91 92 05 	lds	r24, 0x0592
    4f2e:	81 30       	cpi	r24, 0x01	; 1
    4f30:	b9 f4       	brne	.+46     	; 0x4f60 <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    4f32:	0e 94 56 2f 	call	0x5eac	; 0x5eac <prvInitialiseTaskLists>
    4f36:	14 c0       	rjmp	.+40     	; 0x4f60 <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    4f38:	80 91 96 05 	lds	r24, 0x0596
    4f3c:	88 23       	and	r24, r24
    4f3e:	81 f4       	brne	.+32     	; 0x4f60 <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    4f40:	e0 91 8f 05 	lds	r30, 0x058F
    4f44:	f0 91 90 05 	lds	r31, 0x0590
    4f48:	96 89       	ldd	r25, Z+22	; 0x16
    4f4a:	e9 81       	ldd	r30, Y+1	; 0x01
    4f4c:	fa 81       	ldd	r31, Y+2	; 0x02
    4f4e:	86 89       	ldd	r24, Z+22	; 0x16
    4f50:	89 17       	cp	r24, r25
    4f52:	30 f0       	brcs	.+12     	; 0x4f60 <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    4f54:	89 81       	ldd	r24, Y+1	; 0x01
    4f56:	9a 81       	ldd	r25, Y+2	; 0x02
    4f58:	90 93 90 05 	sts	0x0590, r25
    4f5c:	80 93 8f 05 	sts	0x058F, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    4f60:	80 91 9a 05 	lds	r24, 0x059A
    4f64:	8f 5f       	subi	r24, 0xFF	; 255
    4f66:	80 93 9a 05 	sts	0x059A, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    4f6a:	e9 81       	ldd	r30, Y+1	; 0x01
    4f6c:	fa 81       	ldd	r31, Y+2	; 0x02
    4f6e:	96 89       	ldd	r25, Z+22	; 0x16
    4f70:	80 91 95 05 	lds	r24, 0x0595
    4f74:	89 17       	cp	r24, r25
    4f76:	28 f4       	brcc	.+10     	; 0x4f82 <prvAddNewTaskToReadyList+0x8e>
    4f78:	e9 81       	ldd	r30, Y+1	; 0x01
    4f7a:	fa 81       	ldd	r31, Y+2	; 0x02
    4f7c:	86 89       	ldd	r24, Z+22	; 0x16
    4f7e:	80 93 95 05 	sts	0x0595, r24
    4f82:	e9 81       	ldd	r30, Y+1	; 0x01
    4f84:	fa 81       	ldd	r31, Y+2	; 0x02
    4f86:	86 89       	ldd	r24, Z+22	; 0x16
    4f88:	28 2f       	mov	r18, r24
    4f8a:	30 e0       	ldi	r19, 0x00	; 0
    4f8c:	c9 01       	movw	r24, r18
    4f8e:	88 0f       	add	r24, r24
    4f90:	99 1f       	adc	r25, r25
    4f92:	88 0f       	add	r24, r24
    4f94:	99 1f       	adc	r25, r25
    4f96:	88 0f       	add	r24, r24
    4f98:	99 1f       	adc	r25, r25
    4f9a:	82 0f       	add	r24, r18
    4f9c:	93 1f       	adc	r25, r19
    4f9e:	ac 01       	movw	r20, r24
    4fa0:	40 56       	subi	r20, 0x60	; 96
    4fa2:	5a 4f       	sbci	r21, 0xFA	; 250
    4fa4:	89 81       	ldd	r24, Y+1	; 0x01
    4fa6:	9a 81       	ldd	r25, Y+2	; 0x02
    4fa8:	9c 01       	movw	r18, r24
    4faa:	2e 5f       	subi	r18, 0xFE	; 254
    4fac:	3f 4f       	sbci	r19, 0xFF	; 255
    4fae:	ca 01       	movw	r24, r20
    4fb0:	b9 01       	movw	r22, r18
    4fb2:	0e 94 77 22 	call	0x44ee	; 0x44ee <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    4fb6:	0f 90       	pop	r0
    4fb8:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    4fba:	80 91 96 05 	lds	r24, 0x0596
    4fbe:	88 23       	and	r24, r24
    4fc0:	61 f0       	breq	.+24     	; 0x4fda <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    4fc2:	e0 91 8f 05 	lds	r30, 0x058F
    4fc6:	f0 91 90 05 	lds	r31, 0x0590
    4fca:	96 89       	ldd	r25, Z+22	; 0x16
    4fcc:	e9 81       	ldd	r30, Y+1	; 0x01
    4fce:	fa 81       	ldd	r31, Y+2	; 0x02
    4fd0:	86 89       	ldd	r24, Z+22	; 0x16
    4fd2:	98 17       	cp	r25, r24
    4fd4:	10 f4       	brcc	.+4      	; 0x4fda <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    4fd6:	0e 94 32 25 	call	0x4a64	; 0x4a64 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    4fda:	0f 90       	pop	r0
    4fdc:	0f 90       	pop	r0
    4fde:	cf 91       	pop	r28
    4fe0:	df 91       	pop	r29
    4fe2:	08 95       	ret

00004fe4 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    4fe4:	df 93       	push	r29
    4fe6:	cf 93       	push	r28
    4fe8:	00 d0       	rcall	.+0      	; 0x4fea <vTaskDelete+0x6>
    4fea:	00 d0       	rcall	.+0      	; 0x4fec <vTaskDelete+0x8>
    4fec:	00 d0       	rcall	.+0      	; 0x4fee <vTaskDelete+0xa>
    4fee:	cd b7       	in	r28, 0x3d	; 61
    4ff0:	de b7       	in	r29, 0x3e	; 62
    4ff2:	9c 83       	std	Y+4, r25	; 0x04
    4ff4:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    4ff6:	0f b6       	in	r0, 0x3f	; 63
    4ff8:	f8 94       	cli
    4ffa:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    4ffc:	8b 81       	ldd	r24, Y+3	; 0x03
    4ffe:	9c 81       	ldd	r25, Y+4	; 0x04
    5000:	00 97       	sbiw	r24, 0x00	; 0
    5002:	39 f4       	brne	.+14     	; 0x5012 <vTaskDelete+0x2e>
    5004:	80 91 8f 05 	lds	r24, 0x058F
    5008:	90 91 90 05 	lds	r25, 0x0590
    500c:	9e 83       	std	Y+6, r25	; 0x06
    500e:	8d 83       	std	Y+5, r24	; 0x05
    5010:	04 c0       	rjmp	.+8      	; 0x501a <vTaskDelete+0x36>
    5012:	8b 81       	ldd	r24, Y+3	; 0x03
    5014:	9c 81       	ldd	r25, Y+4	; 0x04
    5016:	9e 83       	std	Y+6, r25	; 0x06
    5018:	8d 83       	std	Y+5, r24	; 0x05
    501a:	8d 81       	ldd	r24, Y+5	; 0x05
    501c:	9e 81       	ldd	r25, Y+6	; 0x06
    501e:	9a 83       	std	Y+2, r25	; 0x02
    5020:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5022:	89 81       	ldd	r24, Y+1	; 0x01
    5024:	9a 81       	ldd	r25, Y+2	; 0x02
    5026:	02 96       	adiw	r24, 0x02	; 2
    5028:	0e 94 27 23 	call	0x464e	; 0x464e <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    502c:	e9 81       	ldd	r30, Y+1	; 0x01
    502e:	fa 81       	ldd	r31, Y+2	; 0x02
    5030:	84 89       	ldd	r24, Z+20	; 0x14
    5032:	95 89       	ldd	r25, Z+21	; 0x15
    5034:	00 97       	sbiw	r24, 0x00	; 0
    5036:	29 f0       	breq	.+10     	; 0x5042 <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    5038:	89 81       	ldd	r24, Y+1	; 0x01
    503a:	9a 81       	ldd	r25, Y+2	; 0x02
    503c:	0c 96       	adiw	r24, 0x0c	; 12
    503e:	0e 94 27 23 	call	0x464e	; 0x464e <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    5042:	80 91 9a 05 	lds	r24, 0x059A
    5046:	8f 5f       	subi	r24, 0xFF	; 255
    5048:	80 93 9a 05 	sts	0x059A, r24

			if( pxTCB == pxCurrentTCB )
    504c:	20 91 8f 05 	lds	r18, 0x058F
    5050:	30 91 90 05 	lds	r19, 0x0590
    5054:	89 81       	ldd	r24, Y+1	; 0x01
    5056:	9a 81       	ldd	r25, Y+2	; 0x02
    5058:	82 17       	cp	r24, r18
    505a:	93 07       	cpc	r25, r19
    505c:	81 f4       	brne	.+32     	; 0x507e <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    505e:	89 81       	ldd	r24, Y+1	; 0x01
    5060:	9a 81       	ldd	r25, Y+2	; 0x02
    5062:	9c 01       	movw	r18, r24
    5064:	2e 5f       	subi	r18, 0xFE	; 254
    5066:	3f 4f       	sbci	r19, 0xFF	; 255
    5068:	80 e1       	ldi	r24, 0x10	; 16
    506a:	96 e0       	ldi	r25, 0x06	; 6
    506c:	b9 01       	movw	r22, r18
    506e:	0e 94 77 22 	call	0x44ee	; 0x44ee <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    5072:	80 91 91 05 	lds	r24, 0x0591
    5076:	8f 5f       	subi	r24, 0xFF	; 255
    5078:	80 93 91 05 	sts	0x0591, r24
    507c:	0b c0       	rjmp	.+22     	; 0x5094 <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    507e:	80 91 92 05 	lds	r24, 0x0592
    5082:	81 50       	subi	r24, 0x01	; 1
    5084:	80 93 92 05 	sts	0x0592, r24
				prvDeleteTCB( pxTCB );
    5088:	89 81       	ldd	r24, Y+1	; 0x01
    508a:	9a 81       	ldd	r25, Y+2	; 0x02
    508c:	0e 94 d6 2f 	call	0x5fac	; 0x5fac <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    5090:	0e 94 ec 2f 	call	0x5fd8	; 0x5fd8 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    5094:	0f 90       	pop	r0
    5096:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    5098:	80 91 96 05 	lds	r24, 0x0596
    509c:	88 23       	and	r24, r24
    509e:	59 f0       	breq	.+22     	; 0x50b6 <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    50a0:	20 91 8f 05 	lds	r18, 0x058F
    50a4:	30 91 90 05 	lds	r19, 0x0590
    50a8:	89 81       	ldd	r24, Y+1	; 0x01
    50aa:	9a 81       	ldd	r25, Y+2	; 0x02
    50ac:	82 17       	cp	r24, r18
    50ae:	93 07       	cpc	r25, r19
    50b0:	11 f4       	brne	.+4      	; 0x50b6 <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    50b2:	0e 94 32 25 	call	0x4a64	; 0x4a64 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    50b6:	26 96       	adiw	r28, 0x06	; 6
    50b8:	0f b6       	in	r0, 0x3f	; 63
    50ba:	f8 94       	cli
    50bc:	de bf       	out	0x3e, r29	; 62
    50be:	0f be       	out	0x3f, r0	; 63
    50c0:	cd bf       	out	0x3d, r28	; 61
    50c2:	cf 91       	pop	r28
    50c4:	df 91       	pop	r29
    50c6:	08 95       	ret

000050c8 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    50c8:	df 93       	push	r29
    50ca:	cf 93       	push	r28
    50cc:	cd b7       	in	r28, 0x3d	; 61
    50ce:	de b7       	in	r29, 0x3e	; 62
    50d0:	2a 97       	sbiw	r28, 0x0a	; 10
    50d2:	0f b6       	in	r0, 0x3f	; 63
    50d4:	f8 94       	cli
    50d6:	de bf       	out	0x3e, r29	; 62
    50d8:	0f be       	out	0x3f, r0	; 63
    50da:	cd bf       	out	0x3d, r28	; 61
    50dc:	98 87       	std	Y+8, r25	; 0x08
    50de:	8f 83       	std	Y+7, r24	; 0x07
    50e0:	7a 87       	std	Y+10, r23	; 0x0a
    50e2:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    50e4:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    50e6:	0e 94 65 2b 	call	0x56ca	; 0x56ca <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    50ea:	80 91 93 05 	lds	r24, 0x0593
    50ee:	90 91 94 05 	lds	r25, 0x0594
    50f2:	9a 83       	std	Y+2, r25	; 0x02
    50f4:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    50f6:	ef 81       	ldd	r30, Y+7	; 0x07
    50f8:	f8 85       	ldd	r31, Y+8	; 0x08
    50fa:	20 81       	ld	r18, Z
    50fc:	31 81       	ldd	r19, Z+1	; 0x01
    50fe:	89 85       	ldd	r24, Y+9	; 0x09
    5100:	9a 85       	ldd	r25, Y+10	; 0x0a
    5102:	82 0f       	add	r24, r18
    5104:	93 1f       	adc	r25, r19
    5106:	9e 83       	std	Y+6, r25	; 0x06
    5108:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    510a:	ef 81       	ldd	r30, Y+7	; 0x07
    510c:	f8 85       	ldd	r31, Y+8	; 0x08
    510e:	20 81       	ld	r18, Z
    5110:	31 81       	ldd	r19, Z+1	; 0x01
    5112:	89 81       	ldd	r24, Y+1	; 0x01
    5114:	9a 81       	ldd	r25, Y+2	; 0x02
    5116:	82 17       	cp	r24, r18
    5118:	93 07       	cpc	r25, r19
    511a:	98 f4       	brcc	.+38     	; 0x5142 <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    511c:	ef 81       	ldd	r30, Y+7	; 0x07
    511e:	f8 85       	ldd	r31, Y+8	; 0x08
    5120:	20 81       	ld	r18, Z
    5122:	31 81       	ldd	r19, Z+1	; 0x01
    5124:	8d 81       	ldd	r24, Y+5	; 0x05
    5126:	9e 81       	ldd	r25, Y+6	; 0x06
    5128:	82 17       	cp	r24, r18
    512a:	93 07       	cpc	r25, r19
    512c:	e0 f4       	brcc	.+56     	; 0x5166 <vTaskDelayUntil+0x9e>
    512e:	2d 81       	ldd	r18, Y+5	; 0x05
    5130:	3e 81       	ldd	r19, Y+6	; 0x06
    5132:	89 81       	ldd	r24, Y+1	; 0x01
    5134:	9a 81       	ldd	r25, Y+2	; 0x02
    5136:	82 17       	cp	r24, r18
    5138:	93 07       	cpc	r25, r19
    513a:	a8 f4       	brcc	.+42     	; 0x5166 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    513c:	81 e0       	ldi	r24, 0x01	; 1
    513e:	8b 83       	std	Y+3, r24	; 0x03
    5140:	12 c0       	rjmp	.+36     	; 0x5166 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    5142:	ef 81       	ldd	r30, Y+7	; 0x07
    5144:	f8 85       	ldd	r31, Y+8	; 0x08
    5146:	20 81       	ld	r18, Z
    5148:	31 81       	ldd	r19, Z+1	; 0x01
    514a:	8d 81       	ldd	r24, Y+5	; 0x05
    514c:	9e 81       	ldd	r25, Y+6	; 0x06
    514e:	82 17       	cp	r24, r18
    5150:	93 07       	cpc	r25, r19
    5152:	38 f0       	brcs	.+14     	; 0x5162 <vTaskDelayUntil+0x9a>
    5154:	2d 81       	ldd	r18, Y+5	; 0x05
    5156:	3e 81       	ldd	r19, Y+6	; 0x06
    5158:	89 81       	ldd	r24, Y+1	; 0x01
    515a:	9a 81       	ldd	r25, Y+2	; 0x02
    515c:	82 17       	cp	r24, r18
    515e:	93 07       	cpc	r25, r19
    5160:	10 f4       	brcc	.+4      	; 0x5166 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    5162:	81 e0       	ldi	r24, 0x01	; 1
    5164:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    5166:	ef 81       	ldd	r30, Y+7	; 0x07
    5168:	f8 85       	ldd	r31, Y+8	; 0x08
    516a:	8d 81       	ldd	r24, Y+5	; 0x05
    516c:	9e 81       	ldd	r25, Y+6	; 0x06
    516e:	91 83       	std	Z+1, r25	; 0x01
    5170:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    5172:	8b 81       	ldd	r24, Y+3	; 0x03
    5174:	88 23       	and	r24, r24
    5176:	49 f0       	breq	.+18     	; 0x518a <vTaskDelayUntil+0xc2>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    5178:	8d 81       	ldd	r24, Y+5	; 0x05
    517a:	9e 81       	ldd	r25, Y+6	; 0x06
    517c:	29 81       	ldd	r18, Y+1	; 0x01
    517e:	3a 81       	ldd	r19, Y+2	; 0x02
    5180:	82 1b       	sub	r24, r18
    5182:	93 0b       	sbc	r25, r19
    5184:	60 e0       	ldi	r22, 0x00	; 0
    5186:	0e 94 0f 35 	call	0x6a1e	; 0x6a1e <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    518a:	0e 94 71 2b 	call	0x56e2	; 0x56e2 <xTaskResumeAll>
    518e:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    5190:	8c 81       	ldd	r24, Y+4	; 0x04
    5192:	88 23       	and	r24, r24
    5194:	11 f4       	brne	.+4      	; 0x519a <vTaskDelayUntil+0xd2>
		{
			portYIELD_WITHIN_API();
    5196:	0e 94 32 25 	call	0x4a64	; 0x4a64 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    519a:	2a 96       	adiw	r28, 0x0a	; 10
    519c:	0f b6       	in	r0, 0x3f	; 63
    519e:	f8 94       	cli
    51a0:	de bf       	out	0x3e, r29	; 62
    51a2:	0f be       	out	0x3f, r0	; 63
    51a4:	cd bf       	out	0x3d, r28	; 61
    51a6:	cf 91       	pop	r28
    51a8:	df 91       	pop	r29
    51aa:	08 95       	ret

000051ac <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    51ac:	df 93       	push	r29
    51ae:	cf 93       	push	r28
    51b0:	00 d0       	rcall	.+0      	; 0x51b2 <vTaskDelay+0x6>
    51b2:	0f 92       	push	r0
    51b4:	cd b7       	in	r28, 0x3d	; 61
    51b6:	de b7       	in	r29, 0x3e	; 62
    51b8:	9b 83       	std	Y+3, r25	; 0x03
    51ba:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    51bc:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    51be:	8a 81       	ldd	r24, Y+2	; 0x02
    51c0:	9b 81       	ldd	r25, Y+3	; 0x03
    51c2:	00 97       	sbiw	r24, 0x00	; 0
    51c4:	51 f0       	breq	.+20     	; 0x51da <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    51c6:	0e 94 65 2b 	call	0x56ca	; 0x56ca <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    51ca:	8a 81       	ldd	r24, Y+2	; 0x02
    51cc:	9b 81       	ldd	r25, Y+3	; 0x03
    51ce:	60 e0       	ldi	r22, 0x00	; 0
    51d0:	0e 94 0f 35 	call	0x6a1e	; 0x6a1e <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    51d4:	0e 94 71 2b 	call	0x56e2	; 0x56e2 <xTaskResumeAll>
    51d8:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    51da:	89 81       	ldd	r24, Y+1	; 0x01
    51dc:	88 23       	and	r24, r24
    51de:	11 f4       	brne	.+4      	; 0x51e4 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    51e0:	0e 94 32 25 	call	0x4a64	; 0x4a64 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    51e4:	0f 90       	pop	r0
    51e6:	0f 90       	pop	r0
    51e8:	0f 90       	pop	r0
    51ea:	cf 91       	pop	r28
    51ec:	df 91       	pop	r29
    51ee:	08 95       	ret

000051f0 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    51f0:	df 93       	push	r29
    51f2:	cf 93       	push	r28
    51f4:	cd b7       	in	r28, 0x3d	; 61
    51f6:	de b7       	in	r29, 0x3e	; 62
    51f8:	2a 97       	sbiw	r28, 0x0a	; 10
    51fa:	0f b6       	in	r0, 0x3f	; 63
    51fc:	f8 94       	cli
    51fe:	de bf       	out	0x3e, r29	; 62
    5200:	0f be       	out	0x3f, r0	; 63
    5202:	cd bf       	out	0x3d, r28	; 61
    5204:	9f 83       	std	Y+7, r25	; 0x07
    5206:	8e 83       	std	Y+6, r24	; 0x06
    5208:	68 87       	std	Y+8, r22	; 0x08
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    520a:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    520c:	88 85       	ldd	r24, Y+8	; 0x08
    520e:	89 30       	cpi	r24, 0x09	; 9
    5210:	10 f0       	brcs	.+4      	; 0x5216 <vTaskPrioritySet+0x26>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    5212:	88 e0       	ldi	r24, 0x08	; 8
    5214:	88 87       	std	Y+8, r24	; 0x08
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    5216:	0f b6       	in	r0, 0x3f	; 63
    5218:	f8 94       	cli
    521a:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    521c:	8e 81       	ldd	r24, Y+6	; 0x06
    521e:	9f 81       	ldd	r25, Y+7	; 0x07
    5220:	00 97       	sbiw	r24, 0x00	; 0
    5222:	39 f4       	brne	.+14     	; 0x5232 <vTaskPrioritySet+0x42>
    5224:	80 91 8f 05 	lds	r24, 0x058F
    5228:	90 91 90 05 	lds	r25, 0x0590
    522c:	9a 87       	std	Y+10, r25	; 0x0a
    522e:	89 87       	std	Y+9, r24	; 0x09
    5230:	04 c0       	rjmp	.+8      	; 0x523a <vTaskPrioritySet+0x4a>
    5232:	8e 81       	ldd	r24, Y+6	; 0x06
    5234:	9f 81       	ldd	r25, Y+7	; 0x07
    5236:	9a 87       	std	Y+10, r25	; 0x0a
    5238:	89 87       	std	Y+9, r24	; 0x09
    523a:	89 85       	ldd	r24, Y+9	; 0x09
    523c:	9a 85       	ldd	r25, Y+10	; 0x0a
    523e:	9d 83       	std	Y+5, r25	; 0x05
    5240:	8c 83       	std	Y+4, r24	; 0x04

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
    5242:	ec 81       	ldd	r30, Y+4	; 0x04
    5244:	fd 81       	ldd	r31, Y+5	; 0x05
    5246:	81 a1       	ldd	r24, Z+33	; 0x21
    5248:	8b 83       	std	Y+3, r24	; 0x03
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    524a:	9b 81       	ldd	r25, Y+3	; 0x03
    524c:	88 85       	ldd	r24, Y+8	; 0x08
    524e:	98 17       	cp	r25, r24
    5250:	09 f4       	brne	.+2      	; 0x5254 <vTaskPrioritySet+0x64>
    5252:	8d c0       	rjmp	.+282    	; 0x536e <vTaskPrioritySet+0x17e>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    5254:	98 85       	ldd	r25, Y+8	; 0x08
    5256:	8b 81       	ldd	r24, Y+3	; 0x03
    5258:	89 17       	cp	r24, r25
    525a:	a0 f4       	brcc	.+40     	; 0x5284 <vTaskPrioritySet+0x94>
				{
					if( pxTCB != pxCurrentTCB )
    525c:	20 91 8f 05 	lds	r18, 0x058F
    5260:	30 91 90 05 	lds	r19, 0x0590
    5264:	8c 81       	ldd	r24, Y+4	; 0x04
    5266:	9d 81       	ldd	r25, Y+5	; 0x05
    5268:	82 17       	cp	r24, r18
    526a:	93 07       	cpc	r25, r19
    526c:	b1 f0       	breq	.+44     	; 0x529a <vTaskPrioritySet+0xaa>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    526e:	e0 91 8f 05 	lds	r30, 0x058F
    5272:	f0 91 90 05 	lds	r31, 0x0590
    5276:	96 89       	ldd	r25, Z+22	; 0x16
    5278:	88 85       	ldd	r24, Y+8	; 0x08
    527a:	89 17       	cp	r24, r25
    527c:	70 f0       	brcs	.+28     	; 0x529a <vTaskPrioritySet+0xaa>
						{
							xYieldRequired = pdTRUE;
    527e:	81 e0       	ldi	r24, 0x01	; 1
    5280:	89 83       	std	Y+1, r24	; 0x01
    5282:	0b c0       	rjmp	.+22     	; 0x529a <vTaskPrioritySet+0xaa>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    5284:	20 91 8f 05 	lds	r18, 0x058F
    5288:	30 91 90 05 	lds	r19, 0x0590
    528c:	8c 81       	ldd	r24, Y+4	; 0x04
    528e:	9d 81       	ldd	r25, Y+5	; 0x05
    5290:	82 17       	cp	r24, r18
    5292:	93 07       	cpc	r25, r19
    5294:	11 f4       	brne	.+4      	; 0x529a <vTaskPrioritySet+0xaa>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
    5296:	81 e0       	ldi	r24, 0x01	; 1
    5298:	89 83       	std	Y+1, r24	; 0x01
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    529a:	ec 81       	ldd	r30, Y+4	; 0x04
    529c:	fd 81       	ldd	r31, Y+5	; 0x05
    529e:	86 89       	ldd	r24, Z+22	; 0x16
    52a0:	8a 83       	std	Y+2, r24	; 0x02

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    52a2:	ec 81       	ldd	r30, Y+4	; 0x04
    52a4:	fd 81       	ldd	r31, Y+5	; 0x05
    52a6:	91 a1       	ldd	r25, Z+33	; 0x21
    52a8:	ec 81       	ldd	r30, Y+4	; 0x04
    52aa:	fd 81       	ldd	r31, Y+5	; 0x05
    52ac:	86 89       	ldd	r24, Z+22	; 0x16
    52ae:	98 17       	cp	r25, r24
    52b0:	21 f4       	brne	.+8      	; 0x52ba <vTaskPrioritySet+0xca>
					{
						pxTCB->uxPriority = uxNewPriority;
    52b2:	ec 81       	ldd	r30, Y+4	; 0x04
    52b4:	fd 81       	ldd	r31, Y+5	; 0x05
    52b6:	88 85       	ldd	r24, Y+8	; 0x08
    52b8:	86 8b       	std	Z+22, r24	; 0x16
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
    52ba:	ec 81       	ldd	r30, Y+4	; 0x04
    52bc:	fd 81       	ldd	r31, Y+5	; 0x05
    52be:	88 85       	ldd	r24, Y+8	; 0x08
    52c0:	81 a3       	std	Z+33, r24	; 0x21
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    52c2:	ec 81       	ldd	r30, Y+4	; 0x04
    52c4:	fd 81       	ldd	r31, Y+5	; 0x05
    52c6:	84 85       	ldd	r24, Z+12	; 0x0c
    52c8:	95 85       	ldd	r25, Z+13	; 0x0d
    52ca:	99 23       	and	r25, r25
    52cc:	5c f0       	brlt	.+22     	; 0x52e4 <vTaskPrioritySet+0xf4>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    52ce:	88 85       	ldd	r24, Y+8	; 0x08
    52d0:	28 2f       	mov	r18, r24
    52d2:	30 e0       	ldi	r19, 0x00	; 0
    52d4:	89 e0       	ldi	r24, 0x09	; 9
    52d6:	90 e0       	ldi	r25, 0x00	; 0
    52d8:	82 1b       	sub	r24, r18
    52da:	93 0b       	sbc	r25, r19
    52dc:	ec 81       	ldd	r30, Y+4	; 0x04
    52de:	fd 81       	ldd	r31, Y+5	; 0x05
    52e0:	95 87       	std	Z+13, r25	; 0x0d
    52e2:	84 87       	std	Z+12, r24	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    52e4:	ec 81       	ldd	r30, Y+4	; 0x04
    52e6:	fd 81       	ldd	r31, Y+5	; 0x05
    52e8:	42 85       	ldd	r20, Z+10	; 0x0a
    52ea:	53 85       	ldd	r21, Z+11	; 0x0b
    52ec:	8a 81       	ldd	r24, Y+2	; 0x02
    52ee:	28 2f       	mov	r18, r24
    52f0:	30 e0       	ldi	r19, 0x00	; 0
    52f2:	c9 01       	movw	r24, r18
    52f4:	88 0f       	add	r24, r24
    52f6:	99 1f       	adc	r25, r25
    52f8:	88 0f       	add	r24, r24
    52fa:	99 1f       	adc	r25, r25
    52fc:	88 0f       	add	r24, r24
    52fe:	99 1f       	adc	r25, r25
    5300:	82 0f       	add	r24, r18
    5302:	93 1f       	adc	r25, r19
    5304:	80 56       	subi	r24, 0x60	; 96
    5306:	9a 4f       	sbci	r25, 0xFA	; 250
    5308:	48 17       	cp	r20, r24
    530a:	59 07       	cpc	r21, r25
    530c:	59 f5       	brne	.+86     	; 0x5364 <vTaskPrioritySet+0x174>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    530e:	8c 81       	ldd	r24, Y+4	; 0x04
    5310:	9d 81       	ldd	r25, Y+5	; 0x05
    5312:	02 96       	adiw	r24, 0x02	; 2
    5314:	0e 94 27 23 	call	0x464e	; 0x464e <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    5318:	ec 81       	ldd	r30, Y+4	; 0x04
    531a:	fd 81       	ldd	r31, Y+5	; 0x05
    531c:	96 89       	ldd	r25, Z+22	; 0x16
    531e:	80 91 95 05 	lds	r24, 0x0595
    5322:	89 17       	cp	r24, r25
    5324:	28 f4       	brcc	.+10     	; 0x5330 <vTaskPrioritySet+0x140>
    5326:	ec 81       	ldd	r30, Y+4	; 0x04
    5328:	fd 81       	ldd	r31, Y+5	; 0x05
    532a:	86 89       	ldd	r24, Z+22	; 0x16
    532c:	80 93 95 05 	sts	0x0595, r24
    5330:	ec 81       	ldd	r30, Y+4	; 0x04
    5332:	fd 81       	ldd	r31, Y+5	; 0x05
    5334:	86 89       	ldd	r24, Z+22	; 0x16
    5336:	28 2f       	mov	r18, r24
    5338:	30 e0       	ldi	r19, 0x00	; 0
    533a:	c9 01       	movw	r24, r18
    533c:	88 0f       	add	r24, r24
    533e:	99 1f       	adc	r25, r25
    5340:	88 0f       	add	r24, r24
    5342:	99 1f       	adc	r25, r25
    5344:	88 0f       	add	r24, r24
    5346:	99 1f       	adc	r25, r25
    5348:	82 0f       	add	r24, r18
    534a:	93 1f       	adc	r25, r19
    534c:	ac 01       	movw	r20, r24
    534e:	40 56       	subi	r20, 0x60	; 96
    5350:	5a 4f       	sbci	r21, 0xFA	; 250
    5352:	8c 81       	ldd	r24, Y+4	; 0x04
    5354:	9d 81       	ldd	r25, Y+5	; 0x05
    5356:	9c 01       	movw	r18, r24
    5358:	2e 5f       	subi	r18, 0xFE	; 254
    535a:	3f 4f       	sbci	r19, 0xFF	; 255
    535c:	ca 01       	movw	r24, r20
    535e:	b9 01       	movw	r22, r18
    5360:	0e 94 77 22 	call	0x44ee	; 0x44ee <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
    5364:	89 81       	ldd	r24, Y+1	; 0x01
    5366:	88 23       	and	r24, r24
    5368:	11 f0       	breq	.+4      	; 0x536e <vTaskPrioritySet+0x17e>
				{
					taskYIELD_IF_USING_PREEMPTION();
    536a:	0e 94 32 25 	call	0x4a64	; 0x4a64 <vPortYield>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    536e:	0f 90       	pop	r0
    5370:	0f be       	out	0x3f, r0	; 63
	}
    5372:	2a 96       	adiw	r28, 0x0a	; 10
    5374:	0f b6       	in	r0, 0x3f	; 63
    5376:	f8 94       	cli
    5378:	de bf       	out	0x3e, r29	; 62
    537a:	0f be       	out	0x3f, r0	; 63
    537c:	cd bf       	out	0x3d, r28	; 61
    537e:	cf 91       	pop	r28
    5380:	df 91       	pop	r29
    5382:	08 95       	ret

00005384 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    5384:	df 93       	push	r29
    5386:	cf 93       	push	r28
    5388:	00 d0       	rcall	.+0      	; 0x538a <vTaskSuspend+0x6>
    538a:	00 d0       	rcall	.+0      	; 0x538c <vTaskSuspend+0x8>
    538c:	00 d0       	rcall	.+0      	; 0x538e <vTaskSuspend+0xa>
    538e:	cd b7       	in	r28, 0x3d	; 61
    5390:	de b7       	in	r29, 0x3e	; 62
    5392:	9c 83       	std	Y+4, r25	; 0x04
    5394:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    5396:	0f b6       	in	r0, 0x3f	; 63
    5398:	f8 94       	cli
    539a:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    539c:	8b 81       	ldd	r24, Y+3	; 0x03
    539e:	9c 81       	ldd	r25, Y+4	; 0x04
    53a0:	00 97       	sbiw	r24, 0x00	; 0
    53a2:	39 f4       	brne	.+14     	; 0x53b2 <vTaskSuspend+0x2e>
    53a4:	80 91 8f 05 	lds	r24, 0x058F
    53a8:	90 91 90 05 	lds	r25, 0x0590
    53ac:	9e 83       	std	Y+6, r25	; 0x06
    53ae:	8d 83       	std	Y+5, r24	; 0x05
    53b0:	04 c0       	rjmp	.+8      	; 0x53ba <vTaskSuspend+0x36>
    53b2:	8b 81       	ldd	r24, Y+3	; 0x03
    53b4:	9c 81       	ldd	r25, Y+4	; 0x04
    53b6:	9e 83       	std	Y+6, r25	; 0x06
    53b8:	8d 83       	std	Y+5, r24	; 0x05
    53ba:	8d 81       	ldd	r24, Y+5	; 0x05
    53bc:	9e 81       	ldd	r25, Y+6	; 0x06
    53be:	9a 83       	std	Y+2, r25	; 0x02
    53c0:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    53c2:	89 81       	ldd	r24, Y+1	; 0x01
    53c4:	9a 81       	ldd	r25, Y+2	; 0x02
    53c6:	02 96       	adiw	r24, 0x02	; 2
    53c8:	0e 94 27 23 	call	0x464e	; 0x464e <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    53cc:	e9 81       	ldd	r30, Y+1	; 0x01
    53ce:	fa 81       	ldd	r31, Y+2	; 0x02
    53d0:	84 89       	ldd	r24, Z+20	; 0x14
    53d2:	95 89       	ldd	r25, Z+21	; 0x15
    53d4:	00 97       	sbiw	r24, 0x00	; 0
    53d6:	29 f0       	breq	.+10     	; 0x53e2 <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    53d8:	89 81       	ldd	r24, Y+1	; 0x01
    53da:	9a 81       	ldd	r25, Y+2	; 0x02
    53dc:	0c 96       	adiw	r24, 0x0c	; 12
    53de:	0e 94 27 23 	call	0x464e	; 0x464e <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    53e2:	89 81       	ldd	r24, Y+1	; 0x01
    53e4:	9a 81       	ldd	r25, Y+2	; 0x02
    53e6:	9c 01       	movw	r18, r24
    53e8:	2e 5f       	subi	r18, 0xFE	; 254
    53ea:	3f 4f       	sbci	r19, 0xFF	; 255
    53ec:	89 e1       	ldi	r24, 0x19	; 25
    53ee:	96 e0       	ldi	r25, 0x06	; 6
    53f0:	b9 01       	movw	r22, r18
    53f2:	0e 94 77 22 	call	0x44ee	; 0x44ee <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    53f6:	0f 90       	pop	r0
    53f8:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    53fa:	80 91 96 05 	lds	r24, 0x0596
    53fe:	88 23       	and	r24, r24
    5400:	39 f0       	breq	.+14     	; 0x5410 <vTaskSuspend+0x8c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    5402:	0f b6       	in	r0, 0x3f	; 63
    5404:	f8 94       	cli
    5406:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    5408:	0e 94 ec 2f 	call	0x5fd8	; 0x5fd8 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    540c:	0f 90       	pop	r0
    540e:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    5410:	20 91 8f 05 	lds	r18, 0x058F
    5414:	30 91 90 05 	lds	r19, 0x0590
    5418:	89 81       	ldd	r24, Y+1	; 0x01
    541a:	9a 81       	ldd	r25, Y+2	; 0x02
    541c:	82 17       	cp	r24, r18
    541e:	93 07       	cpc	r25, r19
    5420:	a1 f4       	brne	.+40     	; 0x544a <vTaskSuspend+0xc6>
		{
			if( xSchedulerRunning != pdFALSE )
    5422:	80 91 96 05 	lds	r24, 0x0596
    5426:	88 23       	and	r24, r24
    5428:	19 f0       	breq	.+6      	; 0x5430 <vTaskSuspend+0xac>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    542a:	0e 94 32 25 	call	0x4a64	; 0x4a64 <vPortYield>
    542e:	0d c0       	rjmp	.+26     	; 0x544a <vTaskSuspend+0xc6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    5430:	90 91 19 06 	lds	r25, 0x0619
    5434:	80 91 92 05 	lds	r24, 0x0592
    5438:	98 17       	cp	r25, r24
    543a:	29 f4       	brne	.+10     	; 0x5446 <vTaskSuspend+0xc2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    543c:	10 92 90 05 	sts	0x0590, r1
    5440:	10 92 8f 05 	sts	0x058F, r1
    5444:	02 c0       	rjmp	.+4      	; 0x544a <vTaskSuspend+0xc6>
				}
				else
				{
					vTaskSwitchContext();
    5446:	0e 94 2d 2d 	call	0x5a5a	; 0x5a5a <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    544a:	26 96       	adiw	r28, 0x06	; 6
    544c:	0f b6       	in	r0, 0x3f	; 63
    544e:	f8 94       	cli
    5450:	de bf       	out	0x3e, r29	; 62
    5452:	0f be       	out	0x3f, r0	; 63
    5454:	cd bf       	out	0x3d, r28	; 61
    5456:	cf 91       	pop	r28
    5458:	df 91       	pop	r29
    545a:	08 95       	ret

0000545c <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    545c:	df 93       	push	r29
    545e:	cf 93       	push	r28
    5460:	00 d0       	rcall	.+0      	; 0x5462 <prvTaskIsTaskSuspended+0x6>
    5462:	00 d0       	rcall	.+0      	; 0x5464 <prvTaskIsTaskSuspended+0x8>
    5464:	0f 92       	push	r0
    5466:	cd b7       	in	r28, 0x3d	; 61
    5468:	de b7       	in	r29, 0x3e	; 62
    546a:	9d 83       	std	Y+5, r25	; 0x05
    546c:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    546e:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
    5470:	8c 81       	ldd	r24, Y+4	; 0x04
    5472:	9d 81       	ldd	r25, Y+5	; 0x05
    5474:	9a 83       	std	Y+2, r25	; 0x02
    5476:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    5478:	e9 81       	ldd	r30, Y+1	; 0x01
    547a:	fa 81       	ldd	r31, Y+2	; 0x02
    547c:	82 85       	ldd	r24, Z+10	; 0x0a
    547e:	93 85       	ldd	r25, Z+11	; 0x0b
    5480:	26 e0       	ldi	r18, 0x06	; 6
    5482:	89 31       	cpi	r24, 0x19	; 25
    5484:	92 07       	cpc	r25, r18
    5486:	81 f4       	brne	.+32     	; 0x54a8 <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    5488:	e9 81       	ldd	r30, Y+1	; 0x01
    548a:	fa 81       	ldd	r31, Y+2	; 0x02
    548c:	84 89       	ldd	r24, Z+20	; 0x14
    548e:	95 89       	ldd	r25, Z+21	; 0x15
    5490:	26 e0       	ldi	r18, 0x06	; 6
    5492:	87 30       	cpi	r24, 0x07	; 7
    5494:	92 07       	cpc	r25, r18
    5496:	41 f0       	breq	.+16     	; 0x54a8 <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
    5498:	e9 81       	ldd	r30, Y+1	; 0x01
    549a:	fa 81       	ldd	r31, Y+2	; 0x02
    549c:	84 89       	ldd	r24, Z+20	; 0x14
    549e:	95 89       	ldd	r25, Z+21	; 0x15
    54a0:	00 97       	sbiw	r24, 0x00	; 0
    54a2:	11 f4       	brne	.+4      	; 0x54a8 <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    54a4:	81 e0       	ldi	r24, 0x01	; 1
    54a6:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    54a8:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    54aa:	0f 90       	pop	r0
    54ac:	0f 90       	pop	r0
    54ae:	0f 90       	pop	r0
    54b0:	0f 90       	pop	r0
    54b2:	0f 90       	pop	r0
    54b4:	cf 91       	pop	r28
    54b6:	df 91       	pop	r29
    54b8:	08 95       	ret

000054ba <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    54ba:	df 93       	push	r29
    54bc:	cf 93       	push	r28
    54be:	00 d0       	rcall	.+0      	; 0x54c0 <vTaskResume+0x6>
    54c0:	00 d0       	rcall	.+0      	; 0x54c2 <vTaskResume+0x8>
    54c2:	cd b7       	in	r28, 0x3d	; 61
    54c4:	de b7       	in	r29, 0x3e	; 62
    54c6:	9c 83       	std	Y+4, r25	; 0x04
    54c8:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
    54ca:	8b 81       	ldd	r24, Y+3	; 0x03
    54cc:	9c 81       	ldd	r25, Y+4	; 0x04
    54ce:	9a 83       	std	Y+2, r25	; 0x02
    54d0:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    54d2:	89 81       	ldd	r24, Y+1	; 0x01
    54d4:	9a 81       	ldd	r25, Y+2	; 0x02
    54d6:	00 97       	sbiw	r24, 0x00	; 0
    54d8:	09 f4       	brne	.+2      	; 0x54dc <vTaskResume+0x22>
    54da:	4c c0       	rjmp	.+152    	; 0x5574 <vTaskResume+0xba>
    54dc:	20 91 8f 05 	lds	r18, 0x058F
    54e0:	30 91 90 05 	lds	r19, 0x0590
    54e4:	89 81       	ldd	r24, Y+1	; 0x01
    54e6:	9a 81       	ldd	r25, Y+2	; 0x02
    54e8:	82 17       	cp	r24, r18
    54ea:	93 07       	cpc	r25, r19
    54ec:	09 f4       	brne	.+2      	; 0x54f0 <vTaskResume+0x36>
    54ee:	42 c0       	rjmp	.+132    	; 0x5574 <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    54f0:	0f b6       	in	r0, 0x3f	; 63
    54f2:	f8 94       	cli
    54f4:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    54f6:	89 81       	ldd	r24, Y+1	; 0x01
    54f8:	9a 81       	ldd	r25, Y+2	; 0x02
    54fa:	0e 94 2e 2a 	call	0x545c	; 0x545c <prvTaskIsTaskSuspended>
    54fe:	88 23       	and	r24, r24
    5500:	b9 f1       	breq	.+110    	; 0x5570 <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    5502:	89 81       	ldd	r24, Y+1	; 0x01
    5504:	9a 81       	ldd	r25, Y+2	; 0x02
    5506:	02 96       	adiw	r24, 0x02	; 2
    5508:	0e 94 27 23 	call	0x464e	; 0x464e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    550c:	e9 81       	ldd	r30, Y+1	; 0x01
    550e:	fa 81       	ldd	r31, Y+2	; 0x02
    5510:	96 89       	ldd	r25, Z+22	; 0x16
    5512:	80 91 95 05 	lds	r24, 0x0595
    5516:	89 17       	cp	r24, r25
    5518:	28 f4       	brcc	.+10     	; 0x5524 <vTaskResume+0x6a>
    551a:	e9 81       	ldd	r30, Y+1	; 0x01
    551c:	fa 81       	ldd	r31, Y+2	; 0x02
    551e:	86 89       	ldd	r24, Z+22	; 0x16
    5520:	80 93 95 05 	sts	0x0595, r24
    5524:	e9 81       	ldd	r30, Y+1	; 0x01
    5526:	fa 81       	ldd	r31, Y+2	; 0x02
    5528:	86 89       	ldd	r24, Z+22	; 0x16
    552a:	28 2f       	mov	r18, r24
    552c:	30 e0       	ldi	r19, 0x00	; 0
    552e:	c9 01       	movw	r24, r18
    5530:	88 0f       	add	r24, r24
    5532:	99 1f       	adc	r25, r25
    5534:	88 0f       	add	r24, r24
    5536:	99 1f       	adc	r25, r25
    5538:	88 0f       	add	r24, r24
    553a:	99 1f       	adc	r25, r25
    553c:	82 0f       	add	r24, r18
    553e:	93 1f       	adc	r25, r19
    5540:	ac 01       	movw	r20, r24
    5542:	40 56       	subi	r20, 0x60	; 96
    5544:	5a 4f       	sbci	r21, 0xFA	; 250
    5546:	89 81       	ldd	r24, Y+1	; 0x01
    5548:	9a 81       	ldd	r25, Y+2	; 0x02
    554a:	9c 01       	movw	r18, r24
    554c:	2e 5f       	subi	r18, 0xFE	; 254
    554e:	3f 4f       	sbci	r19, 0xFF	; 255
    5550:	ca 01       	movw	r24, r20
    5552:	b9 01       	movw	r22, r18
    5554:	0e 94 77 22 	call	0x44ee	; 0x44ee <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    5558:	e9 81       	ldd	r30, Y+1	; 0x01
    555a:	fa 81       	ldd	r31, Y+2	; 0x02
    555c:	96 89       	ldd	r25, Z+22	; 0x16
    555e:	e0 91 8f 05 	lds	r30, 0x058F
    5562:	f0 91 90 05 	lds	r31, 0x0590
    5566:	86 89       	ldd	r24, Z+22	; 0x16
    5568:	98 17       	cp	r25, r24
    556a:	10 f0       	brcs	.+4      	; 0x5570 <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    556c:	0e 94 32 25 	call	0x4a64	; 0x4a64 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    5570:	0f 90       	pop	r0
    5572:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    5574:	0f 90       	pop	r0
    5576:	0f 90       	pop	r0
    5578:	0f 90       	pop	r0
    557a:	0f 90       	pop	r0
    557c:	cf 91       	pop	r28
    557e:	df 91       	pop	r29
    5580:	08 95       	ret

00005582 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    5582:	df 93       	push	r29
    5584:	cf 93       	push	r28
    5586:	00 d0       	rcall	.+0      	; 0x5588 <xTaskResumeFromISR+0x6>
    5588:	00 d0       	rcall	.+0      	; 0x558a <xTaskResumeFromISR+0x8>
    558a:	00 d0       	rcall	.+0      	; 0x558c <xTaskResumeFromISR+0xa>
    558c:	cd b7       	in	r28, 0x3d	; 61
    558e:	de b7       	in	r29, 0x3e	; 62
    5590:	9e 83       	std	Y+6, r25	; 0x06
    5592:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    5594:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
    5596:	8d 81       	ldd	r24, Y+5	; 0x05
    5598:	9e 81       	ldd	r25, Y+6	; 0x06
    559a:	9b 83       	std	Y+3, r25	; 0x03
    559c:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    559e:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    55a0:	8a 81       	ldd	r24, Y+2	; 0x02
    55a2:	9b 81       	ldd	r25, Y+3	; 0x03
    55a4:	0e 94 2e 2a 	call	0x545c	; 0x545c <prvTaskIsTaskSuspended>
    55a8:	88 23       	and	r24, r24
    55aa:	09 f4       	brne	.+2      	; 0x55ae <xTaskResumeFromISR+0x2c>
    55ac:	46 c0       	rjmp	.+140    	; 0x563a <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    55ae:	80 91 9f 05 	lds	r24, 0x059F
    55b2:	88 23       	and	r24, r24
    55b4:	c1 f5       	brne	.+112    	; 0x5626 <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    55b6:	ea 81       	ldd	r30, Y+2	; 0x02
    55b8:	fb 81       	ldd	r31, Y+3	; 0x03
    55ba:	96 89       	ldd	r25, Z+22	; 0x16
    55bc:	e0 91 8f 05 	lds	r30, 0x058F
    55c0:	f0 91 90 05 	lds	r31, 0x0590
    55c4:	86 89       	ldd	r24, Z+22	; 0x16
    55c6:	98 17       	cp	r25, r24
    55c8:	10 f0       	brcs	.+4      	; 0x55ce <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    55ca:	81 e0       	ldi	r24, 0x01	; 1
    55cc:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    55ce:	8a 81       	ldd	r24, Y+2	; 0x02
    55d0:	9b 81       	ldd	r25, Y+3	; 0x03
    55d2:	02 96       	adiw	r24, 0x02	; 2
    55d4:	0e 94 27 23 	call	0x464e	; 0x464e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    55d8:	ea 81       	ldd	r30, Y+2	; 0x02
    55da:	fb 81       	ldd	r31, Y+3	; 0x03
    55dc:	96 89       	ldd	r25, Z+22	; 0x16
    55de:	80 91 95 05 	lds	r24, 0x0595
    55e2:	89 17       	cp	r24, r25
    55e4:	28 f4       	brcc	.+10     	; 0x55f0 <xTaskResumeFromISR+0x6e>
    55e6:	ea 81       	ldd	r30, Y+2	; 0x02
    55e8:	fb 81       	ldd	r31, Y+3	; 0x03
    55ea:	86 89       	ldd	r24, Z+22	; 0x16
    55ec:	80 93 95 05 	sts	0x0595, r24
    55f0:	ea 81       	ldd	r30, Y+2	; 0x02
    55f2:	fb 81       	ldd	r31, Y+3	; 0x03
    55f4:	86 89       	ldd	r24, Z+22	; 0x16
    55f6:	28 2f       	mov	r18, r24
    55f8:	30 e0       	ldi	r19, 0x00	; 0
    55fa:	c9 01       	movw	r24, r18
    55fc:	88 0f       	add	r24, r24
    55fe:	99 1f       	adc	r25, r25
    5600:	88 0f       	add	r24, r24
    5602:	99 1f       	adc	r25, r25
    5604:	88 0f       	add	r24, r24
    5606:	99 1f       	adc	r25, r25
    5608:	82 0f       	add	r24, r18
    560a:	93 1f       	adc	r25, r19
    560c:	ac 01       	movw	r20, r24
    560e:	40 56       	subi	r20, 0x60	; 96
    5610:	5a 4f       	sbci	r21, 0xFA	; 250
    5612:	8a 81       	ldd	r24, Y+2	; 0x02
    5614:	9b 81       	ldd	r25, Y+3	; 0x03
    5616:	9c 01       	movw	r18, r24
    5618:	2e 5f       	subi	r18, 0xFE	; 254
    561a:	3f 4f       	sbci	r19, 0xFF	; 255
    561c:	ca 01       	movw	r24, r20
    561e:	b9 01       	movw	r22, r18
    5620:	0e 94 77 22 	call	0x44ee	; 0x44ee <vListInsertEnd>
    5624:	0a c0       	rjmp	.+20     	; 0x563a <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5626:	8a 81       	ldd	r24, Y+2	; 0x02
    5628:	9b 81       	ldd	r25, Y+3	; 0x03
    562a:	9c 01       	movw	r18, r24
    562c:	24 5f       	subi	r18, 0xF4	; 244
    562e:	3f 4f       	sbci	r19, 0xFF	; 255
    5630:	87 e0       	ldi	r24, 0x07	; 7
    5632:	96 e0       	ldi	r25, 0x06	; 6
    5634:	b9 01       	movw	r22, r18
    5636:	0e 94 77 22 	call	0x44ee	; 0x44ee <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    563a:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    563c:	26 96       	adiw	r28, 0x06	; 6
    563e:	0f b6       	in	r0, 0x3f	; 63
    5640:	f8 94       	cli
    5642:	de bf       	out	0x3e, r29	; 62
    5644:	0f be       	out	0x3f, r0	; 63
    5646:	cd bf       	out	0x3d, r28	; 61
    5648:	cf 91       	pop	r28
    564a:	df 91       	pop	r29
    564c:	08 95       	ret

0000564e <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    564e:	ef 92       	push	r14
    5650:	ff 92       	push	r15
    5652:	0f 93       	push	r16
    5654:	df 93       	push	r29
    5656:	cf 93       	push	r28
    5658:	0f 92       	push	r0
    565a:	cd b7       	in	r28, 0x3d	; 61
    565c:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    565e:	8c e4       	ldi	r24, 0x4C	; 76
    5660:	9f e2       	ldi	r25, 0x2F	; 47
    5662:	20 e6       	ldi	r18, 0x60	; 96
    5664:	30 e0       	ldi	r19, 0x00	; 0
    5666:	ed e9       	ldi	r30, 0x9D	; 157
    5668:	f5 e0       	ldi	r31, 0x05	; 5
    566a:	b9 01       	movw	r22, r18
    566c:	40 e5       	ldi	r20, 0x50	; 80
    566e:	50 e0       	ldi	r21, 0x00	; 0
    5670:	20 e0       	ldi	r18, 0x00	; 0
    5672:	30 e0       	ldi	r19, 0x00	; 0
    5674:	00 e0       	ldi	r16, 0x00	; 0
    5676:	7f 01       	movw	r14, r30
    5678:	0e 94 47 26 	call	0x4c8e	; 0x4c8e <xTaskCreate>
    567c:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    567e:	89 81       	ldd	r24, Y+1	; 0x01
    5680:	81 30       	cpi	r24, 0x01	; 1
    5682:	81 f4       	brne	.+32     	; 0x56a4 <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    5684:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    5686:	8f ef       	ldi	r24, 0xFF	; 255
    5688:	9f ef       	ldi	r25, 0xFF	; 255
    568a:	90 93 9c 05 	sts	0x059C, r25
    568e:	80 93 9b 05 	sts	0x059B, r24
		xSchedulerRunning = pdTRUE;
    5692:	81 e0       	ldi	r24, 0x01	; 1
    5694:	80 93 96 05 	sts	0x0596, r24
		xTickCount = ( TickType_t ) 0U;
    5698:	10 92 94 05 	sts	0x0594, r1
    569c:	10 92 93 05 	sts	0x0593, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    56a0:	0e 94 f6 24 	call	0x49ec	; 0x49ec <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    56a4:	0f 90       	pop	r0
    56a6:	cf 91       	pop	r28
    56a8:	df 91       	pop	r29
    56aa:	0f 91       	pop	r16
    56ac:	ff 90       	pop	r15
    56ae:	ef 90       	pop	r14
    56b0:	08 95       	ret

000056b2 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    56b2:	df 93       	push	r29
    56b4:	cf 93       	push	r28
    56b6:	cd b7       	in	r28, 0x3d	; 61
    56b8:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    56ba:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    56bc:	10 92 96 05 	sts	0x0596, r1
	vPortEndScheduler();
    56c0:	0e 94 2b 25 	call	0x4a56	; 0x4a56 <vPortEndScheduler>
}
    56c4:	cf 91       	pop	r28
    56c6:	df 91       	pop	r29
    56c8:	08 95       	ret

000056ca <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    56ca:	df 93       	push	r29
    56cc:	cf 93       	push	r28
    56ce:	cd b7       	in	r28, 0x3d	; 61
    56d0:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    56d2:	80 91 9f 05 	lds	r24, 0x059F
    56d6:	8f 5f       	subi	r24, 0xFF	; 255
    56d8:	80 93 9f 05 	sts	0x059F, r24
}
    56dc:	cf 91       	pop	r28
    56de:	df 91       	pop	r29
    56e0:	08 95       	ret

000056e2 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    56e2:	df 93       	push	r29
    56e4:	cf 93       	push	r28
    56e6:	00 d0       	rcall	.+0      	; 0x56e8 <xTaskResumeAll+0x6>
    56e8:	00 d0       	rcall	.+0      	; 0x56ea <xTaskResumeAll+0x8>
    56ea:	cd b7       	in	r28, 0x3d	; 61
    56ec:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    56ee:	1c 82       	std	Y+4, r1	; 0x04
    56f0:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    56f2:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    56f4:	0f b6       	in	r0, 0x3f	; 63
    56f6:	f8 94       	cli
    56f8:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    56fa:	80 91 9f 05 	lds	r24, 0x059F
    56fe:	81 50       	subi	r24, 0x01	; 1
    5700:	80 93 9f 05 	sts	0x059F, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5704:	80 91 9f 05 	lds	r24, 0x059F
    5708:	88 23       	and	r24, r24
    570a:	09 f0       	breq	.+2      	; 0x570e <xTaskResumeAll+0x2c>
    570c:	73 c0       	rjmp	.+230    	; 0x57f4 <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    570e:	80 91 92 05 	lds	r24, 0x0592
    5712:	88 23       	and	r24, r24
    5714:	09 f4       	brne	.+2      	; 0x5718 <xTaskResumeAll+0x36>
    5716:	6e c0       	rjmp	.+220    	; 0x57f4 <xTaskResumeAll+0x112>
    5718:	45 c0       	rjmp	.+138    	; 0x57a4 <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    571a:	e0 91 0c 06 	lds	r30, 0x060C
    571e:	f0 91 0d 06 	lds	r31, 0x060D
    5722:	86 81       	ldd	r24, Z+6	; 0x06
    5724:	97 81       	ldd	r25, Z+7	; 0x07
    5726:	9c 83       	std	Y+4, r25	; 0x04
    5728:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    572a:	8b 81       	ldd	r24, Y+3	; 0x03
    572c:	9c 81       	ldd	r25, Y+4	; 0x04
    572e:	0c 96       	adiw	r24, 0x0c	; 12
    5730:	0e 94 27 23 	call	0x464e	; 0x464e <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5734:	8b 81       	ldd	r24, Y+3	; 0x03
    5736:	9c 81       	ldd	r25, Y+4	; 0x04
    5738:	02 96       	adiw	r24, 0x02	; 2
    573a:	0e 94 27 23 	call	0x464e	; 0x464e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    573e:	eb 81       	ldd	r30, Y+3	; 0x03
    5740:	fc 81       	ldd	r31, Y+4	; 0x04
    5742:	96 89       	ldd	r25, Z+22	; 0x16
    5744:	80 91 95 05 	lds	r24, 0x0595
    5748:	89 17       	cp	r24, r25
    574a:	28 f4       	brcc	.+10     	; 0x5756 <xTaskResumeAll+0x74>
    574c:	eb 81       	ldd	r30, Y+3	; 0x03
    574e:	fc 81       	ldd	r31, Y+4	; 0x04
    5750:	86 89       	ldd	r24, Z+22	; 0x16
    5752:	80 93 95 05 	sts	0x0595, r24
    5756:	eb 81       	ldd	r30, Y+3	; 0x03
    5758:	fc 81       	ldd	r31, Y+4	; 0x04
    575a:	86 89       	ldd	r24, Z+22	; 0x16
    575c:	28 2f       	mov	r18, r24
    575e:	30 e0       	ldi	r19, 0x00	; 0
    5760:	c9 01       	movw	r24, r18
    5762:	88 0f       	add	r24, r24
    5764:	99 1f       	adc	r25, r25
    5766:	88 0f       	add	r24, r24
    5768:	99 1f       	adc	r25, r25
    576a:	88 0f       	add	r24, r24
    576c:	99 1f       	adc	r25, r25
    576e:	82 0f       	add	r24, r18
    5770:	93 1f       	adc	r25, r19
    5772:	ac 01       	movw	r20, r24
    5774:	40 56       	subi	r20, 0x60	; 96
    5776:	5a 4f       	sbci	r21, 0xFA	; 250
    5778:	8b 81       	ldd	r24, Y+3	; 0x03
    577a:	9c 81       	ldd	r25, Y+4	; 0x04
    577c:	9c 01       	movw	r18, r24
    577e:	2e 5f       	subi	r18, 0xFE	; 254
    5780:	3f 4f       	sbci	r19, 0xFF	; 255
    5782:	ca 01       	movw	r24, r20
    5784:	b9 01       	movw	r22, r18
    5786:	0e 94 77 22 	call	0x44ee	; 0x44ee <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    578a:	eb 81       	ldd	r30, Y+3	; 0x03
    578c:	fc 81       	ldd	r31, Y+4	; 0x04
    578e:	96 89       	ldd	r25, Z+22	; 0x16
    5790:	e0 91 8f 05 	lds	r30, 0x058F
    5794:	f0 91 90 05 	lds	r31, 0x0590
    5798:	86 89       	ldd	r24, Z+22	; 0x16
    579a:	98 17       	cp	r25, r24
    579c:	18 f0       	brcs	.+6      	; 0x57a4 <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    579e:	81 e0       	ldi	r24, 0x01	; 1
    57a0:	80 93 98 05 	sts	0x0598, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    57a4:	80 91 07 06 	lds	r24, 0x0607
    57a8:	88 23       	and	r24, r24
    57aa:	09 f0       	breq	.+2      	; 0x57ae <xTaskResumeAll+0xcc>
    57ac:	b6 cf       	rjmp	.-148    	; 0x571a <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    57ae:	8b 81       	ldd	r24, Y+3	; 0x03
    57b0:	9c 81       	ldd	r25, Y+4	; 0x04
    57b2:	00 97       	sbiw	r24, 0x00	; 0
    57b4:	11 f0       	breq	.+4      	; 0x57ba <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    57b6:	0e 94 ec 2f 	call	0x5fd8	; 0x5fd8 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    57ba:	80 91 97 05 	lds	r24, 0x0597
    57be:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    57c0:	89 81       	ldd	r24, Y+1	; 0x01
    57c2:	88 23       	and	r24, r24
    57c4:	79 f0       	breq	.+30     	; 0x57e4 <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    57c6:	0e 94 61 2c 	call	0x58c2	; 0x58c2 <xTaskIncrementTick>
    57ca:	88 23       	and	r24, r24
    57cc:	19 f0       	breq	.+6      	; 0x57d4 <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    57ce:	81 e0       	ldi	r24, 0x01	; 1
    57d0:	80 93 98 05 	sts	0x0598, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    57d4:	89 81       	ldd	r24, Y+1	; 0x01
    57d6:	81 50       	subi	r24, 0x01	; 1
    57d8:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    57da:	89 81       	ldd	r24, Y+1	; 0x01
    57dc:	88 23       	and	r24, r24
    57de:	99 f7       	brne	.-26     	; 0x57c6 <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    57e0:	10 92 97 05 	sts	0x0597, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    57e4:	80 91 98 05 	lds	r24, 0x0598
    57e8:	88 23       	and	r24, r24
    57ea:	21 f0       	breq	.+8      	; 0x57f4 <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    57ec:	81 e0       	ldi	r24, 0x01	; 1
    57ee:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    57f0:	0e 94 32 25 	call	0x4a64	; 0x4a64 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    57f4:	0f 90       	pop	r0
    57f6:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    57f8:	8a 81       	ldd	r24, Y+2	; 0x02
}
    57fa:	0f 90       	pop	r0
    57fc:	0f 90       	pop	r0
    57fe:	0f 90       	pop	r0
    5800:	0f 90       	pop	r0
    5802:	cf 91       	pop	r28
    5804:	df 91       	pop	r29
    5806:	08 95       	ret

00005808 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    5808:	df 93       	push	r29
    580a:	cf 93       	push	r28
    580c:	00 d0       	rcall	.+0      	; 0x580e <xTaskGetTickCount+0x6>
    580e:	cd b7       	in	r28, 0x3d	; 61
    5810:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    5812:	0f b6       	in	r0, 0x3f	; 63
    5814:	f8 94       	cli
    5816:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    5818:	80 91 93 05 	lds	r24, 0x0593
    581c:	90 91 94 05 	lds	r25, 0x0594
    5820:	9a 83       	std	Y+2, r25	; 0x02
    5822:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    5824:	0f 90       	pop	r0
    5826:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    5828:	89 81       	ldd	r24, Y+1	; 0x01
    582a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    582c:	0f 90       	pop	r0
    582e:	0f 90       	pop	r0
    5830:	cf 91       	pop	r28
    5832:	df 91       	pop	r29
    5834:	08 95       	ret

00005836 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    5836:	df 93       	push	r29
    5838:	cf 93       	push	r28
    583a:	00 d0       	rcall	.+0      	; 0x583c <xTaskGetTickCountFromISR+0x6>
    583c:	0f 92       	push	r0
    583e:	cd b7       	in	r28, 0x3d	; 61
    5840:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    5842:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    5844:	80 91 93 05 	lds	r24, 0x0593
    5848:	90 91 94 05 	lds	r25, 0x0594
    584c:	9b 83       	std	Y+3, r25	; 0x03
    584e:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    5850:	8a 81       	ldd	r24, Y+2	; 0x02
    5852:	9b 81       	ldd	r25, Y+3	; 0x03
}
    5854:	0f 90       	pop	r0
    5856:	0f 90       	pop	r0
    5858:	0f 90       	pop	r0
    585a:	cf 91       	pop	r28
    585c:	df 91       	pop	r29
    585e:	08 95       	ret

00005860 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    5860:	df 93       	push	r29
    5862:	cf 93       	push	r28
    5864:	cd b7       	in	r28, 0x3d	; 61
    5866:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    5868:	80 91 92 05 	lds	r24, 0x0592
}
    586c:	cf 91       	pop	r28
    586e:	df 91       	pop	r29
    5870:	08 95       	ret

00005872 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    5872:	df 93       	push	r29
    5874:	cf 93       	push	r28
    5876:	00 d0       	rcall	.+0      	; 0x5878 <pcTaskGetName+0x6>
    5878:	00 d0       	rcall	.+0      	; 0x587a <pcTaskGetName+0x8>
    587a:	00 d0       	rcall	.+0      	; 0x587c <pcTaskGetName+0xa>
    587c:	cd b7       	in	r28, 0x3d	; 61
    587e:	de b7       	in	r29, 0x3e	; 62
    5880:	9c 83       	std	Y+4, r25	; 0x04
    5882:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    5884:	8b 81       	ldd	r24, Y+3	; 0x03
    5886:	9c 81       	ldd	r25, Y+4	; 0x04
    5888:	00 97       	sbiw	r24, 0x00	; 0
    588a:	39 f4       	brne	.+14     	; 0x589a <pcTaskGetName+0x28>
    588c:	80 91 8f 05 	lds	r24, 0x058F
    5890:	90 91 90 05 	lds	r25, 0x0590
    5894:	9e 83       	std	Y+6, r25	; 0x06
    5896:	8d 83       	std	Y+5, r24	; 0x05
    5898:	04 c0       	rjmp	.+8      	; 0x58a2 <pcTaskGetName+0x30>
    589a:	8b 81       	ldd	r24, Y+3	; 0x03
    589c:	9c 81       	ldd	r25, Y+4	; 0x04
    589e:	9e 83       	std	Y+6, r25	; 0x06
    58a0:	8d 83       	std	Y+5, r24	; 0x05
    58a2:	8d 81       	ldd	r24, Y+5	; 0x05
    58a4:	9e 81       	ldd	r25, Y+6	; 0x06
    58a6:	9a 83       	std	Y+2, r25	; 0x02
    58a8:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    58aa:	89 81       	ldd	r24, Y+1	; 0x01
    58ac:	9a 81       	ldd	r25, Y+2	; 0x02
    58ae:	49 96       	adiw	r24, 0x19	; 25
}
    58b0:	26 96       	adiw	r28, 0x06	; 6
    58b2:	0f b6       	in	r0, 0x3f	; 63
    58b4:	f8 94       	cli
    58b6:	de bf       	out	0x3e, r29	; 62
    58b8:	0f be       	out	0x3f, r0	; 63
    58ba:	cd bf       	out	0x3d, r28	; 61
    58bc:	cf 91       	pop	r28
    58be:	df 91       	pop	r29
    58c0:	08 95       	ret

000058c2 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    58c2:	df 93       	push	r29
    58c4:	cf 93       	push	r28
    58c6:	cd b7       	in	r28, 0x3d	; 61
    58c8:	de b7       	in	r29, 0x3e	; 62
    58ca:	29 97       	sbiw	r28, 0x09	; 9
    58cc:	0f b6       	in	r0, 0x3f	; 63
    58ce:	f8 94       	cli
    58d0:	de bf       	out	0x3e, r29	; 62
    58d2:	0f be       	out	0x3f, r0	; 63
    58d4:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    58d6:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    58d8:	80 91 9f 05 	lds	r24, 0x059F
    58dc:	88 23       	and	r24, r24
    58de:	09 f0       	breq	.+2      	; 0x58e2 <xTaskIncrementTick+0x20>
    58e0:	a7 c0       	rjmp	.+334    	; 0x5a30 <xTaskIncrementTick+0x16e>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
    58e2:	80 91 93 05 	lds	r24, 0x0593
    58e6:	90 91 94 05 	lds	r25, 0x0594
    58ea:	01 96       	adiw	r24, 0x01	; 1
    58ec:	9c 83       	std	Y+4, r25	; 0x04
    58ee:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    58f0:	8b 81       	ldd	r24, Y+3	; 0x03
    58f2:	9c 81       	ldd	r25, Y+4	; 0x04
    58f4:	90 93 94 05 	sts	0x0594, r25
    58f8:	80 93 93 05 	sts	0x0593, r24

		if( xConstTickCount == ( TickType_t ) 0U )
    58fc:	8b 81       	ldd	r24, Y+3	; 0x03
    58fe:	9c 81       	ldd	r25, Y+4	; 0x04
    5900:	00 97       	sbiw	r24, 0x00	; 0
    5902:	d9 f4       	brne	.+54     	; 0x593a <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    5904:	80 91 03 06 	lds	r24, 0x0603
    5908:	90 91 04 06 	lds	r25, 0x0604
    590c:	9a 83       	std	Y+2, r25	; 0x02
    590e:	89 83       	std	Y+1, r24	; 0x01
    5910:	80 91 05 06 	lds	r24, 0x0605
    5914:	90 91 06 06 	lds	r25, 0x0606
    5918:	90 93 04 06 	sts	0x0604, r25
    591c:	80 93 03 06 	sts	0x0603, r24
    5920:	89 81       	ldd	r24, Y+1	; 0x01
    5922:	9a 81       	ldd	r25, Y+2	; 0x02
    5924:	90 93 06 06 	sts	0x0606, r25
    5928:	80 93 05 06 	sts	0x0605, r24
    592c:	80 91 99 05 	lds	r24, 0x0599
    5930:	8f 5f       	subi	r24, 0xFF	; 255
    5932:	80 93 99 05 	sts	0x0599, r24
    5936:	0e 94 ec 2f 	call	0x5fd8	; 0x5fd8 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    593a:	20 91 9b 05 	lds	r18, 0x059B
    593e:	30 91 9c 05 	lds	r19, 0x059C
    5942:	8b 81       	ldd	r24, Y+3	; 0x03
    5944:	9c 81       	ldd	r25, Y+4	; 0x04
    5946:	82 17       	cp	r24, r18
    5948:	93 07       	cpc	r25, r19
    594a:	08 f4       	brcc	.+2      	; 0x594e <xTaskIncrementTick+0x8c>
    594c:	76 c0       	rjmp	.+236    	; 0x5a3a <xTaskIncrementTick+0x178>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    594e:	e0 91 03 06 	lds	r30, 0x0603
    5952:	f0 91 04 06 	lds	r31, 0x0604
    5956:	80 81       	ld	r24, Z
    5958:	88 23       	and	r24, r24
    595a:	39 f4       	brne	.+14     	; 0x596a <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    595c:	8f ef       	ldi	r24, 0xFF	; 255
    595e:	9f ef       	ldi	r25, 0xFF	; 255
    5960:	90 93 9c 05 	sts	0x059C, r25
    5964:	80 93 9b 05 	sts	0x059B, r24
    5968:	68 c0       	rjmp	.+208    	; 0x5a3a <xTaskIncrementTick+0x178>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    596a:	e0 91 03 06 	lds	r30, 0x0603
    596e:	f0 91 04 06 	lds	r31, 0x0604
    5972:	05 80       	ldd	r0, Z+5	; 0x05
    5974:	f6 81       	ldd	r31, Z+6	; 0x06
    5976:	e0 2d       	mov	r30, r0
    5978:	86 81       	ldd	r24, Z+6	; 0x06
    597a:	97 81       	ldd	r25, Z+7	; 0x07
    597c:	99 87       	std	Y+9, r25	; 0x09
    597e:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    5980:	e8 85       	ldd	r30, Y+8	; 0x08
    5982:	f9 85       	ldd	r31, Y+9	; 0x09
    5984:	82 81       	ldd	r24, Z+2	; 0x02
    5986:	93 81       	ldd	r25, Z+3	; 0x03
    5988:	9f 83       	std	Y+7, r25	; 0x07
    598a:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    598c:	2b 81       	ldd	r18, Y+3	; 0x03
    598e:	3c 81       	ldd	r19, Y+4	; 0x04
    5990:	8e 81       	ldd	r24, Y+6	; 0x06
    5992:	9f 81       	ldd	r25, Y+7	; 0x07
    5994:	28 17       	cp	r18, r24
    5996:	39 07       	cpc	r19, r25
    5998:	38 f4       	brcc	.+14     	; 0x59a8 <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    599a:	8e 81       	ldd	r24, Y+6	; 0x06
    599c:	9f 81       	ldd	r25, Y+7	; 0x07
    599e:	90 93 9c 05 	sts	0x059C, r25
    59a2:	80 93 9b 05 	sts	0x059B, r24
    59a6:	49 c0       	rjmp	.+146    	; 0x5a3a <xTaskIncrementTick+0x178>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    59a8:	88 85       	ldd	r24, Y+8	; 0x08
    59aa:	99 85       	ldd	r25, Y+9	; 0x09
    59ac:	02 96       	adiw	r24, 0x02	; 2
    59ae:	0e 94 27 23 	call	0x464e	; 0x464e <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    59b2:	e8 85       	ldd	r30, Y+8	; 0x08
    59b4:	f9 85       	ldd	r31, Y+9	; 0x09
    59b6:	84 89       	ldd	r24, Z+20	; 0x14
    59b8:	95 89       	ldd	r25, Z+21	; 0x15
    59ba:	00 97       	sbiw	r24, 0x00	; 0
    59bc:	29 f0       	breq	.+10     	; 0x59c8 <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    59be:	88 85       	ldd	r24, Y+8	; 0x08
    59c0:	99 85       	ldd	r25, Y+9	; 0x09
    59c2:	0c 96       	adiw	r24, 0x0c	; 12
    59c4:	0e 94 27 23 	call	0x464e	; 0x464e <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    59c8:	e8 85       	ldd	r30, Y+8	; 0x08
    59ca:	f9 85       	ldd	r31, Y+9	; 0x09
    59cc:	96 89       	ldd	r25, Z+22	; 0x16
    59ce:	80 91 95 05 	lds	r24, 0x0595
    59d2:	89 17       	cp	r24, r25
    59d4:	28 f4       	brcc	.+10     	; 0x59e0 <xTaskIncrementTick+0x11e>
    59d6:	e8 85       	ldd	r30, Y+8	; 0x08
    59d8:	f9 85       	ldd	r31, Y+9	; 0x09
    59da:	86 89       	ldd	r24, Z+22	; 0x16
    59dc:	80 93 95 05 	sts	0x0595, r24
    59e0:	e8 85       	ldd	r30, Y+8	; 0x08
    59e2:	f9 85       	ldd	r31, Y+9	; 0x09
    59e4:	86 89       	ldd	r24, Z+22	; 0x16
    59e6:	28 2f       	mov	r18, r24
    59e8:	30 e0       	ldi	r19, 0x00	; 0
    59ea:	c9 01       	movw	r24, r18
    59ec:	88 0f       	add	r24, r24
    59ee:	99 1f       	adc	r25, r25
    59f0:	88 0f       	add	r24, r24
    59f2:	99 1f       	adc	r25, r25
    59f4:	88 0f       	add	r24, r24
    59f6:	99 1f       	adc	r25, r25
    59f8:	82 0f       	add	r24, r18
    59fa:	93 1f       	adc	r25, r19
    59fc:	ac 01       	movw	r20, r24
    59fe:	40 56       	subi	r20, 0x60	; 96
    5a00:	5a 4f       	sbci	r21, 0xFA	; 250
    5a02:	88 85       	ldd	r24, Y+8	; 0x08
    5a04:	99 85       	ldd	r25, Y+9	; 0x09
    5a06:	9c 01       	movw	r18, r24
    5a08:	2e 5f       	subi	r18, 0xFE	; 254
    5a0a:	3f 4f       	sbci	r19, 0xFF	; 255
    5a0c:	ca 01       	movw	r24, r20
    5a0e:	b9 01       	movw	r22, r18
    5a10:	0e 94 77 22 	call	0x44ee	; 0x44ee <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    5a14:	e8 85       	ldd	r30, Y+8	; 0x08
    5a16:	f9 85       	ldd	r31, Y+9	; 0x09
    5a18:	96 89       	ldd	r25, Z+22	; 0x16
    5a1a:	e0 91 8f 05 	lds	r30, 0x058F
    5a1e:	f0 91 90 05 	lds	r31, 0x0590
    5a22:	86 89       	ldd	r24, Z+22	; 0x16
    5a24:	98 17       	cp	r25, r24
    5a26:	08 f4       	brcc	.+2      	; 0x5a2a <xTaskIncrementTick+0x168>
    5a28:	92 cf       	rjmp	.-220    	; 0x594e <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    5a2a:	81 e0       	ldi	r24, 0x01	; 1
    5a2c:	8d 83       	std	Y+5, r24	; 0x05
    5a2e:	8f cf       	rjmp	.-226    	; 0x594e <xTaskIncrementTick+0x8c>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    5a30:	80 91 97 05 	lds	r24, 0x0597
    5a34:	8f 5f       	subi	r24, 0xFF	; 255
    5a36:	80 93 97 05 	sts	0x0597, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    5a3a:	80 91 98 05 	lds	r24, 0x0598
    5a3e:	88 23       	and	r24, r24
    5a40:	11 f0       	breq	.+4      	; 0x5a46 <xTaskIncrementTick+0x184>
		{
			xSwitchRequired = pdTRUE;
    5a42:	81 e0       	ldi	r24, 0x01	; 1
    5a44:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    5a46:	8d 81       	ldd	r24, Y+5	; 0x05
}
    5a48:	29 96       	adiw	r28, 0x09	; 9
    5a4a:	0f b6       	in	r0, 0x3f	; 63
    5a4c:	f8 94       	cli
    5a4e:	de bf       	out	0x3e, r29	; 62
    5a50:	0f be       	out	0x3f, r0	; 63
    5a52:	cd bf       	out	0x3d, r28	; 61
    5a54:	cf 91       	pop	r28
    5a56:	df 91       	pop	r29
    5a58:	08 95       	ret

00005a5a <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    5a5a:	df 93       	push	r29
    5a5c:	cf 93       	push	r28
    5a5e:	00 d0       	rcall	.+0      	; 0x5a60 <vTaskSwitchContext+0x6>
    5a60:	0f 92       	push	r0
    5a62:	cd b7       	in	r28, 0x3d	; 61
    5a64:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    5a66:	80 91 9f 05 	lds	r24, 0x059F
    5a6a:	88 23       	and	r24, r24
    5a6c:	21 f0       	breq	.+8      	; 0x5a76 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    5a6e:	81 e0       	ldi	r24, 0x01	; 1
    5a70:	80 93 98 05 	sts	0x0598, r24
    5a74:	59 c0       	rjmp	.+178    	; 0x5b28 <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    5a76:	10 92 98 05 	sts	0x0598, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    5a7a:	80 91 95 05 	lds	r24, 0x0595
    5a7e:	8b 83       	std	Y+3, r24	; 0x03
    5a80:	03 c0       	rjmp	.+6      	; 0x5a88 <vTaskSwitchContext+0x2e>
    5a82:	8b 81       	ldd	r24, Y+3	; 0x03
    5a84:	81 50       	subi	r24, 0x01	; 1
    5a86:	8b 83       	std	Y+3, r24	; 0x03
    5a88:	8b 81       	ldd	r24, Y+3	; 0x03
    5a8a:	28 2f       	mov	r18, r24
    5a8c:	30 e0       	ldi	r19, 0x00	; 0
    5a8e:	c9 01       	movw	r24, r18
    5a90:	88 0f       	add	r24, r24
    5a92:	99 1f       	adc	r25, r25
    5a94:	88 0f       	add	r24, r24
    5a96:	99 1f       	adc	r25, r25
    5a98:	88 0f       	add	r24, r24
    5a9a:	99 1f       	adc	r25, r25
    5a9c:	82 0f       	add	r24, r18
    5a9e:	93 1f       	adc	r25, r19
    5aa0:	fc 01       	movw	r30, r24
    5aa2:	e0 56       	subi	r30, 0x60	; 96
    5aa4:	fa 4f       	sbci	r31, 0xFA	; 250
    5aa6:	80 81       	ld	r24, Z
    5aa8:	88 23       	and	r24, r24
    5aaa:	59 f3       	breq	.-42     	; 0x5a82 <vTaskSwitchContext+0x28>
    5aac:	8b 81       	ldd	r24, Y+3	; 0x03
    5aae:	28 2f       	mov	r18, r24
    5ab0:	30 e0       	ldi	r19, 0x00	; 0
    5ab2:	c9 01       	movw	r24, r18
    5ab4:	88 0f       	add	r24, r24
    5ab6:	99 1f       	adc	r25, r25
    5ab8:	88 0f       	add	r24, r24
    5aba:	99 1f       	adc	r25, r25
    5abc:	88 0f       	add	r24, r24
    5abe:	99 1f       	adc	r25, r25
    5ac0:	82 0f       	add	r24, r18
    5ac2:	93 1f       	adc	r25, r19
    5ac4:	80 56       	subi	r24, 0x60	; 96
    5ac6:	9a 4f       	sbci	r25, 0xFA	; 250
    5ac8:	9a 83       	std	Y+2, r25	; 0x02
    5aca:	89 83       	std	Y+1, r24	; 0x01
    5acc:	e9 81       	ldd	r30, Y+1	; 0x01
    5ace:	fa 81       	ldd	r31, Y+2	; 0x02
    5ad0:	01 80       	ldd	r0, Z+1	; 0x01
    5ad2:	f2 81       	ldd	r31, Z+2	; 0x02
    5ad4:	e0 2d       	mov	r30, r0
    5ad6:	82 81       	ldd	r24, Z+2	; 0x02
    5ad8:	93 81       	ldd	r25, Z+3	; 0x03
    5ada:	e9 81       	ldd	r30, Y+1	; 0x01
    5adc:	fa 81       	ldd	r31, Y+2	; 0x02
    5ade:	92 83       	std	Z+2, r25	; 0x02
    5ae0:	81 83       	std	Z+1, r24	; 0x01
    5ae2:	e9 81       	ldd	r30, Y+1	; 0x01
    5ae4:	fa 81       	ldd	r31, Y+2	; 0x02
    5ae6:	21 81       	ldd	r18, Z+1	; 0x01
    5ae8:	32 81       	ldd	r19, Z+2	; 0x02
    5aea:	89 81       	ldd	r24, Y+1	; 0x01
    5aec:	9a 81       	ldd	r25, Y+2	; 0x02
    5aee:	03 96       	adiw	r24, 0x03	; 3
    5af0:	28 17       	cp	r18, r24
    5af2:	39 07       	cpc	r19, r25
    5af4:	59 f4       	brne	.+22     	; 0x5b0c <vTaskSwitchContext+0xb2>
    5af6:	e9 81       	ldd	r30, Y+1	; 0x01
    5af8:	fa 81       	ldd	r31, Y+2	; 0x02
    5afa:	01 80       	ldd	r0, Z+1	; 0x01
    5afc:	f2 81       	ldd	r31, Z+2	; 0x02
    5afe:	e0 2d       	mov	r30, r0
    5b00:	82 81       	ldd	r24, Z+2	; 0x02
    5b02:	93 81       	ldd	r25, Z+3	; 0x03
    5b04:	e9 81       	ldd	r30, Y+1	; 0x01
    5b06:	fa 81       	ldd	r31, Y+2	; 0x02
    5b08:	92 83       	std	Z+2, r25	; 0x02
    5b0a:	81 83       	std	Z+1, r24	; 0x01
    5b0c:	e9 81       	ldd	r30, Y+1	; 0x01
    5b0e:	fa 81       	ldd	r31, Y+2	; 0x02
    5b10:	01 80       	ldd	r0, Z+1	; 0x01
    5b12:	f2 81       	ldd	r31, Z+2	; 0x02
    5b14:	e0 2d       	mov	r30, r0
    5b16:	86 81       	ldd	r24, Z+6	; 0x06
    5b18:	97 81       	ldd	r25, Z+7	; 0x07
    5b1a:	90 93 90 05 	sts	0x0590, r25
    5b1e:	80 93 8f 05 	sts	0x058F, r24
    5b22:	8b 81       	ldd	r24, Y+3	; 0x03
    5b24:	80 93 95 05 	sts	0x0595, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    5b28:	0f 90       	pop	r0
    5b2a:	0f 90       	pop	r0
    5b2c:	0f 90       	pop	r0
    5b2e:	cf 91       	pop	r28
    5b30:	df 91       	pop	r29
    5b32:	08 95       	ret

00005b34 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    5b34:	df 93       	push	r29
    5b36:	cf 93       	push	r28
    5b38:	00 d0       	rcall	.+0      	; 0x5b3a <vTaskPlaceOnEventList+0x6>
    5b3a:	00 d0       	rcall	.+0      	; 0x5b3c <vTaskPlaceOnEventList+0x8>
    5b3c:	cd b7       	in	r28, 0x3d	; 61
    5b3e:	de b7       	in	r29, 0x3e	; 62
    5b40:	9a 83       	std	Y+2, r25	; 0x02
    5b42:	89 83       	std	Y+1, r24	; 0x01
    5b44:	7c 83       	std	Y+4, r23	; 0x04
    5b46:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    5b48:	80 91 8f 05 	lds	r24, 0x058F
    5b4c:	90 91 90 05 	lds	r25, 0x0590
    5b50:	9c 01       	movw	r18, r24
    5b52:	24 5f       	subi	r18, 0xF4	; 244
    5b54:	3f 4f       	sbci	r19, 0xFF	; 255
    5b56:	89 81       	ldd	r24, Y+1	; 0x01
    5b58:	9a 81       	ldd	r25, Y+2	; 0x02
    5b5a:	b9 01       	movw	r22, r18
    5b5c:	0e 94 bb 22 	call	0x4576	; 0x4576 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5b60:	8b 81       	ldd	r24, Y+3	; 0x03
    5b62:	9c 81       	ldd	r25, Y+4	; 0x04
    5b64:	61 e0       	ldi	r22, 0x01	; 1
    5b66:	0e 94 0f 35 	call	0x6a1e	; 0x6a1e <prvAddCurrentTaskToDelayedList>
}
    5b6a:	0f 90       	pop	r0
    5b6c:	0f 90       	pop	r0
    5b6e:	0f 90       	pop	r0
    5b70:	0f 90       	pop	r0
    5b72:	cf 91       	pop	r28
    5b74:	df 91       	pop	r29
    5b76:	08 95       	ret

00005b78 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    5b78:	df 93       	push	r29
    5b7a:	cf 93       	push	r28
    5b7c:	00 d0       	rcall	.+0      	; 0x5b7e <vTaskPlaceOnUnorderedEventList+0x6>
    5b7e:	00 d0       	rcall	.+0      	; 0x5b80 <vTaskPlaceOnUnorderedEventList+0x8>
    5b80:	00 d0       	rcall	.+0      	; 0x5b82 <vTaskPlaceOnUnorderedEventList+0xa>
    5b82:	cd b7       	in	r28, 0x3d	; 61
    5b84:	de b7       	in	r29, 0x3e	; 62
    5b86:	9a 83       	std	Y+2, r25	; 0x02
    5b88:	89 83       	std	Y+1, r24	; 0x01
    5b8a:	7c 83       	std	Y+4, r23	; 0x04
    5b8c:	6b 83       	std	Y+3, r22	; 0x03
    5b8e:	5e 83       	std	Y+6, r21	; 0x06
    5b90:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    5b92:	e0 91 8f 05 	lds	r30, 0x058F
    5b96:	f0 91 90 05 	lds	r31, 0x0590
    5b9a:	8b 81       	ldd	r24, Y+3	; 0x03
    5b9c:	9c 81       	ldd	r25, Y+4	; 0x04
    5b9e:	90 68       	ori	r25, 0x80	; 128
    5ba0:	95 87       	std	Z+13, r25	; 0x0d
    5ba2:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    5ba4:	80 91 8f 05 	lds	r24, 0x058F
    5ba8:	90 91 90 05 	lds	r25, 0x0590
    5bac:	9c 01       	movw	r18, r24
    5bae:	24 5f       	subi	r18, 0xF4	; 244
    5bb0:	3f 4f       	sbci	r19, 0xFF	; 255
    5bb2:	89 81       	ldd	r24, Y+1	; 0x01
    5bb4:	9a 81       	ldd	r25, Y+2	; 0x02
    5bb6:	b9 01       	movw	r22, r18
    5bb8:	0e 94 77 22 	call	0x44ee	; 0x44ee <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5bbc:	8d 81       	ldd	r24, Y+5	; 0x05
    5bbe:	9e 81       	ldd	r25, Y+6	; 0x06
    5bc0:	61 e0       	ldi	r22, 0x01	; 1
    5bc2:	0e 94 0f 35 	call	0x6a1e	; 0x6a1e <prvAddCurrentTaskToDelayedList>
}
    5bc6:	26 96       	adiw	r28, 0x06	; 6
    5bc8:	0f b6       	in	r0, 0x3f	; 63
    5bca:	f8 94       	cli
    5bcc:	de bf       	out	0x3e, r29	; 62
    5bce:	0f be       	out	0x3f, r0	; 63
    5bd0:	cd bf       	out	0x3d, r28	; 61
    5bd2:	cf 91       	pop	r28
    5bd4:	df 91       	pop	r29
    5bd6:	08 95       	ret

00005bd8 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    5bd8:	df 93       	push	r29
    5bda:	cf 93       	push	r28
    5bdc:	00 d0       	rcall	.+0      	; 0x5bde <xTaskRemoveFromEventList+0x6>
    5bde:	00 d0       	rcall	.+0      	; 0x5be0 <xTaskRemoveFromEventList+0x8>
    5be0:	0f 92       	push	r0
    5be2:	cd b7       	in	r28, 0x3d	; 61
    5be4:	de b7       	in	r29, 0x3e	; 62
    5be6:	9d 83       	std	Y+5, r25	; 0x05
    5be8:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    5bea:	ec 81       	ldd	r30, Y+4	; 0x04
    5bec:	fd 81       	ldd	r31, Y+5	; 0x05
    5bee:	05 80       	ldd	r0, Z+5	; 0x05
    5bf0:	f6 81       	ldd	r31, Z+6	; 0x06
    5bf2:	e0 2d       	mov	r30, r0
    5bf4:	86 81       	ldd	r24, Z+6	; 0x06
    5bf6:	97 81       	ldd	r25, Z+7	; 0x07
    5bf8:	9b 83       	std	Y+3, r25	; 0x03
    5bfa:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    5bfc:	8a 81       	ldd	r24, Y+2	; 0x02
    5bfe:	9b 81       	ldd	r25, Y+3	; 0x03
    5c00:	0c 96       	adiw	r24, 0x0c	; 12
    5c02:	0e 94 27 23 	call	0x464e	; 0x464e <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5c06:	80 91 9f 05 	lds	r24, 0x059F
    5c0a:	88 23       	and	r24, r24
    5c0c:	61 f5       	brne	.+88     	; 0x5c66 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    5c0e:	8a 81       	ldd	r24, Y+2	; 0x02
    5c10:	9b 81       	ldd	r25, Y+3	; 0x03
    5c12:	02 96       	adiw	r24, 0x02	; 2
    5c14:	0e 94 27 23 	call	0x464e	; 0x464e <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    5c18:	ea 81       	ldd	r30, Y+2	; 0x02
    5c1a:	fb 81       	ldd	r31, Y+3	; 0x03
    5c1c:	96 89       	ldd	r25, Z+22	; 0x16
    5c1e:	80 91 95 05 	lds	r24, 0x0595
    5c22:	89 17       	cp	r24, r25
    5c24:	28 f4       	brcc	.+10     	; 0x5c30 <xTaskRemoveFromEventList+0x58>
    5c26:	ea 81       	ldd	r30, Y+2	; 0x02
    5c28:	fb 81       	ldd	r31, Y+3	; 0x03
    5c2a:	86 89       	ldd	r24, Z+22	; 0x16
    5c2c:	80 93 95 05 	sts	0x0595, r24
    5c30:	ea 81       	ldd	r30, Y+2	; 0x02
    5c32:	fb 81       	ldd	r31, Y+3	; 0x03
    5c34:	86 89       	ldd	r24, Z+22	; 0x16
    5c36:	28 2f       	mov	r18, r24
    5c38:	30 e0       	ldi	r19, 0x00	; 0
    5c3a:	c9 01       	movw	r24, r18
    5c3c:	88 0f       	add	r24, r24
    5c3e:	99 1f       	adc	r25, r25
    5c40:	88 0f       	add	r24, r24
    5c42:	99 1f       	adc	r25, r25
    5c44:	88 0f       	add	r24, r24
    5c46:	99 1f       	adc	r25, r25
    5c48:	82 0f       	add	r24, r18
    5c4a:	93 1f       	adc	r25, r19
    5c4c:	ac 01       	movw	r20, r24
    5c4e:	40 56       	subi	r20, 0x60	; 96
    5c50:	5a 4f       	sbci	r21, 0xFA	; 250
    5c52:	8a 81       	ldd	r24, Y+2	; 0x02
    5c54:	9b 81       	ldd	r25, Y+3	; 0x03
    5c56:	9c 01       	movw	r18, r24
    5c58:	2e 5f       	subi	r18, 0xFE	; 254
    5c5a:	3f 4f       	sbci	r19, 0xFF	; 255
    5c5c:	ca 01       	movw	r24, r20
    5c5e:	b9 01       	movw	r22, r18
    5c60:	0e 94 77 22 	call	0x44ee	; 0x44ee <vListInsertEnd>
    5c64:	0a c0       	rjmp	.+20     	; 0x5c7a <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    5c66:	8a 81       	ldd	r24, Y+2	; 0x02
    5c68:	9b 81       	ldd	r25, Y+3	; 0x03
    5c6a:	9c 01       	movw	r18, r24
    5c6c:	24 5f       	subi	r18, 0xF4	; 244
    5c6e:	3f 4f       	sbci	r19, 0xFF	; 255
    5c70:	87 e0       	ldi	r24, 0x07	; 7
    5c72:	96 e0       	ldi	r25, 0x06	; 6
    5c74:	b9 01       	movw	r22, r18
    5c76:	0e 94 77 22 	call	0x44ee	; 0x44ee <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    5c7a:	ea 81       	ldd	r30, Y+2	; 0x02
    5c7c:	fb 81       	ldd	r31, Y+3	; 0x03
    5c7e:	96 89       	ldd	r25, Z+22	; 0x16
    5c80:	e0 91 8f 05 	lds	r30, 0x058F
    5c84:	f0 91 90 05 	lds	r31, 0x0590
    5c88:	86 89       	ldd	r24, Z+22	; 0x16
    5c8a:	89 17       	cp	r24, r25
    5c8c:	30 f4       	brcc	.+12     	; 0x5c9a <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    5c8e:	81 e0       	ldi	r24, 0x01	; 1
    5c90:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    5c92:	81 e0       	ldi	r24, 0x01	; 1
    5c94:	80 93 98 05 	sts	0x0598, r24
    5c98:	01 c0       	rjmp	.+2      	; 0x5c9c <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    5c9a:	19 82       	std	Y+1, r1	; 0x01
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
    5c9c:	89 81       	ldd	r24, Y+1	; 0x01
}
    5c9e:	0f 90       	pop	r0
    5ca0:	0f 90       	pop	r0
    5ca2:	0f 90       	pop	r0
    5ca4:	0f 90       	pop	r0
    5ca6:	0f 90       	pop	r0
    5ca8:	cf 91       	pop	r28
    5caa:	df 91       	pop	r29
    5cac:	08 95       	ret

00005cae <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    5cae:	df 93       	push	r29
    5cb0:	cf 93       	push	r28
    5cb2:	cd b7       	in	r28, 0x3d	; 61
    5cb4:	de b7       	in	r29, 0x3e	; 62
    5cb6:	27 97       	sbiw	r28, 0x07	; 7
    5cb8:	0f b6       	in	r0, 0x3f	; 63
    5cba:	f8 94       	cli
    5cbc:	de bf       	out	0x3e, r29	; 62
    5cbe:	0f be       	out	0x3f, r0	; 63
    5cc0:	cd bf       	out	0x3d, r28	; 61
    5cc2:	9d 83       	std	Y+5, r25	; 0x05
    5cc4:	8c 83       	std	Y+4, r24	; 0x04
    5cc6:	7f 83       	std	Y+7, r23	; 0x07
    5cc8:	6e 83       	std	Y+6, r22	; 0x06
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    5cca:	8e 81       	ldd	r24, Y+6	; 0x06
    5ccc:	9f 81       	ldd	r25, Y+7	; 0x07
    5cce:	90 68       	ori	r25, 0x80	; 128
    5cd0:	ec 81       	ldd	r30, Y+4	; 0x04
    5cd2:	fd 81       	ldd	r31, Y+5	; 0x05
    5cd4:	91 83       	std	Z+1, r25	; 0x01
    5cd6:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    5cd8:	ec 81       	ldd	r30, Y+4	; 0x04
    5cda:	fd 81       	ldd	r31, Y+5	; 0x05
    5cdc:	86 81       	ldd	r24, Z+6	; 0x06
    5cde:	97 81       	ldd	r25, Z+7	; 0x07
    5ce0:	9b 83       	std	Y+3, r25	; 0x03
    5ce2:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    5ce4:	8c 81       	ldd	r24, Y+4	; 0x04
    5ce6:	9d 81       	ldd	r25, Y+5	; 0x05
    5ce8:	0e 94 27 23 	call	0x464e	; 0x464e <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    5cec:	8a 81       	ldd	r24, Y+2	; 0x02
    5cee:	9b 81       	ldd	r25, Y+3	; 0x03
    5cf0:	02 96       	adiw	r24, 0x02	; 2
    5cf2:	0e 94 27 23 	call	0x464e	; 0x464e <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    5cf6:	ea 81       	ldd	r30, Y+2	; 0x02
    5cf8:	fb 81       	ldd	r31, Y+3	; 0x03
    5cfa:	96 89       	ldd	r25, Z+22	; 0x16
    5cfc:	80 91 95 05 	lds	r24, 0x0595
    5d00:	89 17       	cp	r24, r25
    5d02:	28 f4       	brcc	.+10     	; 0x5d0e <xTaskRemoveFromUnorderedEventList+0x60>
    5d04:	ea 81       	ldd	r30, Y+2	; 0x02
    5d06:	fb 81       	ldd	r31, Y+3	; 0x03
    5d08:	86 89       	ldd	r24, Z+22	; 0x16
    5d0a:	80 93 95 05 	sts	0x0595, r24
    5d0e:	ea 81       	ldd	r30, Y+2	; 0x02
    5d10:	fb 81       	ldd	r31, Y+3	; 0x03
    5d12:	86 89       	ldd	r24, Z+22	; 0x16
    5d14:	28 2f       	mov	r18, r24
    5d16:	30 e0       	ldi	r19, 0x00	; 0
    5d18:	c9 01       	movw	r24, r18
    5d1a:	88 0f       	add	r24, r24
    5d1c:	99 1f       	adc	r25, r25
    5d1e:	88 0f       	add	r24, r24
    5d20:	99 1f       	adc	r25, r25
    5d22:	88 0f       	add	r24, r24
    5d24:	99 1f       	adc	r25, r25
    5d26:	82 0f       	add	r24, r18
    5d28:	93 1f       	adc	r25, r19
    5d2a:	ac 01       	movw	r20, r24
    5d2c:	40 56       	subi	r20, 0x60	; 96
    5d2e:	5a 4f       	sbci	r21, 0xFA	; 250
    5d30:	8a 81       	ldd	r24, Y+2	; 0x02
    5d32:	9b 81       	ldd	r25, Y+3	; 0x03
    5d34:	9c 01       	movw	r18, r24
    5d36:	2e 5f       	subi	r18, 0xFE	; 254
    5d38:	3f 4f       	sbci	r19, 0xFF	; 255
    5d3a:	ca 01       	movw	r24, r20
    5d3c:	b9 01       	movw	r22, r18
    5d3e:	0e 94 77 22 	call	0x44ee	; 0x44ee <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    5d42:	ea 81       	ldd	r30, Y+2	; 0x02
    5d44:	fb 81       	ldd	r31, Y+3	; 0x03
    5d46:	96 89       	ldd	r25, Z+22	; 0x16
    5d48:	e0 91 8f 05 	lds	r30, 0x058F
    5d4c:	f0 91 90 05 	lds	r31, 0x0590
    5d50:	86 89       	ldd	r24, Z+22	; 0x16
    5d52:	89 17       	cp	r24, r25
    5d54:	30 f4       	brcc	.+12     	; 0x5d62 <xTaskRemoveFromUnorderedEventList+0xb4>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    5d56:	81 e0       	ldi	r24, 0x01	; 1
    5d58:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    5d5a:	81 e0       	ldi	r24, 0x01	; 1
    5d5c:	80 93 98 05 	sts	0x0598, r24
    5d60:	01 c0       	rjmp	.+2      	; 0x5d64 <xTaskRemoveFromUnorderedEventList+0xb6>
	}
	else
	{
		xReturn = pdFALSE;
    5d62:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    5d64:	89 81       	ldd	r24, Y+1	; 0x01
}
    5d66:	27 96       	adiw	r28, 0x07	; 7
    5d68:	0f b6       	in	r0, 0x3f	; 63
    5d6a:	f8 94       	cli
    5d6c:	de bf       	out	0x3e, r29	; 62
    5d6e:	0f be       	out	0x3f, r0	; 63
    5d70:	cd bf       	out	0x3d, r28	; 61
    5d72:	cf 91       	pop	r28
    5d74:	df 91       	pop	r29
    5d76:	08 95       	ret

00005d78 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    5d78:	df 93       	push	r29
    5d7a:	cf 93       	push	r28
    5d7c:	00 d0       	rcall	.+0      	; 0x5d7e <vTaskSetTimeOutState+0x6>
    5d7e:	cd b7       	in	r28, 0x3d	; 61
    5d80:	de b7       	in	r29, 0x3e	; 62
    5d82:	9a 83       	std	Y+2, r25	; 0x02
    5d84:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    5d86:	80 91 99 05 	lds	r24, 0x0599
    5d8a:	e9 81       	ldd	r30, Y+1	; 0x01
    5d8c:	fa 81       	ldd	r31, Y+2	; 0x02
    5d8e:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    5d90:	80 91 93 05 	lds	r24, 0x0593
    5d94:	90 91 94 05 	lds	r25, 0x0594
    5d98:	e9 81       	ldd	r30, Y+1	; 0x01
    5d9a:	fa 81       	ldd	r31, Y+2	; 0x02
    5d9c:	92 83       	std	Z+2, r25	; 0x02
    5d9e:	81 83       	std	Z+1, r24	; 0x01
}
    5da0:	0f 90       	pop	r0
    5da2:	0f 90       	pop	r0
    5da4:	cf 91       	pop	r28
    5da6:	df 91       	pop	r29
    5da8:	08 95       	ret

00005daa <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    5daa:	df 93       	push	r29
    5dac:	cf 93       	push	r28
    5dae:	cd b7       	in	r28, 0x3d	; 61
    5db0:	de b7       	in	r29, 0x3e	; 62
    5db2:	27 97       	sbiw	r28, 0x07	; 7
    5db4:	0f b6       	in	r0, 0x3f	; 63
    5db6:	f8 94       	cli
    5db8:	de bf       	out	0x3e, r29	; 62
    5dba:	0f be       	out	0x3f, r0	; 63
    5dbc:	cd bf       	out	0x3d, r28	; 61
    5dbe:	9d 83       	std	Y+5, r25	; 0x05
    5dc0:	8c 83       	std	Y+4, r24	; 0x04
    5dc2:	7f 83       	std	Y+7, r23	; 0x07
    5dc4:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    5dc6:	0f b6       	in	r0, 0x3f	; 63
    5dc8:	f8 94       	cli
    5dca:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    5dcc:	80 91 93 05 	lds	r24, 0x0593
    5dd0:	90 91 94 05 	lds	r25, 0x0594
    5dd4:	9a 83       	std	Y+2, r25	; 0x02
    5dd6:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    5dd8:	ee 81       	ldd	r30, Y+6	; 0x06
    5dda:	ff 81       	ldd	r31, Y+7	; 0x07
    5ddc:	80 81       	ld	r24, Z
    5dde:	91 81       	ldd	r25, Z+1	; 0x01
    5de0:	2f ef       	ldi	r18, 0xFF	; 255
    5de2:	8f 3f       	cpi	r24, 0xFF	; 255
    5de4:	92 07       	cpc	r25, r18
    5de6:	11 f4       	brne	.+4      	; 0x5dec <xTaskCheckForTimeOut+0x42>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    5de8:	1b 82       	std	Y+3, r1	; 0x03
    5dea:	40 c0       	rjmp	.+128    	; 0x5e6c <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    5dec:	ec 81       	ldd	r30, Y+4	; 0x04
    5dee:	fd 81       	ldd	r31, Y+5	; 0x05
    5df0:	90 81       	ld	r25, Z
    5df2:	80 91 99 05 	lds	r24, 0x0599
    5df6:	98 17       	cp	r25, r24
    5df8:	61 f0       	breq	.+24     	; 0x5e12 <xTaskCheckForTimeOut+0x68>
    5dfa:	ec 81       	ldd	r30, Y+4	; 0x04
    5dfc:	fd 81       	ldd	r31, Y+5	; 0x05
    5dfe:	21 81       	ldd	r18, Z+1	; 0x01
    5e00:	32 81       	ldd	r19, Z+2	; 0x02
    5e02:	89 81       	ldd	r24, Y+1	; 0x01
    5e04:	9a 81       	ldd	r25, Y+2	; 0x02
    5e06:	82 17       	cp	r24, r18
    5e08:	93 07       	cpc	r25, r19
    5e0a:	18 f0       	brcs	.+6      	; 0x5e12 <xTaskCheckForTimeOut+0x68>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    5e0c:	81 e0       	ldi	r24, 0x01	; 1
    5e0e:	8b 83       	std	Y+3, r24	; 0x03
    5e10:	2d c0       	rjmp	.+90     	; 0x5e6c <xTaskCheckForTimeOut+0xc2>
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    5e12:	ec 81       	ldd	r30, Y+4	; 0x04
    5e14:	fd 81       	ldd	r31, Y+5	; 0x05
    5e16:	21 81       	ldd	r18, Z+1	; 0x01
    5e18:	32 81       	ldd	r19, Z+2	; 0x02
    5e1a:	89 81       	ldd	r24, Y+1	; 0x01
    5e1c:	9a 81       	ldd	r25, Y+2	; 0x02
    5e1e:	ac 01       	movw	r20, r24
    5e20:	42 1b       	sub	r20, r18
    5e22:	53 0b       	sbc	r21, r19
    5e24:	9a 01       	movw	r18, r20
    5e26:	ee 81       	ldd	r30, Y+6	; 0x06
    5e28:	ff 81       	ldd	r31, Y+7	; 0x07
    5e2a:	80 81       	ld	r24, Z
    5e2c:	91 81       	ldd	r25, Z+1	; 0x01
    5e2e:	28 17       	cp	r18, r24
    5e30:	39 07       	cpc	r19, r25
    5e32:	d0 f4       	brcc	.+52     	; 0x5e68 <xTaskCheckForTimeOut+0xbe>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    5e34:	ee 81       	ldd	r30, Y+6	; 0x06
    5e36:	ff 81       	ldd	r31, Y+7	; 0x07
    5e38:	40 81       	ld	r20, Z
    5e3a:	51 81       	ldd	r21, Z+1	; 0x01
    5e3c:	ec 81       	ldd	r30, Y+4	; 0x04
    5e3e:	fd 81       	ldd	r31, Y+5	; 0x05
    5e40:	21 81       	ldd	r18, Z+1	; 0x01
    5e42:	32 81       	ldd	r19, Z+2	; 0x02
    5e44:	89 81       	ldd	r24, Y+1	; 0x01
    5e46:	9a 81       	ldd	r25, Y+2	; 0x02
    5e48:	b9 01       	movw	r22, r18
    5e4a:	68 1b       	sub	r22, r24
    5e4c:	79 0b       	sbc	r23, r25
    5e4e:	cb 01       	movw	r24, r22
    5e50:	84 0f       	add	r24, r20
    5e52:	95 1f       	adc	r25, r21
    5e54:	ee 81       	ldd	r30, Y+6	; 0x06
    5e56:	ff 81       	ldd	r31, Y+7	; 0x07
    5e58:	91 83       	std	Z+1, r25	; 0x01
    5e5a:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    5e5c:	8c 81       	ldd	r24, Y+4	; 0x04
    5e5e:	9d 81       	ldd	r25, Y+5	; 0x05
    5e60:	0e 94 bc 2e 	call	0x5d78	; 0x5d78 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    5e64:	1b 82       	std	Y+3, r1	; 0x03
    5e66:	02 c0       	rjmp	.+4      	; 0x5e6c <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			xReturn = pdTRUE;
    5e68:	81 e0       	ldi	r24, 0x01	; 1
    5e6a:	8b 83       	std	Y+3, r24	; 0x03
		}
	}
	taskEXIT_CRITICAL();
    5e6c:	0f 90       	pop	r0
    5e6e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    5e70:	8b 81       	ldd	r24, Y+3	; 0x03
}
    5e72:	27 96       	adiw	r28, 0x07	; 7
    5e74:	0f b6       	in	r0, 0x3f	; 63
    5e76:	f8 94       	cli
    5e78:	de bf       	out	0x3e, r29	; 62
    5e7a:	0f be       	out	0x3f, r0	; 63
    5e7c:	cd bf       	out	0x3d, r28	; 61
    5e7e:	cf 91       	pop	r28
    5e80:	df 91       	pop	r29
    5e82:	08 95       	ret

00005e84 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    5e84:	df 93       	push	r29
    5e86:	cf 93       	push	r28
    5e88:	cd b7       	in	r28, 0x3d	; 61
    5e8a:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    5e8c:	81 e0       	ldi	r24, 0x01	; 1
    5e8e:	80 93 98 05 	sts	0x0598, r24
}
    5e92:	cf 91       	pop	r28
    5e94:	df 91       	pop	r29
    5e96:	08 95       	ret

00005e98 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    5e98:	df 93       	push	r29
    5e9a:	cf 93       	push	r28
    5e9c:	00 d0       	rcall	.+0      	; 0x5e9e <prvIdleTask+0x6>
    5e9e:	cd b7       	in	r28, 0x3d	; 61
    5ea0:	de b7       	in	r29, 0x3e	; 62
    5ea2:	9a 83       	std	Y+2, r25	; 0x02
    5ea4:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    5ea6:	0e 94 97 2f 	call	0x5f2e	; 0x5f2e <prvCheckTasksWaitingTermination>
    5eaa:	fd cf       	rjmp	.-6      	; 0x5ea6 <prvIdleTask+0xe>

00005eac <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    5eac:	df 93       	push	r29
    5eae:	cf 93       	push	r28
    5eb0:	0f 92       	push	r0
    5eb2:	cd b7       	in	r28, 0x3d	; 61
    5eb4:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    5eb6:	19 82       	std	Y+1, r1	; 0x01
    5eb8:	13 c0       	rjmp	.+38     	; 0x5ee0 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    5eba:	89 81       	ldd	r24, Y+1	; 0x01
    5ebc:	28 2f       	mov	r18, r24
    5ebe:	30 e0       	ldi	r19, 0x00	; 0
    5ec0:	c9 01       	movw	r24, r18
    5ec2:	88 0f       	add	r24, r24
    5ec4:	99 1f       	adc	r25, r25
    5ec6:	88 0f       	add	r24, r24
    5ec8:	99 1f       	adc	r25, r25
    5eca:	88 0f       	add	r24, r24
    5ecc:	99 1f       	adc	r25, r25
    5ece:	82 0f       	add	r24, r18
    5ed0:	93 1f       	adc	r25, r19
    5ed2:	80 56       	subi	r24, 0x60	; 96
    5ed4:	9a 4f       	sbci	r25, 0xFA	; 250
    5ed6:	0e 94 3d 22 	call	0x447a	; 0x447a <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    5eda:	89 81       	ldd	r24, Y+1	; 0x01
    5edc:	8f 5f       	subi	r24, 0xFF	; 255
    5ede:	89 83       	std	Y+1, r24	; 0x01
    5ee0:	89 81       	ldd	r24, Y+1	; 0x01
    5ee2:	89 30       	cpi	r24, 0x09	; 9
    5ee4:	50 f3       	brcs	.-44     	; 0x5eba <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    5ee6:	81 ef       	ldi	r24, 0xF1	; 241
    5ee8:	95 e0       	ldi	r25, 0x05	; 5
    5eea:	0e 94 3d 22 	call	0x447a	; 0x447a <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    5eee:	8a ef       	ldi	r24, 0xFA	; 250
    5ef0:	95 e0       	ldi	r25, 0x05	; 5
    5ef2:	0e 94 3d 22 	call	0x447a	; 0x447a <vListInitialise>
	vListInitialise( &xPendingReadyList );
    5ef6:	87 e0       	ldi	r24, 0x07	; 7
    5ef8:	96 e0       	ldi	r25, 0x06	; 6
    5efa:	0e 94 3d 22 	call	0x447a	; 0x447a <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    5efe:	80 e1       	ldi	r24, 0x10	; 16
    5f00:	96 e0       	ldi	r25, 0x06	; 6
    5f02:	0e 94 3d 22 	call	0x447a	; 0x447a <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    5f06:	89 e1       	ldi	r24, 0x19	; 25
    5f08:	96 e0       	ldi	r25, 0x06	; 6
    5f0a:	0e 94 3d 22 	call	0x447a	; 0x447a <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    5f0e:	81 ef       	ldi	r24, 0xF1	; 241
    5f10:	95 e0       	ldi	r25, 0x05	; 5
    5f12:	90 93 04 06 	sts	0x0604, r25
    5f16:	80 93 03 06 	sts	0x0603, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    5f1a:	8a ef       	ldi	r24, 0xFA	; 250
    5f1c:	95 e0       	ldi	r25, 0x05	; 5
    5f1e:	90 93 06 06 	sts	0x0606, r25
    5f22:	80 93 05 06 	sts	0x0605, r24
}
    5f26:	0f 90       	pop	r0
    5f28:	cf 91       	pop	r28
    5f2a:	df 91       	pop	r29
    5f2c:	08 95       	ret

00005f2e <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    5f2e:	df 93       	push	r29
    5f30:	cf 93       	push	r28
    5f32:	00 d0       	rcall	.+0      	; 0x5f34 <prvCheckTasksWaitingTermination+0x6>
    5f34:	0f 92       	push	r0
    5f36:	cd b7       	in	r28, 0x3d	; 61
    5f38:	de b7       	in	r29, 0x3e	; 62
    5f3a:	2e c0       	rjmp	.+92     	; 0x5f98 <prvCheckTasksWaitingTermination+0x6a>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    5f3c:	0e 94 65 2b 	call	0x56ca	; 0x56ca <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    5f40:	80 91 10 06 	lds	r24, 0x0610
    5f44:	1b 82       	std	Y+3, r1	; 0x03
    5f46:	88 23       	and	r24, r24
    5f48:	11 f4       	brne	.+4      	; 0x5f4e <prvCheckTasksWaitingTermination+0x20>
    5f4a:	81 e0       	ldi	r24, 0x01	; 1
    5f4c:	8b 83       	std	Y+3, r24	; 0x03
			}
			( void ) xTaskResumeAll();
    5f4e:	0e 94 71 2b 	call	0x56e2	; 0x56e2 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    5f52:	8b 81       	ldd	r24, Y+3	; 0x03
    5f54:	88 23       	and	r24, r24
    5f56:	01 f5       	brne	.+64     	; 0x5f98 <prvCheckTasksWaitingTermination+0x6a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    5f58:	0f b6       	in	r0, 0x3f	; 63
    5f5a:	f8 94       	cli
    5f5c:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    5f5e:	e0 91 15 06 	lds	r30, 0x0615
    5f62:	f0 91 16 06 	lds	r31, 0x0616
    5f66:	86 81       	ldd	r24, Z+6	; 0x06
    5f68:	97 81       	ldd	r25, Z+7	; 0x07
    5f6a:	9a 83       	std	Y+2, r25	; 0x02
    5f6c:	89 83       	std	Y+1, r24	; 0x01
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5f6e:	89 81       	ldd	r24, Y+1	; 0x01
    5f70:	9a 81       	ldd	r25, Y+2	; 0x02
    5f72:	02 96       	adiw	r24, 0x02	; 2
    5f74:	0e 94 27 23 	call	0x464e	; 0x464e <uxListRemove>
					--uxCurrentNumberOfTasks;
    5f78:	80 91 92 05 	lds	r24, 0x0592
    5f7c:	81 50       	subi	r24, 0x01	; 1
    5f7e:	80 93 92 05 	sts	0x0592, r24
					--uxDeletedTasksWaitingCleanUp;
    5f82:	80 91 91 05 	lds	r24, 0x0591
    5f86:	81 50       	subi	r24, 0x01	; 1
    5f88:	80 93 91 05 	sts	0x0591, r24
				}
				taskEXIT_CRITICAL();
    5f8c:	0f 90       	pop	r0
    5f8e:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    5f90:	89 81       	ldd	r24, Y+1	; 0x01
    5f92:	9a 81       	ldd	r25, Y+2	; 0x02
    5f94:	0e 94 d6 2f 	call	0x5fac	; 0x5fac <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    5f98:	80 91 91 05 	lds	r24, 0x0591
    5f9c:	88 23       	and	r24, r24
    5f9e:	71 f6       	brne	.-100    	; 0x5f3c <prvCheckTasksWaitingTermination+0xe>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    5fa0:	0f 90       	pop	r0
    5fa2:	0f 90       	pop	r0
    5fa4:	0f 90       	pop	r0
    5fa6:	cf 91       	pop	r28
    5fa8:	df 91       	pop	r29
    5faa:	08 95       	ret

00005fac <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    5fac:	df 93       	push	r29
    5fae:	cf 93       	push	r28
    5fb0:	00 d0       	rcall	.+0      	; 0x5fb2 <prvDeleteTCB+0x6>
    5fb2:	cd b7       	in	r28, 0x3d	; 61
    5fb4:	de b7       	in	r29, 0x3e	; 62
    5fb6:	9a 83       	std	Y+2, r25	; 0x02
    5fb8:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    5fba:	e9 81       	ldd	r30, Y+1	; 0x01
    5fbc:	fa 81       	ldd	r31, Y+2	; 0x02
    5fbe:	87 89       	ldd	r24, Z+23	; 0x17
    5fc0:	90 8d       	ldd	r25, Z+24	; 0x18
    5fc2:	0e 94 89 21 	call	0x4312	; 0x4312 <vPortFree>
			vPortFree( pxTCB );
    5fc6:	89 81       	ldd	r24, Y+1	; 0x01
    5fc8:	9a 81       	ldd	r25, Y+2	; 0x02
    5fca:	0e 94 89 21 	call	0x4312	; 0x4312 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    5fce:	0f 90       	pop	r0
    5fd0:	0f 90       	pop	r0
    5fd2:	cf 91       	pop	r28
    5fd4:	df 91       	pop	r29
    5fd6:	08 95       	ret

00005fd8 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    5fd8:	df 93       	push	r29
    5fda:	cf 93       	push	r28
    5fdc:	00 d0       	rcall	.+0      	; 0x5fde <prvResetNextTaskUnblockTime+0x6>
    5fde:	cd b7       	in	r28, 0x3d	; 61
    5fe0:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    5fe2:	e0 91 03 06 	lds	r30, 0x0603
    5fe6:	f0 91 04 06 	lds	r31, 0x0604
    5fea:	80 81       	ld	r24, Z
    5fec:	88 23       	and	r24, r24
    5fee:	39 f4       	brne	.+14     	; 0x5ffe <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    5ff0:	8f ef       	ldi	r24, 0xFF	; 255
    5ff2:	9f ef       	ldi	r25, 0xFF	; 255
    5ff4:	90 93 9c 05 	sts	0x059C, r25
    5ff8:	80 93 9b 05 	sts	0x059B, r24
    5ffc:	13 c0       	rjmp	.+38     	; 0x6024 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    5ffe:	e0 91 03 06 	lds	r30, 0x0603
    6002:	f0 91 04 06 	lds	r31, 0x0604
    6006:	05 80       	ldd	r0, Z+5	; 0x05
    6008:	f6 81       	ldd	r31, Z+6	; 0x06
    600a:	e0 2d       	mov	r30, r0
    600c:	86 81       	ldd	r24, Z+6	; 0x06
    600e:	97 81       	ldd	r25, Z+7	; 0x07
    6010:	9a 83       	std	Y+2, r25	; 0x02
    6012:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    6014:	e9 81       	ldd	r30, Y+1	; 0x01
    6016:	fa 81       	ldd	r31, Y+2	; 0x02
    6018:	82 81       	ldd	r24, Z+2	; 0x02
    601a:	93 81       	ldd	r25, Z+3	; 0x03
    601c:	90 93 9c 05 	sts	0x059C, r25
    6020:	80 93 9b 05 	sts	0x059B, r24
	}
}
    6024:	0f 90       	pop	r0
    6026:	0f 90       	pop	r0
    6028:	cf 91       	pop	r28
    602a:	df 91       	pop	r29
    602c:	08 95       	ret

0000602e <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    602e:	df 93       	push	r29
    6030:	cf 93       	push	r28
    6032:	00 d0       	rcall	.+0      	; 0x6034 <xTaskGetCurrentTaskHandle+0x6>
    6034:	cd b7       	in	r28, 0x3d	; 61
    6036:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    6038:	80 91 8f 05 	lds	r24, 0x058F
    603c:	90 91 90 05 	lds	r25, 0x0590
    6040:	9a 83       	std	Y+2, r25	; 0x02
    6042:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    6044:	89 81       	ldd	r24, Y+1	; 0x01
    6046:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    6048:	0f 90       	pop	r0
    604a:	0f 90       	pop	r0
    604c:	cf 91       	pop	r28
    604e:	df 91       	pop	r29
    6050:	08 95       	ret

00006052 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    6052:	df 93       	push	r29
    6054:	cf 93       	push	r28
    6056:	00 d0       	rcall	.+0      	; 0x6058 <vTaskPriorityInherit+0x6>
    6058:	00 d0       	rcall	.+0      	; 0x605a <vTaskPriorityInherit+0x8>
    605a:	cd b7       	in	r28, 0x3d	; 61
    605c:	de b7       	in	r29, 0x3e	; 62
    605e:	9c 83       	std	Y+4, r25	; 0x04
    6060:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    6062:	8b 81       	ldd	r24, Y+3	; 0x03
    6064:	9c 81       	ldd	r25, Y+4	; 0x04
    6066:	9a 83       	std	Y+2, r25	; 0x02
    6068:	89 83       	std	Y+1, r24	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    606a:	8b 81       	ldd	r24, Y+3	; 0x03
    606c:	9c 81       	ldd	r25, Y+4	; 0x04
    606e:	00 97       	sbiw	r24, 0x00	; 0
    6070:	09 f4       	brne	.+2      	; 0x6074 <vTaskPriorityInherit+0x22>
    6072:	73 c0       	rjmp	.+230    	; 0x615a <vTaskPriorityInherit+0x108>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    6074:	e9 81       	ldd	r30, Y+1	; 0x01
    6076:	fa 81       	ldd	r31, Y+2	; 0x02
    6078:	96 89       	ldd	r25, Z+22	; 0x16
    607a:	e0 91 8f 05 	lds	r30, 0x058F
    607e:	f0 91 90 05 	lds	r31, 0x0590
    6082:	86 89       	ldd	r24, Z+22	; 0x16
    6084:	98 17       	cp	r25, r24
    6086:	08 f0       	brcs	.+2      	; 0x608a <vTaskPriorityInherit+0x38>
    6088:	68 c0       	rjmp	.+208    	; 0x615a <vTaskPriorityInherit+0x108>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    608a:	e9 81       	ldd	r30, Y+1	; 0x01
    608c:	fa 81       	ldd	r31, Y+2	; 0x02
    608e:	84 85       	ldd	r24, Z+12	; 0x0c
    6090:	95 85       	ldd	r25, Z+13	; 0x0d
    6092:	99 23       	and	r25, r25
    6094:	7c f0       	brlt	.+30     	; 0x60b4 <vTaskPriorityInherit+0x62>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    6096:	e0 91 8f 05 	lds	r30, 0x058F
    609a:	f0 91 90 05 	lds	r31, 0x0590
    609e:	86 89       	ldd	r24, Z+22	; 0x16
    60a0:	28 2f       	mov	r18, r24
    60a2:	30 e0       	ldi	r19, 0x00	; 0
    60a4:	89 e0       	ldi	r24, 0x09	; 9
    60a6:	90 e0       	ldi	r25, 0x00	; 0
    60a8:	82 1b       	sub	r24, r18
    60aa:	93 0b       	sbc	r25, r19
    60ac:	e9 81       	ldd	r30, Y+1	; 0x01
    60ae:	fa 81       	ldd	r31, Y+2	; 0x02
    60b0:	95 87       	std	Z+13, r25	; 0x0d
    60b2:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    60b4:	e9 81       	ldd	r30, Y+1	; 0x01
    60b6:	fa 81       	ldd	r31, Y+2	; 0x02
    60b8:	42 85       	ldd	r20, Z+10	; 0x0a
    60ba:	53 85       	ldd	r21, Z+11	; 0x0b
    60bc:	e9 81       	ldd	r30, Y+1	; 0x01
    60be:	fa 81       	ldd	r31, Y+2	; 0x02
    60c0:	86 89       	ldd	r24, Z+22	; 0x16
    60c2:	28 2f       	mov	r18, r24
    60c4:	30 e0       	ldi	r19, 0x00	; 0
    60c6:	c9 01       	movw	r24, r18
    60c8:	88 0f       	add	r24, r24
    60ca:	99 1f       	adc	r25, r25
    60cc:	88 0f       	add	r24, r24
    60ce:	99 1f       	adc	r25, r25
    60d0:	88 0f       	add	r24, r24
    60d2:	99 1f       	adc	r25, r25
    60d4:	82 0f       	add	r24, r18
    60d6:	93 1f       	adc	r25, r19
    60d8:	80 56       	subi	r24, 0x60	; 96
    60da:	9a 4f       	sbci	r25, 0xFA	; 250
    60dc:	48 17       	cp	r20, r24
    60de:	59 07       	cpc	r21, r25
    60e0:	a1 f5       	brne	.+104    	; 0x614a <vTaskPriorityInherit+0xf8>
				{
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    60e2:	89 81       	ldd	r24, Y+1	; 0x01
    60e4:	9a 81       	ldd	r25, Y+2	; 0x02
    60e6:	02 96       	adiw	r24, 0x02	; 2
    60e8:	0e 94 27 23 	call	0x464e	; 0x464e <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    60ec:	e0 91 8f 05 	lds	r30, 0x058F
    60f0:	f0 91 90 05 	lds	r31, 0x0590
    60f4:	86 89       	ldd	r24, Z+22	; 0x16
    60f6:	e9 81       	ldd	r30, Y+1	; 0x01
    60f8:	fa 81       	ldd	r31, Y+2	; 0x02
    60fa:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    60fc:	e9 81       	ldd	r30, Y+1	; 0x01
    60fe:	fa 81       	ldd	r31, Y+2	; 0x02
    6100:	96 89       	ldd	r25, Z+22	; 0x16
    6102:	80 91 95 05 	lds	r24, 0x0595
    6106:	89 17       	cp	r24, r25
    6108:	28 f4       	brcc	.+10     	; 0x6114 <vTaskPriorityInherit+0xc2>
    610a:	e9 81       	ldd	r30, Y+1	; 0x01
    610c:	fa 81       	ldd	r31, Y+2	; 0x02
    610e:	86 89       	ldd	r24, Z+22	; 0x16
    6110:	80 93 95 05 	sts	0x0595, r24
    6114:	e9 81       	ldd	r30, Y+1	; 0x01
    6116:	fa 81       	ldd	r31, Y+2	; 0x02
    6118:	86 89       	ldd	r24, Z+22	; 0x16
    611a:	28 2f       	mov	r18, r24
    611c:	30 e0       	ldi	r19, 0x00	; 0
    611e:	c9 01       	movw	r24, r18
    6120:	88 0f       	add	r24, r24
    6122:	99 1f       	adc	r25, r25
    6124:	88 0f       	add	r24, r24
    6126:	99 1f       	adc	r25, r25
    6128:	88 0f       	add	r24, r24
    612a:	99 1f       	adc	r25, r25
    612c:	82 0f       	add	r24, r18
    612e:	93 1f       	adc	r25, r19
    6130:	ac 01       	movw	r20, r24
    6132:	40 56       	subi	r20, 0x60	; 96
    6134:	5a 4f       	sbci	r21, 0xFA	; 250
    6136:	89 81       	ldd	r24, Y+1	; 0x01
    6138:	9a 81       	ldd	r25, Y+2	; 0x02
    613a:	9c 01       	movw	r18, r24
    613c:	2e 5f       	subi	r18, 0xFE	; 254
    613e:	3f 4f       	sbci	r19, 0xFF	; 255
    6140:	ca 01       	movw	r24, r20
    6142:	b9 01       	movw	r22, r18
    6144:	0e 94 77 22 	call	0x44ee	; 0x44ee <vListInsertEnd>
    6148:	08 c0       	rjmp	.+16     	; 0x615a <vTaskPriorityInherit+0x108>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    614a:	e0 91 8f 05 	lds	r30, 0x058F
    614e:	f0 91 90 05 	lds	r31, 0x0590
    6152:	86 89       	ldd	r24, Z+22	; 0x16
    6154:	e9 81       	ldd	r30, Y+1	; 0x01
    6156:	fa 81       	ldd	r31, Y+2	; 0x02
    6158:	86 8b       	std	Z+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    615a:	0f 90       	pop	r0
    615c:	0f 90       	pop	r0
    615e:	0f 90       	pop	r0
    6160:	0f 90       	pop	r0
    6162:	cf 91       	pop	r28
    6164:	df 91       	pop	r29
    6166:	08 95       	ret

00006168 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    6168:	df 93       	push	r29
    616a:	cf 93       	push	r28
    616c:	00 d0       	rcall	.+0      	; 0x616e <xTaskPriorityDisinherit+0x6>
    616e:	00 d0       	rcall	.+0      	; 0x6170 <xTaskPriorityDisinherit+0x8>
    6170:	0f 92       	push	r0
    6172:	cd b7       	in	r28, 0x3d	; 61
    6174:	de b7       	in	r29, 0x3e	; 62
    6176:	9d 83       	std	Y+5, r25	; 0x05
    6178:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    617a:	8c 81       	ldd	r24, Y+4	; 0x04
    617c:	9d 81       	ldd	r25, Y+5	; 0x05
    617e:	9b 83       	std	Y+3, r25	; 0x03
    6180:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    6182:	19 82       	std	Y+1, r1	; 0x01

		if( pxMutexHolder != NULL )
    6184:	8c 81       	ldd	r24, Y+4	; 0x04
    6186:	9d 81       	ldd	r25, Y+5	; 0x05
    6188:	00 97       	sbiw	r24, 0x00	; 0
    618a:	09 f4       	brne	.+2      	; 0x618e <xTaskPriorityDisinherit+0x26>
    618c:	56 c0       	rjmp	.+172    	; 0x623a <xTaskPriorityDisinherit+0xd2>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    618e:	ea 81       	ldd	r30, Y+2	; 0x02
    6190:	fb 81       	ldd	r31, Y+3	; 0x03
    6192:	82 a1       	ldd	r24, Z+34	; 0x22
    6194:	81 50       	subi	r24, 0x01	; 1
    6196:	ea 81       	ldd	r30, Y+2	; 0x02
    6198:	fb 81       	ldd	r31, Y+3	; 0x03
    619a:	82 a3       	std	Z+34, r24	; 0x22

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    619c:	ea 81       	ldd	r30, Y+2	; 0x02
    619e:	fb 81       	ldd	r31, Y+3	; 0x03
    61a0:	96 89       	ldd	r25, Z+22	; 0x16
    61a2:	ea 81       	ldd	r30, Y+2	; 0x02
    61a4:	fb 81       	ldd	r31, Y+3	; 0x03
    61a6:	81 a1       	ldd	r24, Z+33	; 0x21
    61a8:	98 17       	cp	r25, r24
    61aa:	09 f4       	brne	.+2      	; 0x61ae <xTaskPriorityDisinherit+0x46>
    61ac:	46 c0       	rjmp	.+140    	; 0x623a <xTaskPriorityDisinherit+0xd2>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    61ae:	ea 81       	ldd	r30, Y+2	; 0x02
    61b0:	fb 81       	ldd	r31, Y+3	; 0x03
    61b2:	82 a1       	ldd	r24, Z+34	; 0x22
    61b4:	88 23       	and	r24, r24
    61b6:	09 f0       	breq	.+2      	; 0x61ba <xTaskPriorityDisinherit+0x52>
    61b8:	40 c0       	rjmp	.+128    	; 0x623a <xTaskPriorityDisinherit+0xd2>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    61ba:	8a 81       	ldd	r24, Y+2	; 0x02
    61bc:	9b 81       	ldd	r25, Y+3	; 0x03
    61be:	02 96       	adiw	r24, 0x02	; 2
    61c0:	0e 94 27 23 	call	0x464e	; 0x464e <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    61c4:	ea 81       	ldd	r30, Y+2	; 0x02
    61c6:	fb 81       	ldd	r31, Y+3	; 0x03
    61c8:	81 a1       	ldd	r24, Z+33	; 0x21
    61ca:	ea 81       	ldd	r30, Y+2	; 0x02
    61cc:	fb 81       	ldd	r31, Y+3	; 0x03
    61ce:	86 8b       	std	Z+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    61d0:	ea 81       	ldd	r30, Y+2	; 0x02
    61d2:	fb 81       	ldd	r31, Y+3	; 0x03
    61d4:	86 89       	ldd	r24, Z+22	; 0x16
    61d6:	28 2f       	mov	r18, r24
    61d8:	30 e0       	ldi	r19, 0x00	; 0
    61da:	89 e0       	ldi	r24, 0x09	; 9
    61dc:	90 e0       	ldi	r25, 0x00	; 0
    61de:	82 1b       	sub	r24, r18
    61e0:	93 0b       	sbc	r25, r19
    61e2:	ea 81       	ldd	r30, Y+2	; 0x02
    61e4:	fb 81       	ldd	r31, Y+3	; 0x03
    61e6:	95 87       	std	Z+13, r25	; 0x0d
    61e8:	84 87       	std	Z+12, r24	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    61ea:	ea 81       	ldd	r30, Y+2	; 0x02
    61ec:	fb 81       	ldd	r31, Y+3	; 0x03
    61ee:	96 89       	ldd	r25, Z+22	; 0x16
    61f0:	80 91 95 05 	lds	r24, 0x0595
    61f4:	89 17       	cp	r24, r25
    61f6:	28 f4       	brcc	.+10     	; 0x6202 <xTaskPriorityDisinherit+0x9a>
    61f8:	ea 81       	ldd	r30, Y+2	; 0x02
    61fa:	fb 81       	ldd	r31, Y+3	; 0x03
    61fc:	86 89       	ldd	r24, Z+22	; 0x16
    61fe:	80 93 95 05 	sts	0x0595, r24
    6202:	ea 81       	ldd	r30, Y+2	; 0x02
    6204:	fb 81       	ldd	r31, Y+3	; 0x03
    6206:	86 89       	ldd	r24, Z+22	; 0x16
    6208:	28 2f       	mov	r18, r24
    620a:	30 e0       	ldi	r19, 0x00	; 0
    620c:	c9 01       	movw	r24, r18
    620e:	88 0f       	add	r24, r24
    6210:	99 1f       	adc	r25, r25
    6212:	88 0f       	add	r24, r24
    6214:	99 1f       	adc	r25, r25
    6216:	88 0f       	add	r24, r24
    6218:	99 1f       	adc	r25, r25
    621a:	82 0f       	add	r24, r18
    621c:	93 1f       	adc	r25, r19
    621e:	ac 01       	movw	r20, r24
    6220:	40 56       	subi	r20, 0x60	; 96
    6222:	5a 4f       	sbci	r21, 0xFA	; 250
    6224:	8a 81       	ldd	r24, Y+2	; 0x02
    6226:	9b 81       	ldd	r25, Y+3	; 0x03
    6228:	9c 01       	movw	r18, r24
    622a:	2e 5f       	subi	r18, 0xFE	; 254
    622c:	3f 4f       	sbci	r19, 0xFF	; 255
    622e:	ca 01       	movw	r24, r20
    6230:	b9 01       	movw	r22, r18
    6232:	0e 94 77 22 	call	0x44ee	; 0x44ee <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    6236:	81 e0       	ldi	r24, 0x01	; 1
    6238:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    623a:	89 81       	ldd	r24, Y+1	; 0x01
	}
    623c:	0f 90       	pop	r0
    623e:	0f 90       	pop	r0
    6240:	0f 90       	pop	r0
    6242:	0f 90       	pop	r0
    6244:	0f 90       	pop	r0
    6246:	cf 91       	pop	r28
    6248:	df 91       	pop	r29
    624a:	08 95       	ret

0000624c <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    624c:	df 93       	push	r29
    624e:	cf 93       	push	r28
    6250:	00 d0       	rcall	.+0      	; 0x6252 <uxTaskResetEventItemValue+0x6>
    6252:	cd b7       	in	r28, 0x3d	; 61
    6254:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    6256:	e0 91 8f 05 	lds	r30, 0x058F
    625a:	f0 91 90 05 	lds	r31, 0x0590
    625e:	84 85       	ldd	r24, Z+12	; 0x0c
    6260:	95 85       	ldd	r25, Z+13	; 0x0d
    6262:	9a 83       	std	Y+2, r25	; 0x02
    6264:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    6266:	a0 91 8f 05 	lds	r26, 0x058F
    626a:	b0 91 90 05 	lds	r27, 0x0590
    626e:	e0 91 8f 05 	lds	r30, 0x058F
    6272:	f0 91 90 05 	lds	r31, 0x0590
    6276:	86 89       	ldd	r24, Z+22	; 0x16
    6278:	28 2f       	mov	r18, r24
    627a:	30 e0       	ldi	r19, 0x00	; 0
    627c:	89 e0       	ldi	r24, 0x09	; 9
    627e:	90 e0       	ldi	r25, 0x00	; 0
    6280:	82 1b       	sub	r24, r18
    6282:	93 0b       	sbc	r25, r19
    6284:	1d 96       	adiw	r26, 0x0d	; 13
    6286:	9c 93       	st	X, r25
    6288:	8e 93       	st	-X, r24
    628a:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    628c:	89 81       	ldd	r24, Y+1	; 0x01
    628e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    6290:	0f 90       	pop	r0
    6292:	0f 90       	pop	r0
    6294:	cf 91       	pop	r28
    6296:	df 91       	pop	r29
    6298:	08 95       	ret

0000629a <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void *pvTaskIncrementMutexHeldCount( void )
	{
    629a:	df 93       	push	r29
    629c:	cf 93       	push	r28
    629e:	cd b7       	in	r28, 0x3d	; 61
    62a0:	de b7       	in	r29, 0x3e	; 62
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    62a2:	80 91 8f 05 	lds	r24, 0x058F
    62a6:	90 91 90 05 	lds	r25, 0x0590
    62aa:	00 97       	sbiw	r24, 0x00	; 0
    62ac:	39 f0       	breq	.+14     	; 0x62bc <pvTaskIncrementMutexHeldCount+0x22>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    62ae:	e0 91 8f 05 	lds	r30, 0x058F
    62b2:	f0 91 90 05 	lds	r31, 0x0590
    62b6:	82 a1       	ldd	r24, Z+34	; 0x22
    62b8:	8f 5f       	subi	r24, 0xFF	; 255
    62ba:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    62bc:	80 91 8f 05 	lds	r24, 0x058F
    62c0:	90 91 90 05 	lds	r25, 0x0590
	}
    62c4:	cf 91       	pop	r28
    62c6:	df 91       	pop	r29
    62c8:	08 95       	ret

000062ca <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    62ca:	df 93       	push	r29
    62cc:	cf 93       	push	r28
    62ce:	cd b7       	in	r28, 0x3d	; 61
    62d0:	de b7       	in	r29, 0x3e	; 62
    62d2:	27 97       	sbiw	r28, 0x07	; 7
    62d4:	0f b6       	in	r0, 0x3f	; 63
    62d6:	f8 94       	cli
    62d8:	de bf       	out	0x3e, r29	; 62
    62da:	0f be       	out	0x3f, r0	; 63
    62dc:	cd bf       	out	0x3d, r28	; 61
    62de:	8d 83       	std	Y+5, r24	; 0x05
    62e0:	7f 83       	std	Y+7, r23	; 0x07
    62e2:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    62e4:	0f b6       	in	r0, 0x3f	; 63
    62e6:	f8 94       	cli
    62e8:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    62ea:	e0 91 8f 05 	lds	r30, 0x058F
    62ee:	f0 91 90 05 	lds	r31, 0x0590
    62f2:	83 a1       	ldd	r24, Z+35	; 0x23
    62f4:	94 a1       	ldd	r25, Z+36	; 0x24
    62f6:	a5 a1       	ldd	r26, Z+37	; 0x25
    62f8:	b6 a1       	ldd	r27, Z+38	; 0x26
    62fa:	00 97       	sbiw	r24, 0x00	; 0
    62fc:	a1 05       	cpc	r26, r1
    62fe:	b1 05       	cpc	r27, r1
    6300:	89 f4       	brne	.+34     	; 0x6324 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    6302:	e0 91 8f 05 	lds	r30, 0x058F
    6306:	f0 91 90 05 	lds	r31, 0x0590
    630a:	81 e0       	ldi	r24, 0x01	; 1
    630c:	87 a3       	std	Z+39, r24	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    630e:	8e 81       	ldd	r24, Y+6	; 0x06
    6310:	9f 81       	ldd	r25, Y+7	; 0x07
    6312:	00 97       	sbiw	r24, 0x00	; 0
    6314:	39 f0       	breq	.+14     	; 0x6324 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    6316:	8e 81       	ldd	r24, Y+6	; 0x06
    6318:	9f 81       	ldd	r25, Y+7	; 0x07
    631a:	61 e0       	ldi	r22, 0x01	; 1
    631c:	0e 94 0f 35 	call	0x6a1e	; 0x6a1e <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    6320:	0e 94 32 25 	call	0x4a64	; 0x4a64 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    6324:	0f 90       	pop	r0
    6326:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    6328:	0f b6       	in	r0, 0x3f	; 63
    632a:	f8 94       	cli
    632c:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    632e:	e0 91 8f 05 	lds	r30, 0x058F
    6332:	f0 91 90 05 	lds	r31, 0x0590
    6336:	83 a1       	ldd	r24, Z+35	; 0x23
    6338:	94 a1       	ldd	r25, Z+36	; 0x24
    633a:	a5 a1       	ldd	r26, Z+37	; 0x25
    633c:	b6 a1       	ldd	r27, Z+38	; 0x26
    633e:	89 83       	std	Y+1, r24	; 0x01
    6340:	9a 83       	std	Y+2, r25	; 0x02
    6342:	ab 83       	std	Y+3, r26	; 0x03
    6344:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    6346:	89 81       	ldd	r24, Y+1	; 0x01
    6348:	9a 81       	ldd	r25, Y+2	; 0x02
    634a:	ab 81       	ldd	r26, Y+3	; 0x03
    634c:	bc 81       	ldd	r27, Y+4	; 0x04
    634e:	00 97       	sbiw	r24, 0x00	; 0
    6350:	a1 05       	cpc	r26, r1
    6352:	b1 05       	cpc	r27, r1
    6354:	d9 f0       	breq	.+54     	; 0x638c <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    6356:	8d 81       	ldd	r24, Y+5	; 0x05
    6358:	88 23       	and	r24, r24
    635a:	49 f0       	breq	.+18     	; 0x636e <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    635c:	e0 91 8f 05 	lds	r30, 0x058F
    6360:	f0 91 90 05 	lds	r31, 0x0590
    6364:	13 a2       	std	Z+35, r1	; 0x23
    6366:	14 a2       	std	Z+36, r1	; 0x24
    6368:	15 a2       	std	Z+37, r1	; 0x25
    636a:	16 a2       	std	Z+38, r1	; 0x26
    636c:	0f c0       	rjmp	.+30     	; 0x638c <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
    636e:	e0 91 8f 05 	lds	r30, 0x058F
    6372:	f0 91 90 05 	lds	r31, 0x0590
    6376:	89 81       	ldd	r24, Y+1	; 0x01
    6378:	9a 81       	ldd	r25, Y+2	; 0x02
    637a:	ab 81       	ldd	r26, Y+3	; 0x03
    637c:	bc 81       	ldd	r27, Y+4	; 0x04
    637e:	01 97       	sbiw	r24, 0x01	; 1
    6380:	a1 09       	sbc	r26, r1
    6382:	b1 09       	sbc	r27, r1
    6384:	83 a3       	std	Z+35, r24	; 0x23
    6386:	94 a3       	std	Z+36, r25	; 0x24
    6388:	a5 a3       	std	Z+37, r26	; 0x25
    638a:	b6 a3       	std	Z+38, r27	; 0x26
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    638c:	e0 91 8f 05 	lds	r30, 0x058F
    6390:	f0 91 90 05 	lds	r31, 0x0590
    6394:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    6396:	0f 90       	pop	r0
    6398:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    639a:	89 81       	ldd	r24, Y+1	; 0x01
    639c:	9a 81       	ldd	r25, Y+2	; 0x02
    639e:	ab 81       	ldd	r26, Y+3	; 0x03
    63a0:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    63a2:	bc 01       	movw	r22, r24
    63a4:	cd 01       	movw	r24, r26
    63a6:	27 96       	adiw	r28, 0x07	; 7
    63a8:	0f b6       	in	r0, 0x3f	; 63
    63aa:	f8 94       	cli
    63ac:	de bf       	out	0x3e, r29	; 62
    63ae:	0f be       	out	0x3f, r0	; 63
    63b0:	cd bf       	out	0x3d, r28	; 61
    63b2:	cf 91       	pop	r28
    63b4:	df 91       	pop	r29
    63b6:	08 95       	ret

000063b8 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    63b8:	ef 92       	push	r14
    63ba:	ff 92       	push	r15
    63bc:	0f 93       	push	r16
    63be:	1f 93       	push	r17
    63c0:	df 93       	push	r29
    63c2:	cf 93       	push	r28
    63c4:	cd b7       	in	r28, 0x3d	; 61
    63c6:	de b7       	in	r29, 0x3e	; 62
    63c8:	2d 97       	sbiw	r28, 0x0d	; 13
    63ca:	0f b6       	in	r0, 0x3f	; 63
    63cc:	f8 94       	cli
    63ce:	de bf       	out	0x3e, r29	; 62
    63d0:	0f be       	out	0x3f, r0	; 63
    63d2:	cd bf       	out	0x3d, r28	; 61
    63d4:	6a 83       	std	Y+2, r22	; 0x02
    63d6:	7b 83       	std	Y+3, r23	; 0x03
    63d8:	8c 83       	std	Y+4, r24	; 0x04
    63da:	9d 83       	std	Y+5, r25	; 0x05
    63dc:	2e 83       	std	Y+6, r18	; 0x06
    63de:	3f 83       	std	Y+7, r19	; 0x07
    63e0:	48 87       	std	Y+8, r20	; 0x08
    63e2:	59 87       	std	Y+9, r21	; 0x09
    63e4:	1b 87       	std	Y+11, r17	; 0x0b
    63e6:	0a 87       	std	Y+10, r16	; 0x0a
    63e8:	fd 86       	std	Y+13, r15	; 0x0d
    63ea:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    63ec:	0f b6       	in	r0, 0x3f	; 63
    63ee:	f8 94       	cli
    63f0:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    63f2:	e0 91 8f 05 	lds	r30, 0x058F
    63f6:	f0 91 90 05 	lds	r31, 0x0590
    63fa:	87 a1       	ldd	r24, Z+39	; 0x27
    63fc:	82 30       	cpi	r24, 0x02	; 2
    63fe:	49 f1       	breq	.+82     	; 0x6452 <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    6400:	e0 91 8f 05 	lds	r30, 0x058F
    6404:	f0 91 90 05 	lds	r31, 0x0590
    6408:	23 a1       	ldd	r18, Z+35	; 0x23
    640a:	34 a1       	ldd	r19, Z+36	; 0x24
    640c:	45 a1       	ldd	r20, Z+37	; 0x25
    640e:	56 a1       	ldd	r21, Z+38	; 0x26
    6410:	8a 81       	ldd	r24, Y+2	; 0x02
    6412:	9b 81       	ldd	r25, Y+3	; 0x03
    6414:	ac 81       	ldd	r26, Y+4	; 0x04
    6416:	bd 81       	ldd	r27, Y+5	; 0x05
    6418:	80 95       	com	r24
    641a:	90 95       	com	r25
    641c:	a0 95       	com	r26
    641e:	b0 95       	com	r27
    6420:	82 23       	and	r24, r18
    6422:	93 23       	and	r25, r19
    6424:	a4 23       	and	r26, r20
    6426:	b5 23       	and	r27, r21
    6428:	83 a3       	std	Z+35, r24	; 0x23
    642a:	94 a3       	std	Z+36, r25	; 0x24
    642c:	a5 a3       	std	Z+37, r26	; 0x25
    642e:	b6 a3       	std	Z+38, r27	; 0x26

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    6430:	e0 91 8f 05 	lds	r30, 0x058F
    6434:	f0 91 90 05 	lds	r31, 0x0590
    6438:	81 e0       	ldi	r24, 0x01	; 1
    643a:	87 a3       	std	Z+39, r24	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    643c:	8c 85       	ldd	r24, Y+12	; 0x0c
    643e:	9d 85       	ldd	r25, Y+13	; 0x0d
    6440:	00 97       	sbiw	r24, 0x00	; 0
    6442:	39 f0       	breq	.+14     	; 0x6452 <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    6444:	8c 85       	ldd	r24, Y+12	; 0x0c
    6446:	9d 85       	ldd	r25, Y+13	; 0x0d
    6448:	61 e0       	ldi	r22, 0x01	; 1
    644a:	0e 94 0f 35 	call	0x6a1e	; 0x6a1e <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    644e:	0e 94 32 25 	call	0x4a64	; 0x4a64 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    6452:	0f 90       	pop	r0
    6454:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    6456:	0f b6       	in	r0, 0x3f	; 63
    6458:	f8 94       	cli
    645a:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    645c:	8a 85       	ldd	r24, Y+10	; 0x0a
    645e:	9b 85       	ldd	r25, Y+11	; 0x0b
    6460:	00 97       	sbiw	r24, 0x00	; 0
    6462:	71 f0       	breq	.+28     	; 0x6480 <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    6464:	e0 91 8f 05 	lds	r30, 0x058F
    6468:	f0 91 90 05 	lds	r31, 0x0590
    646c:	83 a1       	ldd	r24, Z+35	; 0x23
    646e:	94 a1       	ldd	r25, Z+36	; 0x24
    6470:	a5 a1       	ldd	r26, Z+37	; 0x25
    6472:	b6 a1       	ldd	r27, Z+38	; 0x26
    6474:	ea 85       	ldd	r30, Y+10	; 0x0a
    6476:	fb 85       	ldd	r31, Y+11	; 0x0b
    6478:	80 83       	st	Z, r24
    647a:	91 83       	std	Z+1, r25	; 0x01
    647c:	a2 83       	std	Z+2, r26	; 0x02
    647e:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    6480:	e0 91 8f 05 	lds	r30, 0x058F
    6484:	f0 91 90 05 	lds	r31, 0x0590
    6488:	87 a1       	ldd	r24, Z+39	; 0x27
    648a:	81 30       	cpi	r24, 0x01	; 1
    648c:	11 f4       	brne	.+4      	; 0x6492 <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    648e:	19 82       	std	Y+1, r1	; 0x01
    6490:	1a c0       	rjmp	.+52     	; 0x64c6 <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    6492:	e0 91 8f 05 	lds	r30, 0x058F
    6496:	f0 91 90 05 	lds	r31, 0x0590
    649a:	23 a1       	ldd	r18, Z+35	; 0x23
    649c:	34 a1       	ldd	r19, Z+36	; 0x24
    649e:	45 a1       	ldd	r20, Z+37	; 0x25
    64a0:	56 a1       	ldd	r21, Z+38	; 0x26
    64a2:	8e 81       	ldd	r24, Y+6	; 0x06
    64a4:	9f 81       	ldd	r25, Y+7	; 0x07
    64a6:	a8 85       	ldd	r26, Y+8	; 0x08
    64a8:	b9 85       	ldd	r27, Y+9	; 0x09
    64aa:	80 95       	com	r24
    64ac:	90 95       	com	r25
    64ae:	a0 95       	com	r26
    64b0:	b0 95       	com	r27
    64b2:	82 23       	and	r24, r18
    64b4:	93 23       	and	r25, r19
    64b6:	a4 23       	and	r26, r20
    64b8:	b5 23       	and	r27, r21
    64ba:	83 a3       	std	Z+35, r24	; 0x23
    64bc:	94 a3       	std	Z+36, r25	; 0x24
    64be:	a5 a3       	std	Z+37, r26	; 0x25
    64c0:	b6 a3       	std	Z+38, r27	; 0x26
				xReturn = pdTRUE;
    64c2:	81 e0       	ldi	r24, 0x01	; 1
    64c4:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    64c6:	e0 91 8f 05 	lds	r30, 0x058F
    64ca:	f0 91 90 05 	lds	r31, 0x0590
    64ce:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    64d0:	0f 90       	pop	r0
    64d2:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    64d4:	89 81       	ldd	r24, Y+1	; 0x01
	}
    64d6:	2d 96       	adiw	r28, 0x0d	; 13
    64d8:	0f b6       	in	r0, 0x3f	; 63
    64da:	f8 94       	cli
    64dc:	de bf       	out	0x3e, r29	; 62
    64de:	0f be       	out	0x3f, r0	; 63
    64e0:	cd bf       	out	0x3d, r28	; 61
    64e2:	cf 91       	pop	r28
    64e4:	df 91       	pop	r29
    64e6:	1f 91       	pop	r17
    64e8:	0f 91       	pop	r16
    64ea:	ff 90       	pop	r15
    64ec:	ef 90       	pop	r14
    64ee:	08 95       	ret

000064f0 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    64f0:	0f 93       	push	r16
    64f2:	1f 93       	push	r17
    64f4:	df 93       	push	r29
    64f6:	cf 93       	push	r28
    64f8:	cd b7       	in	r28, 0x3d	; 61
    64fa:	de b7       	in	r29, 0x3e	; 62
    64fc:	2f 97       	sbiw	r28, 0x0f	; 15
    64fe:	0f b6       	in	r0, 0x3f	; 63
    6500:	f8 94       	cli
    6502:	de bf       	out	0x3e, r29	; 62
    6504:	0f be       	out	0x3f, r0	; 63
    6506:	cd bf       	out	0x3d, r28	; 61
    6508:	9e 83       	std	Y+6, r25	; 0x06
    650a:	8d 83       	std	Y+5, r24	; 0x05
    650c:	4f 83       	std	Y+7, r20	; 0x07
    650e:	58 87       	std	Y+8, r21	; 0x08
    6510:	69 87       	std	Y+9, r22	; 0x09
    6512:	7a 87       	std	Y+10, r23	; 0x0a
    6514:	2b 87       	std	Y+11, r18	; 0x0b
    6516:	1d 87       	std	Y+13, r17	; 0x0d
    6518:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    651a:	81 e0       	ldi	r24, 0x01	; 1
    651c:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;
    651e:	8d 81       	ldd	r24, Y+5	; 0x05
    6520:	9e 81       	ldd	r25, Y+6	; 0x06
    6522:	9c 83       	std	Y+4, r25	; 0x04
    6524:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    6526:	0f b6       	in	r0, 0x3f	; 63
    6528:	f8 94       	cli
    652a:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    652c:	8c 85       	ldd	r24, Y+12	; 0x0c
    652e:	9d 85       	ldd	r25, Y+13	; 0x0d
    6530:	00 97       	sbiw	r24, 0x00	; 0
    6532:	61 f0       	breq	.+24     	; 0x654c <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    6534:	eb 81       	ldd	r30, Y+3	; 0x03
    6536:	fc 81       	ldd	r31, Y+4	; 0x04
    6538:	83 a1       	ldd	r24, Z+35	; 0x23
    653a:	94 a1       	ldd	r25, Z+36	; 0x24
    653c:	a5 a1       	ldd	r26, Z+37	; 0x25
    653e:	b6 a1       	ldd	r27, Z+38	; 0x26
    6540:	ec 85       	ldd	r30, Y+12	; 0x0c
    6542:	fd 85       	ldd	r31, Y+13	; 0x0d
    6544:	80 83       	st	Z, r24
    6546:	91 83       	std	Z+1, r25	; 0x01
    6548:	a2 83       	std	Z+2, r26	; 0x02
    654a:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    654c:	eb 81       	ldd	r30, Y+3	; 0x03
    654e:	fc 81       	ldd	r31, Y+4	; 0x04
    6550:	87 a1       	ldd	r24, Z+39	; 0x27
    6552:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    6554:	eb 81       	ldd	r30, Y+3	; 0x03
    6556:	fc 81       	ldd	r31, Y+4	; 0x04
    6558:	82 e0       	ldi	r24, 0x02	; 2
    655a:	87 a3       	std	Z+39, r24	; 0x27

			switch( eAction )
    655c:	8b 85       	ldd	r24, Y+11	; 0x0b
    655e:	28 2f       	mov	r18, r24
    6560:	30 e0       	ldi	r19, 0x00	; 0
    6562:	3f 87       	std	Y+15, r19	; 0x0f
    6564:	2e 87       	std	Y+14, r18	; 0x0e
    6566:	8e 85       	ldd	r24, Y+14	; 0x0e
    6568:	9f 85       	ldd	r25, Y+15	; 0x0f
    656a:	82 30       	cpi	r24, 0x02	; 2
    656c:	91 05       	cpc	r25, r1
    656e:	59 f1       	breq	.+86     	; 0x65c6 <xTaskGenericNotify+0xd6>
    6570:	2e 85       	ldd	r18, Y+14	; 0x0e
    6572:	3f 85       	ldd	r19, Y+15	; 0x0f
    6574:	23 30       	cpi	r18, 0x03	; 3
    6576:	31 05       	cpc	r19, r1
    6578:	34 f4       	brge	.+12     	; 0x6586 <xTaskGenericNotify+0x96>
    657a:	8e 85       	ldd	r24, Y+14	; 0x0e
    657c:	9f 85       	ldd	r25, Y+15	; 0x0f
    657e:	81 30       	cpi	r24, 0x01	; 1
    6580:	91 05       	cpc	r25, r1
    6582:	61 f0       	breq	.+24     	; 0x659c <xTaskGenericNotify+0xac>
    6584:	4a c0       	rjmp	.+148    	; 0x661a <xTaskGenericNotify+0x12a>
    6586:	2e 85       	ldd	r18, Y+14	; 0x0e
    6588:	3f 85       	ldd	r19, Y+15	; 0x0f
    658a:	23 30       	cpi	r18, 0x03	; 3
    658c:	31 05       	cpc	r19, r1
    658e:	59 f1       	breq	.+86     	; 0x65e6 <xTaskGenericNotify+0xf6>
    6590:	8e 85       	ldd	r24, Y+14	; 0x0e
    6592:	9f 85       	ldd	r25, Y+15	; 0x0f
    6594:	84 30       	cpi	r24, 0x04	; 4
    6596:	91 05       	cpc	r25, r1
    6598:	89 f1       	breq	.+98     	; 0x65fc <xTaskGenericNotify+0x10c>
    659a:	3f c0       	rjmp	.+126    	; 0x661a <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    659c:	eb 81       	ldd	r30, Y+3	; 0x03
    659e:	fc 81       	ldd	r31, Y+4	; 0x04
    65a0:	23 a1       	ldd	r18, Z+35	; 0x23
    65a2:	34 a1       	ldd	r19, Z+36	; 0x24
    65a4:	45 a1       	ldd	r20, Z+37	; 0x25
    65a6:	56 a1       	ldd	r21, Z+38	; 0x26
    65a8:	8f 81       	ldd	r24, Y+7	; 0x07
    65aa:	98 85       	ldd	r25, Y+8	; 0x08
    65ac:	a9 85       	ldd	r26, Y+9	; 0x09
    65ae:	ba 85       	ldd	r27, Y+10	; 0x0a
    65b0:	82 2b       	or	r24, r18
    65b2:	93 2b       	or	r25, r19
    65b4:	a4 2b       	or	r26, r20
    65b6:	b5 2b       	or	r27, r21
    65b8:	eb 81       	ldd	r30, Y+3	; 0x03
    65ba:	fc 81       	ldd	r31, Y+4	; 0x04
    65bc:	83 a3       	std	Z+35, r24	; 0x23
    65be:	94 a3       	std	Z+36, r25	; 0x24
    65c0:	a5 a3       	std	Z+37, r26	; 0x25
    65c2:	b6 a3       	std	Z+38, r27	; 0x26
    65c4:	2a c0       	rjmp	.+84     	; 0x661a <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    65c6:	eb 81       	ldd	r30, Y+3	; 0x03
    65c8:	fc 81       	ldd	r31, Y+4	; 0x04
    65ca:	83 a1       	ldd	r24, Z+35	; 0x23
    65cc:	94 a1       	ldd	r25, Z+36	; 0x24
    65ce:	a5 a1       	ldd	r26, Z+37	; 0x25
    65d0:	b6 a1       	ldd	r27, Z+38	; 0x26
    65d2:	01 96       	adiw	r24, 0x01	; 1
    65d4:	a1 1d       	adc	r26, r1
    65d6:	b1 1d       	adc	r27, r1
    65d8:	eb 81       	ldd	r30, Y+3	; 0x03
    65da:	fc 81       	ldd	r31, Y+4	; 0x04
    65dc:	83 a3       	std	Z+35, r24	; 0x23
    65de:	94 a3       	std	Z+36, r25	; 0x24
    65e0:	a5 a3       	std	Z+37, r26	; 0x25
    65e2:	b6 a3       	std	Z+38, r27	; 0x26
    65e4:	1a c0       	rjmp	.+52     	; 0x661a <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    65e6:	eb 81       	ldd	r30, Y+3	; 0x03
    65e8:	fc 81       	ldd	r31, Y+4	; 0x04
    65ea:	8f 81       	ldd	r24, Y+7	; 0x07
    65ec:	98 85       	ldd	r25, Y+8	; 0x08
    65ee:	a9 85       	ldd	r26, Y+9	; 0x09
    65f0:	ba 85       	ldd	r27, Y+10	; 0x0a
    65f2:	83 a3       	std	Z+35, r24	; 0x23
    65f4:	94 a3       	std	Z+36, r25	; 0x24
    65f6:	a5 a3       	std	Z+37, r26	; 0x25
    65f8:	b6 a3       	std	Z+38, r27	; 0x26
    65fa:	0f c0       	rjmp	.+30     	; 0x661a <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    65fc:	89 81       	ldd	r24, Y+1	; 0x01
    65fe:	82 30       	cpi	r24, 0x02	; 2
    6600:	59 f0       	breq	.+22     	; 0x6618 <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    6602:	eb 81       	ldd	r30, Y+3	; 0x03
    6604:	fc 81       	ldd	r31, Y+4	; 0x04
    6606:	8f 81       	ldd	r24, Y+7	; 0x07
    6608:	98 85       	ldd	r25, Y+8	; 0x08
    660a:	a9 85       	ldd	r26, Y+9	; 0x09
    660c:	ba 85       	ldd	r27, Y+10	; 0x0a
    660e:	83 a3       	std	Z+35, r24	; 0x23
    6610:	94 a3       	std	Z+36, r25	; 0x24
    6612:	a5 a3       	std	Z+37, r26	; 0x25
    6614:	b6 a3       	std	Z+38, r27	; 0x26
    6616:	01 c0       	rjmp	.+2      	; 0x661a <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    6618:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    661a:	89 81       	ldd	r24, Y+1	; 0x01
    661c:	81 30       	cpi	r24, 0x01	; 1
    661e:	b9 f5       	brne	.+110    	; 0x668e <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    6620:	8b 81       	ldd	r24, Y+3	; 0x03
    6622:	9c 81       	ldd	r25, Y+4	; 0x04
    6624:	02 96       	adiw	r24, 0x02	; 2
    6626:	0e 94 27 23 	call	0x464e	; 0x464e <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    662a:	eb 81       	ldd	r30, Y+3	; 0x03
    662c:	fc 81       	ldd	r31, Y+4	; 0x04
    662e:	96 89       	ldd	r25, Z+22	; 0x16
    6630:	80 91 95 05 	lds	r24, 0x0595
    6634:	89 17       	cp	r24, r25
    6636:	28 f4       	brcc	.+10     	; 0x6642 <xTaskGenericNotify+0x152>
    6638:	eb 81       	ldd	r30, Y+3	; 0x03
    663a:	fc 81       	ldd	r31, Y+4	; 0x04
    663c:	86 89       	ldd	r24, Z+22	; 0x16
    663e:	80 93 95 05 	sts	0x0595, r24
    6642:	eb 81       	ldd	r30, Y+3	; 0x03
    6644:	fc 81       	ldd	r31, Y+4	; 0x04
    6646:	86 89       	ldd	r24, Z+22	; 0x16
    6648:	28 2f       	mov	r18, r24
    664a:	30 e0       	ldi	r19, 0x00	; 0
    664c:	c9 01       	movw	r24, r18
    664e:	88 0f       	add	r24, r24
    6650:	99 1f       	adc	r25, r25
    6652:	88 0f       	add	r24, r24
    6654:	99 1f       	adc	r25, r25
    6656:	88 0f       	add	r24, r24
    6658:	99 1f       	adc	r25, r25
    665a:	82 0f       	add	r24, r18
    665c:	93 1f       	adc	r25, r19
    665e:	ac 01       	movw	r20, r24
    6660:	40 56       	subi	r20, 0x60	; 96
    6662:	5a 4f       	sbci	r21, 0xFA	; 250
    6664:	8b 81       	ldd	r24, Y+3	; 0x03
    6666:	9c 81       	ldd	r25, Y+4	; 0x04
    6668:	9c 01       	movw	r18, r24
    666a:	2e 5f       	subi	r18, 0xFE	; 254
    666c:	3f 4f       	sbci	r19, 0xFF	; 255
    666e:	ca 01       	movw	r24, r20
    6670:	b9 01       	movw	r22, r18
    6672:	0e 94 77 22 	call	0x44ee	; 0x44ee <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    6676:	eb 81       	ldd	r30, Y+3	; 0x03
    6678:	fc 81       	ldd	r31, Y+4	; 0x04
    667a:	96 89       	ldd	r25, Z+22	; 0x16
    667c:	e0 91 8f 05 	lds	r30, 0x058F
    6680:	f0 91 90 05 	lds	r31, 0x0590
    6684:	86 89       	ldd	r24, Z+22	; 0x16
    6686:	89 17       	cp	r24, r25
    6688:	10 f4       	brcc	.+4      	; 0x668e <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    668a:	0e 94 32 25 	call	0x4a64	; 0x4a64 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    668e:	0f 90       	pop	r0
    6690:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    6692:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    6694:	2f 96       	adiw	r28, 0x0f	; 15
    6696:	0f b6       	in	r0, 0x3f	; 63
    6698:	f8 94       	cli
    669a:	de bf       	out	0x3e, r29	; 62
    669c:	0f be       	out	0x3f, r0	; 63
    669e:	cd bf       	out	0x3d, r28	; 61
    66a0:	cf 91       	pop	r28
    66a2:	df 91       	pop	r29
    66a4:	1f 91       	pop	r17
    66a6:	0f 91       	pop	r16
    66a8:	08 95       	ret

000066aa <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    66aa:	ef 92       	push	r14
    66ac:	ff 92       	push	r15
    66ae:	0f 93       	push	r16
    66b0:	1f 93       	push	r17
    66b2:	df 93       	push	r29
    66b4:	cf 93       	push	r28
    66b6:	cd b7       	in	r28, 0x3d	; 61
    66b8:	de b7       	in	r29, 0x3e	; 62
    66ba:	62 97       	sbiw	r28, 0x12	; 18
    66bc:	0f b6       	in	r0, 0x3f	; 63
    66be:	f8 94       	cli
    66c0:	de bf       	out	0x3e, r29	; 62
    66c2:	0f be       	out	0x3f, r0	; 63
    66c4:	cd bf       	out	0x3d, r28	; 61
    66c6:	9f 83       	std	Y+7, r25	; 0x07
    66c8:	8e 83       	std	Y+6, r24	; 0x06
    66ca:	48 87       	std	Y+8, r20	; 0x08
    66cc:	59 87       	std	Y+9, r21	; 0x09
    66ce:	6a 87       	std	Y+10, r22	; 0x0a
    66d0:	7b 87       	std	Y+11, r23	; 0x0b
    66d2:	2c 87       	std	Y+12, r18	; 0x0c
    66d4:	1e 87       	std	Y+14, r17	; 0x0e
    66d6:	0d 87       	std	Y+13, r16	; 0x0d
    66d8:	f8 8a       	std	Y+16, r15	; 0x10
    66da:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    66dc:	81 e0       	ldi	r24, 0x01	; 1
    66de:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    66e0:	8e 81       	ldd	r24, Y+6	; 0x06
    66e2:	9f 81       	ldd	r25, Y+7	; 0x07
    66e4:	9d 83       	std	Y+5, r25	; 0x05
    66e6:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    66e8:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    66ea:	8d 85       	ldd	r24, Y+13	; 0x0d
    66ec:	9e 85       	ldd	r25, Y+14	; 0x0e
    66ee:	00 97       	sbiw	r24, 0x00	; 0
    66f0:	61 f0       	breq	.+24     	; 0x670a <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    66f2:	ec 81       	ldd	r30, Y+4	; 0x04
    66f4:	fd 81       	ldd	r31, Y+5	; 0x05
    66f6:	83 a1       	ldd	r24, Z+35	; 0x23
    66f8:	94 a1       	ldd	r25, Z+36	; 0x24
    66fa:	a5 a1       	ldd	r26, Z+37	; 0x25
    66fc:	b6 a1       	ldd	r27, Z+38	; 0x26
    66fe:	ed 85       	ldd	r30, Y+13	; 0x0d
    6700:	fe 85       	ldd	r31, Y+14	; 0x0e
    6702:	80 83       	st	Z, r24
    6704:	91 83       	std	Z+1, r25	; 0x01
    6706:	a2 83       	std	Z+2, r26	; 0x02
    6708:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    670a:	ec 81       	ldd	r30, Y+4	; 0x04
    670c:	fd 81       	ldd	r31, Y+5	; 0x05
    670e:	87 a1       	ldd	r24, Z+39	; 0x27
    6710:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    6712:	ec 81       	ldd	r30, Y+4	; 0x04
    6714:	fd 81       	ldd	r31, Y+5	; 0x05
    6716:	82 e0       	ldi	r24, 0x02	; 2
    6718:	87 a3       	std	Z+39, r24	; 0x27

			switch( eAction )
    671a:	8c 85       	ldd	r24, Y+12	; 0x0c
    671c:	28 2f       	mov	r18, r24
    671e:	30 e0       	ldi	r19, 0x00	; 0
    6720:	3a 8b       	std	Y+18, r19	; 0x12
    6722:	29 8b       	std	Y+17, r18	; 0x11
    6724:	89 89       	ldd	r24, Y+17	; 0x11
    6726:	9a 89       	ldd	r25, Y+18	; 0x12
    6728:	82 30       	cpi	r24, 0x02	; 2
    672a:	91 05       	cpc	r25, r1
    672c:	59 f1       	breq	.+86     	; 0x6784 <xTaskGenericNotifyFromISR+0xda>
    672e:	29 89       	ldd	r18, Y+17	; 0x11
    6730:	3a 89       	ldd	r19, Y+18	; 0x12
    6732:	23 30       	cpi	r18, 0x03	; 3
    6734:	31 05       	cpc	r19, r1
    6736:	34 f4       	brge	.+12     	; 0x6744 <xTaskGenericNotifyFromISR+0x9a>
    6738:	89 89       	ldd	r24, Y+17	; 0x11
    673a:	9a 89       	ldd	r25, Y+18	; 0x12
    673c:	81 30       	cpi	r24, 0x01	; 1
    673e:	91 05       	cpc	r25, r1
    6740:	61 f0       	breq	.+24     	; 0x675a <xTaskGenericNotifyFromISR+0xb0>
    6742:	4a c0       	rjmp	.+148    	; 0x67d8 <xTaskGenericNotifyFromISR+0x12e>
    6744:	29 89       	ldd	r18, Y+17	; 0x11
    6746:	3a 89       	ldd	r19, Y+18	; 0x12
    6748:	23 30       	cpi	r18, 0x03	; 3
    674a:	31 05       	cpc	r19, r1
    674c:	59 f1       	breq	.+86     	; 0x67a4 <xTaskGenericNotifyFromISR+0xfa>
    674e:	89 89       	ldd	r24, Y+17	; 0x11
    6750:	9a 89       	ldd	r25, Y+18	; 0x12
    6752:	84 30       	cpi	r24, 0x04	; 4
    6754:	91 05       	cpc	r25, r1
    6756:	89 f1       	breq	.+98     	; 0x67ba <xTaskGenericNotifyFromISR+0x110>
    6758:	3f c0       	rjmp	.+126    	; 0x67d8 <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    675a:	ec 81       	ldd	r30, Y+4	; 0x04
    675c:	fd 81       	ldd	r31, Y+5	; 0x05
    675e:	23 a1       	ldd	r18, Z+35	; 0x23
    6760:	34 a1       	ldd	r19, Z+36	; 0x24
    6762:	45 a1       	ldd	r20, Z+37	; 0x25
    6764:	56 a1       	ldd	r21, Z+38	; 0x26
    6766:	88 85       	ldd	r24, Y+8	; 0x08
    6768:	99 85       	ldd	r25, Y+9	; 0x09
    676a:	aa 85       	ldd	r26, Y+10	; 0x0a
    676c:	bb 85       	ldd	r27, Y+11	; 0x0b
    676e:	82 2b       	or	r24, r18
    6770:	93 2b       	or	r25, r19
    6772:	a4 2b       	or	r26, r20
    6774:	b5 2b       	or	r27, r21
    6776:	ec 81       	ldd	r30, Y+4	; 0x04
    6778:	fd 81       	ldd	r31, Y+5	; 0x05
    677a:	83 a3       	std	Z+35, r24	; 0x23
    677c:	94 a3       	std	Z+36, r25	; 0x24
    677e:	a5 a3       	std	Z+37, r26	; 0x25
    6780:	b6 a3       	std	Z+38, r27	; 0x26
    6782:	2a c0       	rjmp	.+84     	; 0x67d8 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    6784:	ec 81       	ldd	r30, Y+4	; 0x04
    6786:	fd 81       	ldd	r31, Y+5	; 0x05
    6788:	83 a1       	ldd	r24, Z+35	; 0x23
    678a:	94 a1       	ldd	r25, Z+36	; 0x24
    678c:	a5 a1       	ldd	r26, Z+37	; 0x25
    678e:	b6 a1       	ldd	r27, Z+38	; 0x26
    6790:	01 96       	adiw	r24, 0x01	; 1
    6792:	a1 1d       	adc	r26, r1
    6794:	b1 1d       	adc	r27, r1
    6796:	ec 81       	ldd	r30, Y+4	; 0x04
    6798:	fd 81       	ldd	r31, Y+5	; 0x05
    679a:	83 a3       	std	Z+35, r24	; 0x23
    679c:	94 a3       	std	Z+36, r25	; 0x24
    679e:	a5 a3       	std	Z+37, r26	; 0x25
    67a0:	b6 a3       	std	Z+38, r27	; 0x26
    67a2:	1a c0       	rjmp	.+52     	; 0x67d8 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    67a4:	ec 81       	ldd	r30, Y+4	; 0x04
    67a6:	fd 81       	ldd	r31, Y+5	; 0x05
    67a8:	88 85       	ldd	r24, Y+8	; 0x08
    67aa:	99 85       	ldd	r25, Y+9	; 0x09
    67ac:	aa 85       	ldd	r26, Y+10	; 0x0a
    67ae:	bb 85       	ldd	r27, Y+11	; 0x0b
    67b0:	83 a3       	std	Z+35, r24	; 0x23
    67b2:	94 a3       	std	Z+36, r25	; 0x24
    67b4:	a5 a3       	std	Z+37, r26	; 0x25
    67b6:	b6 a3       	std	Z+38, r27	; 0x26
    67b8:	0f c0       	rjmp	.+30     	; 0x67d8 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    67ba:	8b 81       	ldd	r24, Y+3	; 0x03
    67bc:	82 30       	cpi	r24, 0x02	; 2
    67be:	59 f0       	breq	.+22     	; 0x67d6 <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    67c0:	ec 81       	ldd	r30, Y+4	; 0x04
    67c2:	fd 81       	ldd	r31, Y+5	; 0x05
    67c4:	88 85       	ldd	r24, Y+8	; 0x08
    67c6:	99 85       	ldd	r25, Y+9	; 0x09
    67c8:	aa 85       	ldd	r26, Y+10	; 0x0a
    67ca:	bb 85       	ldd	r27, Y+11	; 0x0b
    67cc:	83 a3       	std	Z+35, r24	; 0x23
    67ce:	94 a3       	std	Z+36, r25	; 0x24
    67d0:	a5 a3       	std	Z+37, r26	; 0x25
    67d2:	b6 a3       	std	Z+38, r27	; 0x26
    67d4:	01 c0       	rjmp	.+2      	; 0x67d8 <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    67d6:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    67d8:	8b 81       	ldd	r24, Y+3	; 0x03
    67da:	81 30       	cpi	r24, 0x01	; 1
    67dc:	09 f0       	breq	.+2      	; 0x67e0 <xTaskGenericNotifyFromISR+0x136>
    67de:	50 c0       	rjmp	.+160    	; 0x6880 <xTaskGenericNotifyFromISR+0x1d6>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    67e0:	80 91 9f 05 	lds	r24, 0x059F
    67e4:	88 23       	and	r24, r24
    67e6:	61 f5       	brne	.+88     	; 0x6840 <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    67e8:	8c 81       	ldd	r24, Y+4	; 0x04
    67ea:	9d 81       	ldd	r25, Y+5	; 0x05
    67ec:	02 96       	adiw	r24, 0x02	; 2
    67ee:	0e 94 27 23 	call	0x464e	; 0x464e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    67f2:	ec 81       	ldd	r30, Y+4	; 0x04
    67f4:	fd 81       	ldd	r31, Y+5	; 0x05
    67f6:	96 89       	ldd	r25, Z+22	; 0x16
    67f8:	80 91 95 05 	lds	r24, 0x0595
    67fc:	89 17       	cp	r24, r25
    67fe:	28 f4       	brcc	.+10     	; 0x680a <xTaskGenericNotifyFromISR+0x160>
    6800:	ec 81       	ldd	r30, Y+4	; 0x04
    6802:	fd 81       	ldd	r31, Y+5	; 0x05
    6804:	86 89       	ldd	r24, Z+22	; 0x16
    6806:	80 93 95 05 	sts	0x0595, r24
    680a:	ec 81       	ldd	r30, Y+4	; 0x04
    680c:	fd 81       	ldd	r31, Y+5	; 0x05
    680e:	86 89       	ldd	r24, Z+22	; 0x16
    6810:	28 2f       	mov	r18, r24
    6812:	30 e0       	ldi	r19, 0x00	; 0
    6814:	c9 01       	movw	r24, r18
    6816:	88 0f       	add	r24, r24
    6818:	99 1f       	adc	r25, r25
    681a:	88 0f       	add	r24, r24
    681c:	99 1f       	adc	r25, r25
    681e:	88 0f       	add	r24, r24
    6820:	99 1f       	adc	r25, r25
    6822:	82 0f       	add	r24, r18
    6824:	93 1f       	adc	r25, r19
    6826:	ac 01       	movw	r20, r24
    6828:	40 56       	subi	r20, 0x60	; 96
    682a:	5a 4f       	sbci	r21, 0xFA	; 250
    682c:	8c 81       	ldd	r24, Y+4	; 0x04
    682e:	9d 81       	ldd	r25, Y+5	; 0x05
    6830:	9c 01       	movw	r18, r24
    6832:	2e 5f       	subi	r18, 0xFE	; 254
    6834:	3f 4f       	sbci	r19, 0xFF	; 255
    6836:	ca 01       	movw	r24, r20
    6838:	b9 01       	movw	r22, r18
    683a:	0e 94 77 22 	call	0x44ee	; 0x44ee <vListInsertEnd>
    683e:	0a c0       	rjmp	.+20     	; 0x6854 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    6840:	8c 81       	ldd	r24, Y+4	; 0x04
    6842:	9d 81       	ldd	r25, Y+5	; 0x05
    6844:	9c 01       	movw	r18, r24
    6846:	24 5f       	subi	r18, 0xF4	; 244
    6848:	3f 4f       	sbci	r19, 0xFF	; 255
    684a:	87 e0       	ldi	r24, 0x07	; 7
    684c:	96 e0       	ldi	r25, 0x06	; 6
    684e:	b9 01       	movw	r22, r18
    6850:	0e 94 77 22 	call	0x44ee	; 0x44ee <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    6854:	ec 81       	ldd	r30, Y+4	; 0x04
    6856:	fd 81       	ldd	r31, Y+5	; 0x05
    6858:	96 89       	ldd	r25, Z+22	; 0x16
    685a:	e0 91 8f 05 	lds	r30, 0x058F
    685e:	f0 91 90 05 	lds	r31, 0x0590
    6862:	86 89       	ldd	r24, Z+22	; 0x16
    6864:	89 17       	cp	r24, r25
    6866:	60 f4       	brcc	.+24     	; 0x6880 <xTaskGenericNotifyFromISR+0x1d6>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    6868:	8f 85       	ldd	r24, Y+15	; 0x0f
    686a:	98 89       	ldd	r25, Y+16	; 0x10
    686c:	00 97       	sbiw	r24, 0x00	; 0
    686e:	29 f0       	breq	.+10     	; 0x687a <xTaskGenericNotifyFromISR+0x1d0>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    6870:	ef 85       	ldd	r30, Y+15	; 0x0f
    6872:	f8 89       	ldd	r31, Y+16	; 0x10
    6874:	81 e0       	ldi	r24, 0x01	; 1
    6876:	80 83       	st	Z, r24
    6878:	03 c0       	rjmp	.+6      	; 0x6880 <xTaskGenericNotifyFromISR+0x1d6>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    687a:	81 e0       	ldi	r24, 0x01	; 1
    687c:	80 93 98 05 	sts	0x0598, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    6880:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    6882:	62 96       	adiw	r28, 0x12	; 18
    6884:	0f b6       	in	r0, 0x3f	; 63
    6886:	f8 94       	cli
    6888:	de bf       	out	0x3e, r29	; 62
    688a:	0f be       	out	0x3f, r0	; 63
    688c:	cd bf       	out	0x3d, r28	; 61
    688e:	cf 91       	pop	r28
    6890:	df 91       	pop	r29
    6892:	1f 91       	pop	r17
    6894:	0f 91       	pop	r16
    6896:	ff 90       	pop	r15
    6898:	ef 90       	pop	r14
    689a:	08 95       	ret

0000689c <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    689c:	df 93       	push	r29
    689e:	cf 93       	push	r28
    68a0:	cd b7       	in	r28, 0x3d	; 61
    68a2:	de b7       	in	r29, 0x3e	; 62
    68a4:	28 97       	sbiw	r28, 0x08	; 8
    68a6:	0f b6       	in	r0, 0x3f	; 63
    68a8:	f8 94       	cli
    68aa:	de bf       	out	0x3e, r29	; 62
    68ac:	0f be       	out	0x3f, r0	; 63
    68ae:	cd bf       	out	0x3d, r28	; 61
    68b0:	9e 83       	std	Y+6, r25	; 0x06
    68b2:	8d 83       	std	Y+5, r24	; 0x05
    68b4:	78 87       	std	Y+8, r23	; 0x08
    68b6:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    68b8:	8d 81       	ldd	r24, Y+5	; 0x05
    68ba:	9e 81       	ldd	r25, Y+6	; 0x06
    68bc:	9c 83       	std	Y+4, r25	; 0x04
    68be:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    68c0:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    68c2:	eb 81       	ldd	r30, Y+3	; 0x03
    68c4:	fc 81       	ldd	r31, Y+4	; 0x04
    68c6:	87 a1       	ldd	r24, Z+39	; 0x27
    68c8:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    68ca:	eb 81       	ldd	r30, Y+3	; 0x03
    68cc:	fc 81       	ldd	r31, Y+4	; 0x04
    68ce:	82 e0       	ldi	r24, 0x02	; 2
    68d0:	87 a3       	std	Z+39, r24	; 0x27

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    68d2:	eb 81       	ldd	r30, Y+3	; 0x03
    68d4:	fc 81       	ldd	r31, Y+4	; 0x04
    68d6:	83 a1       	ldd	r24, Z+35	; 0x23
    68d8:	94 a1       	ldd	r25, Z+36	; 0x24
    68da:	a5 a1       	ldd	r26, Z+37	; 0x25
    68dc:	b6 a1       	ldd	r27, Z+38	; 0x26
    68de:	01 96       	adiw	r24, 0x01	; 1
    68e0:	a1 1d       	adc	r26, r1
    68e2:	b1 1d       	adc	r27, r1
    68e4:	eb 81       	ldd	r30, Y+3	; 0x03
    68e6:	fc 81       	ldd	r31, Y+4	; 0x04
    68e8:	83 a3       	std	Z+35, r24	; 0x23
    68ea:	94 a3       	std	Z+36, r25	; 0x24
    68ec:	a5 a3       	std	Z+37, r26	; 0x25
    68ee:	b6 a3       	std	Z+38, r27	; 0x26

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    68f0:	8a 81       	ldd	r24, Y+2	; 0x02
    68f2:	81 30       	cpi	r24, 0x01	; 1
    68f4:	09 f0       	breq	.+2      	; 0x68f8 <vTaskNotifyGiveFromISR+0x5c>
    68f6:	50 c0       	rjmp	.+160    	; 0x6998 <vTaskNotifyGiveFromISR+0xfc>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    68f8:	80 91 9f 05 	lds	r24, 0x059F
    68fc:	88 23       	and	r24, r24
    68fe:	61 f5       	brne	.+88     	; 0x6958 <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    6900:	8b 81       	ldd	r24, Y+3	; 0x03
    6902:	9c 81       	ldd	r25, Y+4	; 0x04
    6904:	02 96       	adiw	r24, 0x02	; 2
    6906:	0e 94 27 23 	call	0x464e	; 0x464e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    690a:	eb 81       	ldd	r30, Y+3	; 0x03
    690c:	fc 81       	ldd	r31, Y+4	; 0x04
    690e:	96 89       	ldd	r25, Z+22	; 0x16
    6910:	80 91 95 05 	lds	r24, 0x0595
    6914:	89 17       	cp	r24, r25
    6916:	28 f4       	brcc	.+10     	; 0x6922 <vTaskNotifyGiveFromISR+0x86>
    6918:	eb 81       	ldd	r30, Y+3	; 0x03
    691a:	fc 81       	ldd	r31, Y+4	; 0x04
    691c:	86 89       	ldd	r24, Z+22	; 0x16
    691e:	80 93 95 05 	sts	0x0595, r24
    6922:	eb 81       	ldd	r30, Y+3	; 0x03
    6924:	fc 81       	ldd	r31, Y+4	; 0x04
    6926:	86 89       	ldd	r24, Z+22	; 0x16
    6928:	28 2f       	mov	r18, r24
    692a:	30 e0       	ldi	r19, 0x00	; 0
    692c:	c9 01       	movw	r24, r18
    692e:	88 0f       	add	r24, r24
    6930:	99 1f       	adc	r25, r25
    6932:	88 0f       	add	r24, r24
    6934:	99 1f       	adc	r25, r25
    6936:	88 0f       	add	r24, r24
    6938:	99 1f       	adc	r25, r25
    693a:	82 0f       	add	r24, r18
    693c:	93 1f       	adc	r25, r19
    693e:	ac 01       	movw	r20, r24
    6940:	40 56       	subi	r20, 0x60	; 96
    6942:	5a 4f       	sbci	r21, 0xFA	; 250
    6944:	8b 81       	ldd	r24, Y+3	; 0x03
    6946:	9c 81       	ldd	r25, Y+4	; 0x04
    6948:	9c 01       	movw	r18, r24
    694a:	2e 5f       	subi	r18, 0xFE	; 254
    694c:	3f 4f       	sbci	r19, 0xFF	; 255
    694e:	ca 01       	movw	r24, r20
    6950:	b9 01       	movw	r22, r18
    6952:	0e 94 77 22 	call	0x44ee	; 0x44ee <vListInsertEnd>
    6956:	0a c0       	rjmp	.+20     	; 0x696c <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    6958:	8b 81       	ldd	r24, Y+3	; 0x03
    695a:	9c 81       	ldd	r25, Y+4	; 0x04
    695c:	9c 01       	movw	r18, r24
    695e:	24 5f       	subi	r18, 0xF4	; 244
    6960:	3f 4f       	sbci	r19, 0xFF	; 255
    6962:	87 e0       	ldi	r24, 0x07	; 7
    6964:	96 e0       	ldi	r25, 0x06	; 6
    6966:	b9 01       	movw	r22, r18
    6968:	0e 94 77 22 	call	0x44ee	; 0x44ee <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    696c:	eb 81       	ldd	r30, Y+3	; 0x03
    696e:	fc 81       	ldd	r31, Y+4	; 0x04
    6970:	96 89       	ldd	r25, Z+22	; 0x16
    6972:	e0 91 8f 05 	lds	r30, 0x058F
    6976:	f0 91 90 05 	lds	r31, 0x0590
    697a:	86 89       	ldd	r24, Z+22	; 0x16
    697c:	89 17       	cp	r24, r25
    697e:	60 f4       	brcc	.+24     	; 0x6998 <vTaskNotifyGiveFromISR+0xfc>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    6980:	8f 81       	ldd	r24, Y+7	; 0x07
    6982:	98 85       	ldd	r25, Y+8	; 0x08
    6984:	00 97       	sbiw	r24, 0x00	; 0
    6986:	29 f0       	breq	.+10     	; 0x6992 <vTaskNotifyGiveFromISR+0xf6>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    6988:	ef 81       	ldd	r30, Y+7	; 0x07
    698a:	f8 85       	ldd	r31, Y+8	; 0x08
    698c:	81 e0       	ldi	r24, 0x01	; 1
    698e:	80 83       	st	Z, r24
    6990:	03 c0       	rjmp	.+6      	; 0x6998 <vTaskNotifyGiveFromISR+0xfc>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    6992:	81 e0       	ldi	r24, 0x01	; 1
    6994:	80 93 98 05 	sts	0x0598, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    6998:	28 96       	adiw	r28, 0x08	; 8
    699a:	0f b6       	in	r0, 0x3f	; 63
    699c:	f8 94       	cli
    699e:	de bf       	out	0x3e, r29	; 62
    69a0:	0f be       	out	0x3f, r0	; 63
    69a2:	cd bf       	out	0x3d, r28	; 61
    69a4:	cf 91       	pop	r28
    69a6:	df 91       	pop	r29
    69a8:	08 95       	ret

000069aa <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    69aa:	df 93       	push	r29
    69ac:	cf 93       	push	r28
    69ae:	cd b7       	in	r28, 0x3d	; 61
    69b0:	de b7       	in	r29, 0x3e	; 62
    69b2:	27 97       	sbiw	r28, 0x07	; 7
    69b4:	0f b6       	in	r0, 0x3f	; 63
    69b6:	f8 94       	cli
    69b8:	de bf       	out	0x3e, r29	; 62
    69ba:	0f be       	out	0x3f, r0	; 63
    69bc:	cd bf       	out	0x3d, r28	; 61
    69be:	9d 83       	std	Y+5, r25	; 0x05
    69c0:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    69c2:	8c 81       	ldd	r24, Y+4	; 0x04
    69c4:	9d 81       	ldd	r25, Y+5	; 0x05
    69c6:	00 97       	sbiw	r24, 0x00	; 0
    69c8:	39 f4       	brne	.+14     	; 0x69d8 <xTaskNotifyStateClear+0x2e>
    69ca:	80 91 8f 05 	lds	r24, 0x058F
    69ce:	90 91 90 05 	lds	r25, 0x0590
    69d2:	9f 83       	std	Y+7, r25	; 0x07
    69d4:	8e 83       	std	Y+6, r24	; 0x06
    69d6:	04 c0       	rjmp	.+8      	; 0x69e0 <xTaskNotifyStateClear+0x36>
    69d8:	8c 81       	ldd	r24, Y+4	; 0x04
    69da:	9d 81       	ldd	r25, Y+5	; 0x05
    69dc:	9f 83       	std	Y+7, r25	; 0x07
    69de:	8e 83       	std	Y+6, r24	; 0x06
    69e0:	8e 81       	ldd	r24, Y+6	; 0x06
    69e2:	9f 81       	ldd	r25, Y+7	; 0x07
    69e4:	9b 83       	std	Y+3, r25	; 0x03
    69e6:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    69e8:	0f b6       	in	r0, 0x3f	; 63
    69ea:	f8 94       	cli
    69ec:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    69ee:	ea 81       	ldd	r30, Y+2	; 0x02
    69f0:	fb 81       	ldd	r31, Y+3	; 0x03
    69f2:	87 a1       	ldd	r24, Z+39	; 0x27
    69f4:	82 30       	cpi	r24, 0x02	; 2
    69f6:	31 f4       	brne	.+12     	; 0x6a04 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    69f8:	ea 81       	ldd	r30, Y+2	; 0x02
    69fa:	fb 81       	ldd	r31, Y+3	; 0x03
    69fc:	17 a2       	std	Z+39, r1	; 0x27
				xReturn = pdPASS;
    69fe:	81 e0       	ldi	r24, 0x01	; 1
    6a00:	89 83       	std	Y+1, r24	; 0x01
    6a02:	01 c0       	rjmp	.+2      	; 0x6a06 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    6a04:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    6a06:	0f 90       	pop	r0
    6a08:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    6a0a:	89 81       	ldd	r24, Y+1	; 0x01
	}
    6a0c:	27 96       	adiw	r28, 0x07	; 7
    6a0e:	0f b6       	in	r0, 0x3f	; 63
    6a10:	f8 94       	cli
    6a12:	de bf       	out	0x3e, r29	; 62
    6a14:	0f be       	out	0x3f, r0	; 63
    6a16:	cd bf       	out	0x3d, r28	; 61
    6a18:	cf 91       	pop	r28
    6a1a:	df 91       	pop	r29
    6a1c:	08 95       	ret

00006a1e <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    6a1e:	df 93       	push	r29
    6a20:	cf 93       	push	r28
    6a22:	cd b7       	in	r28, 0x3d	; 61
    6a24:	de b7       	in	r29, 0x3e	; 62
    6a26:	27 97       	sbiw	r28, 0x07	; 7
    6a28:	0f b6       	in	r0, 0x3f	; 63
    6a2a:	f8 94       	cli
    6a2c:	de bf       	out	0x3e, r29	; 62
    6a2e:	0f be       	out	0x3f, r0	; 63
    6a30:	cd bf       	out	0x3d, r28	; 61
    6a32:	9e 83       	std	Y+6, r25	; 0x06
    6a34:	8d 83       	std	Y+5, r24	; 0x05
    6a36:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    6a38:	80 91 93 05 	lds	r24, 0x0593
    6a3c:	90 91 94 05 	lds	r25, 0x0594
    6a40:	9a 83       	std	Y+2, r25	; 0x02
    6a42:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    6a44:	80 91 8f 05 	lds	r24, 0x058F
    6a48:	90 91 90 05 	lds	r25, 0x0590
    6a4c:	02 96       	adiw	r24, 0x02	; 2
    6a4e:	0e 94 27 23 	call	0x464e	; 0x464e <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    6a52:	8d 81       	ldd	r24, Y+5	; 0x05
    6a54:	9e 81       	ldd	r25, Y+6	; 0x06
    6a56:	2f ef       	ldi	r18, 0xFF	; 255
    6a58:	8f 3f       	cpi	r24, 0xFF	; 255
    6a5a:	92 07       	cpc	r25, r18
    6a5c:	81 f4       	brne	.+32     	; 0x6a7e <prvAddCurrentTaskToDelayedList+0x60>
    6a5e:	8f 81       	ldd	r24, Y+7	; 0x07
    6a60:	88 23       	and	r24, r24
    6a62:	69 f0       	breq	.+26     	; 0x6a7e <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    6a64:	80 91 8f 05 	lds	r24, 0x058F
    6a68:	90 91 90 05 	lds	r25, 0x0590
    6a6c:	9c 01       	movw	r18, r24
    6a6e:	2e 5f       	subi	r18, 0xFE	; 254
    6a70:	3f 4f       	sbci	r19, 0xFF	; 255
    6a72:	89 e1       	ldi	r24, 0x19	; 25
    6a74:	96 e0       	ldi	r25, 0x06	; 6
    6a76:	b9 01       	movw	r22, r18
    6a78:	0e 94 77 22 	call	0x44ee	; 0x44ee <vListInsertEnd>
    6a7c:	43 c0       	rjmp	.+134    	; 0x6b04 <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    6a7e:	29 81       	ldd	r18, Y+1	; 0x01
    6a80:	3a 81       	ldd	r19, Y+2	; 0x02
    6a82:	8d 81       	ldd	r24, Y+5	; 0x05
    6a84:	9e 81       	ldd	r25, Y+6	; 0x06
    6a86:	82 0f       	add	r24, r18
    6a88:	93 1f       	adc	r25, r19
    6a8a:	9c 83       	std	Y+4, r25	; 0x04
    6a8c:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    6a8e:	e0 91 8f 05 	lds	r30, 0x058F
    6a92:	f0 91 90 05 	lds	r31, 0x0590
    6a96:	8b 81       	ldd	r24, Y+3	; 0x03
    6a98:	9c 81       	ldd	r25, Y+4	; 0x04
    6a9a:	93 83       	std	Z+3, r25	; 0x03
    6a9c:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    6a9e:	2b 81       	ldd	r18, Y+3	; 0x03
    6aa0:	3c 81       	ldd	r19, Y+4	; 0x04
    6aa2:	89 81       	ldd	r24, Y+1	; 0x01
    6aa4:	9a 81       	ldd	r25, Y+2	; 0x02
    6aa6:	28 17       	cp	r18, r24
    6aa8:	39 07       	cpc	r19, r25
    6aaa:	70 f4       	brcc	.+28     	; 0x6ac8 <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    6aac:	80 91 05 06 	lds	r24, 0x0605
    6ab0:	90 91 06 06 	lds	r25, 0x0606
    6ab4:	20 91 8f 05 	lds	r18, 0x058F
    6ab8:	30 91 90 05 	lds	r19, 0x0590
    6abc:	2e 5f       	subi	r18, 0xFE	; 254
    6abe:	3f 4f       	sbci	r19, 0xFF	; 255
    6ac0:	b9 01       	movw	r22, r18
    6ac2:	0e 94 bb 22 	call	0x4576	; 0x4576 <vListInsert>
    6ac6:	1e c0       	rjmp	.+60     	; 0x6b04 <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    6ac8:	40 91 03 06 	lds	r20, 0x0603
    6acc:	50 91 04 06 	lds	r21, 0x0604
    6ad0:	80 91 8f 05 	lds	r24, 0x058F
    6ad4:	90 91 90 05 	lds	r25, 0x0590
    6ad8:	9c 01       	movw	r18, r24
    6ada:	2e 5f       	subi	r18, 0xFE	; 254
    6adc:	3f 4f       	sbci	r19, 0xFF	; 255
    6ade:	ca 01       	movw	r24, r20
    6ae0:	b9 01       	movw	r22, r18
    6ae2:	0e 94 bb 22 	call	0x4576	; 0x4576 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    6ae6:	20 91 9b 05 	lds	r18, 0x059B
    6aea:	30 91 9c 05 	lds	r19, 0x059C
    6aee:	8b 81       	ldd	r24, Y+3	; 0x03
    6af0:	9c 81       	ldd	r25, Y+4	; 0x04
    6af2:	82 17       	cp	r24, r18
    6af4:	93 07       	cpc	r25, r19
    6af6:	30 f4       	brcc	.+12     	; 0x6b04 <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    6af8:	8b 81       	ldd	r24, Y+3	; 0x03
    6afa:	9c 81       	ldd	r25, Y+4	; 0x04
    6afc:	90 93 9c 05 	sts	0x059C, r25
    6b00:	80 93 9b 05 	sts	0x059B, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    6b04:	27 96       	adiw	r28, 0x07	; 7
    6b06:	0f b6       	in	r0, 0x3f	; 63
    6b08:	f8 94       	cli
    6b0a:	de bf       	out	0x3e, r29	; 62
    6b0c:	0f be       	out	0x3f, r0	; 63
    6b0e:	cd bf       	out	0x3d, r28	; 61
    6b10:	cf 91       	pop	r28
    6b12:	df 91       	pop	r29
    6b14:	08 95       	ret

00006b16 <APP_Control_Car_Init>:
float computePID(float e);
void APP_Control_Car_Init(void);
void APP_Control_Car_App(void);

// Initialize the car control system
void APP_Control_Car_Init(void) {
    6b16:	df 93       	push	r29
    6b18:	cf 93       	push	r28
    6b1a:	cd b7       	in	r28, 0x3d	; 61
    6b1c:	de b7       	in	r29, 0x3e	; 62
    // Initialize peripherals
    HAL_Buzzer_u8BuzzerInit(PortA, Pin3); // Buzzer
    6b1e:	80 e0       	ldi	r24, 0x00	; 0
    6b20:	63 e0       	ldi	r22, 0x03	; 3
    6b22:	0e 94 4c 20 	call	0x4098	; 0x4098 <HAL_Buzzer_u8BuzzerInit>
    HAL_SM_voidSMInit();                 // Servo Motor
    6b26:	0e 94 ea 1c 	call	0x39d4	; 0x39d4 <HAL_SM_voidSMInit>
    HAL_Ultrasonic_Sensor_voidInit();    // Ultrasonic Sensor
    6b2a:	0e 94 cb 1a 	call	0x3596	; 0x3596 <HAL_Ultrasonic_Sensor_voidInit>
    HAL_void_H_BridgeInit();             // H-Bridge
    6b2e:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <HAL_void_H_BridgeInit>
    HAL_LED_u8LedInit(PortA, Pin0);      // LED1
    6b32:	80 e0       	ldi	r24, 0x00	; 0
    6b34:	60 e0       	ldi	r22, 0x00	; 0
    6b36:	0e 94 f1 1e 	call	0x3de2	; 0x3de2 <HAL_LED_u8LedInit>
    HAL_LED_u8LedInit(PortA, Pin1);      // LED2
    6b3a:	80 e0       	ldi	r24, 0x00	; 0
    6b3c:	61 e0       	ldi	r22, 0x01	; 1
    6b3e:	0e 94 f1 1e 	call	0x3de2	; 0x3de2 <HAL_LED_u8LedInit>
    MCAL_UART_UARTInit();
    6b42:	0e 94 a5 07 	call	0xf4a	; 0xf4a <MCAL_UART_UARTInit>
    UART_voidInit();// UART
    6b46:	0e 94 3f 08 	call	0x107e	; 0x107e <UART_voidInit>
}
    6b4a:	cf 91       	pop	r28
    6b4c:	df 91       	pop	r29
    6b4e:	08 95       	ret

00006b50 <computePID>:

// Compute PID controller output
float computePID(float e) {
    6b50:	ef 92       	push	r14
    6b52:	ff 92       	push	r15
    6b54:	0f 93       	push	r16
    6b56:	1f 93       	push	r17
    6b58:	df 93       	push	r29
    6b5a:	cf 93       	push	r28
    6b5c:	cd b7       	in	r28, 0x3d	; 61
    6b5e:	de b7       	in	r29, 0x3e	; 62
    6b60:	28 97       	sbiw	r28, 0x08	; 8
    6b62:	0f b6       	in	r0, 0x3f	; 63
    6b64:	f8 94       	cli
    6b66:	de bf       	out	0x3e, r29	; 62
    6b68:	0f be       	out	0x3f, r0	; 63
    6b6a:	cd bf       	out	0x3d, r28	; 61
    6b6c:	6d 83       	std	Y+5, r22	; 0x05
    6b6e:	7e 83       	std	Y+6, r23	; 0x06
    6b70:	8f 83       	std	Y+7, r24	; 0x07
    6b72:	98 87       	std	Y+8, r25	; 0x08
    integral += e; // Accumulate the error for the integral term
    6b74:	80 91 36 06 	lds	r24, 0x0636
    6b78:	90 91 37 06 	lds	r25, 0x0637
    6b7c:	a0 91 38 06 	lds	r26, 0x0638
    6b80:	b0 91 39 06 	lds	r27, 0x0639
    6b84:	bc 01       	movw	r22, r24
    6b86:	cd 01       	movw	r24, r26
    6b88:	2d 81       	ldd	r18, Y+5	; 0x05
    6b8a:	3e 81       	ldd	r19, Y+6	; 0x06
    6b8c:	4f 81       	ldd	r20, Y+7	; 0x07
    6b8e:	58 85       	ldd	r21, Y+8	; 0x08
    6b90:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <__addsf3>
    6b94:	dc 01       	movw	r26, r24
    6b96:	cb 01       	movw	r24, r22
    6b98:	80 93 36 06 	sts	0x0636, r24
    6b9c:	90 93 37 06 	sts	0x0637, r25
    6ba0:	a0 93 38 06 	sts	0x0638, r26
    6ba4:	b0 93 39 06 	sts	0x0639, r27
    float derivative = e - last_error; // Calculate the derivative of the error
    6ba8:	20 91 32 06 	lds	r18, 0x0632
    6bac:	30 91 33 06 	lds	r19, 0x0633
    6bb0:	40 91 34 06 	lds	r20, 0x0634
    6bb4:	50 91 35 06 	lds	r21, 0x0635
    6bb8:	6d 81       	ldd	r22, Y+5	; 0x05
    6bba:	7e 81       	ldd	r23, Y+6	; 0x06
    6bbc:	8f 81       	ldd	r24, Y+7	; 0x07
    6bbe:	98 85       	ldd	r25, Y+8	; 0x08
    6bc0:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
    6bc4:	dc 01       	movw	r26, r24
    6bc6:	cb 01       	movw	r24, r22
    6bc8:	89 83       	std	Y+1, r24	; 0x01
    6bca:	9a 83       	std	Y+2, r25	; 0x02
    6bcc:	ab 83       	std	Y+3, r26	; 0x03
    6bce:	bc 83       	std	Y+4, r27	; 0x04
    last_error = e;
    6bd0:	8d 81       	ldd	r24, Y+5	; 0x05
    6bd2:	9e 81       	ldd	r25, Y+6	; 0x06
    6bd4:	af 81       	ldd	r26, Y+7	; 0x07
    6bd6:	b8 85       	ldd	r27, Y+8	; 0x08
    6bd8:	80 93 32 06 	sts	0x0632, r24
    6bdc:	90 93 33 06 	sts	0x0633, r25
    6be0:	a0 93 34 06 	sts	0x0634, r26
    6be4:	b0 93 35 06 	sts	0x0635, r27

    // Compute PID output
    return (Kp * e + Ki * integral + Kd * derivative);
    6be8:	80 91 75 01 	lds	r24, 0x0175
    6bec:	90 91 76 01 	lds	r25, 0x0176
    6bf0:	a0 91 77 01 	lds	r26, 0x0177
    6bf4:	b0 91 78 01 	lds	r27, 0x0178
    6bf8:	bc 01       	movw	r22, r24
    6bfa:	cd 01       	movw	r24, r26
    6bfc:	2d 81       	ldd	r18, Y+5	; 0x05
    6bfe:	3e 81       	ldd	r19, Y+6	; 0x06
    6c00:	4f 81       	ldd	r20, Y+7	; 0x07
    6c02:	58 85       	ldd	r21, Y+8	; 0x08
    6c04:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6c08:	dc 01       	movw	r26, r24
    6c0a:	cb 01       	movw	r24, r22
    6c0c:	7c 01       	movw	r14, r24
    6c0e:	8d 01       	movw	r16, r26
    6c10:	80 91 79 01 	lds	r24, 0x0179
    6c14:	90 91 7a 01 	lds	r25, 0x017A
    6c18:	a0 91 7b 01 	lds	r26, 0x017B
    6c1c:	b0 91 7c 01 	lds	r27, 0x017C
    6c20:	20 91 36 06 	lds	r18, 0x0636
    6c24:	30 91 37 06 	lds	r19, 0x0637
    6c28:	40 91 38 06 	lds	r20, 0x0638
    6c2c:	50 91 39 06 	lds	r21, 0x0639
    6c30:	bc 01       	movw	r22, r24
    6c32:	cd 01       	movw	r24, r26
    6c34:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6c38:	dc 01       	movw	r26, r24
    6c3a:	cb 01       	movw	r24, r22
    6c3c:	9c 01       	movw	r18, r24
    6c3e:	ad 01       	movw	r20, r26
    6c40:	c8 01       	movw	r24, r16
    6c42:	b7 01       	movw	r22, r14
    6c44:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <__addsf3>
    6c48:	dc 01       	movw	r26, r24
    6c4a:	cb 01       	movw	r24, r22
    6c4c:	7c 01       	movw	r14, r24
    6c4e:	8d 01       	movw	r16, r26
    6c50:	80 91 7d 01 	lds	r24, 0x017D
    6c54:	90 91 7e 01 	lds	r25, 0x017E
    6c58:	a0 91 7f 01 	lds	r26, 0x017F
    6c5c:	b0 91 80 01 	lds	r27, 0x0180
    6c60:	bc 01       	movw	r22, r24
    6c62:	cd 01       	movw	r24, r26
    6c64:	29 81       	ldd	r18, Y+1	; 0x01
    6c66:	3a 81       	ldd	r19, Y+2	; 0x02
    6c68:	4b 81       	ldd	r20, Y+3	; 0x03
    6c6a:	5c 81       	ldd	r21, Y+4	; 0x04
    6c6c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6c70:	dc 01       	movw	r26, r24
    6c72:	cb 01       	movw	r24, r22
    6c74:	9c 01       	movw	r18, r24
    6c76:	ad 01       	movw	r20, r26
    6c78:	c8 01       	movw	r24, r16
    6c7a:	b7 01       	movw	r22, r14
    6c7c:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <__addsf3>
    6c80:	dc 01       	movw	r26, r24
    6c82:	cb 01       	movw	r24, r22
}
    6c84:	bc 01       	movw	r22, r24
    6c86:	cd 01       	movw	r24, r26
    6c88:	28 96       	adiw	r28, 0x08	; 8
    6c8a:	0f b6       	in	r0, 0x3f	; 63
    6c8c:	f8 94       	cli
    6c8e:	de bf       	out	0x3e, r29	; 62
    6c90:	0f be       	out	0x3f, r0	; 63
    6c92:	cd bf       	out	0x3d, r28	; 61
    6c94:	cf 91       	pop	r28
    6c96:	df 91       	pop	r29
    6c98:	1f 91       	pop	r17
    6c9a:	0f 91       	pop	r16
    6c9c:	ff 90       	pop	r15
    6c9e:	ef 90       	pop	r14
    6ca0:	08 95       	ret

00006ca2 <MapVel>:
// u32 Mapping (u32 Range1_max,u32 Range1_min,u32 Range2_max,u32 Range2_min,u32 Range1_reading){

// 	return (Range2_max-((Range2_max-Range2_min)*(Range1_max-Range1_reading)/(Range1_max-Range1_min)));
// }

float MapVel(int max1,int min1, int max2,int min2,float val){
    6ca2:	af 92       	push	r10
    6ca4:	bf 92       	push	r11
    6ca6:	cf 92       	push	r12
    6ca8:	df 92       	push	r13
    6caa:	ef 92       	push	r14
    6cac:	ff 92       	push	r15
    6cae:	0f 93       	push	r16
    6cb0:	1f 93       	push	r17
    6cb2:	df 93       	push	r29
    6cb4:	cf 93       	push	r28
    6cb6:	cd b7       	in	r28, 0x3d	; 61
    6cb8:	de b7       	in	r29, 0x3e	; 62
    6cba:	2c 97       	sbiw	r28, 0x0c	; 12
    6cbc:	0f b6       	in	r0, 0x3f	; 63
    6cbe:	f8 94       	cli
    6cc0:	de bf       	out	0x3e, r29	; 62
    6cc2:	0f be       	out	0x3f, r0	; 63
    6cc4:	cd bf       	out	0x3d, r28	; 61
    6cc6:	9a 83       	std	Y+2, r25	; 0x02
    6cc8:	89 83       	std	Y+1, r24	; 0x01
    6cca:	7c 83       	std	Y+4, r23	; 0x04
    6ccc:	6b 83       	std	Y+3, r22	; 0x03
    6cce:	5e 83       	std	Y+6, r21	; 0x06
    6cd0:	4d 83       	std	Y+5, r20	; 0x05
    6cd2:	38 87       	std	Y+8, r19	; 0x08
    6cd4:	2f 83       	std	Y+7, r18	; 0x07
    6cd6:	e9 86       	std	Y+9, r14	; 0x09
    6cd8:	fa 86       	std	Y+10, r15	; 0x0a
    6cda:	0b 87       	std	Y+11, r16	; 0x0b
    6cdc:	1c 87       	std	Y+12, r17	; 0x0c
    return (max2 - ((max2 - min2) * (max1 - val) /(max1 -min1)));
    6cde:	8d 81       	ldd	r24, Y+5	; 0x05
    6ce0:	9e 81       	ldd	r25, Y+6	; 0x06
    6ce2:	aa 27       	eor	r26, r26
    6ce4:	97 fd       	sbrc	r25, 7
    6ce6:	a0 95       	com	r26
    6ce8:	ba 2f       	mov	r27, r26
    6cea:	bc 01       	movw	r22, r24
    6cec:	cd 01       	movw	r24, r26
    6cee:	0e 94 85 04 	call	0x90a	; 0x90a <__floatsisf>
    6cf2:	5b 01       	movw	r10, r22
    6cf4:	6c 01       	movw	r12, r24
    6cf6:	2d 81       	ldd	r18, Y+5	; 0x05
    6cf8:	3e 81       	ldd	r19, Y+6	; 0x06
    6cfa:	8f 81       	ldd	r24, Y+7	; 0x07
    6cfc:	98 85       	ldd	r25, Y+8	; 0x08
    6cfe:	a9 01       	movw	r20, r18
    6d00:	48 1b       	sub	r20, r24
    6d02:	59 0b       	sbc	r21, r25
    6d04:	ca 01       	movw	r24, r20
    6d06:	aa 27       	eor	r26, r26
    6d08:	97 fd       	sbrc	r25, 7
    6d0a:	a0 95       	com	r26
    6d0c:	ba 2f       	mov	r27, r26
    6d0e:	bc 01       	movw	r22, r24
    6d10:	cd 01       	movw	r24, r26
    6d12:	0e 94 85 04 	call	0x90a	; 0x90a <__floatsisf>
    6d16:	7b 01       	movw	r14, r22
    6d18:	8c 01       	movw	r16, r24
    6d1a:	89 81       	ldd	r24, Y+1	; 0x01
    6d1c:	9a 81       	ldd	r25, Y+2	; 0x02
    6d1e:	aa 27       	eor	r26, r26
    6d20:	97 fd       	sbrc	r25, 7
    6d22:	a0 95       	com	r26
    6d24:	ba 2f       	mov	r27, r26
    6d26:	bc 01       	movw	r22, r24
    6d28:	cd 01       	movw	r24, r26
    6d2a:	0e 94 85 04 	call	0x90a	; 0x90a <__floatsisf>
    6d2e:	dc 01       	movw	r26, r24
    6d30:	cb 01       	movw	r24, r22
    6d32:	bc 01       	movw	r22, r24
    6d34:	cd 01       	movw	r24, r26
    6d36:	29 85       	ldd	r18, Y+9	; 0x09
    6d38:	3a 85       	ldd	r19, Y+10	; 0x0a
    6d3a:	4b 85       	ldd	r20, Y+11	; 0x0b
    6d3c:	5c 85       	ldd	r21, Y+12	; 0x0c
    6d3e:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
    6d42:	dc 01       	movw	r26, r24
    6d44:	cb 01       	movw	r24, r22
    6d46:	9c 01       	movw	r18, r24
    6d48:	ad 01       	movw	r20, r26
    6d4a:	c8 01       	movw	r24, r16
    6d4c:	b7 01       	movw	r22, r14
    6d4e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6d52:	dc 01       	movw	r26, r24
    6d54:	cb 01       	movw	r24, r22
    6d56:	7c 01       	movw	r14, r24
    6d58:	8d 01       	movw	r16, r26
    6d5a:	29 81       	ldd	r18, Y+1	; 0x01
    6d5c:	3a 81       	ldd	r19, Y+2	; 0x02
    6d5e:	8b 81       	ldd	r24, Y+3	; 0x03
    6d60:	9c 81       	ldd	r25, Y+4	; 0x04
    6d62:	a9 01       	movw	r20, r18
    6d64:	48 1b       	sub	r20, r24
    6d66:	59 0b       	sbc	r21, r25
    6d68:	ca 01       	movw	r24, r20
    6d6a:	aa 27       	eor	r26, r26
    6d6c:	97 fd       	sbrc	r25, 7
    6d6e:	a0 95       	com	r26
    6d70:	ba 2f       	mov	r27, r26
    6d72:	bc 01       	movw	r22, r24
    6d74:	cd 01       	movw	r24, r26
    6d76:	0e 94 85 04 	call	0x90a	; 0x90a <__floatsisf>
    6d7a:	9b 01       	movw	r18, r22
    6d7c:	ac 01       	movw	r20, r24
    6d7e:	c8 01       	movw	r24, r16
    6d80:	b7 01       	movw	r22, r14
    6d82:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    6d86:	dc 01       	movw	r26, r24
    6d88:	cb 01       	movw	r24, r22
    6d8a:	9c 01       	movw	r18, r24
    6d8c:	ad 01       	movw	r20, r26
    6d8e:	c6 01       	movw	r24, r12
    6d90:	b5 01       	movw	r22, r10
    6d92:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
    6d96:	dc 01       	movw	r26, r24
    6d98:	cb 01       	movw	r24, r22
}
    6d9a:	bc 01       	movw	r22, r24
    6d9c:	cd 01       	movw	r24, r26
    6d9e:	2c 96       	adiw	r28, 0x0c	; 12
    6da0:	0f b6       	in	r0, 0x3f	; 63
    6da2:	f8 94       	cli
    6da4:	de bf       	out	0x3e, r29	; 62
    6da6:	0f be       	out	0x3f, r0	; 63
    6da8:	cd bf       	out	0x3d, r28	; 61
    6daa:	cf 91       	pop	r28
    6dac:	df 91       	pop	r29
    6dae:	1f 91       	pop	r17
    6db0:	0f 91       	pop	r16
    6db2:	ff 90       	pop	r15
    6db4:	ef 90       	pop	r14
    6db6:	df 90       	pop	r13
    6db8:	cf 90       	pop	r12
    6dba:	bf 90       	pop	r11
    6dbc:	af 90       	pop	r10
    6dbe:	08 95       	ret

00006dc0 <APP_Control_Car_App>:

// Main application logic
void APP_Control_Car_App(void) {
    6dc0:	ef 92       	push	r14
    6dc2:	ff 92       	push	r15
    6dc4:	0f 93       	push	r16
    6dc6:	1f 93       	push	r17
    6dc8:	df 93       	push	r29
    6dca:	cf 93       	push	r28
    6dcc:	cd b7       	in	r28, 0x3d	; 61
    6dce:	de b7       	in	r29, 0x3e	; 62
    6dd0:	66 97       	sbiw	r28, 0x16	; 22
    6dd2:	0f b6       	in	r0, 0x3f	; 63
    6dd4:	f8 94       	cli
    6dd6:	de bf       	out	0x3e, r29	; 62
    6dd8:	0f be       	out	0x3f, r0	; 63
    6dda:	cd bf       	out	0x3d, r28	; 61
    // Initialize UART
 //   MCAL_UART_UARTInit();
	APP_Control_Car_Init();
    6ddc:	0e 94 8b 35 	call	0x6b16	; 0x6b16 <APP_Control_Car_Init>

    while (1) {
        // Calculate distance using ultrasonic sensor


        HAL_Ultrasonic_Sensor_voidCalcDistancse(&distance);
    6de0:	8a e2       	ldi	r24, 0x2A	; 42
    6de2:	96 e0       	ldi	r25, 0x06	; 6
    6de4:	0e 94 ca 1b 	call	0x3794	; 0x3794 <HAL_Ultrasonic_Sensor_voidCalcDistancse>
        // Send distance to UART for debugging
        // Calculate error and compute PID output
        error =  distance - set_point_distance;
    6de8:	80 91 2a 06 	lds	r24, 0x062A
    6dec:	90 91 2b 06 	lds	r25, 0x062B
    6df0:	a0 91 2c 06 	lds	r26, 0x062C
    6df4:	b0 91 2d 06 	lds	r27, 0x062D
    6df8:	20 91 71 01 	lds	r18, 0x0171
    6dfc:	30 91 72 01 	lds	r19, 0x0172
    6e00:	40 91 73 01 	lds	r20, 0x0173
    6e04:	50 91 74 01 	lds	r21, 0x0174
    6e08:	bc 01       	movw	r22, r24
    6e0a:	cd 01       	movw	r24, r26
    6e0c:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
    6e10:	dc 01       	movw	r26, r24
    6e12:	cb 01       	movw	r24, r22
    6e14:	80 93 2e 06 	sts	0x062E, r24
    6e18:	90 93 2f 06 	sts	0x062F, r25
    6e1c:	a0 93 30 06 	sts	0x0630, r26
    6e20:	b0 93 31 06 	sts	0x0631, r27
        float u = computePID(error);
    6e24:	80 91 2e 06 	lds	r24, 0x062E
    6e28:	90 91 2f 06 	lds	r25, 0x062F
    6e2c:	a0 91 30 06 	lds	r26, 0x0630
    6e30:	b0 91 31 06 	lds	r27, 0x0631
    6e34:	bc 01       	movw	r22, r24
    6e36:	cd 01       	movw	r24, r26
    6e38:	0e 94 a8 35 	call	0x6b50	; 0x6b50 <computePID>
    6e3c:	dc 01       	movw	r26, r24
    6e3e:	cb 01       	movw	r24, r22
    6e40:	8b 8b       	std	Y+19, r24	; 0x13
    6e42:	9c 8b       	std	Y+20, r25	; 0x14
    6e44:	ad 8b       	std	Y+21, r26	; 0x15
    6e46:	be 8b       	std	Y+22, r27	; 0x16
        float speed = MapVel(200,0,90,14, last_speed - u);
    6e48:	80 91 26 06 	lds	r24, 0x0626
    6e4c:	90 91 27 06 	lds	r25, 0x0627
    6e50:	a0 91 28 06 	lds	r26, 0x0628
    6e54:	b0 91 29 06 	lds	r27, 0x0629
    6e58:	bc 01       	movw	r22, r24
    6e5a:	cd 01       	movw	r24, r26
    6e5c:	2b 89       	ldd	r18, Y+19	; 0x13
    6e5e:	3c 89       	ldd	r19, Y+20	; 0x14
    6e60:	4d 89       	ldd	r20, Y+21	; 0x15
    6e62:	5e 89       	ldd	r21, Y+22	; 0x16
    6e64:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
    6e68:	dc 01       	movw	r26, r24
    6e6a:	cb 01       	movw	r24, r22
    6e6c:	7c 01       	movw	r14, r24
    6e6e:	8d 01       	movw	r16, r26
    6e70:	88 ec       	ldi	r24, 0xC8	; 200
    6e72:	90 e0       	ldi	r25, 0x00	; 0
    6e74:	60 e0       	ldi	r22, 0x00	; 0
    6e76:	70 e0       	ldi	r23, 0x00	; 0
    6e78:	4a e5       	ldi	r20, 0x5A	; 90
    6e7a:	50 e0       	ldi	r21, 0x00	; 0
    6e7c:	2e e0       	ldi	r18, 0x0E	; 14
    6e7e:	30 e0       	ldi	r19, 0x00	; 0
    6e80:	0e 94 51 36 	call	0x6ca2	; 0x6ca2 <MapVel>
    6e84:	dc 01       	movw	r26, r24
    6e86:	cb 01       	movw	r24, r22
    6e88:	8f 87       	std	Y+15, r24	; 0x0f
    6e8a:	98 8b       	std	Y+16, r25	; 0x10
    6e8c:	a9 8b       	std	Y+17, r26	; 0x11
    6e8e:	ba 8b       	std	Y+18, r27	; 0x12
        last_speed = speed;
    6e90:	8f 85       	ldd	r24, Y+15	; 0x0f
    6e92:	98 89       	ldd	r25, Y+16	; 0x10
    6e94:	a9 89       	ldd	r26, Y+17	; 0x11
    6e96:	ba 89       	ldd	r27, Y+18	; 0x12
    6e98:	80 93 26 06 	sts	0x0626, r24
    6e9c:	90 93 27 06 	sts	0x0627, r25
    6ea0:	a0 93 28 06 	sts	0x0628, r26
    6ea4:	b0 93 29 06 	sts	0x0629, r27
        if(error<0)
    6ea8:	80 91 2e 06 	lds	r24, 0x062E
    6eac:	90 91 2f 06 	lds	r25, 0x062F
    6eb0:	a0 91 30 06 	lds	r26, 0x0630
    6eb4:	b0 91 31 06 	lds	r27, 0x0631
    6eb8:	bc 01       	movw	r22, r24
    6eba:	cd 01       	movw	r24, r26
    6ebc:	20 e0       	ldi	r18, 0x00	; 0
    6ebe:	30 e0       	ldi	r19, 0x00	; 0
    6ec0:	40 e0       	ldi	r20, 0x00	; 0
    6ec2:	50 e0       	ldi	r21, 0x00	; 0
    6ec4:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    6ec8:	88 23       	and	r24, r24
    6eca:	5c f4       	brge	.+22     	; 0x6ee2 <APP_Control_Car_App+0x122>
        {
        	HAL_void_H_BridgeBack((int)speed);
    6ecc:	6f 85       	ldd	r22, Y+15	; 0x0f
    6ece:	78 89       	ldd	r23, Y+16	; 0x10
    6ed0:	89 89       	ldd	r24, Y+17	; 0x11
    6ed2:	9a 89       	ldd	r25, Y+18	; 0x12
    6ed4:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <__fixsfsi>
    6ed8:	dc 01       	movw	r26, r24
    6eda:	cb 01       	movw	r24, r22
    6edc:	0e 94 da 1f 	call	0x3fb4	; 0x3fb4 <HAL_void_H_BridgeBack>
    6ee0:	0a c0       	rjmp	.+20     	; 0x6ef6 <APP_Control_Car_App+0x136>
        }
        else
        {

        // Control the car using H-Bridge
        HAL_void_H_BridgeFront((int)speed);
    6ee2:	6f 85       	ldd	r22, Y+15	; 0x0f
    6ee4:	78 89       	ldd	r23, Y+16	; 0x10
    6ee6:	89 89       	ldd	r24, Y+17	; 0x11
    6ee8:	9a 89       	ldd	r25, Y+18	; 0x12
    6eea:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <__fixsfsi>
    6eee:	dc 01       	movw	r26, r24
    6ef0:	cb 01       	movw	r24, r22
    6ef2:	0e 94 b4 1f 	call	0x3f68	; 0x3f68 <HAL_void_H_BridgeFront>

        }
        UART_voidSendNumber((u32)distance);
    6ef6:	80 91 2a 06 	lds	r24, 0x062A
    6efa:	90 91 2b 06 	lds	r25, 0x062B
    6efe:	a0 91 2c 06 	lds	r26, 0x062C
    6f02:	b0 91 2d 06 	lds	r27, 0x062D
    6f06:	bc 01       	movw	r22, r24
    6f08:	cd 01       	movw	r24, r26
    6f0a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6f0e:	dc 01       	movw	r26, r24
    6f10:	cb 01       	movw	r24, r22
    6f12:	bc 01       	movw	r22, r24
    6f14:	cd 01       	movw	r24, r26
    6f16:	0e 94 9b 08 	call	0x1136	; 0x1136 <UART_voidSendNumber>
    6f1a:	80 e0       	ldi	r24, 0x00	; 0
    6f1c:	90 e0       	ldi	r25, 0x00	; 0
    6f1e:	a8 e4       	ldi	r26, 0x48	; 72
    6f20:	b2 e4       	ldi	r27, 0x42	; 66
    6f22:	8b 87       	std	Y+11, r24	; 0x0b
    6f24:	9c 87       	std	Y+12, r25	; 0x0c
    6f26:	ad 87       	std	Y+13, r26	; 0x0d
    6f28:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    6f2a:	6b 85       	ldd	r22, Y+11	; 0x0b
    6f2c:	7c 85       	ldd	r23, Y+12	; 0x0c
    6f2e:	8d 85       	ldd	r24, Y+13	; 0x0d
    6f30:	9e 85       	ldd	r25, Y+14	; 0x0e
    6f32:	20 e0       	ldi	r18, 0x00	; 0
    6f34:	30 e0       	ldi	r19, 0x00	; 0
    6f36:	4a e7       	ldi	r20, 0x7A	; 122
    6f38:	55 e4       	ldi	r21, 0x45	; 69
    6f3a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6f3e:	dc 01       	movw	r26, r24
    6f40:	cb 01       	movw	r24, r22
    6f42:	8f 83       	std	Y+7, r24	; 0x07
    6f44:	98 87       	std	Y+8, r25	; 0x08
    6f46:	a9 87       	std	Y+9, r26	; 0x09
    6f48:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    6f4a:	6f 81       	ldd	r22, Y+7	; 0x07
    6f4c:	78 85       	ldd	r23, Y+8	; 0x08
    6f4e:	89 85       	ldd	r24, Y+9	; 0x09
    6f50:	9a 85       	ldd	r25, Y+10	; 0x0a
    6f52:	20 e0       	ldi	r18, 0x00	; 0
    6f54:	30 e0       	ldi	r19, 0x00	; 0
    6f56:	40 e8       	ldi	r20, 0x80	; 128
    6f58:	5f e3       	ldi	r21, 0x3F	; 63
    6f5a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    6f5e:	88 23       	and	r24, r24
    6f60:	2c f4       	brge	.+10     	; 0x6f6c <APP_Control_Car_App+0x1ac>
		__ticks = 1;
    6f62:	81 e0       	ldi	r24, 0x01	; 1
    6f64:	90 e0       	ldi	r25, 0x00	; 0
    6f66:	9e 83       	std	Y+6, r25	; 0x06
    6f68:	8d 83       	std	Y+5, r24	; 0x05
    6f6a:	3f c0       	rjmp	.+126    	; 0x6fea <APP_Control_Car_App+0x22a>
	else if (__tmp > 65535)
    6f6c:	6f 81       	ldd	r22, Y+7	; 0x07
    6f6e:	78 85       	ldd	r23, Y+8	; 0x08
    6f70:	89 85       	ldd	r24, Y+9	; 0x09
    6f72:	9a 85       	ldd	r25, Y+10	; 0x0a
    6f74:	20 e0       	ldi	r18, 0x00	; 0
    6f76:	3f ef       	ldi	r19, 0xFF	; 255
    6f78:	4f e7       	ldi	r20, 0x7F	; 127
    6f7a:	57 e4       	ldi	r21, 0x47	; 71
    6f7c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    6f80:	18 16       	cp	r1, r24
    6f82:	4c f5       	brge	.+82     	; 0x6fd6 <APP_Control_Car_App+0x216>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6f84:	6b 85       	ldd	r22, Y+11	; 0x0b
    6f86:	7c 85       	ldd	r23, Y+12	; 0x0c
    6f88:	8d 85       	ldd	r24, Y+13	; 0x0d
    6f8a:	9e 85       	ldd	r25, Y+14	; 0x0e
    6f8c:	20 e0       	ldi	r18, 0x00	; 0
    6f8e:	30 e0       	ldi	r19, 0x00	; 0
    6f90:	40 e2       	ldi	r20, 0x20	; 32
    6f92:	51 e4       	ldi	r21, 0x41	; 65
    6f94:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6f98:	dc 01       	movw	r26, r24
    6f9a:	cb 01       	movw	r24, r22
    6f9c:	bc 01       	movw	r22, r24
    6f9e:	cd 01       	movw	r24, r26
    6fa0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6fa4:	dc 01       	movw	r26, r24
    6fa6:	cb 01       	movw	r24, r22
    6fa8:	9e 83       	std	Y+6, r25	; 0x06
    6faa:	8d 83       	std	Y+5, r24	; 0x05
    6fac:	0f c0       	rjmp	.+30     	; 0x6fcc <APP_Control_Car_App+0x20c>
    6fae:	80 e9       	ldi	r24, 0x90	; 144
    6fb0:	91 e0       	ldi	r25, 0x01	; 1
    6fb2:	9c 83       	std	Y+4, r25	; 0x04
    6fb4:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    6fb6:	8b 81       	ldd	r24, Y+3	; 0x03
    6fb8:	9c 81       	ldd	r25, Y+4	; 0x04
    6fba:	01 97       	sbiw	r24, 0x01	; 1
    6fbc:	f1 f7       	brne	.-4      	; 0x6fba <APP_Control_Car_App+0x1fa>
    6fbe:	9c 83       	std	Y+4, r25	; 0x04
    6fc0:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6fc2:	8d 81       	ldd	r24, Y+5	; 0x05
    6fc4:	9e 81       	ldd	r25, Y+6	; 0x06
    6fc6:	01 97       	sbiw	r24, 0x01	; 1
    6fc8:	9e 83       	std	Y+6, r25	; 0x06
    6fca:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6fcc:	8d 81       	ldd	r24, Y+5	; 0x05
    6fce:	9e 81       	ldd	r25, Y+6	; 0x06
    6fd0:	00 97       	sbiw	r24, 0x00	; 0
    6fd2:	69 f7       	brne	.-38     	; 0x6fae <APP_Control_Car_App+0x1ee>
    6fd4:	05 cf       	rjmp	.-502    	; 0x6de0 <APP_Control_Car_App+0x20>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6fd6:	6f 81       	ldd	r22, Y+7	; 0x07
    6fd8:	78 85       	ldd	r23, Y+8	; 0x08
    6fda:	89 85       	ldd	r24, Y+9	; 0x09
    6fdc:	9a 85       	ldd	r25, Y+10	; 0x0a
    6fde:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6fe2:	dc 01       	movw	r26, r24
    6fe4:	cb 01       	movw	r24, r22
    6fe6:	9e 83       	std	Y+6, r25	; 0x06
    6fe8:	8d 83       	std	Y+5, r24	; 0x05
    6fea:	8d 81       	ldd	r24, Y+5	; 0x05
    6fec:	9e 81       	ldd	r25, Y+6	; 0x06
    6fee:	9a 83       	std	Y+2, r25	; 0x02
    6ff0:	89 83       	std	Y+1, r24	; 0x01
    6ff2:	89 81       	ldd	r24, Y+1	; 0x01
    6ff4:	9a 81       	ldd	r25, Y+2	; 0x02
    6ff6:	01 97       	sbiw	r24, 0x01	; 1
    6ff8:	f1 f7       	brne	.-4      	; 0x6ff6 <APP_Control_Car_App+0x236>
    6ffa:	9a 83       	std	Y+2, r25	; 0x02
    6ffc:	89 83       	std	Y+1, r24	; 0x01
    6ffe:	f0 ce       	rjmp	.-544    	; 0x6de0 <APP_Control_Car_App+0x20>

00007000 <main>:
 *      Author: Mohamed
 */

#include "Autonomous_Car/Autonomous_Car.h"
#include "Control_Car/Control_Car.h"
int main(void) {
    7000:	df 93       	push	r29
    7002:	cf 93       	push	r28
    7004:	0f 92       	push	r0
    7006:	cd b7       	in	r28, 0x3d	; 61
    7008:	de b7       	in	r29, 0x3e	; 62
	u8 Loc_u8Mode = 'X';
    700a:	88 e5       	ldi	r24, 0x58	; 88
    700c:	89 83       	std	Y+1, r24	; 0x01
	//APP_Autonomous_Car_voidInit();
	APP_Control_Car_Init();
    700e:	0e 94 8b 35 	call	0x6b16	; 0x6b16 <APP_Control_Car_Init>
	while (1) {
		//MCAL_UART_UARTReceive(&Loc_u8Mode);
		//if (Loc_u8Mode == 'x') {
			APP_Control_Car_App();
    7012:	0e 94 e0 36 	call	0x6dc0	; 0x6dc0 <APP_Control_Car_App>
    7016:	fd cf       	rjmp	.-6      	; 0x7012 <main+0x12>

00007018 <__udivmodsi4>:
    7018:	a1 e2       	ldi	r26, 0x21	; 33
    701a:	1a 2e       	mov	r1, r26
    701c:	aa 1b       	sub	r26, r26
    701e:	bb 1b       	sub	r27, r27
    7020:	fd 01       	movw	r30, r26
    7022:	0d c0       	rjmp	.+26     	; 0x703e <__udivmodsi4_ep>

00007024 <__udivmodsi4_loop>:
    7024:	aa 1f       	adc	r26, r26
    7026:	bb 1f       	adc	r27, r27
    7028:	ee 1f       	adc	r30, r30
    702a:	ff 1f       	adc	r31, r31
    702c:	a2 17       	cp	r26, r18
    702e:	b3 07       	cpc	r27, r19
    7030:	e4 07       	cpc	r30, r20
    7032:	f5 07       	cpc	r31, r21
    7034:	20 f0       	brcs	.+8      	; 0x703e <__udivmodsi4_ep>
    7036:	a2 1b       	sub	r26, r18
    7038:	b3 0b       	sbc	r27, r19
    703a:	e4 0b       	sbc	r30, r20
    703c:	f5 0b       	sbc	r31, r21

0000703e <__udivmodsi4_ep>:
    703e:	66 1f       	adc	r22, r22
    7040:	77 1f       	adc	r23, r23
    7042:	88 1f       	adc	r24, r24
    7044:	99 1f       	adc	r25, r25
    7046:	1a 94       	dec	r1
    7048:	69 f7       	brne	.-38     	; 0x7024 <__udivmodsi4_loop>
    704a:	60 95       	com	r22
    704c:	70 95       	com	r23
    704e:	80 95       	com	r24
    7050:	90 95       	com	r25
    7052:	9b 01       	movw	r18, r22
    7054:	ac 01       	movw	r20, r24
    7056:	bd 01       	movw	r22, r26
    7058:	cf 01       	movw	r24, r30
    705a:	08 95       	ret

0000705c <__prologue_saves__>:
    705c:	2f 92       	push	r2
    705e:	3f 92       	push	r3
    7060:	4f 92       	push	r4
    7062:	5f 92       	push	r5
    7064:	6f 92       	push	r6
    7066:	7f 92       	push	r7
    7068:	8f 92       	push	r8
    706a:	9f 92       	push	r9
    706c:	af 92       	push	r10
    706e:	bf 92       	push	r11
    7070:	cf 92       	push	r12
    7072:	df 92       	push	r13
    7074:	ef 92       	push	r14
    7076:	ff 92       	push	r15
    7078:	0f 93       	push	r16
    707a:	1f 93       	push	r17
    707c:	cf 93       	push	r28
    707e:	df 93       	push	r29
    7080:	cd b7       	in	r28, 0x3d	; 61
    7082:	de b7       	in	r29, 0x3e	; 62
    7084:	ca 1b       	sub	r28, r26
    7086:	db 0b       	sbc	r29, r27
    7088:	0f b6       	in	r0, 0x3f	; 63
    708a:	f8 94       	cli
    708c:	de bf       	out	0x3e, r29	; 62
    708e:	0f be       	out	0x3f, r0	; 63
    7090:	cd bf       	out	0x3d, r28	; 61
    7092:	09 94       	ijmp

00007094 <__epilogue_restores__>:
    7094:	2a 88       	ldd	r2, Y+18	; 0x12
    7096:	39 88       	ldd	r3, Y+17	; 0x11
    7098:	48 88       	ldd	r4, Y+16	; 0x10
    709a:	5f 84       	ldd	r5, Y+15	; 0x0f
    709c:	6e 84       	ldd	r6, Y+14	; 0x0e
    709e:	7d 84       	ldd	r7, Y+13	; 0x0d
    70a0:	8c 84       	ldd	r8, Y+12	; 0x0c
    70a2:	9b 84       	ldd	r9, Y+11	; 0x0b
    70a4:	aa 84       	ldd	r10, Y+10	; 0x0a
    70a6:	b9 84       	ldd	r11, Y+9	; 0x09
    70a8:	c8 84       	ldd	r12, Y+8	; 0x08
    70aa:	df 80       	ldd	r13, Y+7	; 0x07
    70ac:	ee 80       	ldd	r14, Y+6	; 0x06
    70ae:	fd 80       	ldd	r15, Y+5	; 0x05
    70b0:	0c 81       	ldd	r16, Y+4	; 0x04
    70b2:	1b 81       	ldd	r17, Y+3	; 0x03
    70b4:	aa 81       	ldd	r26, Y+2	; 0x02
    70b6:	b9 81       	ldd	r27, Y+1	; 0x01
    70b8:	ce 0f       	add	r28, r30
    70ba:	d1 1d       	adc	r29, r1
    70bc:	0f b6       	in	r0, 0x3f	; 63
    70be:	f8 94       	cli
    70c0:	de bf       	out	0x3e, r29	; 62
    70c2:	0f be       	out	0x3f, r0	; 63
    70c4:	cd bf       	out	0x3d, r28	; 61
    70c6:	ed 01       	movw	r28, r26
    70c8:	08 95       	ret

000070ca <_exit>:
    70ca:	f8 94       	cli

000070cc <__stop_program>:
    70cc:	ff cf       	rjmp	.-2      	; 0x70cc <__stop_program>
