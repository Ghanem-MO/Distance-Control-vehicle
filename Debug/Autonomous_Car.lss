
Autonomous_Car.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000994a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000001ce  00800060  0000994a  000099de  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000004b0  0080022e  0080022e  00009bac  2**0
                  ALLOC
  3 .stab         0000c0a8  00000000  00000000  00009bac  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00006ea0  00000000  00000000  00015c54  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001e0  00000000  00000000  0001caf4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000232  00000000  00000000  0001ccd4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002891  00000000  00000000  0001cf06  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001628  00000000  00000000  0001f797  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000013de  00000000  00000000  00020dbf  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000200  00000000  00000000  000221a0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000030f  00000000  00000000  000223a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000a56  00000000  00000000  000226af  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00023105  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 df 14 	jmp	0x29be	; 0x29be <__vector_1>
       8:	0c 94 12 15 	jmp	0x2a24	; 0x2a24 <__vector_2>
       c:	0c 94 45 15 	jmp	0x2a8a	; 0x2a8a <__vector_3>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 ec 0e 	jmp	0x1dd8	; 0x1dd8 <__vector_6>
      1c:	0c 94 6e 2e 	jmp	0x5cdc	; 0x5cdc <__vector_7>
      20:	0c 94 b9 0e 	jmp	0x1d72	; 0x1d72 <__vector_8>
      24:	0c 94 53 0e 	jmp	0x1ca6	; 0x1ca6 <__vector_9>
      28:	0c 94 e2 12 	jmp	0x25c4	; 0x25c4 <__vector_10>
      2c:	0c 94 a6 12 	jmp	0x254c	; 0x254c <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	12 e0       	ldi	r17, 0x02	; 2
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea e4       	ldi	r30, 0x4A	; 74
      68:	f9 e9       	ldi	r31, 0x99	; 153
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ae 32       	cpi	r26, 0x2E	; 46
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	16 e0       	ldi	r17, 0x06	; 6
      78:	ae e2       	ldi	r26, 0x2E	; 46
      7a:	b2 e0       	ldi	r27, 0x02	; 2
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ae 3d       	cpi	r26, 0xDE	; 222
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 f7 4b 	call	0x97ee	; 0x97ee <main>
      8a:	0c 94 a3 4c 	jmp	0x9946	; 0x9946 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 27 4c 	jmp	0x984e	; 0x984e <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	af e1       	ldi	r26, 0x1F	; 31
     128:	b1 e0       	ldi	r27, 0x01	; 1
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 43 4c 	jmp	0x9886	; 0x9886 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 33 4c 	jmp	0x9866	; 0x9866 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 ff 05 	call	0xbfe	; 0xbfe <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 4f 4c 	jmp	0x989e	; 0x989e <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 33 4c 	jmp	0x9866	; 0x9866 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 ff 05 	call	0xbfe	; 0xbfe <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 4f 4c 	jmp	0x989e	; 0x989e <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 27 4c 	jmp	0x984e	; 0x984e <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	8f e1       	ldi	r24, 0x1F	; 31
     496:	91 e0       	ldi	r25, 0x01	; 1
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 ff 05 	call	0xbfe	; 0xbfe <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 43 4c 	jmp	0x9886	; 0x9886 <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 2f 4c 	jmp	0x985e	; 0x985e <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	6f e1       	ldi	r22, 0x1F	; 31
     69c:	71 e0       	ldi	r23, 0x01	; 1
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 ff 05 	call	0xbfe	; 0xbfe <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 4b 4c 	jmp	0x9896	; 0x9896 <__epilogue_restores__+0x10>

0000078a <__gtsf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 33 4c 	jmp	0x9866	; 0x9866 <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__gtsf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__gtsf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 4c 07 	call	0xe98	; 0xe98 <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__gtsf2+0x58>
     7e0:	8f ef       	ldi	r24, 0xFF	; 255
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 4f 4c 	jmp	0x989e	; 0x989e <__epilogue_restores__+0x18>

000007ea <__gesf2>:
     7ea:	a8 e1       	ldi	r26, 0x18	; 24
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 33 4c 	jmp	0x9866	; 0x9866 <__prologue_saves__+0x18>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	2d 83       	std	Y+5, r18	; 0x05
     800:	3e 83       	std	Y+6, r19	; 0x06
     802:	4f 83       	std	Y+7, r20	; 0x07
     804:	58 87       	std	Y+8, r21	; 0x08
     806:	89 e0       	ldi	r24, 0x09	; 9
     808:	e8 2e       	mov	r14, r24
     80a:	f1 2c       	mov	r15, r1
     80c:	ec 0e       	add	r14, r28
     80e:	fd 1e       	adc	r15, r29
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	b7 01       	movw	r22, r14
     816:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     81a:	8e 01       	movw	r16, r28
     81c:	0f 5e       	subi	r16, 0xEF	; 239
     81e:	1f 4f       	sbci	r17, 0xFF	; 255
     820:	ce 01       	movw	r24, r28
     822:	05 96       	adiw	r24, 0x05	; 5
     824:	b8 01       	movw	r22, r16
     826:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     82a:	89 85       	ldd	r24, Y+9	; 0x09
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	40 f0       	brcs	.+16     	; 0x840 <__gesf2+0x56>
     830:	89 89       	ldd	r24, Y+17	; 0x11
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	28 f0       	brcs	.+10     	; 0x840 <__gesf2+0x56>
     836:	c7 01       	movw	r24, r14
     838:	b8 01       	movw	r22, r16
     83a:	0e 94 4c 07 	call	0xe98	; 0xe98 <__fpcmp_parts_f>
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__gesf2+0x58>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	68 96       	adiw	r28, 0x18	; 24
     844:	e6 e0       	ldi	r30, 0x06	; 6
     846:	0c 94 4f 4c 	jmp	0x989e	; 0x989e <__epilogue_restores__+0x18>

0000084a <__ltsf2>:
     84a:	a8 e1       	ldi	r26, 0x18	; 24
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	eb e2       	ldi	r30, 0x2B	; 43
     850:	f4 e0       	ldi	r31, 0x04	; 4
     852:	0c 94 33 4c 	jmp	0x9866	; 0x9866 <__prologue_saves__+0x18>
     856:	69 83       	std	Y+1, r22	; 0x01
     858:	7a 83       	std	Y+2, r23	; 0x02
     85a:	8b 83       	std	Y+3, r24	; 0x03
     85c:	9c 83       	std	Y+4, r25	; 0x04
     85e:	2d 83       	std	Y+5, r18	; 0x05
     860:	3e 83       	std	Y+6, r19	; 0x06
     862:	4f 83       	std	Y+7, r20	; 0x07
     864:	58 87       	std	Y+8, r21	; 0x08
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 2e       	mov	r14, r24
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	b7 01       	movw	r22, r14
     876:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     87a:	8e 01       	movw	r16, r28
     87c:	0f 5e       	subi	r16, 0xEF	; 239
     87e:	1f 4f       	sbci	r17, 0xFF	; 255
     880:	ce 01       	movw	r24, r28
     882:	05 96       	adiw	r24, 0x05	; 5
     884:	b8 01       	movw	r22, r16
     886:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     88a:	89 85       	ldd	r24, Y+9	; 0x09
     88c:	82 30       	cpi	r24, 0x02	; 2
     88e:	40 f0       	brcs	.+16     	; 0x8a0 <__stack+0x41>
     890:	89 89       	ldd	r24, Y+17	; 0x11
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	28 f0       	brcs	.+10     	; 0x8a0 <__stack+0x41>
     896:	c7 01       	movw	r24, r14
     898:	b8 01       	movw	r22, r16
     89a:	0e 94 4c 07 	call	0xe98	; 0xe98 <__fpcmp_parts_f>
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <__stack+0x43>
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	68 96       	adiw	r28, 0x18	; 24
     8a4:	e6 e0       	ldi	r30, 0x06	; 6
     8a6:	0c 94 4f 4c 	jmp	0x989e	; 0x989e <__epilogue_restores__+0x18>

000008aa <__lesf2>:
     8aa:	a8 e1       	ldi	r26, 0x18	; 24
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	eb e5       	ldi	r30, 0x5B	; 91
     8b0:	f4 e0       	ldi	r31, 0x04	; 4
     8b2:	0c 94 33 4c 	jmp	0x9866	; 0x9866 <__prologue_saves__+0x18>
     8b6:	69 83       	std	Y+1, r22	; 0x01
     8b8:	7a 83       	std	Y+2, r23	; 0x02
     8ba:	8b 83       	std	Y+3, r24	; 0x03
     8bc:	9c 83       	std	Y+4, r25	; 0x04
     8be:	2d 83       	std	Y+5, r18	; 0x05
     8c0:	3e 83       	std	Y+6, r19	; 0x06
     8c2:	4f 83       	std	Y+7, r20	; 0x07
     8c4:	58 87       	std	Y+8, r21	; 0x08
     8c6:	89 e0       	ldi	r24, 0x09	; 9
     8c8:	e8 2e       	mov	r14, r24
     8ca:	f1 2c       	mov	r15, r1
     8cc:	ec 0e       	add	r14, r28
     8ce:	fd 1e       	adc	r15, r29
     8d0:	ce 01       	movw	r24, r28
     8d2:	01 96       	adiw	r24, 0x01	; 1
     8d4:	b7 01       	movw	r22, r14
     8d6:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     8da:	8e 01       	movw	r16, r28
     8dc:	0f 5e       	subi	r16, 0xEF	; 239
     8de:	1f 4f       	sbci	r17, 0xFF	; 255
     8e0:	ce 01       	movw	r24, r28
     8e2:	05 96       	adiw	r24, 0x05	; 5
     8e4:	b8 01       	movw	r22, r16
     8e6:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     8ea:	89 85       	ldd	r24, Y+9	; 0x09
     8ec:	82 30       	cpi	r24, 0x02	; 2
     8ee:	40 f0       	brcs	.+16     	; 0x900 <__lesf2+0x56>
     8f0:	89 89       	ldd	r24, Y+17	; 0x11
     8f2:	82 30       	cpi	r24, 0x02	; 2
     8f4:	28 f0       	brcs	.+10     	; 0x900 <__lesf2+0x56>
     8f6:	c7 01       	movw	r24, r14
     8f8:	b8 01       	movw	r22, r16
     8fa:	0e 94 4c 07 	call	0xe98	; 0xe98 <__fpcmp_parts_f>
     8fe:	01 c0       	rjmp	.+2      	; 0x902 <__lesf2+0x58>
     900:	81 e0       	ldi	r24, 0x01	; 1
     902:	68 96       	adiw	r28, 0x18	; 24
     904:	e6 e0       	ldi	r30, 0x06	; 6
     906:	0c 94 4f 4c 	jmp	0x989e	; 0x989e <__epilogue_restores__+0x18>

0000090a <__floatsisf>:
     90a:	a8 e0       	ldi	r26, 0x08	; 8
     90c:	b0 e0       	ldi	r27, 0x00	; 0
     90e:	eb e8       	ldi	r30, 0x8B	; 139
     910:	f4 e0       	ldi	r31, 0x04	; 4
     912:	0c 94 30 4c 	jmp	0x9860	; 0x9860 <__prologue_saves__+0x12>
     916:	9b 01       	movw	r18, r22
     918:	ac 01       	movw	r20, r24
     91a:	83 e0       	ldi	r24, 0x03	; 3
     91c:	89 83       	std	Y+1, r24	; 0x01
     91e:	da 01       	movw	r26, r20
     920:	c9 01       	movw	r24, r18
     922:	88 27       	eor	r24, r24
     924:	b7 fd       	sbrc	r27, 7
     926:	83 95       	inc	r24
     928:	99 27       	eor	r25, r25
     92a:	aa 27       	eor	r26, r26
     92c:	bb 27       	eor	r27, r27
     92e:	b8 2e       	mov	r11, r24
     930:	21 15       	cp	r18, r1
     932:	31 05       	cpc	r19, r1
     934:	41 05       	cpc	r20, r1
     936:	51 05       	cpc	r21, r1
     938:	19 f4       	brne	.+6      	; 0x940 <__floatsisf+0x36>
     93a:	82 e0       	ldi	r24, 0x02	; 2
     93c:	89 83       	std	Y+1, r24	; 0x01
     93e:	3a c0       	rjmp	.+116    	; 0x9b4 <__floatsisf+0xaa>
     940:	88 23       	and	r24, r24
     942:	a9 f0       	breq	.+42     	; 0x96e <__floatsisf+0x64>
     944:	20 30       	cpi	r18, 0x00	; 0
     946:	80 e0       	ldi	r24, 0x00	; 0
     948:	38 07       	cpc	r19, r24
     94a:	80 e0       	ldi	r24, 0x00	; 0
     94c:	48 07       	cpc	r20, r24
     94e:	80 e8       	ldi	r24, 0x80	; 128
     950:	58 07       	cpc	r21, r24
     952:	29 f4       	brne	.+10     	; 0x95e <__floatsisf+0x54>
     954:	60 e0       	ldi	r22, 0x00	; 0
     956:	70 e0       	ldi	r23, 0x00	; 0
     958:	80 e0       	ldi	r24, 0x00	; 0
     95a:	9f ec       	ldi	r25, 0xCF	; 207
     95c:	30 c0       	rjmp	.+96     	; 0x9be <__floatsisf+0xb4>
     95e:	ee 24       	eor	r14, r14
     960:	ff 24       	eor	r15, r15
     962:	87 01       	movw	r16, r14
     964:	e2 1a       	sub	r14, r18
     966:	f3 0a       	sbc	r15, r19
     968:	04 0b       	sbc	r16, r20
     96a:	15 0b       	sbc	r17, r21
     96c:	02 c0       	rjmp	.+4      	; 0x972 <__floatsisf+0x68>
     96e:	79 01       	movw	r14, r18
     970:	8a 01       	movw	r16, r20
     972:	8e e1       	ldi	r24, 0x1E	; 30
     974:	c8 2e       	mov	r12, r24
     976:	d1 2c       	mov	r13, r1
     978:	dc 82       	std	Y+4, r13	; 0x04
     97a:	cb 82       	std	Y+3, r12	; 0x03
     97c:	ed 82       	std	Y+5, r14	; 0x05
     97e:	fe 82       	std	Y+6, r15	; 0x06
     980:	0f 83       	std	Y+7, r16	; 0x07
     982:	18 87       	std	Y+8, r17	; 0x08
     984:	c8 01       	movw	r24, r16
     986:	b7 01       	movw	r22, r14
     988:	0e 94 b0 05 	call	0xb60	; 0xb60 <__clzsi2>
     98c:	01 97       	sbiw	r24, 0x01	; 1
     98e:	18 16       	cp	r1, r24
     990:	19 06       	cpc	r1, r25
     992:	84 f4       	brge	.+32     	; 0x9b4 <__floatsisf+0xaa>
     994:	08 2e       	mov	r0, r24
     996:	04 c0       	rjmp	.+8      	; 0x9a0 <__floatsisf+0x96>
     998:	ee 0c       	add	r14, r14
     99a:	ff 1c       	adc	r15, r15
     99c:	00 1f       	adc	r16, r16
     99e:	11 1f       	adc	r17, r17
     9a0:	0a 94       	dec	r0
     9a2:	d2 f7       	brpl	.-12     	; 0x998 <__floatsisf+0x8e>
     9a4:	ed 82       	std	Y+5, r14	; 0x05
     9a6:	fe 82       	std	Y+6, r15	; 0x06
     9a8:	0f 83       	std	Y+7, r16	; 0x07
     9aa:	18 87       	std	Y+8, r17	; 0x08
     9ac:	c8 1a       	sub	r12, r24
     9ae:	d9 0a       	sbc	r13, r25
     9b0:	dc 82       	std	Y+4, r13	; 0x04
     9b2:	cb 82       	std	Y+3, r12	; 0x03
     9b4:	ba 82       	std	Y+2, r11	; 0x02
     9b6:	ce 01       	movw	r24, r28
     9b8:	01 96       	adiw	r24, 0x01	; 1
     9ba:	0e 94 ff 05 	call	0xbfe	; 0xbfe <__pack_f>
     9be:	28 96       	adiw	r28, 0x08	; 8
     9c0:	e9 e0       	ldi	r30, 0x09	; 9
     9c2:	0c 94 4c 4c 	jmp	0x9898	; 0x9898 <__epilogue_restores__+0x12>

000009c6 <__fixsfsi>:
     9c6:	ac e0       	ldi	r26, 0x0C	; 12
     9c8:	b0 e0       	ldi	r27, 0x00	; 0
     9ca:	e9 ee       	ldi	r30, 0xE9	; 233
     9cc:	f4 e0       	ldi	r31, 0x04	; 4
     9ce:	0c 94 37 4c 	jmp	0x986e	; 0x986e <__prologue_saves__+0x20>
     9d2:	69 83       	std	Y+1, r22	; 0x01
     9d4:	7a 83       	std	Y+2, r23	; 0x02
     9d6:	8b 83       	std	Y+3, r24	; 0x03
     9d8:	9c 83       	std	Y+4, r25	; 0x04
     9da:	ce 01       	movw	r24, r28
     9dc:	01 96       	adiw	r24, 0x01	; 1
     9de:	be 01       	movw	r22, r28
     9e0:	6b 5f       	subi	r22, 0xFB	; 251
     9e2:	7f 4f       	sbci	r23, 0xFF	; 255
     9e4:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     9e8:	8d 81       	ldd	r24, Y+5	; 0x05
     9ea:	82 30       	cpi	r24, 0x02	; 2
     9ec:	61 f1       	breq	.+88     	; 0xa46 <__fixsfsi+0x80>
     9ee:	82 30       	cpi	r24, 0x02	; 2
     9f0:	50 f1       	brcs	.+84     	; 0xa46 <__fixsfsi+0x80>
     9f2:	84 30       	cpi	r24, 0x04	; 4
     9f4:	21 f4       	brne	.+8      	; 0x9fe <__fixsfsi+0x38>
     9f6:	8e 81       	ldd	r24, Y+6	; 0x06
     9f8:	88 23       	and	r24, r24
     9fa:	51 f1       	breq	.+84     	; 0xa50 <__fixsfsi+0x8a>
     9fc:	2e c0       	rjmp	.+92     	; 0xa5a <__fixsfsi+0x94>
     9fe:	2f 81       	ldd	r18, Y+7	; 0x07
     a00:	38 85       	ldd	r19, Y+8	; 0x08
     a02:	37 fd       	sbrc	r19, 7
     a04:	20 c0       	rjmp	.+64     	; 0xa46 <__fixsfsi+0x80>
     a06:	6e 81       	ldd	r22, Y+6	; 0x06
     a08:	2f 31       	cpi	r18, 0x1F	; 31
     a0a:	31 05       	cpc	r19, r1
     a0c:	1c f0       	brlt	.+6      	; 0xa14 <__fixsfsi+0x4e>
     a0e:	66 23       	and	r22, r22
     a10:	f9 f0       	breq	.+62     	; 0xa50 <__fixsfsi+0x8a>
     a12:	23 c0       	rjmp	.+70     	; 0xa5a <__fixsfsi+0x94>
     a14:	8e e1       	ldi	r24, 0x1E	; 30
     a16:	90 e0       	ldi	r25, 0x00	; 0
     a18:	82 1b       	sub	r24, r18
     a1a:	93 0b       	sbc	r25, r19
     a1c:	29 85       	ldd	r18, Y+9	; 0x09
     a1e:	3a 85       	ldd	r19, Y+10	; 0x0a
     a20:	4b 85       	ldd	r20, Y+11	; 0x0b
     a22:	5c 85       	ldd	r21, Y+12	; 0x0c
     a24:	04 c0       	rjmp	.+8      	; 0xa2e <__fixsfsi+0x68>
     a26:	56 95       	lsr	r21
     a28:	47 95       	ror	r20
     a2a:	37 95       	ror	r19
     a2c:	27 95       	ror	r18
     a2e:	8a 95       	dec	r24
     a30:	d2 f7       	brpl	.-12     	; 0xa26 <__fixsfsi+0x60>
     a32:	66 23       	and	r22, r22
     a34:	b1 f0       	breq	.+44     	; 0xa62 <__fixsfsi+0x9c>
     a36:	50 95       	com	r21
     a38:	40 95       	com	r20
     a3a:	30 95       	com	r19
     a3c:	21 95       	neg	r18
     a3e:	3f 4f       	sbci	r19, 0xFF	; 255
     a40:	4f 4f       	sbci	r20, 0xFF	; 255
     a42:	5f 4f       	sbci	r21, 0xFF	; 255
     a44:	0e c0       	rjmp	.+28     	; 0xa62 <__fixsfsi+0x9c>
     a46:	20 e0       	ldi	r18, 0x00	; 0
     a48:	30 e0       	ldi	r19, 0x00	; 0
     a4a:	40 e0       	ldi	r20, 0x00	; 0
     a4c:	50 e0       	ldi	r21, 0x00	; 0
     a4e:	09 c0       	rjmp	.+18     	; 0xa62 <__fixsfsi+0x9c>
     a50:	2f ef       	ldi	r18, 0xFF	; 255
     a52:	3f ef       	ldi	r19, 0xFF	; 255
     a54:	4f ef       	ldi	r20, 0xFF	; 255
     a56:	5f e7       	ldi	r21, 0x7F	; 127
     a58:	04 c0       	rjmp	.+8      	; 0xa62 <__fixsfsi+0x9c>
     a5a:	20 e0       	ldi	r18, 0x00	; 0
     a5c:	30 e0       	ldi	r19, 0x00	; 0
     a5e:	40 e0       	ldi	r20, 0x00	; 0
     a60:	50 e8       	ldi	r21, 0x80	; 128
     a62:	b9 01       	movw	r22, r18
     a64:	ca 01       	movw	r24, r20
     a66:	2c 96       	adiw	r28, 0x0c	; 12
     a68:	e2 e0       	ldi	r30, 0x02	; 2
     a6a:	0c 94 53 4c 	jmp	0x98a6	; 0x98a6 <__epilogue_restores__+0x20>

00000a6e <__floatunsisf>:
     a6e:	a8 e0       	ldi	r26, 0x08	; 8
     a70:	b0 e0       	ldi	r27, 0x00	; 0
     a72:	ed e3       	ldi	r30, 0x3D	; 61
     a74:	f5 e0       	ldi	r31, 0x05	; 5
     a76:	0c 94 2f 4c 	jmp	0x985e	; 0x985e <__prologue_saves__+0x10>
     a7a:	7b 01       	movw	r14, r22
     a7c:	8c 01       	movw	r16, r24
     a7e:	61 15       	cp	r22, r1
     a80:	71 05       	cpc	r23, r1
     a82:	81 05       	cpc	r24, r1
     a84:	91 05       	cpc	r25, r1
     a86:	19 f4       	brne	.+6      	; 0xa8e <__floatunsisf+0x20>
     a88:	82 e0       	ldi	r24, 0x02	; 2
     a8a:	89 83       	std	Y+1, r24	; 0x01
     a8c:	60 c0       	rjmp	.+192    	; 0xb4e <__floatunsisf+0xe0>
     a8e:	83 e0       	ldi	r24, 0x03	; 3
     a90:	89 83       	std	Y+1, r24	; 0x01
     a92:	8e e1       	ldi	r24, 0x1E	; 30
     a94:	c8 2e       	mov	r12, r24
     a96:	d1 2c       	mov	r13, r1
     a98:	dc 82       	std	Y+4, r13	; 0x04
     a9a:	cb 82       	std	Y+3, r12	; 0x03
     a9c:	ed 82       	std	Y+5, r14	; 0x05
     a9e:	fe 82       	std	Y+6, r15	; 0x06
     aa0:	0f 83       	std	Y+7, r16	; 0x07
     aa2:	18 87       	std	Y+8, r17	; 0x08
     aa4:	c8 01       	movw	r24, r16
     aa6:	b7 01       	movw	r22, r14
     aa8:	0e 94 b0 05 	call	0xb60	; 0xb60 <__clzsi2>
     aac:	fc 01       	movw	r30, r24
     aae:	31 97       	sbiw	r30, 0x01	; 1
     ab0:	f7 ff       	sbrs	r31, 7
     ab2:	3b c0       	rjmp	.+118    	; 0xb2a <__floatunsisf+0xbc>
     ab4:	22 27       	eor	r18, r18
     ab6:	33 27       	eor	r19, r19
     ab8:	2e 1b       	sub	r18, r30
     aba:	3f 0b       	sbc	r19, r31
     abc:	57 01       	movw	r10, r14
     abe:	68 01       	movw	r12, r16
     ac0:	02 2e       	mov	r0, r18
     ac2:	04 c0       	rjmp	.+8      	; 0xacc <__floatunsisf+0x5e>
     ac4:	d6 94       	lsr	r13
     ac6:	c7 94       	ror	r12
     ac8:	b7 94       	ror	r11
     aca:	a7 94       	ror	r10
     acc:	0a 94       	dec	r0
     ace:	d2 f7       	brpl	.-12     	; 0xac4 <__floatunsisf+0x56>
     ad0:	40 e0       	ldi	r20, 0x00	; 0
     ad2:	50 e0       	ldi	r21, 0x00	; 0
     ad4:	60 e0       	ldi	r22, 0x00	; 0
     ad6:	70 e0       	ldi	r23, 0x00	; 0
     ad8:	81 e0       	ldi	r24, 0x01	; 1
     ada:	90 e0       	ldi	r25, 0x00	; 0
     adc:	a0 e0       	ldi	r26, 0x00	; 0
     ade:	b0 e0       	ldi	r27, 0x00	; 0
     ae0:	04 c0       	rjmp	.+8      	; 0xaea <__floatunsisf+0x7c>
     ae2:	88 0f       	add	r24, r24
     ae4:	99 1f       	adc	r25, r25
     ae6:	aa 1f       	adc	r26, r26
     ae8:	bb 1f       	adc	r27, r27
     aea:	2a 95       	dec	r18
     aec:	d2 f7       	brpl	.-12     	; 0xae2 <__floatunsisf+0x74>
     aee:	01 97       	sbiw	r24, 0x01	; 1
     af0:	a1 09       	sbc	r26, r1
     af2:	b1 09       	sbc	r27, r1
     af4:	8e 21       	and	r24, r14
     af6:	9f 21       	and	r25, r15
     af8:	a0 23       	and	r26, r16
     afa:	b1 23       	and	r27, r17
     afc:	00 97       	sbiw	r24, 0x00	; 0
     afe:	a1 05       	cpc	r26, r1
     b00:	b1 05       	cpc	r27, r1
     b02:	21 f0       	breq	.+8      	; 0xb0c <__floatunsisf+0x9e>
     b04:	41 e0       	ldi	r20, 0x01	; 1
     b06:	50 e0       	ldi	r21, 0x00	; 0
     b08:	60 e0       	ldi	r22, 0x00	; 0
     b0a:	70 e0       	ldi	r23, 0x00	; 0
     b0c:	4a 29       	or	r20, r10
     b0e:	5b 29       	or	r21, r11
     b10:	6c 29       	or	r22, r12
     b12:	7d 29       	or	r23, r13
     b14:	4d 83       	std	Y+5, r20	; 0x05
     b16:	5e 83       	std	Y+6, r21	; 0x06
     b18:	6f 83       	std	Y+7, r22	; 0x07
     b1a:	78 87       	std	Y+8, r23	; 0x08
     b1c:	8e e1       	ldi	r24, 0x1E	; 30
     b1e:	90 e0       	ldi	r25, 0x00	; 0
     b20:	8e 1b       	sub	r24, r30
     b22:	9f 0b       	sbc	r25, r31
     b24:	9c 83       	std	Y+4, r25	; 0x04
     b26:	8b 83       	std	Y+3, r24	; 0x03
     b28:	12 c0       	rjmp	.+36     	; 0xb4e <__floatunsisf+0xe0>
     b2a:	30 97       	sbiw	r30, 0x00	; 0
     b2c:	81 f0       	breq	.+32     	; 0xb4e <__floatunsisf+0xe0>
     b2e:	0e 2e       	mov	r0, r30
     b30:	04 c0       	rjmp	.+8      	; 0xb3a <__floatunsisf+0xcc>
     b32:	ee 0c       	add	r14, r14
     b34:	ff 1c       	adc	r15, r15
     b36:	00 1f       	adc	r16, r16
     b38:	11 1f       	adc	r17, r17
     b3a:	0a 94       	dec	r0
     b3c:	d2 f7       	brpl	.-12     	; 0xb32 <__floatunsisf+0xc4>
     b3e:	ed 82       	std	Y+5, r14	; 0x05
     b40:	fe 82       	std	Y+6, r15	; 0x06
     b42:	0f 83       	std	Y+7, r16	; 0x07
     b44:	18 87       	std	Y+8, r17	; 0x08
     b46:	ce 1a       	sub	r12, r30
     b48:	df 0a       	sbc	r13, r31
     b4a:	dc 82       	std	Y+4, r13	; 0x04
     b4c:	cb 82       	std	Y+3, r12	; 0x03
     b4e:	1a 82       	std	Y+2, r1	; 0x02
     b50:	ce 01       	movw	r24, r28
     b52:	01 96       	adiw	r24, 0x01	; 1
     b54:	0e 94 ff 05 	call	0xbfe	; 0xbfe <__pack_f>
     b58:	28 96       	adiw	r28, 0x08	; 8
     b5a:	ea e0       	ldi	r30, 0x0A	; 10
     b5c:	0c 94 4b 4c 	jmp	0x9896	; 0x9896 <__epilogue_restores__+0x10>

00000b60 <__clzsi2>:
     b60:	ef 92       	push	r14
     b62:	ff 92       	push	r15
     b64:	0f 93       	push	r16
     b66:	1f 93       	push	r17
     b68:	7b 01       	movw	r14, r22
     b6a:	8c 01       	movw	r16, r24
     b6c:	80 e0       	ldi	r24, 0x00	; 0
     b6e:	e8 16       	cp	r14, r24
     b70:	80 e0       	ldi	r24, 0x00	; 0
     b72:	f8 06       	cpc	r15, r24
     b74:	81 e0       	ldi	r24, 0x01	; 1
     b76:	08 07       	cpc	r16, r24
     b78:	80 e0       	ldi	r24, 0x00	; 0
     b7a:	18 07       	cpc	r17, r24
     b7c:	88 f4       	brcc	.+34     	; 0xba0 <__clzsi2+0x40>
     b7e:	8f ef       	ldi	r24, 0xFF	; 255
     b80:	e8 16       	cp	r14, r24
     b82:	f1 04       	cpc	r15, r1
     b84:	01 05       	cpc	r16, r1
     b86:	11 05       	cpc	r17, r1
     b88:	31 f0       	breq	.+12     	; 0xb96 <__clzsi2+0x36>
     b8a:	28 f0       	brcs	.+10     	; 0xb96 <__clzsi2+0x36>
     b8c:	88 e0       	ldi	r24, 0x08	; 8
     b8e:	90 e0       	ldi	r25, 0x00	; 0
     b90:	a0 e0       	ldi	r26, 0x00	; 0
     b92:	b0 e0       	ldi	r27, 0x00	; 0
     b94:	17 c0       	rjmp	.+46     	; 0xbc4 <__clzsi2+0x64>
     b96:	80 e0       	ldi	r24, 0x00	; 0
     b98:	90 e0       	ldi	r25, 0x00	; 0
     b9a:	a0 e0       	ldi	r26, 0x00	; 0
     b9c:	b0 e0       	ldi	r27, 0x00	; 0
     b9e:	12 c0       	rjmp	.+36     	; 0xbc4 <__clzsi2+0x64>
     ba0:	80 e0       	ldi	r24, 0x00	; 0
     ba2:	e8 16       	cp	r14, r24
     ba4:	80 e0       	ldi	r24, 0x00	; 0
     ba6:	f8 06       	cpc	r15, r24
     ba8:	80 e0       	ldi	r24, 0x00	; 0
     baa:	08 07       	cpc	r16, r24
     bac:	81 e0       	ldi	r24, 0x01	; 1
     bae:	18 07       	cpc	r17, r24
     bb0:	28 f0       	brcs	.+10     	; 0xbbc <__clzsi2+0x5c>
     bb2:	88 e1       	ldi	r24, 0x18	; 24
     bb4:	90 e0       	ldi	r25, 0x00	; 0
     bb6:	a0 e0       	ldi	r26, 0x00	; 0
     bb8:	b0 e0       	ldi	r27, 0x00	; 0
     bba:	04 c0       	rjmp	.+8      	; 0xbc4 <__clzsi2+0x64>
     bbc:	80 e1       	ldi	r24, 0x10	; 16
     bbe:	90 e0       	ldi	r25, 0x00	; 0
     bc0:	a0 e0       	ldi	r26, 0x00	; 0
     bc2:	b0 e0       	ldi	r27, 0x00	; 0
     bc4:	20 e2       	ldi	r18, 0x20	; 32
     bc6:	30 e0       	ldi	r19, 0x00	; 0
     bc8:	40 e0       	ldi	r20, 0x00	; 0
     bca:	50 e0       	ldi	r21, 0x00	; 0
     bcc:	28 1b       	sub	r18, r24
     bce:	39 0b       	sbc	r19, r25
     bd0:	4a 0b       	sbc	r20, r26
     bd2:	5b 0b       	sbc	r21, r27
     bd4:	04 c0       	rjmp	.+8      	; 0xbde <__clzsi2+0x7e>
     bd6:	16 95       	lsr	r17
     bd8:	07 95       	ror	r16
     bda:	f7 94       	ror	r15
     bdc:	e7 94       	ror	r14
     bde:	8a 95       	dec	r24
     be0:	d2 f7       	brpl	.-12     	; 0xbd6 <__clzsi2+0x76>
     be2:	f7 01       	movw	r30, r14
     be4:	e9 5d       	subi	r30, 0xD9	; 217
     be6:	fe 4f       	sbci	r31, 0xFE	; 254
     be8:	80 81       	ld	r24, Z
     bea:	28 1b       	sub	r18, r24
     bec:	31 09       	sbc	r19, r1
     bee:	41 09       	sbc	r20, r1
     bf0:	51 09       	sbc	r21, r1
     bf2:	c9 01       	movw	r24, r18
     bf4:	1f 91       	pop	r17
     bf6:	0f 91       	pop	r16
     bf8:	ff 90       	pop	r15
     bfa:	ef 90       	pop	r14
     bfc:	08 95       	ret

00000bfe <__pack_f>:
     bfe:	df 92       	push	r13
     c00:	ef 92       	push	r14
     c02:	ff 92       	push	r15
     c04:	0f 93       	push	r16
     c06:	1f 93       	push	r17
     c08:	fc 01       	movw	r30, r24
     c0a:	e4 80       	ldd	r14, Z+4	; 0x04
     c0c:	f5 80       	ldd	r15, Z+5	; 0x05
     c0e:	06 81       	ldd	r16, Z+6	; 0x06
     c10:	17 81       	ldd	r17, Z+7	; 0x07
     c12:	d1 80       	ldd	r13, Z+1	; 0x01
     c14:	80 81       	ld	r24, Z
     c16:	82 30       	cpi	r24, 0x02	; 2
     c18:	48 f4       	brcc	.+18     	; 0xc2c <__pack_f+0x2e>
     c1a:	80 e0       	ldi	r24, 0x00	; 0
     c1c:	90 e0       	ldi	r25, 0x00	; 0
     c1e:	a0 e1       	ldi	r26, 0x10	; 16
     c20:	b0 e0       	ldi	r27, 0x00	; 0
     c22:	e8 2a       	or	r14, r24
     c24:	f9 2a       	or	r15, r25
     c26:	0a 2b       	or	r16, r26
     c28:	1b 2b       	or	r17, r27
     c2a:	a5 c0       	rjmp	.+330    	; 0xd76 <__pack_f+0x178>
     c2c:	84 30       	cpi	r24, 0x04	; 4
     c2e:	09 f4       	brne	.+2      	; 0xc32 <__pack_f+0x34>
     c30:	9f c0       	rjmp	.+318    	; 0xd70 <__pack_f+0x172>
     c32:	82 30       	cpi	r24, 0x02	; 2
     c34:	21 f4       	brne	.+8      	; 0xc3e <__pack_f+0x40>
     c36:	ee 24       	eor	r14, r14
     c38:	ff 24       	eor	r15, r15
     c3a:	87 01       	movw	r16, r14
     c3c:	05 c0       	rjmp	.+10     	; 0xc48 <__pack_f+0x4a>
     c3e:	e1 14       	cp	r14, r1
     c40:	f1 04       	cpc	r15, r1
     c42:	01 05       	cpc	r16, r1
     c44:	11 05       	cpc	r17, r1
     c46:	19 f4       	brne	.+6      	; 0xc4e <__pack_f+0x50>
     c48:	e0 e0       	ldi	r30, 0x00	; 0
     c4a:	f0 e0       	ldi	r31, 0x00	; 0
     c4c:	96 c0       	rjmp	.+300    	; 0xd7a <__pack_f+0x17c>
     c4e:	62 81       	ldd	r22, Z+2	; 0x02
     c50:	73 81       	ldd	r23, Z+3	; 0x03
     c52:	9f ef       	ldi	r25, 0xFF	; 255
     c54:	62 38       	cpi	r22, 0x82	; 130
     c56:	79 07       	cpc	r23, r25
     c58:	0c f0       	brlt	.+2      	; 0xc5c <__pack_f+0x5e>
     c5a:	5b c0       	rjmp	.+182    	; 0xd12 <__pack_f+0x114>
     c5c:	22 e8       	ldi	r18, 0x82	; 130
     c5e:	3f ef       	ldi	r19, 0xFF	; 255
     c60:	26 1b       	sub	r18, r22
     c62:	37 0b       	sbc	r19, r23
     c64:	2a 31       	cpi	r18, 0x1A	; 26
     c66:	31 05       	cpc	r19, r1
     c68:	2c f0       	brlt	.+10     	; 0xc74 <__pack_f+0x76>
     c6a:	20 e0       	ldi	r18, 0x00	; 0
     c6c:	30 e0       	ldi	r19, 0x00	; 0
     c6e:	40 e0       	ldi	r20, 0x00	; 0
     c70:	50 e0       	ldi	r21, 0x00	; 0
     c72:	2a c0       	rjmp	.+84     	; 0xcc8 <__pack_f+0xca>
     c74:	b8 01       	movw	r22, r16
     c76:	a7 01       	movw	r20, r14
     c78:	02 2e       	mov	r0, r18
     c7a:	04 c0       	rjmp	.+8      	; 0xc84 <__pack_f+0x86>
     c7c:	76 95       	lsr	r23
     c7e:	67 95       	ror	r22
     c80:	57 95       	ror	r21
     c82:	47 95       	ror	r20
     c84:	0a 94       	dec	r0
     c86:	d2 f7       	brpl	.-12     	; 0xc7c <__pack_f+0x7e>
     c88:	81 e0       	ldi	r24, 0x01	; 1
     c8a:	90 e0       	ldi	r25, 0x00	; 0
     c8c:	a0 e0       	ldi	r26, 0x00	; 0
     c8e:	b0 e0       	ldi	r27, 0x00	; 0
     c90:	04 c0       	rjmp	.+8      	; 0xc9a <__pack_f+0x9c>
     c92:	88 0f       	add	r24, r24
     c94:	99 1f       	adc	r25, r25
     c96:	aa 1f       	adc	r26, r26
     c98:	bb 1f       	adc	r27, r27
     c9a:	2a 95       	dec	r18
     c9c:	d2 f7       	brpl	.-12     	; 0xc92 <__pack_f+0x94>
     c9e:	01 97       	sbiw	r24, 0x01	; 1
     ca0:	a1 09       	sbc	r26, r1
     ca2:	b1 09       	sbc	r27, r1
     ca4:	8e 21       	and	r24, r14
     ca6:	9f 21       	and	r25, r15
     ca8:	a0 23       	and	r26, r16
     caa:	b1 23       	and	r27, r17
     cac:	00 97       	sbiw	r24, 0x00	; 0
     cae:	a1 05       	cpc	r26, r1
     cb0:	b1 05       	cpc	r27, r1
     cb2:	21 f0       	breq	.+8      	; 0xcbc <__pack_f+0xbe>
     cb4:	81 e0       	ldi	r24, 0x01	; 1
     cb6:	90 e0       	ldi	r25, 0x00	; 0
     cb8:	a0 e0       	ldi	r26, 0x00	; 0
     cba:	b0 e0       	ldi	r27, 0x00	; 0
     cbc:	9a 01       	movw	r18, r20
     cbe:	ab 01       	movw	r20, r22
     cc0:	28 2b       	or	r18, r24
     cc2:	39 2b       	or	r19, r25
     cc4:	4a 2b       	or	r20, r26
     cc6:	5b 2b       	or	r21, r27
     cc8:	da 01       	movw	r26, r20
     cca:	c9 01       	movw	r24, r18
     ccc:	8f 77       	andi	r24, 0x7F	; 127
     cce:	90 70       	andi	r25, 0x00	; 0
     cd0:	a0 70       	andi	r26, 0x00	; 0
     cd2:	b0 70       	andi	r27, 0x00	; 0
     cd4:	80 34       	cpi	r24, 0x40	; 64
     cd6:	91 05       	cpc	r25, r1
     cd8:	a1 05       	cpc	r26, r1
     cda:	b1 05       	cpc	r27, r1
     cdc:	39 f4       	brne	.+14     	; 0xcec <__pack_f+0xee>
     cde:	27 ff       	sbrs	r18, 7
     ce0:	09 c0       	rjmp	.+18     	; 0xcf4 <__pack_f+0xf6>
     ce2:	20 5c       	subi	r18, 0xC0	; 192
     ce4:	3f 4f       	sbci	r19, 0xFF	; 255
     ce6:	4f 4f       	sbci	r20, 0xFF	; 255
     ce8:	5f 4f       	sbci	r21, 0xFF	; 255
     cea:	04 c0       	rjmp	.+8      	; 0xcf4 <__pack_f+0xf6>
     cec:	21 5c       	subi	r18, 0xC1	; 193
     cee:	3f 4f       	sbci	r19, 0xFF	; 255
     cf0:	4f 4f       	sbci	r20, 0xFF	; 255
     cf2:	5f 4f       	sbci	r21, 0xFF	; 255
     cf4:	e0 e0       	ldi	r30, 0x00	; 0
     cf6:	f0 e0       	ldi	r31, 0x00	; 0
     cf8:	20 30       	cpi	r18, 0x00	; 0
     cfa:	a0 e0       	ldi	r26, 0x00	; 0
     cfc:	3a 07       	cpc	r19, r26
     cfe:	a0 e0       	ldi	r26, 0x00	; 0
     d00:	4a 07       	cpc	r20, r26
     d02:	a0 e4       	ldi	r26, 0x40	; 64
     d04:	5a 07       	cpc	r21, r26
     d06:	10 f0       	brcs	.+4      	; 0xd0c <__pack_f+0x10e>
     d08:	e1 e0       	ldi	r30, 0x01	; 1
     d0a:	f0 e0       	ldi	r31, 0x00	; 0
     d0c:	79 01       	movw	r14, r18
     d0e:	8a 01       	movw	r16, r20
     d10:	27 c0       	rjmp	.+78     	; 0xd60 <__pack_f+0x162>
     d12:	60 38       	cpi	r22, 0x80	; 128
     d14:	71 05       	cpc	r23, r1
     d16:	64 f5       	brge	.+88     	; 0xd70 <__pack_f+0x172>
     d18:	fb 01       	movw	r30, r22
     d1a:	e1 58       	subi	r30, 0x81	; 129
     d1c:	ff 4f       	sbci	r31, 0xFF	; 255
     d1e:	d8 01       	movw	r26, r16
     d20:	c7 01       	movw	r24, r14
     d22:	8f 77       	andi	r24, 0x7F	; 127
     d24:	90 70       	andi	r25, 0x00	; 0
     d26:	a0 70       	andi	r26, 0x00	; 0
     d28:	b0 70       	andi	r27, 0x00	; 0
     d2a:	80 34       	cpi	r24, 0x40	; 64
     d2c:	91 05       	cpc	r25, r1
     d2e:	a1 05       	cpc	r26, r1
     d30:	b1 05       	cpc	r27, r1
     d32:	39 f4       	brne	.+14     	; 0xd42 <__pack_f+0x144>
     d34:	e7 fe       	sbrs	r14, 7
     d36:	0d c0       	rjmp	.+26     	; 0xd52 <__pack_f+0x154>
     d38:	80 e4       	ldi	r24, 0x40	; 64
     d3a:	90 e0       	ldi	r25, 0x00	; 0
     d3c:	a0 e0       	ldi	r26, 0x00	; 0
     d3e:	b0 e0       	ldi	r27, 0x00	; 0
     d40:	04 c0       	rjmp	.+8      	; 0xd4a <__pack_f+0x14c>
     d42:	8f e3       	ldi	r24, 0x3F	; 63
     d44:	90 e0       	ldi	r25, 0x00	; 0
     d46:	a0 e0       	ldi	r26, 0x00	; 0
     d48:	b0 e0       	ldi	r27, 0x00	; 0
     d4a:	e8 0e       	add	r14, r24
     d4c:	f9 1e       	adc	r15, r25
     d4e:	0a 1f       	adc	r16, r26
     d50:	1b 1f       	adc	r17, r27
     d52:	17 ff       	sbrs	r17, 7
     d54:	05 c0       	rjmp	.+10     	; 0xd60 <__pack_f+0x162>
     d56:	16 95       	lsr	r17
     d58:	07 95       	ror	r16
     d5a:	f7 94       	ror	r15
     d5c:	e7 94       	ror	r14
     d5e:	31 96       	adiw	r30, 0x01	; 1
     d60:	87 e0       	ldi	r24, 0x07	; 7
     d62:	16 95       	lsr	r17
     d64:	07 95       	ror	r16
     d66:	f7 94       	ror	r15
     d68:	e7 94       	ror	r14
     d6a:	8a 95       	dec	r24
     d6c:	d1 f7       	brne	.-12     	; 0xd62 <__pack_f+0x164>
     d6e:	05 c0       	rjmp	.+10     	; 0xd7a <__pack_f+0x17c>
     d70:	ee 24       	eor	r14, r14
     d72:	ff 24       	eor	r15, r15
     d74:	87 01       	movw	r16, r14
     d76:	ef ef       	ldi	r30, 0xFF	; 255
     d78:	f0 e0       	ldi	r31, 0x00	; 0
     d7a:	6e 2f       	mov	r22, r30
     d7c:	67 95       	ror	r22
     d7e:	66 27       	eor	r22, r22
     d80:	67 95       	ror	r22
     d82:	90 2f       	mov	r25, r16
     d84:	9f 77       	andi	r25, 0x7F	; 127
     d86:	d7 94       	ror	r13
     d88:	dd 24       	eor	r13, r13
     d8a:	d7 94       	ror	r13
     d8c:	8e 2f       	mov	r24, r30
     d8e:	86 95       	lsr	r24
     d90:	49 2f       	mov	r20, r25
     d92:	46 2b       	or	r20, r22
     d94:	58 2f       	mov	r21, r24
     d96:	5d 29       	or	r21, r13
     d98:	b7 01       	movw	r22, r14
     d9a:	ca 01       	movw	r24, r20
     d9c:	1f 91       	pop	r17
     d9e:	0f 91       	pop	r16
     da0:	ff 90       	pop	r15
     da2:	ef 90       	pop	r14
     da4:	df 90       	pop	r13
     da6:	08 95       	ret

00000da8 <__unpack_f>:
     da8:	fc 01       	movw	r30, r24
     daa:	db 01       	movw	r26, r22
     dac:	40 81       	ld	r20, Z
     dae:	51 81       	ldd	r21, Z+1	; 0x01
     db0:	22 81       	ldd	r18, Z+2	; 0x02
     db2:	62 2f       	mov	r22, r18
     db4:	6f 77       	andi	r22, 0x7F	; 127
     db6:	70 e0       	ldi	r23, 0x00	; 0
     db8:	22 1f       	adc	r18, r18
     dba:	22 27       	eor	r18, r18
     dbc:	22 1f       	adc	r18, r18
     dbe:	93 81       	ldd	r25, Z+3	; 0x03
     dc0:	89 2f       	mov	r24, r25
     dc2:	88 0f       	add	r24, r24
     dc4:	82 2b       	or	r24, r18
     dc6:	28 2f       	mov	r18, r24
     dc8:	30 e0       	ldi	r19, 0x00	; 0
     dca:	99 1f       	adc	r25, r25
     dcc:	99 27       	eor	r25, r25
     dce:	99 1f       	adc	r25, r25
     dd0:	11 96       	adiw	r26, 0x01	; 1
     dd2:	9c 93       	st	X, r25
     dd4:	11 97       	sbiw	r26, 0x01	; 1
     dd6:	21 15       	cp	r18, r1
     dd8:	31 05       	cpc	r19, r1
     dda:	a9 f5       	brne	.+106    	; 0xe46 <__unpack_f+0x9e>
     ddc:	41 15       	cp	r20, r1
     dde:	51 05       	cpc	r21, r1
     de0:	61 05       	cpc	r22, r1
     de2:	71 05       	cpc	r23, r1
     de4:	11 f4       	brne	.+4      	; 0xdea <__unpack_f+0x42>
     de6:	82 e0       	ldi	r24, 0x02	; 2
     de8:	37 c0       	rjmp	.+110    	; 0xe58 <__unpack_f+0xb0>
     dea:	82 e8       	ldi	r24, 0x82	; 130
     dec:	9f ef       	ldi	r25, 0xFF	; 255
     dee:	13 96       	adiw	r26, 0x03	; 3
     df0:	9c 93       	st	X, r25
     df2:	8e 93       	st	-X, r24
     df4:	12 97       	sbiw	r26, 0x02	; 2
     df6:	9a 01       	movw	r18, r20
     df8:	ab 01       	movw	r20, r22
     dfa:	67 e0       	ldi	r22, 0x07	; 7
     dfc:	22 0f       	add	r18, r18
     dfe:	33 1f       	adc	r19, r19
     e00:	44 1f       	adc	r20, r20
     e02:	55 1f       	adc	r21, r21
     e04:	6a 95       	dec	r22
     e06:	d1 f7       	brne	.-12     	; 0xdfc <__unpack_f+0x54>
     e08:	83 e0       	ldi	r24, 0x03	; 3
     e0a:	8c 93       	st	X, r24
     e0c:	0d c0       	rjmp	.+26     	; 0xe28 <__unpack_f+0x80>
     e0e:	22 0f       	add	r18, r18
     e10:	33 1f       	adc	r19, r19
     e12:	44 1f       	adc	r20, r20
     e14:	55 1f       	adc	r21, r21
     e16:	12 96       	adiw	r26, 0x02	; 2
     e18:	8d 91       	ld	r24, X+
     e1a:	9c 91       	ld	r25, X
     e1c:	13 97       	sbiw	r26, 0x03	; 3
     e1e:	01 97       	sbiw	r24, 0x01	; 1
     e20:	13 96       	adiw	r26, 0x03	; 3
     e22:	9c 93       	st	X, r25
     e24:	8e 93       	st	-X, r24
     e26:	12 97       	sbiw	r26, 0x02	; 2
     e28:	20 30       	cpi	r18, 0x00	; 0
     e2a:	80 e0       	ldi	r24, 0x00	; 0
     e2c:	38 07       	cpc	r19, r24
     e2e:	80 e0       	ldi	r24, 0x00	; 0
     e30:	48 07       	cpc	r20, r24
     e32:	80 e4       	ldi	r24, 0x40	; 64
     e34:	58 07       	cpc	r21, r24
     e36:	58 f3       	brcs	.-42     	; 0xe0e <__unpack_f+0x66>
     e38:	14 96       	adiw	r26, 0x04	; 4
     e3a:	2d 93       	st	X+, r18
     e3c:	3d 93       	st	X+, r19
     e3e:	4d 93       	st	X+, r20
     e40:	5c 93       	st	X, r21
     e42:	17 97       	sbiw	r26, 0x07	; 7
     e44:	08 95       	ret
     e46:	2f 3f       	cpi	r18, 0xFF	; 255
     e48:	31 05       	cpc	r19, r1
     e4a:	79 f4       	brne	.+30     	; 0xe6a <__unpack_f+0xc2>
     e4c:	41 15       	cp	r20, r1
     e4e:	51 05       	cpc	r21, r1
     e50:	61 05       	cpc	r22, r1
     e52:	71 05       	cpc	r23, r1
     e54:	19 f4       	brne	.+6      	; 0xe5c <__unpack_f+0xb4>
     e56:	84 e0       	ldi	r24, 0x04	; 4
     e58:	8c 93       	st	X, r24
     e5a:	08 95       	ret
     e5c:	64 ff       	sbrs	r22, 4
     e5e:	03 c0       	rjmp	.+6      	; 0xe66 <__unpack_f+0xbe>
     e60:	81 e0       	ldi	r24, 0x01	; 1
     e62:	8c 93       	st	X, r24
     e64:	12 c0       	rjmp	.+36     	; 0xe8a <__unpack_f+0xe2>
     e66:	1c 92       	st	X, r1
     e68:	10 c0       	rjmp	.+32     	; 0xe8a <__unpack_f+0xe2>
     e6a:	2f 57       	subi	r18, 0x7F	; 127
     e6c:	30 40       	sbci	r19, 0x00	; 0
     e6e:	13 96       	adiw	r26, 0x03	; 3
     e70:	3c 93       	st	X, r19
     e72:	2e 93       	st	-X, r18
     e74:	12 97       	sbiw	r26, 0x02	; 2
     e76:	83 e0       	ldi	r24, 0x03	; 3
     e78:	8c 93       	st	X, r24
     e7a:	87 e0       	ldi	r24, 0x07	; 7
     e7c:	44 0f       	add	r20, r20
     e7e:	55 1f       	adc	r21, r21
     e80:	66 1f       	adc	r22, r22
     e82:	77 1f       	adc	r23, r23
     e84:	8a 95       	dec	r24
     e86:	d1 f7       	brne	.-12     	; 0xe7c <__unpack_f+0xd4>
     e88:	70 64       	ori	r23, 0x40	; 64
     e8a:	14 96       	adiw	r26, 0x04	; 4
     e8c:	4d 93       	st	X+, r20
     e8e:	5d 93       	st	X+, r21
     e90:	6d 93       	st	X+, r22
     e92:	7c 93       	st	X, r23
     e94:	17 97       	sbiw	r26, 0x07	; 7
     e96:	08 95       	ret

00000e98 <__fpcmp_parts_f>:
     e98:	1f 93       	push	r17
     e9a:	dc 01       	movw	r26, r24
     e9c:	fb 01       	movw	r30, r22
     e9e:	9c 91       	ld	r25, X
     ea0:	92 30       	cpi	r25, 0x02	; 2
     ea2:	08 f4       	brcc	.+2      	; 0xea6 <__fpcmp_parts_f+0xe>
     ea4:	47 c0       	rjmp	.+142    	; 0xf34 <__fpcmp_parts_f+0x9c>
     ea6:	80 81       	ld	r24, Z
     ea8:	82 30       	cpi	r24, 0x02	; 2
     eaa:	08 f4       	brcc	.+2      	; 0xeae <__fpcmp_parts_f+0x16>
     eac:	43 c0       	rjmp	.+134    	; 0xf34 <__fpcmp_parts_f+0x9c>
     eae:	94 30       	cpi	r25, 0x04	; 4
     eb0:	51 f4       	brne	.+20     	; 0xec6 <__fpcmp_parts_f+0x2e>
     eb2:	11 96       	adiw	r26, 0x01	; 1
     eb4:	1c 91       	ld	r17, X
     eb6:	84 30       	cpi	r24, 0x04	; 4
     eb8:	99 f5       	brne	.+102    	; 0xf20 <__fpcmp_parts_f+0x88>
     eba:	81 81       	ldd	r24, Z+1	; 0x01
     ebc:	68 2f       	mov	r22, r24
     ebe:	70 e0       	ldi	r23, 0x00	; 0
     ec0:	61 1b       	sub	r22, r17
     ec2:	71 09       	sbc	r23, r1
     ec4:	3f c0       	rjmp	.+126    	; 0xf44 <__fpcmp_parts_f+0xac>
     ec6:	84 30       	cpi	r24, 0x04	; 4
     ec8:	21 f0       	breq	.+8      	; 0xed2 <__fpcmp_parts_f+0x3a>
     eca:	92 30       	cpi	r25, 0x02	; 2
     ecc:	31 f4       	brne	.+12     	; 0xeda <__fpcmp_parts_f+0x42>
     ece:	82 30       	cpi	r24, 0x02	; 2
     ed0:	b9 f1       	breq	.+110    	; 0xf40 <__fpcmp_parts_f+0xa8>
     ed2:	81 81       	ldd	r24, Z+1	; 0x01
     ed4:	88 23       	and	r24, r24
     ed6:	89 f1       	breq	.+98     	; 0xf3a <__fpcmp_parts_f+0xa2>
     ed8:	2d c0       	rjmp	.+90     	; 0xf34 <__fpcmp_parts_f+0x9c>
     eda:	11 96       	adiw	r26, 0x01	; 1
     edc:	1c 91       	ld	r17, X
     ede:	11 97       	sbiw	r26, 0x01	; 1
     ee0:	82 30       	cpi	r24, 0x02	; 2
     ee2:	f1 f0       	breq	.+60     	; 0xf20 <__fpcmp_parts_f+0x88>
     ee4:	81 81       	ldd	r24, Z+1	; 0x01
     ee6:	18 17       	cp	r17, r24
     ee8:	d9 f4       	brne	.+54     	; 0xf20 <__fpcmp_parts_f+0x88>
     eea:	12 96       	adiw	r26, 0x02	; 2
     eec:	2d 91       	ld	r18, X+
     eee:	3c 91       	ld	r19, X
     ef0:	13 97       	sbiw	r26, 0x03	; 3
     ef2:	82 81       	ldd	r24, Z+2	; 0x02
     ef4:	93 81       	ldd	r25, Z+3	; 0x03
     ef6:	82 17       	cp	r24, r18
     ef8:	93 07       	cpc	r25, r19
     efa:	94 f0       	brlt	.+36     	; 0xf20 <__fpcmp_parts_f+0x88>
     efc:	28 17       	cp	r18, r24
     efe:	39 07       	cpc	r19, r25
     f00:	bc f0       	brlt	.+46     	; 0xf30 <__fpcmp_parts_f+0x98>
     f02:	14 96       	adiw	r26, 0x04	; 4
     f04:	8d 91       	ld	r24, X+
     f06:	9d 91       	ld	r25, X+
     f08:	0d 90       	ld	r0, X+
     f0a:	bc 91       	ld	r27, X
     f0c:	a0 2d       	mov	r26, r0
     f0e:	24 81       	ldd	r18, Z+4	; 0x04
     f10:	35 81       	ldd	r19, Z+5	; 0x05
     f12:	46 81       	ldd	r20, Z+6	; 0x06
     f14:	57 81       	ldd	r21, Z+7	; 0x07
     f16:	28 17       	cp	r18, r24
     f18:	39 07       	cpc	r19, r25
     f1a:	4a 07       	cpc	r20, r26
     f1c:	5b 07       	cpc	r21, r27
     f1e:	18 f4       	brcc	.+6      	; 0xf26 <__fpcmp_parts_f+0x8e>
     f20:	11 23       	and	r17, r17
     f22:	41 f0       	breq	.+16     	; 0xf34 <__fpcmp_parts_f+0x9c>
     f24:	0a c0       	rjmp	.+20     	; 0xf3a <__fpcmp_parts_f+0xa2>
     f26:	82 17       	cp	r24, r18
     f28:	93 07       	cpc	r25, r19
     f2a:	a4 07       	cpc	r26, r20
     f2c:	b5 07       	cpc	r27, r21
     f2e:	40 f4       	brcc	.+16     	; 0xf40 <__fpcmp_parts_f+0xa8>
     f30:	11 23       	and	r17, r17
     f32:	19 f0       	breq	.+6      	; 0xf3a <__fpcmp_parts_f+0xa2>
     f34:	61 e0       	ldi	r22, 0x01	; 1
     f36:	70 e0       	ldi	r23, 0x00	; 0
     f38:	05 c0       	rjmp	.+10     	; 0xf44 <__fpcmp_parts_f+0xac>
     f3a:	6f ef       	ldi	r22, 0xFF	; 255
     f3c:	7f ef       	ldi	r23, 0xFF	; 255
     f3e:	02 c0       	rjmp	.+4      	; 0xf44 <__fpcmp_parts_f+0xac>
     f40:	60 e0       	ldi	r22, 0x00	; 0
     f42:	70 e0       	ldi	r23, 0x00	; 0
     f44:	cb 01       	movw	r24, r22
     f46:	1f 91       	pop	r17
     f48:	08 95       	ret

00000f4a <MCAL_UART_UARTInit>:
 */

#include "UART.h"
//#include "avr/interrupt.h"

void MCAL_UART_UARTInit(void) {
     f4a:	df 93       	push	r29
     f4c:	cf 93       	push	r28
     f4e:	cd b7       	in	r28, 0x3d	; 61
     f50:	de b7       	in	r29, 0x3e	; 62
	/* Set baud rate */
	UBRRH = (u8) (Baud_Rate >> Shift_8_bit);
     f52:	e0 e4       	ldi	r30, 0x40	; 64
     f54:	f0 e0       	ldi	r31, 0x00	; 0
     f56:	10 82       	st	Z, r1
	UBRRL = (u8) Baud_Rate;
     f58:	e9 e2       	ldi	r30, 0x29	; 41
     f5a:	f0 e0       	ldi	r31, 0x00	; 0
     f5c:	87 e6       	ldi	r24, 0x67	; 103
     f5e:	80 83       	st	Z, r24

	/* Enable RX and TX */
//	UCSRB = (1 << RXEN) | (1 << TXEN);
	SET_BIT(UCSRB,RXEN_PIN);
     f60:	aa e2       	ldi	r26, 0x2A	; 42
     f62:	b0 e0       	ldi	r27, 0x00	; 0
     f64:	ea e2       	ldi	r30, 0x2A	; 42
     f66:	f0 e0       	ldi	r31, 0x00	; 0
     f68:	80 81       	ld	r24, Z
     f6a:	80 61       	ori	r24, 0x10	; 16
     f6c:	8c 93       	st	X, r24
	SET_BIT(UCSRB,TXEN_PIN);
     f6e:	aa e2       	ldi	r26, 0x2A	; 42
     f70:	b0 e0       	ldi	r27, 0x00	; 0
     f72:	ea e2       	ldi	r30, 0x2A	; 42
     f74:	f0 e0       	ldi	r31, 0x00	; 0
     f76:	80 81       	ld	r24, Z
     f78:	88 60       	ori	r24, 0x08	; 8
     f7a:	8c 93       	st	X, r24

	/* Set frame format: 8data, 2stop bit */
//	UCSRC = (1 << URSEL) | (1 << USBS) | (3 << UCSZ0);
	UCSRC = UCSRC_Size;
     f7c:	e0 e4       	ldi	r30, 0x40	; 64
     f7e:	f0 e0       	ldi	r31, 0x00	; 0
     f80:	8e e8       	ldi	r24, 0x8E	; 142
     f82:	80 83       	st	Z, r24
	//Logical Error
//	SET_BIT(UCSRC,URSEL_PIN);
//	SET_BIT(UCSRC,USBS_PIN);
//	SET_BIT(UCSRC,UCSZ0_PIN);
//	SET_BIT(UCSRC,UCSZ1_PIN);
}
     f84:	cf 91       	pop	r28
     f86:	df 91       	pop	r29
     f88:	08 95       	ret

00000f8a <MCAL_UART_UARTTransmit>:

void MCAL_UART_UARTTransmit(u8 Loc_u8data) {
     f8a:	df 93       	push	r29
     f8c:	cf 93       	push	r28
     f8e:	0f 92       	push	r0
     f90:	cd b7       	in	r28, 0x3d	; 61
     f92:	de b7       	in	r29, 0x3e	; 62
     f94:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for empty transmit buffer */
//	while (!( UCSRA & (1 << UDRE_PIN)));
	while (GET_BIT(UCSRA,UDRE_PIN)==0);
     f96:	eb e2       	ldi	r30, 0x2B	; 43
     f98:	f0 e0       	ldi	r31, 0x00	; 0
     f9a:	80 81       	ld	r24, Z
     f9c:	82 95       	swap	r24
     f9e:	86 95       	lsr	r24
     fa0:	87 70       	andi	r24, 0x07	; 7
     fa2:	88 2f       	mov	r24, r24
     fa4:	90 e0       	ldi	r25, 0x00	; 0
     fa6:	81 70       	andi	r24, 0x01	; 1
     fa8:	90 70       	andi	r25, 0x00	; 0
     faa:	00 97       	sbiw	r24, 0x00	; 0
     fac:	a1 f3       	breq	.-24     	; 0xf96 <MCAL_UART_UARTTransmit+0xc>

	/* Put data into buffer, sends the data */
	UDR = Loc_u8data;
     fae:	ec e2       	ldi	r30, 0x2C	; 44
     fb0:	f0 e0       	ldi	r31, 0x00	; 0
     fb2:	89 81       	ldd	r24, Y+1	; 0x01
     fb4:	80 83       	st	Z, r24

	/* Wait for data to be transmitted */
	while (GET_BIT(UCSRA,TXC_PIN)==0);
     fb6:	eb e2       	ldi	r30, 0x2B	; 43
     fb8:	f0 e0       	ldi	r31, 0x00	; 0
     fba:	80 81       	ld	r24, Z
     fbc:	82 95       	swap	r24
     fbe:	86 95       	lsr	r24
     fc0:	86 95       	lsr	r24
     fc2:	83 70       	andi	r24, 0x03	; 3
     fc4:	88 2f       	mov	r24, r24
     fc6:	90 e0       	ldi	r25, 0x00	; 0
     fc8:	81 70       	andi	r24, 0x01	; 1
     fca:	90 70       	andi	r25, 0x00	; 0
     fcc:	00 97       	sbiw	r24, 0x00	; 0
     fce:	99 f3       	breq	.-26     	; 0xfb6 <MCAL_UART_UARTTransmit+0x2c>
	SET_BIT(UCSRA,TXC_PIN);
     fd0:	ab e2       	ldi	r26, 0x2B	; 43
     fd2:	b0 e0       	ldi	r27, 0x00	; 0
     fd4:	eb e2       	ldi	r30, 0x2B	; 43
     fd6:	f0 e0       	ldi	r31, 0x00	; 0
     fd8:	80 81       	ld	r24, Z
     fda:	80 64       	ori	r24, 0x40	; 64
     fdc:	8c 93       	st	X, r24

}
     fde:	0f 90       	pop	r0
     fe0:	cf 91       	pop	r28
     fe2:	df 91       	pop	r29
     fe4:	08 95       	ret

00000fe6 <MCAL_UART_UARTReceive>:
//		MCAL_UART_UARTTransmit(Loc_u8data[i]);
//	}
//
//}

void MCAL_UART_UARTReceive(u8* Loc_u8data) {
     fe6:	df 93       	push	r29
     fe8:	cf 93       	push	r28
     fea:	00 d0       	rcall	.+0      	; 0xfec <MCAL_UART_UARTReceive+0x6>
     fec:	cd b7       	in	r28, 0x3d	; 61
     fee:	de b7       	in	r29, 0x3e	; 62
     ff0:	9a 83       	std	Y+2, r25	; 0x02
     ff2:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for data to be received */
//	while (!(UCSRA & (1 << RXC_PIN)));
	while (GET_BIT(UCSRA,RXC_PIN)==0);
     ff4:	eb e2       	ldi	r30, 0x2B	; 43
     ff6:	f0 e0       	ldi	r31, 0x00	; 0
     ff8:	80 81       	ld	r24, Z
     ffa:	88 23       	and	r24, r24
     ffc:	dc f7       	brge	.-10     	; 0xff4 <MCAL_UART_UARTReceive+0xe>

	/* 	Save Received Data in Var-Loc_u8data */
	*Loc_u8data=UDR;
     ffe:	ec e2       	ldi	r30, 0x2C	; 44
    1000:	f0 e0       	ldi	r31, 0x00	; 0
    1002:	80 81       	ld	r24, Z
    1004:	e9 81       	ldd	r30, Y+1	; 0x01
    1006:	fa 81       	ldd	r31, Y+2	; 0x02
    1008:	80 83       	st	Z, r24
}
    100a:	0f 90       	pop	r0
    100c:	0f 90       	pop	r0
    100e:	cf 91       	pop	r28
    1010:	df 91       	pop	r29
    1012:	08 95       	ret

00001014 <MCAL_T1_u8T1Init>:
 *  Created on: Oct 22, 2023
 *      Author: TOP_WORLD
 */
#include "Timer1.h"
void (*Gptr_3)(void)='\0';
u8 MCAL_T1_u8T1Init(u8 LOC_u8Timer1Mode) {
    1014:	df 93       	push	r29
    1016:	cf 93       	push	r28
    1018:	00 d0       	rcall	.+0      	; 0x101a <MCAL_T1_u8T1Init+0x6>
    101a:	cd b7       	in	r28, 0x3d	; 61
    101c:	de b7       	in	r29, 0x3e	; 62
    101e:	8a 83       	std	Y+2, r24	; 0x02
	u8 LOC_u8ReturnValue = E_NOT_OK;
    1020:	81 e0       	ldi	r24, 0x01	; 1
    1022:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_u8Timer1Mode <= FAST_PWM_OCR1A) {
    1024:	8a 81       	ldd	r24, Y+2	; 0x02
    1026:	80 31       	cpi	r24, 0x10	; 16
    1028:	08 f0       	brcs	.+2      	; 0x102c <MCAL_T1_u8T1Init+0x18>
    102a:	0f c2       	rjmp	.+1054   	; 0x144a <MCAL_T1_u8T1Init+0x436>
		if (LOC_u8Timer1Mode == NORMAL_MODE) {
    102c:	8a 81       	ldd	r24, Y+2	; 0x02
    102e:	88 23       	and	r24, r24
    1030:	f1 f4       	brne	.+60     	; 0x106e <MCAL_T1_u8T1Init+0x5a>
			CLR_BIT(TCCR1A, PIN0);
    1032:	af e4       	ldi	r26, 0x4F	; 79
    1034:	b0 e0       	ldi	r27, 0x00	; 0
    1036:	ef e4       	ldi	r30, 0x4F	; 79
    1038:	f0 e0       	ldi	r31, 0x00	; 0
    103a:	80 81       	ld	r24, Z
    103c:	8e 7f       	andi	r24, 0xFE	; 254
    103e:	8c 93       	st	X, r24
			CLR_BIT(TCCR1A, PIN1);
    1040:	af e4       	ldi	r26, 0x4F	; 79
    1042:	b0 e0       	ldi	r27, 0x00	; 0
    1044:	ef e4       	ldi	r30, 0x4F	; 79
    1046:	f0 e0       	ldi	r31, 0x00	; 0
    1048:	80 81       	ld	r24, Z
    104a:	8d 7f       	andi	r24, 0xFD	; 253
    104c:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN3);
    104e:	ae e4       	ldi	r26, 0x4E	; 78
    1050:	b0 e0       	ldi	r27, 0x00	; 0
    1052:	ee e4       	ldi	r30, 0x4E	; 78
    1054:	f0 e0       	ldi	r31, 0x00	; 0
    1056:	80 81       	ld	r24, Z
    1058:	87 7f       	andi	r24, 0xF7	; 247
    105a:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN4);
    105c:	ae e4       	ldi	r26, 0x4E	; 78
    105e:	b0 e0       	ldi	r27, 0x00	; 0
    1060:	ee e4       	ldi	r30, 0x4E	; 78
    1062:	f0 e0       	ldi	r31, 0x00	; 0
    1064:	80 81       	ld	r24, Z
    1066:	8f 7e       	andi	r24, 0xEF	; 239
    1068:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    106a:	19 82       	std	Y+1, r1	; 0x01
    106c:	ee c1       	rjmp	.+988    	; 0x144a <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == PWM_PHASE_CORRECT_8bit) {
    106e:	8a 81       	ldd	r24, Y+2	; 0x02
    1070:	81 30       	cpi	r24, 0x01	; 1
    1072:	f1 f4       	brne	.+60     	; 0x10b0 <MCAL_T1_u8T1Init+0x9c>
			SET_BIT(TCCR1A, PIN0);
    1074:	af e4       	ldi	r26, 0x4F	; 79
    1076:	b0 e0       	ldi	r27, 0x00	; 0
    1078:	ef e4       	ldi	r30, 0x4F	; 79
    107a:	f0 e0       	ldi	r31, 0x00	; 0
    107c:	80 81       	ld	r24, Z
    107e:	81 60       	ori	r24, 0x01	; 1
    1080:	8c 93       	st	X, r24
			CLR_BIT(TCCR1A, PIN1);
    1082:	af e4       	ldi	r26, 0x4F	; 79
    1084:	b0 e0       	ldi	r27, 0x00	; 0
    1086:	ef e4       	ldi	r30, 0x4F	; 79
    1088:	f0 e0       	ldi	r31, 0x00	; 0
    108a:	80 81       	ld	r24, Z
    108c:	8d 7f       	andi	r24, 0xFD	; 253
    108e:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN3);
    1090:	ae e4       	ldi	r26, 0x4E	; 78
    1092:	b0 e0       	ldi	r27, 0x00	; 0
    1094:	ee e4       	ldi	r30, 0x4E	; 78
    1096:	f0 e0       	ldi	r31, 0x00	; 0
    1098:	80 81       	ld	r24, Z
    109a:	87 7f       	andi	r24, 0xF7	; 247
    109c:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN4);
    109e:	ae e4       	ldi	r26, 0x4E	; 78
    10a0:	b0 e0       	ldi	r27, 0x00	; 0
    10a2:	ee e4       	ldi	r30, 0x4E	; 78
    10a4:	f0 e0       	ldi	r31, 0x00	; 0
    10a6:	80 81       	ld	r24, Z
    10a8:	8f 7e       	andi	r24, 0xEF	; 239
    10aa:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    10ac:	19 82       	std	Y+1, r1	; 0x01
    10ae:	cd c1       	rjmp	.+922    	; 0x144a <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == PWM_PHASE_CORRECT_9bit) {
    10b0:	8a 81       	ldd	r24, Y+2	; 0x02
    10b2:	82 30       	cpi	r24, 0x02	; 2
    10b4:	f1 f4       	brne	.+60     	; 0x10f2 <MCAL_T1_u8T1Init+0xde>
			CLR_BIT(TCCR1A, PIN0);
    10b6:	af e4       	ldi	r26, 0x4F	; 79
    10b8:	b0 e0       	ldi	r27, 0x00	; 0
    10ba:	ef e4       	ldi	r30, 0x4F	; 79
    10bc:	f0 e0       	ldi	r31, 0x00	; 0
    10be:	80 81       	ld	r24, Z
    10c0:	8e 7f       	andi	r24, 0xFE	; 254
    10c2:	8c 93       	st	X, r24
			SET_BIT(TCCR1A, PIN1);
    10c4:	af e4       	ldi	r26, 0x4F	; 79
    10c6:	b0 e0       	ldi	r27, 0x00	; 0
    10c8:	ef e4       	ldi	r30, 0x4F	; 79
    10ca:	f0 e0       	ldi	r31, 0x00	; 0
    10cc:	80 81       	ld	r24, Z
    10ce:	82 60       	ori	r24, 0x02	; 2
    10d0:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN3);
    10d2:	ae e4       	ldi	r26, 0x4E	; 78
    10d4:	b0 e0       	ldi	r27, 0x00	; 0
    10d6:	ee e4       	ldi	r30, 0x4E	; 78
    10d8:	f0 e0       	ldi	r31, 0x00	; 0
    10da:	80 81       	ld	r24, Z
    10dc:	87 7f       	andi	r24, 0xF7	; 247
    10de:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN4);
    10e0:	ae e4       	ldi	r26, 0x4E	; 78
    10e2:	b0 e0       	ldi	r27, 0x00	; 0
    10e4:	ee e4       	ldi	r30, 0x4E	; 78
    10e6:	f0 e0       	ldi	r31, 0x00	; 0
    10e8:	80 81       	ld	r24, Z
    10ea:	8f 7e       	andi	r24, 0xEF	; 239
    10ec:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    10ee:	19 82       	std	Y+1, r1	; 0x01
    10f0:	ac c1       	rjmp	.+856    	; 0x144a <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == PWM_PHASE_CORRECT_10bit) {
    10f2:	8a 81       	ldd	r24, Y+2	; 0x02
    10f4:	83 30       	cpi	r24, 0x03	; 3
    10f6:	f1 f4       	brne	.+60     	; 0x1134 <MCAL_T1_u8T1Init+0x120>
			SET_BIT(TCCR1A, PIN0);
    10f8:	af e4       	ldi	r26, 0x4F	; 79
    10fa:	b0 e0       	ldi	r27, 0x00	; 0
    10fc:	ef e4       	ldi	r30, 0x4F	; 79
    10fe:	f0 e0       	ldi	r31, 0x00	; 0
    1100:	80 81       	ld	r24, Z
    1102:	81 60       	ori	r24, 0x01	; 1
    1104:	8c 93       	st	X, r24
			SET_BIT(TCCR1A, PIN1);
    1106:	af e4       	ldi	r26, 0x4F	; 79
    1108:	b0 e0       	ldi	r27, 0x00	; 0
    110a:	ef e4       	ldi	r30, 0x4F	; 79
    110c:	f0 e0       	ldi	r31, 0x00	; 0
    110e:	80 81       	ld	r24, Z
    1110:	82 60       	ori	r24, 0x02	; 2
    1112:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN3);
    1114:	ae e4       	ldi	r26, 0x4E	; 78
    1116:	b0 e0       	ldi	r27, 0x00	; 0
    1118:	ee e4       	ldi	r30, 0x4E	; 78
    111a:	f0 e0       	ldi	r31, 0x00	; 0
    111c:	80 81       	ld	r24, Z
    111e:	87 7f       	andi	r24, 0xF7	; 247
    1120:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN4);
    1122:	ae e4       	ldi	r26, 0x4E	; 78
    1124:	b0 e0       	ldi	r27, 0x00	; 0
    1126:	ee e4       	ldi	r30, 0x4E	; 78
    1128:	f0 e0       	ldi	r31, 0x00	; 0
    112a:	80 81       	ld	r24, Z
    112c:	8f 7e       	andi	r24, 0xEF	; 239
    112e:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    1130:	19 82       	std	Y+1, r1	; 0x01
    1132:	8b c1       	rjmp	.+790    	; 0x144a <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == CTC_OCR1A) {
    1134:	8a 81       	ldd	r24, Y+2	; 0x02
    1136:	84 30       	cpi	r24, 0x04	; 4
    1138:	f1 f4       	brne	.+60     	; 0x1176 <MCAL_T1_u8T1Init+0x162>
			CLR_BIT(TCCR1A, PIN0);
    113a:	af e4       	ldi	r26, 0x4F	; 79
    113c:	b0 e0       	ldi	r27, 0x00	; 0
    113e:	ef e4       	ldi	r30, 0x4F	; 79
    1140:	f0 e0       	ldi	r31, 0x00	; 0
    1142:	80 81       	ld	r24, Z
    1144:	8e 7f       	andi	r24, 0xFE	; 254
    1146:	8c 93       	st	X, r24
			CLR_BIT(TCCR1A, PIN1);
    1148:	af e4       	ldi	r26, 0x4F	; 79
    114a:	b0 e0       	ldi	r27, 0x00	; 0
    114c:	ef e4       	ldi	r30, 0x4F	; 79
    114e:	f0 e0       	ldi	r31, 0x00	; 0
    1150:	80 81       	ld	r24, Z
    1152:	8d 7f       	andi	r24, 0xFD	; 253
    1154:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN3);
    1156:	ae e4       	ldi	r26, 0x4E	; 78
    1158:	b0 e0       	ldi	r27, 0x00	; 0
    115a:	ee e4       	ldi	r30, 0x4E	; 78
    115c:	f0 e0       	ldi	r31, 0x00	; 0
    115e:	80 81       	ld	r24, Z
    1160:	88 60       	ori	r24, 0x08	; 8
    1162:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN4);
    1164:	ae e4       	ldi	r26, 0x4E	; 78
    1166:	b0 e0       	ldi	r27, 0x00	; 0
    1168:	ee e4       	ldi	r30, 0x4E	; 78
    116a:	f0 e0       	ldi	r31, 0x00	; 0
    116c:	80 81       	ld	r24, Z
    116e:	8f 7e       	andi	r24, 0xEF	; 239
    1170:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    1172:	19 82       	std	Y+1, r1	; 0x01
    1174:	6a c1       	rjmp	.+724    	; 0x144a <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == FAST_PWM_8bit) {
    1176:	8a 81       	ldd	r24, Y+2	; 0x02
    1178:	85 30       	cpi	r24, 0x05	; 5
    117a:	f1 f4       	brne	.+60     	; 0x11b8 <MCAL_T1_u8T1Init+0x1a4>
			SET_BIT(TCCR1A, PIN0);
    117c:	af e4       	ldi	r26, 0x4F	; 79
    117e:	b0 e0       	ldi	r27, 0x00	; 0
    1180:	ef e4       	ldi	r30, 0x4F	; 79
    1182:	f0 e0       	ldi	r31, 0x00	; 0
    1184:	80 81       	ld	r24, Z
    1186:	81 60       	ori	r24, 0x01	; 1
    1188:	8c 93       	st	X, r24
			CLR_BIT(TCCR1A, PIN1);
    118a:	af e4       	ldi	r26, 0x4F	; 79
    118c:	b0 e0       	ldi	r27, 0x00	; 0
    118e:	ef e4       	ldi	r30, 0x4F	; 79
    1190:	f0 e0       	ldi	r31, 0x00	; 0
    1192:	80 81       	ld	r24, Z
    1194:	8d 7f       	andi	r24, 0xFD	; 253
    1196:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN3);
    1198:	ae e4       	ldi	r26, 0x4E	; 78
    119a:	b0 e0       	ldi	r27, 0x00	; 0
    119c:	ee e4       	ldi	r30, 0x4E	; 78
    119e:	f0 e0       	ldi	r31, 0x00	; 0
    11a0:	80 81       	ld	r24, Z
    11a2:	88 60       	ori	r24, 0x08	; 8
    11a4:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN4);
    11a6:	ae e4       	ldi	r26, 0x4E	; 78
    11a8:	b0 e0       	ldi	r27, 0x00	; 0
    11aa:	ee e4       	ldi	r30, 0x4E	; 78
    11ac:	f0 e0       	ldi	r31, 0x00	; 0
    11ae:	80 81       	ld	r24, Z
    11b0:	8f 7e       	andi	r24, 0xEF	; 239
    11b2:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    11b4:	19 82       	std	Y+1, r1	; 0x01
    11b6:	49 c1       	rjmp	.+658    	; 0x144a <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == FAST_PWM_9bit) {
    11b8:	8a 81       	ldd	r24, Y+2	; 0x02
    11ba:	86 30       	cpi	r24, 0x06	; 6
    11bc:	f1 f4       	brne	.+60     	; 0x11fa <MCAL_T1_u8T1Init+0x1e6>
			CLR_BIT(TCCR1A, PIN0);
    11be:	af e4       	ldi	r26, 0x4F	; 79
    11c0:	b0 e0       	ldi	r27, 0x00	; 0
    11c2:	ef e4       	ldi	r30, 0x4F	; 79
    11c4:	f0 e0       	ldi	r31, 0x00	; 0
    11c6:	80 81       	ld	r24, Z
    11c8:	8e 7f       	andi	r24, 0xFE	; 254
    11ca:	8c 93       	st	X, r24
			SET_BIT(TCCR1A, PIN1);
    11cc:	af e4       	ldi	r26, 0x4F	; 79
    11ce:	b0 e0       	ldi	r27, 0x00	; 0
    11d0:	ef e4       	ldi	r30, 0x4F	; 79
    11d2:	f0 e0       	ldi	r31, 0x00	; 0
    11d4:	80 81       	ld	r24, Z
    11d6:	82 60       	ori	r24, 0x02	; 2
    11d8:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN3);
    11da:	ae e4       	ldi	r26, 0x4E	; 78
    11dc:	b0 e0       	ldi	r27, 0x00	; 0
    11de:	ee e4       	ldi	r30, 0x4E	; 78
    11e0:	f0 e0       	ldi	r31, 0x00	; 0
    11e2:	80 81       	ld	r24, Z
    11e4:	88 60       	ori	r24, 0x08	; 8
    11e6:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN4);
    11e8:	ae e4       	ldi	r26, 0x4E	; 78
    11ea:	b0 e0       	ldi	r27, 0x00	; 0
    11ec:	ee e4       	ldi	r30, 0x4E	; 78
    11ee:	f0 e0       	ldi	r31, 0x00	; 0
    11f0:	80 81       	ld	r24, Z
    11f2:	8f 7e       	andi	r24, 0xEF	; 239
    11f4:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    11f6:	19 82       	std	Y+1, r1	; 0x01
    11f8:	28 c1       	rjmp	.+592    	; 0x144a <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == FAST_PWM_10bit) {
    11fa:	8a 81       	ldd	r24, Y+2	; 0x02
    11fc:	87 30       	cpi	r24, 0x07	; 7
    11fe:	f1 f4       	brne	.+60     	; 0x123c <MCAL_T1_u8T1Init+0x228>
			SET_BIT(TCCR1A, PIN0);
    1200:	af e4       	ldi	r26, 0x4F	; 79
    1202:	b0 e0       	ldi	r27, 0x00	; 0
    1204:	ef e4       	ldi	r30, 0x4F	; 79
    1206:	f0 e0       	ldi	r31, 0x00	; 0
    1208:	80 81       	ld	r24, Z
    120a:	81 60       	ori	r24, 0x01	; 1
    120c:	8c 93       	st	X, r24
			SET_BIT(TCCR1A, PIN1);
    120e:	af e4       	ldi	r26, 0x4F	; 79
    1210:	b0 e0       	ldi	r27, 0x00	; 0
    1212:	ef e4       	ldi	r30, 0x4F	; 79
    1214:	f0 e0       	ldi	r31, 0x00	; 0
    1216:	80 81       	ld	r24, Z
    1218:	82 60       	ori	r24, 0x02	; 2
    121a:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN3);
    121c:	ae e4       	ldi	r26, 0x4E	; 78
    121e:	b0 e0       	ldi	r27, 0x00	; 0
    1220:	ee e4       	ldi	r30, 0x4E	; 78
    1222:	f0 e0       	ldi	r31, 0x00	; 0
    1224:	80 81       	ld	r24, Z
    1226:	88 60       	ori	r24, 0x08	; 8
    1228:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN4);
    122a:	ae e4       	ldi	r26, 0x4E	; 78
    122c:	b0 e0       	ldi	r27, 0x00	; 0
    122e:	ee e4       	ldi	r30, 0x4E	; 78
    1230:	f0 e0       	ldi	r31, 0x00	; 0
    1232:	80 81       	ld	r24, Z
    1234:	8f 7e       	andi	r24, 0xEF	; 239
    1236:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    1238:	19 82       	std	Y+1, r1	; 0x01
    123a:	07 c1       	rjmp	.+526    	; 0x144a <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == PWM_PHASE_AND_FREQUANCY_CORRECT_ICR1) {
    123c:	8a 81       	ldd	r24, Y+2	; 0x02
    123e:	88 30       	cpi	r24, 0x08	; 8
    1240:	f1 f4       	brne	.+60     	; 0x127e <MCAL_T1_u8T1Init+0x26a>
			CLR_BIT(TCCR1A, PIN0);
    1242:	af e4       	ldi	r26, 0x4F	; 79
    1244:	b0 e0       	ldi	r27, 0x00	; 0
    1246:	ef e4       	ldi	r30, 0x4F	; 79
    1248:	f0 e0       	ldi	r31, 0x00	; 0
    124a:	80 81       	ld	r24, Z
    124c:	8e 7f       	andi	r24, 0xFE	; 254
    124e:	8c 93       	st	X, r24
			CLR_BIT(TCCR1A, PIN1);
    1250:	af e4       	ldi	r26, 0x4F	; 79
    1252:	b0 e0       	ldi	r27, 0x00	; 0
    1254:	ef e4       	ldi	r30, 0x4F	; 79
    1256:	f0 e0       	ldi	r31, 0x00	; 0
    1258:	80 81       	ld	r24, Z
    125a:	8d 7f       	andi	r24, 0xFD	; 253
    125c:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN3);
    125e:	ae e4       	ldi	r26, 0x4E	; 78
    1260:	b0 e0       	ldi	r27, 0x00	; 0
    1262:	ee e4       	ldi	r30, 0x4E	; 78
    1264:	f0 e0       	ldi	r31, 0x00	; 0
    1266:	80 81       	ld	r24, Z
    1268:	87 7f       	andi	r24, 0xF7	; 247
    126a:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN4);
    126c:	ae e4       	ldi	r26, 0x4E	; 78
    126e:	b0 e0       	ldi	r27, 0x00	; 0
    1270:	ee e4       	ldi	r30, 0x4E	; 78
    1272:	f0 e0       	ldi	r31, 0x00	; 0
    1274:	80 81       	ld	r24, Z
    1276:	80 61       	ori	r24, 0x10	; 16
    1278:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    127a:	19 82       	std	Y+1, r1	; 0x01
    127c:	e6 c0       	rjmp	.+460    	; 0x144a <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == PWM_PHASE_AND_FREQUANCY_CORRECT_OCR1A) {
    127e:	8a 81       	ldd	r24, Y+2	; 0x02
    1280:	89 30       	cpi	r24, 0x09	; 9
    1282:	f1 f4       	brne	.+60     	; 0x12c0 <MCAL_T1_u8T1Init+0x2ac>
			SET_BIT(TCCR1A, PIN0);
    1284:	af e4       	ldi	r26, 0x4F	; 79
    1286:	b0 e0       	ldi	r27, 0x00	; 0
    1288:	ef e4       	ldi	r30, 0x4F	; 79
    128a:	f0 e0       	ldi	r31, 0x00	; 0
    128c:	80 81       	ld	r24, Z
    128e:	81 60       	ori	r24, 0x01	; 1
    1290:	8c 93       	st	X, r24
			CLR_BIT(TCCR1A, PIN1);
    1292:	af e4       	ldi	r26, 0x4F	; 79
    1294:	b0 e0       	ldi	r27, 0x00	; 0
    1296:	ef e4       	ldi	r30, 0x4F	; 79
    1298:	f0 e0       	ldi	r31, 0x00	; 0
    129a:	80 81       	ld	r24, Z
    129c:	8d 7f       	andi	r24, 0xFD	; 253
    129e:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN3);
    12a0:	ae e4       	ldi	r26, 0x4E	; 78
    12a2:	b0 e0       	ldi	r27, 0x00	; 0
    12a4:	ee e4       	ldi	r30, 0x4E	; 78
    12a6:	f0 e0       	ldi	r31, 0x00	; 0
    12a8:	80 81       	ld	r24, Z
    12aa:	87 7f       	andi	r24, 0xF7	; 247
    12ac:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN4);
    12ae:	ae e4       	ldi	r26, 0x4E	; 78
    12b0:	b0 e0       	ldi	r27, 0x00	; 0
    12b2:	ee e4       	ldi	r30, 0x4E	; 78
    12b4:	f0 e0       	ldi	r31, 0x00	; 0
    12b6:	80 81       	ld	r24, Z
    12b8:	80 61       	ori	r24, 0x10	; 16
    12ba:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    12bc:	19 82       	std	Y+1, r1	; 0x01
    12be:	c5 c0       	rjmp	.+394    	; 0x144a <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == PWM_PHASE_CORRECT_ICR1) {
    12c0:	8a 81       	ldd	r24, Y+2	; 0x02
    12c2:	8a 30       	cpi	r24, 0x0A	; 10
    12c4:	f1 f4       	brne	.+60     	; 0x1302 <MCAL_T1_u8T1Init+0x2ee>
			CLR_BIT(TCCR1A, PIN0);
    12c6:	af e4       	ldi	r26, 0x4F	; 79
    12c8:	b0 e0       	ldi	r27, 0x00	; 0
    12ca:	ef e4       	ldi	r30, 0x4F	; 79
    12cc:	f0 e0       	ldi	r31, 0x00	; 0
    12ce:	80 81       	ld	r24, Z
    12d0:	8e 7f       	andi	r24, 0xFE	; 254
    12d2:	8c 93       	st	X, r24
			SET_BIT(TCCR1A, PIN1);
    12d4:	af e4       	ldi	r26, 0x4F	; 79
    12d6:	b0 e0       	ldi	r27, 0x00	; 0
    12d8:	ef e4       	ldi	r30, 0x4F	; 79
    12da:	f0 e0       	ldi	r31, 0x00	; 0
    12dc:	80 81       	ld	r24, Z
    12de:	82 60       	ori	r24, 0x02	; 2
    12e0:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN3);
    12e2:	ae e4       	ldi	r26, 0x4E	; 78
    12e4:	b0 e0       	ldi	r27, 0x00	; 0
    12e6:	ee e4       	ldi	r30, 0x4E	; 78
    12e8:	f0 e0       	ldi	r31, 0x00	; 0
    12ea:	80 81       	ld	r24, Z
    12ec:	87 7f       	andi	r24, 0xF7	; 247
    12ee:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN4);
    12f0:	ae e4       	ldi	r26, 0x4E	; 78
    12f2:	b0 e0       	ldi	r27, 0x00	; 0
    12f4:	ee e4       	ldi	r30, 0x4E	; 78
    12f6:	f0 e0       	ldi	r31, 0x00	; 0
    12f8:	80 81       	ld	r24, Z
    12fa:	80 61       	ori	r24, 0x10	; 16
    12fc:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    12fe:	19 82       	std	Y+1, r1	; 0x01
    1300:	a4 c0       	rjmp	.+328    	; 0x144a <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == PWM_PHASE_CORRECT_OCR1A) {
    1302:	8a 81       	ldd	r24, Y+2	; 0x02
    1304:	8b 30       	cpi	r24, 0x0B	; 11
    1306:	f1 f4       	brne	.+60     	; 0x1344 <MCAL_T1_u8T1Init+0x330>
			SET_BIT(TCCR1A, PIN0);
    1308:	af e4       	ldi	r26, 0x4F	; 79
    130a:	b0 e0       	ldi	r27, 0x00	; 0
    130c:	ef e4       	ldi	r30, 0x4F	; 79
    130e:	f0 e0       	ldi	r31, 0x00	; 0
    1310:	80 81       	ld	r24, Z
    1312:	81 60       	ori	r24, 0x01	; 1
    1314:	8c 93       	st	X, r24
			SET_BIT(TCCR1A, PIN1);
    1316:	af e4       	ldi	r26, 0x4F	; 79
    1318:	b0 e0       	ldi	r27, 0x00	; 0
    131a:	ef e4       	ldi	r30, 0x4F	; 79
    131c:	f0 e0       	ldi	r31, 0x00	; 0
    131e:	80 81       	ld	r24, Z
    1320:	82 60       	ori	r24, 0x02	; 2
    1322:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN3);
    1324:	ae e4       	ldi	r26, 0x4E	; 78
    1326:	b0 e0       	ldi	r27, 0x00	; 0
    1328:	ee e4       	ldi	r30, 0x4E	; 78
    132a:	f0 e0       	ldi	r31, 0x00	; 0
    132c:	80 81       	ld	r24, Z
    132e:	87 7f       	andi	r24, 0xF7	; 247
    1330:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN4);
    1332:	ae e4       	ldi	r26, 0x4E	; 78
    1334:	b0 e0       	ldi	r27, 0x00	; 0
    1336:	ee e4       	ldi	r30, 0x4E	; 78
    1338:	f0 e0       	ldi	r31, 0x00	; 0
    133a:	80 81       	ld	r24, Z
    133c:	80 61       	ori	r24, 0x10	; 16
    133e:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    1340:	19 82       	std	Y+1, r1	; 0x01
    1342:	83 c0       	rjmp	.+262    	; 0x144a <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == CTC_ICR1) {
    1344:	8a 81       	ldd	r24, Y+2	; 0x02
    1346:	8c 30       	cpi	r24, 0x0C	; 12
    1348:	f1 f4       	brne	.+60     	; 0x1386 <MCAL_T1_u8T1Init+0x372>
			CLR_BIT(TCCR1A, PIN0);
    134a:	af e4       	ldi	r26, 0x4F	; 79
    134c:	b0 e0       	ldi	r27, 0x00	; 0
    134e:	ef e4       	ldi	r30, 0x4F	; 79
    1350:	f0 e0       	ldi	r31, 0x00	; 0
    1352:	80 81       	ld	r24, Z
    1354:	8e 7f       	andi	r24, 0xFE	; 254
    1356:	8c 93       	st	X, r24
			CLR_BIT(TCCR1A, PIN1);
    1358:	af e4       	ldi	r26, 0x4F	; 79
    135a:	b0 e0       	ldi	r27, 0x00	; 0
    135c:	ef e4       	ldi	r30, 0x4F	; 79
    135e:	f0 e0       	ldi	r31, 0x00	; 0
    1360:	80 81       	ld	r24, Z
    1362:	8d 7f       	andi	r24, 0xFD	; 253
    1364:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN3);
    1366:	ae e4       	ldi	r26, 0x4E	; 78
    1368:	b0 e0       	ldi	r27, 0x00	; 0
    136a:	ee e4       	ldi	r30, 0x4E	; 78
    136c:	f0 e0       	ldi	r31, 0x00	; 0
    136e:	80 81       	ld	r24, Z
    1370:	88 60       	ori	r24, 0x08	; 8
    1372:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN4);
    1374:	ae e4       	ldi	r26, 0x4E	; 78
    1376:	b0 e0       	ldi	r27, 0x00	; 0
    1378:	ee e4       	ldi	r30, 0x4E	; 78
    137a:	f0 e0       	ldi	r31, 0x00	; 0
    137c:	80 81       	ld	r24, Z
    137e:	80 61       	ori	r24, 0x10	; 16
    1380:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    1382:	19 82       	std	Y+1, r1	; 0x01
    1384:	62 c0       	rjmp	.+196    	; 0x144a <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == REVERSED_MODE) {
    1386:	8a 81       	ldd	r24, Y+2	; 0x02
    1388:	8d 30       	cpi	r24, 0x0D	; 13
    138a:	f1 f4       	brne	.+60     	; 0x13c8 <MCAL_T1_u8T1Init+0x3b4>
			SET_BIT(TCCR1A, PIN0);
    138c:	af e4       	ldi	r26, 0x4F	; 79
    138e:	b0 e0       	ldi	r27, 0x00	; 0
    1390:	ef e4       	ldi	r30, 0x4F	; 79
    1392:	f0 e0       	ldi	r31, 0x00	; 0
    1394:	80 81       	ld	r24, Z
    1396:	81 60       	ori	r24, 0x01	; 1
    1398:	8c 93       	st	X, r24
			CLR_BIT(TCCR1A, PIN1);
    139a:	af e4       	ldi	r26, 0x4F	; 79
    139c:	b0 e0       	ldi	r27, 0x00	; 0
    139e:	ef e4       	ldi	r30, 0x4F	; 79
    13a0:	f0 e0       	ldi	r31, 0x00	; 0
    13a2:	80 81       	ld	r24, Z
    13a4:	8d 7f       	andi	r24, 0xFD	; 253
    13a6:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN3);
    13a8:	ae e4       	ldi	r26, 0x4E	; 78
    13aa:	b0 e0       	ldi	r27, 0x00	; 0
    13ac:	ee e4       	ldi	r30, 0x4E	; 78
    13ae:	f0 e0       	ldi	r31, 0x00	; 0
    13b0:	80 81       	ld	r24, Z
    13b2:	88 60       	ori	r24, 0x08	; 8
    13b4:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN4);
    13b6:	ae e4       	ldi	r26, 0x4E	; 78
    13b8:	b0 e0       	ldi	r27, 0x00	; 0
    13ba:	ee e4       	ldi	r30, 0x4E	; 78
    13bc:	f0 e0       	ldi	r31, 0x00	; 0
    13be:	80 81       	ld	r24, Z
    13c0:	80 61       	ori	r24, 0x10	; 16
    13c2:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    13c4:	19 82       	std	Y+1, r1	; 0x01
    13c6:	41 c0       	rjmp	.+130    	; 0x144a <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == FAST_PWM_ICR1) {
    13c8:	8a 81       	ldd	r24, Y+2	; 0x02
    13ca:	8e 30       	cpi	r24, 0x0E	; 14
    13cc:	f1 f4       	brne	.+60     	; 0x140a <MCAL_T1_u8T1Init+0x3f6>
			CLR_BIT(TCCR1A, PIN0);
    13ce:	af e4       	ldi	r26, 0x4F	; 79
    13d0:	b0 e0       	ldi	r27, 0x00	; 0
    13d2:	ef e4       	ldi	r30, 0x4F	; 79
    13d4:	f0 e0       	ldi	r31, 0x00	; 0
    13d6:	80 81       	ld	r24, Z
    13d8:	8e 7f       	andi	r24, 0xFE	; 254
    13da:	8c 93       	st	X, r24
			SET_BIT(TCCR1A, PIN1);
    13dc:	af e4       	ldi	r26, 0x4F	; 79
    13de:	b0 e0       	ldi	r27, 0x00	; 0
    13e0:	ef e4       	ldi	r30, 0x4F	; 79
    13e2:	f0 e0       	ldi	r31, 0x00	; 0
    13e4:	80 81       	ld	r24, Z
    13e6:	82 60       	ori	r24, 0x02	; 2
    13e8:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN3);
    13ea:	ae e4       	ldi	r26, 0x4E	; 78
    13ec:	b0 e0       	ldi	r27, 0x00	; 0
    13ee:	ee e4       	ldi	r30, 0x4E	; 78
    13f0:	f0 e0       	ldi	r31, 0x00	; 0
    13f2:	80 81       	ld	r24, Z
    13f4:	88 60       	ori	r24, 0x08	; 8
    13f6:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN4);
    13f8:	ae e4       	ldi	r26, 0x4E	; 78
    13fa:	b0 e0       	ldi	r27, 0x00	; 0
    13fc:	ee e4       	ldi	r30, 0x4E	; 78
    13fe:	f0 e0       	ldi	r31, 0x00	; 0
    1400:	80 81       	ld	r24, Z
    1402:	80 61       	ori	r24, 0x10	; 16
    1404:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    1406:	19 82       	std	Y+1, r1	; 0x01
    1408:	20 c0       	rjmp	.+64     	; 0x144a <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == FAST_PWM_OCR1A) {
    140a:	8a 81       	ldd	r24, Y+2	; 0x02
    140c:	8f 30       	cpi	r24, 0x0F	; 15
    140e:	e9 f4       	brne	.+58     	; 0x144a <MCAL_T1_u8T1Init+0x436>
			SET_BIT(TCCR1A, PIN0);
    1410:	af e4       	ldi	r26, 0x4F	; 79
    1412:	b0 e0       	ldi	r27, 0x00	; 0
    1414:	ef e4       	ldi	r30, 0x4F	; 79
    1416:	f0 e0       	ldi	r31, 0x00	; 0
    1418:	80 81       	ld	r24, Z
    141a:	81 60       	ori	r24, 0x01	; 1
    141c:	8c 93       	st	X, r24
			SET_BIT(TCCR1A, PIN1);
    141e:	af e4       	ldi	r26, 0x4F	; 79
    1420:	b0 e0       	ldi	r27, 0x00	; 0
    1422:	ef e4       	ldi	r30, 0x4F	; 79
    1424:	f0 e0       	ldi	r31, 0x00	; 0
    1426:	80 81       	ld	r24, Z
    1428:	82 60       	ori	r24, 0x02	; 2
    142a:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN3);
    142c:	ae e4       	ldi	r26, 0x4E	; 78
    142e:	b0 e0       	ldi	r27, 0x00	; 0
    1430:	ee e4       	ldi	r30, 0x4E	; 78
    1432:	f0 e0       	ldi	r31, 0x00	; 0
    1434:	80 81       	ld	r24, Z
    1436:	88 60       	ori	r24, 0x08	; 8
    1438:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN4);
    143a:	ae e4       	ldi	r26, 0x4E	; 78
    143c:	b0 e0       	ldi	r27, 0x00	; 0
    143e:	ee e4       	ldi	r30, 0x4E	; 78
    1440:	f0 e0       	ldi	r31, 0x00	; 0
    1442:	80 81       	ld	r24, Z
    1444:	80 61       	ori	r24, 0x10	; 16
    1446:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    1448:	19 82       	std	Y+1, r1	; 0x01
			//NOTHING
		}
	} else {
		//NOTHING
	}
	return LOC_u8ReturnValue;
    144a:	89 81       	ldd	r24, Y+1	; 0x01
}
    144c:	0f 90       	pop	r0
    144e:	0f 90       	pop	r0
    1450:	cf 91       	pop	r28
    1452:	df 91       	pop	r29
    1454:	08 95       	ret

00001456 <MCAL_T1_u8T1Prescaler>:
u8 MCAL_T1_u8T1Prescaler(u8 LOC_u8Clock_Selection, f32 *LOC_pfl32TickTime) {
    1456:	df 93       	push	r29
    1458:	cf 93       	push	r28
    145a:	00 d0       	rcall	.+0      	; 0x145c <MCAL_T1_u8T1Prescaler+0x6>
    145c:	00 d0       	rcall	.+0      	; 0x145e <MCAL_T1_u8T1Prescaler+0x8>
    145e:	cd b7       	in	r28, 0x3d	; 61
    1460:	de b7       	in	r29, 0x3e	; 62
    1462:	8a 83       	std	Y+2, r24	; 0x02
    1464:	7c 83       	std	Y+4, r23	; 0x04
    1466:	6b 83       	std	Y+3, r22	; 0x03
	u8 LOC_u8ReturnValue = E_NOT_OK;
    1468:	81 e0       	ldi	r24, 0x01	; 1
    146a:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_u8Clock_Selection <= EXTERNAL_RISING_EDGE) {
    146c:	8a 81       	ldd	r24, Y+2	; 0x02
    146e:	88 30       	cpi	r24, 0x08	; 8
    1470:	08 f0       	brcs	.+2      	; 0x1474 <MCAL_T1_u8T1Prescaler+0x1e>
    1472:	01 c1       	rjmp	.+514    	; 0x1676 <MCAL_T1_u8T1Prescaler+0x220>
		if (LOC_u8Clock_Selection == COUNTER_STOP) {
    1474:	8a 81       	ldd	r24, Y+2	; 0x02
    1476:	88 23       	and	r24, r24
    1478:	b9 f4       	brne	.+46     	; 0x14a8 <MCAL_T1_u8T1Prescaler+0x52>
			CLR_BIT(TCCR1B, PIN0);
    147a:	ae e4       	ldi	r26, 0x4E	; 78
    147c:	b0 e0       	ldi	r27, 0x00	; 0
    147e:	ee e4       	ldi	r30, 0x4E	; 78
    1480:	f0 e0       	ldi	r31, 0x00	; 0
    1482:	80 81       	ld	r24, Z
    1484:	8e 7f       	andi	r24, 0xFE	; 254
    1486:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN1);
    1488:	ae e4       	ldi	r26, 0x4E	; 78
    148a:	b0 e0       	ldi	r27, 0x00	; 0
    148c:	ee e4       	ldi	r30, 0x4E	; 78
    148e:	f0 e0       	ldi	r31, 0x00	; 0
    1490:	80 81       	ld	r24, Z
    1492:	8d 7f       	andi	r24, 0xFD	; 253
    1494:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN2);
    1496:	ae e4       	ldi	r26, 0x4E	; 78
    1498:	b0 e0       	ldi	r27, 0x00	; 0
    149a:	ee e4       	ldi	r30, 0x4E	; 78
    149c:	f0 e0       	ldi	r31, 0x00	; 0
    149e:	80 81       	ld	r24, Z
    14a0:	8b 7f       	andi	r24, 0xFB	; 251
    14a2:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    14a4:	19 82       	std	Y+1, r1	; 0x01
    14a6:	e7 c0       	rjmp	.+462    	; 0x1676 <MCAL_T1_u8T1Prescaler+0x220>
		} else if (LOC_u8Clock_Selection == PRESCALLING_0) {
    14a8:	8a 81       	ldd	r24, Y+2	; 0x02
    14aa:	81 30       	cpi	r24, 0x01	; 1
    14ac:	09 f5       	brne	.+66     	; 0x14f0 <MCAL_T1_u8T1Prescaler+0x9a>
			SET_BIT(TCCR1B, PIN0);
    14ae:	ae e4       	ldi	r26, 0x4E	; 78
    14b0:	b0 e0       	ldi	r27, 0x00	; 0
    14b2:	ee e4       	ldi	r30, 0x4E	; 78
    14b4:	f0 e0       	ldi	r31, 0x00	; 0
    14b6:	80 81       	ld	r24, Z
    14b8:	81 60       	ori	r24, 0x01	; 1
    14ba:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN1);
    14bc:	ae e4       	ldi	r26, 0x4E	; 78
    14be:	b0 e0       	ldi	r27, 0x00	; 0
    14c0:	ee e4       	ldi	r30, 0x4E	; 78
    14c2:	f0 e0       	ldi	r31, 0x00	; 0
    14c4:	80 81       	ld	r24, Z
    14c6:	8d 7f       	andi	r24, 0xFD	; 253
    14c8:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN2);
    14ca:	ae e4       	ldi	r26, 0x4E	; 78
    14cc:	b0 e0       	ldi	r27, 0x00	; 0
    14ce:	ee e4       	ldi	r30, 0x4E	; 78
    14d0:	f0 e0       	ldi	r31, 0x00	; 0
    14d2:	80 81       	ld	r24, Z
    14d4:	8b 7f       	andi	r24, 0xFB	; 251
    14d6:	8c 93       	st	X, r24
			*LOC_pfl32TickTime = PRESCALLING0 / (f32) CPU_FREQUNCY;
    14d8:	eb 81       	ldd	r30, Y+3	; 0x03
    14da:	fc 81       	ldd	r31, Y+4	; 0x04
    14dc:	8d eb       	ldi	r24, 0xBD	; 189
    14de:	97 e3       	ldi	r25, 0x37	; 55
    14e0:	a6 e8       	ldi	r26, 0x86	; 134
    14e2:	b3 e3       	ldi	r27, 0x33	; 51
    14e4:	80 83       	st	Z, r24
    14e6:	91 83       	std	Z+1, r25	; 0x01
    14e8:	a2 83       	std	Z+2, r26	; 0x02
    14ea:	b3 83       	std	Z+3, r27	; 0x03
			LOC_u8ReturnValue = E_OK;
    14ec:	19 82       	std	Y+1, r1	; 0x01
    14ee:	c3 c0       	rjmp	.+390    	; 0x1676 <MCAL_T1_u8T1Prescaler+0x220>
		} else if (LOC_u8Clock_Selection == PRESCALLING_8) {
    14f0:	8a 81       	ldd	r24, Y+2	; 0x02
    14f2:	82 30       	cpi	r24, 0x02	; 2
    14f4:	09 f5       	brne	.+66     	; 0x1538 <MCAL_T1_u8T1Prescaler+0xe2>
			CLR_BIT(TCCR1B, PIN0);
    14f6:	ae e4       	ldi	r26, 0x4E	; 78
    14f8:	b0 e0       	ldi	r27, 0x00	; 0
    14fa:	ee e4       	ldi	r30, 0x4E	; 78
    14fc:	f0 e0       	ldi	r31, 0x00	; 0
    14fe:	80 81       	ld	r24, Z
    1500:	8e 7f       	andi	r24, 0xFE	; 254
    1502:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN1);
    1504:	ae e4       	ldi	r26, 0x4E	; 78
    1506:	b0 e0       	ldi	r27, 0x00	; 0
    1508:	ee e4       	ldi	r30, 0x4E	; 78
    150a:	f0 e0       	ldi	r31, 0x00	; 0
    150c:	80 81       	ld	r24, Z
    150e:	82 60       	ori	r24, 0x02	; 2
    1510:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN2);
    1512:	ae e4       	ldi	r26, 0x4E	; 78
    1514:	b0 e0       	ldi	r27, 0x00	; 0
    1516:	ee e4       	ldi	r30, 0x4E	; 78
    1518:	f0 e0       	ldi	r31, 0x00	; 0
    151a:	80 81       	ld	r24, Z
    151c:	8b 7f       	andi	r24, 0xFB	; 251
    151e:	8c 93       	st	X, r24
			*LOC_pfl32TickTime = PRESCALLING8 / (f32) CPU_FREQUNCY;
    1520:	eb 81       	ldd	r30, Y+3	; 0x03
    1522:	fc 81       	ldd	r31, Y+4	; 0x04
    1524:	8d eb       	ldi	r24, 0xBD	; 189
    1526:	97 e3       	ldi	r25, 0x37	; 55
    1528:	a6 e0       	ldi	r26, 0x06	; 6
    152a:	b5 e3       	ldi	r27, 0x35	; 53
    152c:	80 83       	st	Z, r24
    152e:	91 83       	std	Z+1, r25	; 0x01
    1530:	a2 83       	std	Z+2, r26	; 0x02
    1532:	b3 83       	std	Z+3, r27	; 0x03
			LOC_u8ReturnValue = E_OK;
    1534:	19 82       	std	Y+1, r1	; 0x01
    1536:	9f c0       	rjmp	.+318    	; 0x1676 <MCAL_T1_u8T1Prescaler+0x220>
		} else if (LOC_u8Clock_Selection == PRESCALLING_64) {
    1538:	8a 81       	ldd	r24, Y+2	; 0x02
    153a:	83 30       	cpi	r24, 0x03	; 3
    153c:	09 f5       	brne	.+66     	; 0x1580 <MCAL_T1_u8T1Prescaler+0x12a>
			SET_BIT(TCCR1B, PIN0);
    153e:	ae e4       	ldi	r26, 0x4E	; 78
    1540:	b0 e0       	ldi	r27, 0x00	; 0
    1542:	ee e4       	ldi	r30, 0x4E	; 78
    1544:	f0 e0       	ldi	r31, 0x00	; 0
    1546:	80 81       	ld	r24, Z
    1548:	81 60       	ori	r24, 0x01	; 1
    154a:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN1);
    154c:	ae e4       	ldi	r26, 0x4E	; 78
    154e:	b0 e0       	ldi	r27, 0x00	; 0
    1550:	ee e4       	ldi	r30, 0x4E	; 78
    1552:	f0 e0       	ldi	r31, 0x00	; 0
    1554:	80 81       	ld	r24, Z
    1556:	82 60       	ori	r24, 0x02	; 2
    1558:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN2);
    155a:	ae e4       	ldi	r26, 0x4E	; 78
    155c:	b0 e0       	ldi	r27, 0x00	; 0
    155e:	ee e4       	ldi	r30, 0x4E	; 78
    1560:	f0 e0       	ldi	r31, 0x00	; 0
    1562:	80 81       	ld	r24, Z
    1564:	8b 7f       	andi	r24, 0xFB	; 251
    1566:	8c 93       	st	X, r24
			*LOC_pfl32TickTime = PRESCALLING64 / (f32) CPU_FREQUNCY;
    1568:	eb 81       	ldd	r30, Y+3	; 0x03
    156a:	fc 81       	ldd	r31, Y+4	; 0x04
    156c:	8d eb       	ldi	r24, 0xBD	; 189
    156e:	97 e3       	ldi	r25, 0x37	; 55
    1570:	a6 e8       	ldi	r26, 0x86	; 134
    1572:	b6 e3       	ldi	r27, 0x36	; 54
    1574:	80 83       	st	Z, r24
    1576:	91 83       	std	Z+1, r25	; 0x01
    1578:	a2 83       	std	Z+2, r26	; 0x02
    157a:	b3 83       	std	Z+3, r27	; 0x03
			LOC_u8ReturnValue = E_OK;
    157c:	19 82       	std	Y+1, r1	; 0x01
    157e:	7b c0       	rjmp	.+246    	; 0x1676 <MCAL_T1_u8T1Prescaler+0x220>
		} else if (LOC_u8Clock_Selection == PRESCALLING_256) {
    1580:	8a 81       	ldd	r24, Y+2	; 0x02
    1582:	84 30       	cpi	r24, 0x04	; 4
    1584:	09 f5       	brne	.+66     	; 0x15c8 <MCAL_T1_u8T1Prescaler+0x172>
			CLR_BIT(TCCR1B, PIN0);
    1586:	ae e4       	ldi	r26, 0x4E	; 78
    1588:	b0 e0       	ldi	r27, 0x00	; 0
    158a:	ee e4       	ldi	r30, 0x4E	; 78
    158c:	f0 e0       	ldi	r31, 0x00	; 0
    158e:	80 81       	ld	r24, Z
    1590:	8e 7f       	andi	r24, 0xFE	; 254
    1592:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN1);
    1594:	ae e4       	ldi	r26, 0x4E	; 78
    1596:	b0 e0       	ldi	r27, 0x00	; 0
    1598:	ee e4       	ldi	r30, 0x4E	; 78
    159a:	f0 e0       	ldi	r31, 0x00	; 0
    159c:	80 81       	ld	r24, Z
    159e:	8d 7f       	andi	r24, 0xFD	; 253
    15a0:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN2);
    15a2:	ae e4       	ldi	r26, 0x4E	; 78
    15a4:	b0 e0       	ldi	r27, 0x00	; 0
    15a6:	ee e4       	ldi	r30, 0x4E	; 78
    15a8:	f0 e0       	ldi	r31, 0x00	; 0
    15aa:	80 81       	ld	r24, Z
    15ac:	84 60       	ori	r24, 0x04	; 4
    15ae:	8c 93       	st	X, r24
			*LOC_pfl32TickTime = PRESCALLING256 / (f32) CPU_FREQUNCY;
    15b0:	eb 81       	ldd	r30, Y+3	; 0x03
    15b2:	fc 81       	ldd	r31, Y+4	; 0x04
    15b4:	8d eb       	ldi	r24, 0xBD	; 189
    15b6:	97 e3       	ldi	r25, 0x37	; 55
    15b8:	a6 e8       	ldi	r26, 0x86	; 134
    15ba:	b7 e3       	ldi	r27, 0x37	; 55
    15bc:	80 83       	st	Z, r24
    15be:	91 83       	std	Z+1, r25	; 0x01
    15c0:	a2 83       	std	Z+2, r26	; 0x02
    15c2:	b3 83       	std	Z+3, r27	; 0x03
			LOC_u8ReturnValue = E_OK;
    15c4:	19 82       	std	Y+1, r1	; 0x01
    15c6:	57 c0       	rjmp	.+174    	; 0x1676 <MCAL_T1_u8T1Prescaler+0x220>
		} else if (LOC_u8Clock_Selection == PRESCALLING_1024) {
    15c8:	8a 81       	ldd	r24, Y+2	; 0x02
    15ca:	85 30       	cpi	r24, 0x05	; 5
    15cc:	09 f5       	brne	.+66     	; 0x1610 <MCAL_T1_u8T1Prescaler+0x1ba>
			SET_BIT(TCCR1B, PIN0);
    15ce:	ae e4       	ldi	r26, 0x4E	; 78
    15d0:	b0 e0       	ldi	r27, 0x00	; 0
    15d2:	ee e4       	ldi	r30, 0x4E	; 78
    15d4:	f0 e0       	ldi	r31, 0x00	; 0
    15d6:	80 81       	ld	r24, Z
    15d8:	81 60       	ori	r24, 0x01	; 1
    15da:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, PIN1);
    15dc:	ae e4       	ldi	r26, 0x4E	; 78
    15de:	b0 e0       	ldi	r27, 0x00	; 0
    15e0:	ee e4       	ldi	r30, 0x4E	; 78
    15e2:	f0 e0       	ldi	r31, 0x00	; 0
    15e4:	80 81       	ld	r24, Z
    15e6:	8d 7f       	andi	r24, 0xFD	; 253
    15e8:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN2);
    15ea:	ae e4       	ldi	r26, 0x4E	; 78
    15ec:	b0 e0       	ldi	r27, 0x00	; 0
    15ee:	ee e4       	ldi	r30, 0x4E	; 78
    15f0:	f0 e0       	ldi	r31, 0x00	; 0
    15f2:	80 81       	ld	r24, Z
    15f4:	84 60       	ori	r24, 0x04	; 4
    15f6:	8c 93       	st	X, r24
			*LOC_pfl32TickTime = PRESCALLING1024 / (f32) CPU_FREQUNCY;
    15f8:	eb 81       	ldd	r30, Y+3	; 0x03
    15fa:	fc 81       	ldd	r31, Y+4	; 0x04
    15fc:	8d eb       	ldi	r24, 0xBD	; 189
    15fe:	97 e3       	ldi	r25, 0x37	; 55
    1600:	a6 e8       	ldi	r26, 0x86	; 134
    1602:	b8 e3       	ldi	r27, 0x38	; 56
    1604:	80 83       	st	Z, r24
    1606:	91 83       	std	Z+1, r25	; 0x01
    1608:	a2 83       	std	Z+2, r26	; 0x02
    160a:	b3 83       	std	Z+3, r27	; 0x03
			LOC_u8ReturnValue = E_OK;
    160c:	19 82       	std	Y+1, r1	; 0x01
    160e:	33 c0       	rjmp	.+102    	; 0x1676 <MCAL_T1_u8T1Prescaler+0x220>
		} else if (LOC_u8Clock_Selection == EXTERNAL_FALLING_EDGE) {
    1610:	8a 81       	ldd	r24, Y+2	; 0x02
    1612:	86 30       	cpi	r24, 0x06	; 6
    1614:	b9 f4       	brne	.+46     	; 0x1644 <MCAL_T1_u8T1Prescaler+0x1ee>
			CLR_BIT(TCCR1B, PIN0);
    1616:	ae e4       	ldi	r26, 0x4E	; 78
    1618:	b0 e0       	ldi	r27, 0x00	; 0
    161a:	ee e4       	ldi	r30, 0x4E	; 78
    161c:	f0 e0       	ldi	r31, 0x00	; 0
    161e:	80 81       	ld	r24, Z
    1620:	8e 7f       	andi	r24, 0xFE	; 254
    1622:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN1);
    1624:	ae e4       	ldi	r26, 0x4E	; 78
    1626:	b0 e0       	ldi	r27, 0x00	; 0
    1628:	ee e4       	ldi	r30, 0x4E	; 78
    162a:	f0 e0       	ldi	r31, 0x00	; 0
    162c:	80 81       	ld	r24, Z
    162e:	82 60       	ori	r24, 0x02	; 2
    1630:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN2);
    1632:	ae e4       	ldi	r26, 0x4E	; 78
    1634:	b0 e0       	ldi	r27, 0x00	; 0
    1636:	ee e4       	ldi	r30, 0x4E	; 78
    1638:	f0 e0       	ldi	r31, 0x00	; 0
    163a:	80 81       	ld	r24, Z
    163c:	84 60       	ori	r24, 0x04	; 4
    163e:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    1640:	19 82       	std	Y+1, r1	; 0x01
    1642:	19 c0       	rjmp	.+50     	; 0x1676 <MCAL_T1_u8T1Prescaler+0x220>
		} else if (LOC_u8Clock_Selection == EXTERNAL_RISING_EDGE) {
    1644:	8a 81       	ldd	r24, Y+2	; 0x02
    1646:	87 30       	cpi	r24, 0x07	; 7
    1648:	b1 f4       	brne	.+44     	; 0x1676 <MCAL_T1_u8T1Prescaler+0x220>
			SET_BIT(TCCR1B, PIN0);
    164a:	ae e4       	ldi	r26, 0x4E	; 78
    164c:	b0 e0       	ldi	r27, 0x00	; 0
    164e:	ee e4       	ldi	r30, 0x4E	; 78
    1650:	f0 e0       	ldi	r31, 0x00	; 0
    1652:	80 81       	ld	r24, Z
    1654:	81 60       	ori	r24, 0x01	; 1
    1656:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN1);
    1658:	ae e4       	ldi	r26, 0x4E	; 78
    165a:	b0 e0       	ldi	r27, 0x00	; 0
    165c:	ee e4       	ldi	r30, 0x4E	; 78
    165e:	f0 e0       	ldi	r31, 0x00	; 0
    1660:	80 81       	ld	r24, Z
    1662:	82 60       	ori	r24, 0x02	; 2
    1664:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, PIN2);
    1666:	ae e4       	ldi	r26, 0x4E	; 78
    1668:	b0 e0       	ldi	r27, 0x00	; 0
    166a:	ee e4       	ldi	r30, 0x4E	; 78
    166c:	f0 e0       	ldi	r31, 0x00	; 0
    166e:	80 81       	ld	r24, Z
    1670:	84 60       	ori	r24, 0x04	; 4
    1672:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    1674:	19 82       	std	Y+1, r1	; 0x01
			//NOTHING
		}
	} else {
		//NOTHING
	}
	return LOC_u8ReturnValue;
    1676:	89 81       	ldd	r24, Y+1	; 0x01
}
    1678:	0f 90       	pop	r0
    167a:	0f 90       	pop	r0
    167c:	0f 90       	pop	r0
    167e:	0f 90       	pop	r0
    1680:	cf 91       	pop	r28
    1682:	df 91       	pop	r29
    1684:	08 95       	ret

00001686 <MCAL_T1_u8T1CompareOutputMode>:
//Fast MODE PWM & PHASE CORRECT
u8 MCAL_T1_u8T1CompareOutputMode(u8 LOC_u8OutputMode, u8 LOC_u8Channel) {
    1686:	df 93       	push	r29
    1688:	cf 93       	push	r28
    168a:	00 d0       	rcall	.+0      	; 0x168c <MCAL_T1_u8T1CompareOutputMode+0x6>
    168c:	0f 92       	push	r0
    168e:	cd b7       	in	r28, 0x3d	; 61
    1690:	de b7       	in	r29, 0x3e	; 62
    1692:	8a 83       	std	Y+2, r24	; 0x02
    1694:	6b 83       	std	Y+3, r22	; 0x03
	u8 LOC_u8ReturnValue = E_NOT_OK;
    1696:	81 e0       	ldi	r24, 0x01	; 1
    1698:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_u8OutputMode <= INVERTING_MODE && LOC_u8Channel <= CHENNEL_B) {
    169a:	8a 81       	ldd	r24, Y+2	; 0x02
    169c:	82 30       	cpi	r24, 0x02	; 2
    169e:	08 f0       	brcs	.+2      	; 0x16a2 <MCAL_T1_u8T1CompareOutputMode+0x1c>
    16a0:	72 c0       	rjmp	.+228    	; 0x1786 <MCAL_T1_u8T1CompareOutputMode+0x100>
    16a2:	8b 81       	ldd	r24, Y+3	; 0x03
    16a4:	82 30       	cpi	r24, 0x02	; 2
    16a6:	08 f0       	brcs	.+2      	; 0x16aa <MCAL_T1_u8T1CompareOutputMode+0x24>
    16a8:	6e c0       	rjmp	.+220    	; 0x1786 <MCAL_T1_u8T1CompareOutputMode+0x100>
		if (LOC_u8Channel == CHENNEL_A) {
    16aa:	8b 81       	ldd	r24, Y+3	; 0x03
    16ac:	88 23       	and	r24, r24
    16ae:	a9 f5       	brne	.+106    	; 0x171a <MCAL_T1_u8T1CompareOutputMode+0x94>
			if (LOC_u8OutputMode == NON_INVERTING_MODE) {
    16b0:	8a 81       	ldd	r24, Y+2	; 0x02
    16b2:	88 23       	and	r24, r24
    16b4:	b9 f4       	brne	.+46     	; 0x16e4 <MCAL_T1_u8T1CompareOutputMode+0x5e>
				CLR_BIT(TCCR1A, PIN6);
    16b6:	af e4       	ldi	r26, 0x4F	; 79
    16b8:	b0 e0       	ldi	r27, 0x00	; 0
    16ba:	ef e4       	ldi	r30, 0x4F	; 79
    16bc:	f0 e0       	ldi	r31, 0x00	; 0
    16be:	80 81       	ld	r24, Z
    16c0:	8f 7b       	andi	r24, 0xBF	; 191
    16c2:	8c 93       	st	X, r24
				SET_BIT(TCCR1A, PIN7);
    16c4:	af e4       	ldi	r26, 0x4F	; 79
    16c6:	b0 e0       	ldi	r27, 0x00	; 0
    16c8:	ef e4       	ldi	r30, 0x4F	; 79
    16ca:	f0 e0       	ldi	r31, 0x00	; 0
    16cc:	80 81       	ld	r24, Z
    16ce:	80 68       	ori	r24, 0x80	; 128
    16d0:	8c 93       	st	X, r24
				SET_BIT(DDRD, PIN5);
    16d2:	a1 e3       	ldi	r26, 0x31	; 49
    16d4:	b0 e0       	ldi	r27, 0x00	; 0
    16d6:	e1 e3       	ldi	r30, 0x31	; 49
    16d8:	f0 e0       	ldi	r31, 0x00	; 0
    16da:	80 81       	ld	r24, Z
    16dc:	80 62       	ori	r24, 0x20	; 32
    16de:	8c 93       	st	X, r24
				LOC_u8ReturnValue = E_OK;
    16e0:	19 82       	std	Y+1, r1	; 0x01
    16e2:	51 c0       	rjmp	.+162    	; 0x1786 <MCAL_T1_u8T1CompareOutputMode+0x100>
			} else if (LOC_u8OutputMode == INVERTING_MODE) {
    16e4:	8a 81       	ldd	r24, Y+2	; 0x02
    16e6:	81 30       	cpi	r24, 0x01	; 1
    16e8:	09 f0       	breq	.+2      	; 0x16ec <MCAL_T1_u8T1CompareOutputMode+0x66>
    16ea:	4d c0       	rjmp	.+154    	; 0x1786 <MCAL_T1_u8T1CompareOutputMode+0x100>
				SET_BIT(TCCR1A, PIN6);
    16ec:	af e4       	ldi	r26, 0x4F	; 79
    16ee:	b0 e0       	ldi	r27, 0x00	; 0
    16f0:	ef e4       	ldi	r30, 0x4F	; 79
    16f2:	f0 e0       	ldi	r31, 0x00	; 0
    16f4:	80 81       	ld	r24, Z
    16f6:	80 64       	ori	r24, 0x40	; 64
    16f8:	8c 93       	st	X, r24
				SET_BIT(TCCR1A, PIN7);
    16fa:	af e4       	ldi	r26, 0x4F	; 79
    16fc:	b0 e0       	ldi	r27, 0x00	; 0
    16fe:	ef e4       	ldi	r30, 0x4F	; 79
    1700:	f0 e0       	ldi	r31, 0x00	; 0
    1702:	80 81       	ld	r24, Z
    1704:	80 68       	ori	r24, 0x80	; 128
    1706:	8c 93       	st	X, r24
				SET_BIT(DDRD, PIN5);
    1708:	a1 e3       	ldi	r26, 0x31	; 49
    170a:	b0 e0       	ldi	r27, 0x00	; 0
    170c:	e1 e3       	ldi	r30, 0x31	; 49
    170e:	f0 e0       	ldi	r31, 0x00	; 0
    1710:	80 81       	ld	r24, Z
    1712:	80 62       	ori	r24, 0x20	; 32
    1714:	8c 93       	st	X, r24
				LOC_u8ReturnValue = E_OK;
    1716:	19 82       	std	Y+1, r1	; 0x01
    1718:	36 c0       	rjmp	.+108    	; 0x1786 <MCAL_T1_u8T1CompareOutputMode+0x100>
			} else {
				//NOTHING
			}
		} else if (LOC_u8Channel == CHENNEL_B) {
    171a:	8b 81       	ldd	r24, Y+3	; 0x03
    171c:	81 30       	cpi	r24, 0x01	; 1
    171e:	99 f5       	brne	.+102    	; 0x1786 <MCAL_T1_u8T1CompareOutputMode+0x100>
			if (LOC_u8OutputMode == NON_INVERTING_MODE) {
    1720:	8a 81       	ldd	r24, Y+2	; 0x02
    1722:	88 23       	and	r24, r24
    1724:	b9 f4       	brne	.+46     	; 0x1754 <MCAL_T1_u8T1CompareOutputMode+0xce>
				CLR_BIT(TCCR1A, PIN4);
    1726:	af e4       	ldi	r26, 0x4F	; 79
    1728:	b0 e0       	ldi	r27, 0x00	; 0
    172a:	ef e4       	ldi	r30, 0x4F	; 79
    172c:	f0 e0       	ldi	r31, 0x00	; 0
    172e:	80 81       	ld	r24, Z
    1730:	8f 7e       	andi	r24, 0xEF	; 239
    1732:	8c 93       	st	X, r24
				SET_BIT(TCCR1A, PIN5);
    1734:	af e4       	ldi	r26, 0x4F	; 79
    1736:	b0 e0       	ldi	r27, 0x00	; 0
    1738:	ef e4       	ldi	r30, 0x4F	; 79
    173a:	f0 e0       	ldi	r31, 0x00	; 0
    173c:	80 81       	ld	r24, Z
    173e:	80 62       	ori	r24, 0x20	; 32
    1740:	8c 93       	st	X, r24
				SET_BIT(DDRD, PIN4);
    1742:	a1 e3       	ldi	r26, 0x31	; 49
    1744:	b0 e0       	ldi	r27, 0x00	; 0
    1746:	e1 e3       	ldi	r30, 0x31	; 49
    1748:	f0 e0       	ldi	r31, 0x00	; 0
    174a:	80 81       	ld	r24, Z
    174c:	80 61       	ori	r24, 0x10	; 16
    174e:	8c 93       	st	X, r24
				LOC_u8ReturnValue = E_OK;
    1750:	19 82       	std	Y+1, r1	; 0x01
    1752:	19 c0       	rjmp	.+50     	; 0x1786 <MCAL_T1_u8T1CompareOutputMode+0x100>
			} else if (LOC_u8OutputMode == INVERTING_MODE) {
    1754:	8a 81       	ldd	r24, Y+2	; 0x02
    1756:	81 30       	cpi	r24, 0x01	; 1
    1758:	b1 f4       	brne	.+44     	; 0x1786 <MCAL_T1_u8T1CompareOutputMode+0x100>
				SET_BIT(TCCR1A, PIN4);
    175a:	af e4       	ldi	r26, 0x4F	; 79
    175c:	b0 e0       	ldi	r27, 0x00	; 0
    175e:	ef e4       	ldi	r30, 0x4F	; 79
    1760:	f0 e0       	ldi	r31, 0x00	; 0
    1762:	80 81       	ld	r24, Z
    1764:	80 61       	ori	r24, 0x10	; 16
    1766:	8c 93       	st	X, r24
				SET_BIT(TCCR1A, PIN5);
    1768:	af e4       	ldi	r26, 0x4F	; 79
    176a:	b0 e0       	ldi	r27, 0x00	; 0
    176c:	ef e4       	ldi	r30, 0x4F	; 79
    176e:	f0 e0       	ldi	r31, 0x00	; 0
    1770:	80 81       	ld	r24, Z
    1772:	80 62       	ori	r24, 0x20	; 32
    1774:	8c 93       	st	X, r24
				SET_BIT(DDRD, PIN4);
    1776:	a1 e3       	ldi	r26, 0x31	; 49
    1778:	b0 e0       	ldi	r27, 0x00	; 0
    177a:	e1 e3       	ldi	r30, 0x31	; 49
    177c:	f0 e0       	ldi	r31, 0x00	; 0
    177e:	80 81       	ld	r24, Z
    1780:	80 61       	ori	r24, 0x10	; 16
    1782:	8c 93       	st	X, r24
				LOC_u8ReturnValue = E_OK;
    1784:	19 82       	std	Y+1, r1	; 0x01
			//NOTHING
		}
	} else {
		//NOTHING
	}
	return LOC_u8ReturnValue;
    1786:	89 81       	ldd	r24, Y+1	; 0x01
}
    1788:	0f 90       	pop	r0
    178a:	0f 90       	pop	r0
    178c:	0f 90       	pop	r0
    178e:	cf 91       	pop	r28
    1790:	df 91       	pop	r29
    1792:	08 95       	ret

00001794 <MCAL_T1_voidNoiseCancller>:
//NOISE CANCLLER
void MCAL_T1_voidNoiseCancller(void) {
    1794:	df 93       	push	r29
    1796:	cf 93       	push	r28
    1798:	cd b7       	in	r28, 0x3d	; 61
    179a:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(TCCR1B, PIN7);
    179c:	ae e4       	ldi	r26, 0x4E	; 78
    179e:	b0 e0       	ldi	r27, 0x00	; 0
    17a0:	ee e4       	ldi	r30, 0x4E	; 78
    17a2:	f0 e0       	ldi	r31, 0x00	; 0
    17a4:	80 81       	ld	r24, Z
    17a6:	80 68       	ori	r24, 0x80	; 128
    17a8:	8c 93       	st	X, r24
}
    17aa:	cf 91       	pop	r28
    17ac:	df 91       	pop	r29
    17ae:	08 95       	ret

000017b0 <MCAL_T1_voidSetTCNT1Value>:
//Set TCNT1 Value
void MCAL_T1_voidSetTCNT1Value(u16 LOC_u16Value) {
    17b0:	df 93       	push	r29
    17b2:	cf 93       	push	r28
    17b4:	00 d0       	rcall	.+0      	; 0x17b6 <MCAL_T1_voidSetTCNT1Value+0x6>
    17b6:	cd b7       	in	r28, 0x3d	; 61
    17b8:	de b7       	in	r29, 0x3e	; 62
    17ba:	9a 83       	std	Y+2, r25	; 0x02
    17bc:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_u16Value <= SIXTEEN_BIT_MAX_VALUE) {
		TCNT1 = LOC_u16Value;
    17be:	ec e4       	ldi	r30, 0x4C	; 76
    17c0:	f0 e0       	ldi	r31, 0x00	; 0
    17c2:	89 81       	ldd	r24, Y+1	; 0x01
    17c4:	9a 81       	ldd	r25, Y+2	; 0x02
    17c6:	91 83       	std	Z+1, r25	; 0x01
    17c8:	80 83       	st	Z, r24
	} else {
		//NOTHING
	}
}
    17ca:	0f 90       	pop	r0
    17cc:	0f 90       	pop	r0
    17ce:	cf 91       	pop	r28
    17d0:	df 91       	pop	r29
    17d2:	08 95       	ret

000017d4 <MCAL_T1_voidGetTCNT1Value>:
//GIT TCNT1
void MCAL_T1_voidGetTCNT1Value(u16 *LOC_pu16Value) {
    17d4:	df 93       	push	r29
    17d6:	cf 93       	push	r28
    17d8:	00 d0       	rcall	.+0      	; 0x17da <MCAL_T1_voidGetTCNT1Value+0x6>
    17da:	cd b7       	in	r28, 0x3d	; 61
    17dc:	de b7       	in	r29, 0x3e	; 62
    17de:	9a 83       	std	Y+2, r25	; 0x02
    17e0:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_pu16Value) {
    17e2:	89 81       	ldd	r24, Y+1	; 0x01
    17e4:	9a 81       	ldd	r25, Y+2	; 0x02
    17e6:	00 97       	sbiw	r24, 0x00	; 0
    17e8:	41 f0       	breq	.+16     	; 0x17fa <MCAL_T1_voidGetTCNT1Value+0x26>
		*LOC_pu16Value = TCNT1;
    17ea:	ec e4       	ldi	r30, 0x4C	; 76
    17ec:	f0 e0       	ldi	r31, 0x00	; 0
    17ee:	80 81       	ld	r24, Z
    17f0:	91 81       	ldd	r25, Z+1	; 0x01
    17f2:	e9 81       	ldd	r30, Y+1	; 0x01
    17f4:	fa 81       	ldd	r31, Y+2	; 0x02
    17f6:	91 83       	std	Z+1, r25	; 0x01
    17f8:	80 83       	st	Z, r24
	}
}
    17fa:	0f 90       	pop	r0
    17fc:	0f 90       	pop	r0
    17fe:	cf 91       	pop	r28
    1800:	df 91       	pop	r29
    1802:	08 95       	ret

00001804 <MCAL_T1_voidSetOCR1AValue>:
//Set OCR1A
void MCAL_T1_voidSetOCR1AValue(u16 LOC_u16Value) {
    1804:	df 93       	push	r29
    1806:	cf 93       	push	r28
    1808:	00 d0       	rcall	.+0      	; 0x180a <MCAL_T1_voidSetOCR1AValue+0x6>
    180a:	cd b7       	in	r28, 0x3d	; 61
    180c:	de b7       	in	r29, 0x3e	; 62
    180e:	9a 83       	std	Y+2, r25	; 0x02
    1810:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_u16Value <= SIXTEEN_BIT_MAX_VALUE) {
		OCR1A = LOC_u16Value;
    1812:	ea e4       	ldi	r30, 0x4A	; 74
    1814:	f0 e0       	ldi	r31, 0x00	; 0
    1816:	89 81       	ldd	r24, Y+1	; 0x01
    1818:	9a 81       	ldd	r25, Y+2	; 0x02
    181a:	91 83       	std	Z+1, r25	; 0x01
    181c:	80 83       	st	Z, r24
	} else {
		//NOTHING
	}
}
    181e:	0f 90       	pop	r0
    1820:	0f 90       	pop	r0
    1822:	cf 91       	pop	r28
    1824:	df 91       	pop	r29
    1826:	08 95       	ret

00001828 <MCAL_T1_voidSetOCR1BValue>:
//SET OCR1B
void MCAL_T1_voidSetOCR1BValue(u16 LOC_u16Value) {
    1828:	df 93       	push	r29
    182a:	cf 93       	push	r28
    182c:	00 d0       	rcall	.+0      	; 0x182e <MCAL_T1_voidSetOCR1BValue+0x6>
    182e:	cd b7       	in	r28, 0x3d	; 61
    1830:	de b7       	in	r29, 0x3e	; 62
    1832:	9a 83       	std	Y+2, r25	; 0x02
    1834:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_u16Value <= SIXTEEN_BIT_MAX_VALUE) {
		OCR1B = LOC_u16Value;
    1836:	e8 e4       	ldi	r30, 0x48	; 72
    1838:	f0 e0       	ldi	r31, 0x00	; 0
    183a:	89 81       	ldd	r24, Y+1	; 0x01
    183c:	9a 81       	ldd	r25, Y+2	; 0x02
    183e:	91 83       	std	Z+1, r25	; 0x01
    1840:	80 83       	st	Z, r24
	} else {
		//NOTHING
	}
}
    1842:	0f 90       	pop	r0
    1844:	0f 90       	pop	r0
    1846:	cf 91       	pop	r28
    1848:	df 91       	pop	r29
    184a:	08 95       	ret

0000184c <MCAL_T1_voidSetICR1Value>:
//SET ICR1
void MCAL_T1_voidSetICR1Value(u16 LOC_u16Value) {
    184c:	df 93       	push	r29
    184e:	cf 93       	push	r28
    1850:	00 d0       	rcall	.+0      	; 0x1852 <MCAL_T1_voidSetICR1Value+0x6>
    1852:	cd b7       	in	r28, 0x3d	; 61
    1854:	de b7       	in	r29, 0x3e	; 62
    1856:	9a 83       	std	Y+2, r25	; 0x02
    1858:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_u16Value <= SIXTEEN_BIT_MAX_VALUE) {
		ICR1 = LOC_u16Value;
    185a:	e6 e4       	ldi	r30, 0x46	; 70
    185c:	f0 e0       	ldi	r31, 0x00	; 0
    185e:	89 81       	ldd	r24, Y+1	; 0x01
    1860:	9a 81       	ldd	r25, Y+2	; 0x02
    1862:	91 83       	std	Z+1, r25	; 0x01
    1864:	80 83       	st	Z, r24
	} else {
		//NOTHING
	}
}
    1866:	0f 90       	pop	r0
    1868:	0f 90       	pop	r0
    186a:	cf 91       	pop	r28
    186c:	df 91       	pop	r29
    186e:	08 95       	ret

00001870 <MCAL_T1_voidGetICR1Value>:
//Get ICR1
void MCAL_T1_voidGetICR1Value(u16 *LOC_pu16Value) {
    1870:	df 93       	push	r29
    1872:	cf 93       	push	r28
    1874:	00 d0       	rcall	.+0      	; 0x1876 <MCAL_T1_voidGetICR1Value+0x6>
    1876:	cd b7       	in	r28, 0x3d	; 61
    1878:	de b7       	in	r29, 0x3e	; 62
    187a:	9a 83       	std	Y+2, r25	; 0x02
    187c:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_pu16Value) {
    187e:	89 81       	ldd	r24, Y+1	; 0x01
    1880:	9a 81       	ldd	r25, Y+2	; 0x02
    1882:	00 97       	sbiw	r24, 0x00	; 0
    1884:	41 f0       	breq	.+16     	; 0x1896 <MCAL_T1_voidGetICR1Value+0x26>
		*LOC_pu16Value =ICR1;
    1886:	e6 e4       	ldi	r30, 0x46	; 70
    1888:	f0 e0       	ldi	r31, 0x00	; 0
    188a:	80 81       	ld	r24, Z
    188c:	91 81       	ldd	r25, Z+1	; 0x01
    188e:	e9 81       	ldd	r30, Y+1	; 0x01
    1890:	fa 81       	ldd	r31, Y+2	; 0x02
    1892:	91 83       	std	Z+1, r25	; 0x01
    1894:	80 83       	st	Z, r24
	}
}
    1896:	0f 90       	pop	r0
    1898:	0f 90       	pop	r0
    189a:	cf 91       	pop	r28
    189c:	df 91       	pop	r29
    189e:	08 95       	ret

000018a0 <MCAL_T1_voidTCNT1_GIEEnable>:
//TCNT1 PIE
void MCAL_T1_voidTCNT1_GIEEnable(void) {
    18a0:	df 93       	push	r29
    18a2:	cf 93       	push	r28
    18a4:	cd b7       	in	r28, 0x3d	; 61
    18a6:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG, PIN7);
    18a8:	af e5       	ldi	r26, 0x5F	; 95
    18aa:	b0 e0       	ldi	r27, 0x00	; 0
    18ac:	ef e5       	ldi	r30, 0x5F	; 95
    18ae:	f0 e0       	ldi	r31, 0x00	; 0
    18b0:	80 81       	ld	r24, Z
    18b2:	80 68       	ori	r24, 0x80	; 128
    18b4:	8c 93       	st	X, r24
	SET_BIT(TIMSK, PIN2);
    18b6:	a9 e5       	ldi	r26, 0x59	; 89
    18b8:	b0 e0       	ldi	r27, 0x00	; 0
    18ba:	e9 e5       	ldi	r30, 0x59	; 89
    18bc:	f0 e0       	ldi	r31, 0x00	; 0
    18be:	80 81       	ld	r24, Z
    18c0:	84 60       	ori	r24, 0x04	; 4
    18c2:	8c 93       	st	X, r24
}
    18c4:	cf 91       	pop	r28
    18c6:	df 91       	pop	r29
    18c8:	08 95       	ret

000018ca <MCAL_T1_voidTCNT1_GIEDisable>:
void MCAL_T1_voidTCNT1_GIEDisable(void) {
    18ca:	df 93       	push	r29
    18cc:	cf 93       	push	r28
    18ce:	cd b7       	in	r28, 0x3d	; 61
    18d0:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK, PIN2);
    18d2:	a9 e5       	ldi	r26, 0x59	; 89
    18d4:	b0 e0       	ldi	r27, 0x00	; 0
    18d6:	e9 e5       	ldi	r30, 0x59	; 89
    18d8:	f0 e0       	ldi	r31, 0x00	; 0
    18da:	80 81       	ld	r24, Z
    18dc:	8b 7f       	andi	r24, 0xFB	; 251
    18de:	8c 93       	st	X, r24
}
    18e0:	cf 91       	pop	r28
    18e2:	df 91       	pop	r29
    18e4:	08 95       	ret

000018e6 <MCAL_T1_voidOCR1B_GIEEnable>:
//OCR1B PIE
void MCAL_T1_voidOCR1B_GIEEnable(void) {
    18e6:	df 93       	push	r29
    18e8:	cf 93       	push	r28
    18ea:	cd b7       	in	r28, 0x3d	; 61
    18ec:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG, PIN7);
    18ee:	af e5       	ldi	r26, 0x5F	; 95
    18f0:	b0 e0       	ldi	r27, 0x00	; 0
    18f2:	ef e5       	ldi	r30, 0x5F	; 95
    18f4:	f0 e0       	ldi	r31, 0x00	; 0
    18f6:	80 81       	ld	r24, Z
    18f8:	80 68       	ori	r24, 0x80	; 128
    18fa:	8c 93       	st	X, r24
	SET_BIT(TIMSK, PIN3);
    18fc:	a9 e5       	ldi	r26, 0x59	; 89
    18fe:	b0 e0       	ldi	r27, 0x00	; 0
    1900:	e9 e5       	ldi	r30, 0x59	; 89
    1902:	f0 e0       	ldi	r31, 0x00	; 0
    1904:	80 81       	ld	r24, Z
    1906:	88 60       	ori	r24, 0x08	; 8
    1908:	8c 93       	st	X, r24
}
    190a:	cf 91       	pop	r28
    190c:	df 91       	pop	r29
    190e:	08 95       	ret

00001910 <MCAL_T1_voidOCR1B_GIEDisable>:
void MCAL_T1_voidOCR1B_GIEDisable(void) {
    1910:	df 93       	push	r29
    1912:	cf 93       	push	r28
    1914:	cd b7       	in	r28, 0x3d	; 61
    1916:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK, PIN3);
    1918:	a9 e5       	ldi	r26, 0x59	; 89
    191a:	b0 e0       	ldi	r27, 0x00	; 0
    191c:	e9 e5       	ldi	r30, 0x59	; 89
    191e:	f0 e0       	ldi	r31, 0x00	; 0
    1920:	80 81       	ld	r24, Z
    1922:	87 7f       	andi	r24, 0xF7	; 247
    1924:	8c 93       	st	X, r24
}
    1926:	cf 91       	pop	r28
    1928:	df 91       	pop	r29
    192a:	08 95       	ret

0000192c <MCAL_T1_voidOCR1A_GIEEnable>:
//OCR1A PIE
void MCAL_T1_voidOCR1A_GIEEnable(void) {
    192c:	df 93       	push	r29
    192e:	cf 93       	push	r28
    1930:	cd b7       	in	r28, 0x3d	; 61
    1932:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG, PIN7);
    1934:	af e5       	ldi	r26, 0x5F	; 95
    1936:	b0 e0       	ldi	r27, 0x00	; 0
    1938:	ef e5       	ldi	r30, 0x5F	; 95
    193a:	f0 e0       	ldi	r31, 0x00	; 0
    193c:	80 81       	ld	r24, Z
    193e:	80 68       	ori	r24, 0x80	; 128
    1940:	8c 93       	st	X, r24
	SET_BIT(TIMSK, PIN4);
    1942:	a9 e5       	ldi	r26, 0x59	; 89
    1944:	b0 e0       	ldi	r27, 0x00	; 0
    1946:	e9 e5       	ldi	r30, 0x59	; 89
    1948:	f0 e0       	ldi	r31, 0x00	; 0
    194a:	80 81       	ld	r24, Z
    194c:	80 61       	ori	r24, 0x10	; 16
    194e:	8c 93       	st	X, r24
}
    1950:	cf 91       	pop	r28
    1952:	df 91       	pop	r29
    1954:	08 95       	ret

00001956 <MCAL_T1_voidOCR1A_GIEDisable>:
void MCAL_T1_voidOCR1A_GIEDisable(void) {
    1956:	df 93       	push	r29
    1958:	cf 93       	push	r28
    195a:	cd b7       	in	r28, 0x3d	; 61
    195c:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK, PIN4);
    195e:	a9 e5       	ldi	r26, 0x59	; 89
    1960:	b0 e0       	ldi	r27, 0x00	; 0
    1962:	e9 e5       	ldi	r30, 0x59	; 89
    1964:	f0 e0       	ldi	r31, 0x00	; 0
    1966:	80 81       	ld	r24, Z
    1968:	8f 7e       	andi	r24, 0xEF	; 239
    196a:	8c 93       	st	X, r24
}
    196c:	cf 91       	pop	r28
    196e:	df 91       	pop	r29
    1970:	08 95       	ret

00001972 <MCAL_T1_voidICR1_GIEEnable>:
//ICR1 PIE
void MCAL_T1_voidICR1_GIEEnable(void) {
    1972:	df 93       	push	r29
    1974:	cf 93       	push	r28
    1976:	cd b7       	in	r28, 0x3d	; 61
    1978:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG, PIN7);
    197a:	af e5       	ldi	r26, 0x5F	; 95
    197c:	b0 e0       	ldi	r27, 0x00	; 0
    197e:	ef e5       	ldi	r30, 0x5F	; 95
    1980:	f0 e0       	ldi	r31, 0x00	; 0
    1982:	80 81       	ld	r24, Z
    1984:	80 68       	ori	r24, 0x80	; 128
    1986:	8c 93       	st	X, r24
	SET_BIT(TIMSK, PIN5);
    1988:	a9 e5       	ldi	r26, 0x59	; 89
    198a:	b0 e0       	ldi	r27, 0x00	; 0
    198c:	e9 e5       	ldi	r30, 0x59	; 89
    198e:	f0 e0       	ldi	r31, 0x00	; 0
    1990:	80 81       	ld	r24, Z
    1992:	80 62       	ori	r24, 0x20	; 32
    1994:	8c 93       	st	X, r24
}
    1996:	cf 91       	pop	r28
    1998:	df 91       	pop	r29
    199a:	08 95       	ret

0000199c <MCAL_T1_voidICR1_GIEDisable>:
void MCAL_T1_voidICR1_GIEDisable(void) {
    199c:	df 93       	push	r29
    199e:	cf 93       	push	r28
    19a0:	cd b7       	in	r28, 0x3d	; 61
    19a2:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK, PIN5);
    19a4:	a9 e5       	ldi	r26, 0x59	; 89
    19a6:	b0 e0       	ldi	r27, 0x00	; 0
    19a8:	e9 e5       	ldi	r30, 0x59	; 89
    19aa:	f0 e0       	ldi	r31, 0x00	; 0
    19ac:	80 81       	ld	r24, Z
    19ae:	8f 7d       	andi	r24, 0xDF	; 223
    19b0:	8c 93       	st	X, r24
}
    19b2:	cf 91       	pop	r28
    19b4:	df 91       	pop	r29
    19b6:	08 95       	ret

000019b8 <MCAL_T1_u8T1DelayNormalMode>:

u8 MCAL_T1_u8T1DelayNormalMode(u8 LOC_u8Clock_Selection,
		f32 LOC_f32NumOFSecond, u16 *LOC_pu8StartValue, u16 *LOC_pu16Counter) {
    19b8:	0f 93       	push	r16
    19ba:	1f 93       	push	r17
    19bc:	df 93       	push	r29
    19be:	cf 93       	push	r28
    19c0:	cd b7       	in	r28, 0x3d	; 61
    19c2:	de b7       	in	r29, 0x3e	; 62
    19c4:	66 97       	sbiw	r28, 0x16	; 22
    19c6:	0f b6       	in	r0, 0x3f	; 63
    19c8:	f8 94       	cli
    19ca:	de bf       	out	0x3e, r29	; 62
    19cc:	0f be       	out	0x3f, r0	; 63
    19ce:	cd bf       	out	0x3d, r28	; 61
    19d0:	8e 87       	std	Y+14, r24	; 0x0e
    19d2:	4f 87       	std	Y+15, r20	; 0x0f
    19d4:	58 8b       	std	Y+16, r21	; 0x10
    19d6:	69 8b       	std	Y+17, r22	; 0x11
    19d8:	7a 8b       	std	Y+18, r23	; 0x12
    19da:	3c 8b       	std	Y+20, r19	; 0x14
    19dc:	2b 8b       	std	Y+19, r18	; 0x13
    19de:	1e 8b       	std	Y+22, r17	; 0x16
    19e0:	0d 8b       	std	Y+21, r16	; 0x15
	u8 LOC_u8ReturnValue = E_NOT_OK;
    19e2:	81 e0       	ldi	r24, 0x01	; 1
    19e4:	89 87       	std	Y+9, r24	; 0x09
	f32 TickTime = NUMBER_0;
    19e6:	80 e0       	ldi	r24, 0x00	; 0
    19e8:	90 e0       	ldi	r25, 0x00	; 0
    19ea:	a0 e0       	ldi	r26, 0x00	; 0
    19ec:	b0 e0       	ldi	r27, 0x00	; 0
    19ee:	8a 87       	std	Y+10, r24	; 0x0a
    19f0:	9b 87       	std	Y+11, r25	; 0x0b
    19f2:	ac 87       	std	Y+12, r26	; 0x0c
    19f4:	bd 87       	std	Y+13, r27	; 0x0d
	u32 N = NUMBER_0;
    19f6:	1d 82       	std	Y+5, r1	; 0x05
    19f8:	1e 82       	std	Y+6, r1	; 0x06
    19fa:	1f 82       	std	Y+7, r1	; 0x07
    19fc:	18 86       	std	Y+8, r1	; 0x08
	u16 counter = NUMBER_0;
    19fe:	1c 82       	std	Y+4, r1	; 0x04
    1a00:	1b 82       	std	Y+3, r1	; 0x03
	u16 Reminder = NUMBER_0;
    1a02:	1a 82       	std	Y+2, r1	; 0x02
    1a04:	19 82       	std	Y+1, r1	; 0x01
	MCAL_T1_u8T1Prescaler(LOC_u8Clock_Selection, &TickTime);
    1a06:	9e 01       	movw	r18, r28
    1a08:	26 5f       	subi	r18, 0xF6	; 246
    1a0a:	3f 4f       	sbci	r19, 0xFF	; 255
    1a0c:	8e 85       	ldd	r24, Y+14	; 0x0e
    1a0e:	b9 01       	movw	r22, r18
    1a10:	0e 94 2b 0a 	call	0x1456	; 0x1456 <MCAL_T1_u8T1Prescaler>
	if (LOC_f32NumOFSecond <= 0 || LOC_f32NumOFSecond > 0) {
    1a14:	6f 85       	ldd	r22, Y+15	; 0x0f
    1a16:	78 89       	ldd	r23, Y+16	; 0x10
    1a18:	89 89       	ldd	r24, Y+17	; 0x11
    1a1a:	9a 89       	ldd	r25, Y+18	; 0x12
    1a1c:	20 e0       	ldi	r18, 0x00	; 0
    1a1e:	30 e0       	ldi	r19, 0x00	; 0
    1a20:	40 e0       	ldi	r20, 0x00	; 0
    1a22:	50 e0       	ldi	r21, 0x00	; 0
    1a24:	0e 94 55 04 	call	0x8aa	; 0x8aa <__lesf2>
    1a28:	18 16       	cp	r1, r24
    1a2a:	6c f4       	brge	.+26     	; 0x1a46 <MCAL_T1_u8T1DelayNormalMode+0x8e>
    1a2c:	6f 85       	ldd	r22, Y+15	; 0x0f
    1a2e:	78 89       	ldd	r23, Y+16	; 0x10
    1a30:	89 89       	ldd	r24, Y+17	; 0x11
    1a32:	9a 89       	ldd	r25, Y+18	; 0x12
    1a34:	20 e0       	ldi	r18, 0x00	; 0
    1a36:	30 e0       	ldi	r19, 0x00	; 0
    1a38:	40 e0       	ldi	r20, 0x00	; 0
    1a3a:	50 e0       	ldi	r21, 0x00	; 0
    1a3c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1a40:	18 16       	cp	r1, r24
    1a42:	0c f0       	brlt	.+2      	; 0x1a46 <MCAL_T1_u8T1DelayNormalMode+0x8e>
    1a44:	6b c0       	rjmp	.+214    	; 0x1b1c <MCAL_T1_u8T1DelayNormalMode+0x164>
		N = LOC_f32NumOFSecond / (f32) TickTime;
    1a46:	2a 85       	ldd	r18, Y+10	; 0x0a
    1a48:	3b 85       	ldd	r19, Y+11	; 0x0b
    1a4a:	4c 85       	ldd	r20, Y+12	; 0x0c
    1a4c:	5d 85       	ldd	r21, Y+13	; 0x0d
    1a4e:	6f 85       	ldd	r22, Y+15	; 0x0f
    1a50:	78 89       	ldd	r23, Y+16	; 0x10
    1a52:	89 89       	ldd	r24, Y+17	; 0x11
    1a54:	9a 89       	ldd	r25, Y+18	; 0x12
    1a56:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1a5a:	dc 01       	movw	r26, r24
    1a5c:	cb 01       	movw	r24, r22
    1a5e:	bc 01       	movw	r22, r24
    1a60:	cd 01       	movw	r24, r26
    1a62:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1a66:	dc 01       	movw	r26, r24
    1a68:	cb 01       	movw	r24, r22
    1a6a:	8d 83       	std	Y+5, r24	; 0x05
    1a6c:	9e 83       	std	Y+6, r25	; 0x06
    1a6e:	af 83       	std	Y+7, r26	; 0x07
    1a70:	b8 87       	std	Y+8, r27	; 0x08
		Reminder = N % OVER_FLOW_COUNT;
    1a72:	8d 81       	ldd	r24, Y+5	; 0x05
    1a74:	9e 81       	ldd	r25, Y+6	; 0x06
    1a76:	af 81       	ldd	r26, Y+7	; 0x07
    1a78:	b8 85       	ldd	r27, Y+8	; 0x08
    1a7a:	2f ef       	ldi	r18, 0xFF	; 255
    1a7c:	3f ef       	ldi	r19, 0xFF	; 255
    1a7e:	40 e0       	ldi	r20, 0x00	; 0
    1a80:	50 e0       	ldi	r21, 0x00	; 0
    1a82:	bc 01       	movw	r22, r24
    1a84:	cd 01       	movw	r24, r26
    1a86:	0e 94 05 4c 	call	0x980a	; 0x980a <__udivmodsi4>
    1a8a:	dc 01       	movw	r26, r24
    1a8c:	cb 01       	movw	r24, r22
    1a8e:	9a 83       	std	Y+2, r25	; 0x02
    1a90:	89 83       	std	Y+1, r24	; 0x01
		*LOC_pu8StartValue = Reminder;
    1a92:	eb 89       	ldd	r30, Y+19	; 0x13
    1a94:	fc 89       	ldd	r31, Y+20	; 0x14
    1a96:	89 81       	ldd	r24, Y+1	; 0x01
    1a98:	9a 81       	ldd	r25, Y+2	; 0x02
    1a9a:	91 83       	std	Z+1, r25	; 0x01
    1a9c:	80 83       	st	Z, r24
		if (Reminder == NUMBER_0) {
    1a9e:	89 81       	ldd	r24, Y+1	; 0x01
    1aa0:	9a 81       	ldd	r25, Y+2	; 0x02
    1aa2:	00 97       	sbiw	r24, 0x00	; 0
    1aa4:	d9 f4       	brne	.+54     	; 0x1adc <MCAL_T1_u8T1DelayNormalMode+0x124>
			MCAL_T1_voidSetTCNT1Value(Reminder);
    1aa6:	89 81       	ldd	r24, Y+1	; 0x01
    1aa8:	9a 81       	ldd	r25, Y+2	; 0x02
    1aaa:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <MCAL_T1_voidSetTCNT1Value>
			counter = N / OVER_FLOW_COUNT;
    1aae:	8d 81       	ldd	r24, Y+5	; 0x05
    1ab0:	9e 81       	ldd	r25, Y+6	; 0x06
    1ab2:	af 81       	ldd	r26, Y+7	; 0x07
    1ab4:	b8 85       	ldd	r27, Y+8	; 0x08
    1ab6:	2f ef       	ldi	r18, 0xFF	; 255
    1ab8:	3f ef       	ldi	r19, 0xFF	; 255
    1aba:	40 e0       	ldi	r20, 0x00	; 0
    1abc:	50 e0       	ldi	r21, 0x00	; 0
    1abe:	bc 01       	movw	r22, r24
    1ac0:	cd 01       	movw	r24, r26
    1ac2:	0e 94 05 4c 	call	0x980a	; 0x980a <__udivmodsi4>
    1ac6:	da 01       	movw	r26, r20
    1ac8:	c9 01       	movw	r24, r18
    1aca:	9c 83       	std	Y+4, r25	; 0x04
    1acc:	8b 83       	std	Y+3, r24	; 0x03
			*LOC_pu16Counter = counter;
    1ace:	ed 89       	ldd	r30, Y+21	; 0x15
    1ad0:	fe 89       	ldd	r31, Y+22	; 0x16
    1ad2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ad4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ad6:	91 83       	std	Z+1, r25	; 0x01
    1ad8:	80 83       	st	Z, r24
    1ada:	1f c0       	rjmp	.+62     	; 0x1b1a <MCAL_T1_u8T1DelayNormalMode+0x162>
		} else if (Reminder != NUMBER_0) {
    1adc:	89 81       	ldd	r24, Y+1	; 0x01
    1ade:	9a 81       	ldd	r25, Y+2	; 0x02
    1ae0:	00 97       	sbiw	r24, 0x00	; 0
    1ae2:	d9 f0       	breq	.+54     	; 0x1b1a <MCAL_T1_u8T1DelayNormalMode+0x162>
			MCAL_T1_voidSetTCNT1Value(Reminder);
    1ae4:	89 81       	ldd	r24, Y+1	; 0x01
    1ae6:	9a 81       	ldd	r25, Y+2	; 0x02
    1ae8:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <MCAL_T1_voidSetTCNT1Value>
			counter = ((N / OVER_FLOW_COUNT) + NUMBER_1);
    1aec:	8d 81       	ldd	r24, Y+5	; 0x05
    1aee:	9e 81       	ldd	r25, Y+6	; 0x06
    1af0:	af 81       	ldd	r26, Y+7	; 0x07
    1af2:	b8 85       	ldd	r27, Y+8	; 0x08
    1af4:	2f ef       	ldi	r18, 0xFF	; 255
    1af6:	3f ef       	ldi	r19, 0xFF	; 255
    1af8:	40 e0       	ldi	r20, 0x00	; 0
    1afa:	50 e0       	ldi	r21, 0x00	; 0
    1afc:	bc 01       	movw	r22, r24
    1afe:	cd 01       	movw	r24, r26
    1b00:	0e 94 05 4c 	call	0x980a	; 0x980a <__udivmodsi4>
    1b04:	da 01       	movw	r26, r20
    1b06:	c9 01       	movw	r24, r18
    1b08:	01 96       	adiw	r24, 0x01	; 1
    1b0a:	9c 83       	std	Y+4, r25	; 0x04
    1b0c:	8b 83       	std	Y+3, r24	; 0x03
			*LOC_pu16Counter = counter;
    1b0e:	ed 89       	ldd	r30, Y+21	; 0x15
    1b10:	fe 89       	ldd	r31, Y+22	; 0x16
    1b12:	8b 81       	ldd	r24, Y+3	; 0x03
    1b14:	9c 81       	ldd	r25, Y+4	; 0x04
    1b16:	91 83       	std	Z+1, r25	; 0x01
    1b18:	80 83       	st	Z, r24
		} else {
			//NOTHING
		}
		LOC_u8ReturnValue = E_OK;
    1b1a:	19 86       	std	Y+9, r1	; 0x09
	}
	return LOC_u8ReturnValue;
    1b1c:	89 85       	ldd	r24, Y+9	; 0x09

}
    1b1e:	66 96       	adiw	r28, 0x16	; 22
    1b20:	0f b6       	in	r0, 0x3f	; 63
    1b22:	f8 94       	cli
    1b24:	de bf       	out	0x3e, r29	; 62
    1b26:	0f be       	out	0x3f, r0	; 63
    1b28:	cd bf       	out	0x3d, r28	; 61
    1b2a:	cf 91       	pop	r28
    1b2c:	df 91       	pop	r29
    1b2e:	1f 91       	pop	r17
    1b30:	0f 91       	pop	r16
    1b32:	08 95       	ret

00001b34 <MCAL_T1_voidDelayCTCMode>:

void MCAL_T1_voidDelayCTCMode(u8 LOC_u8Clock_Selection,
		f32 LOC_fl32NumOFSecond, u16 *LOC_pu16Counter) {
    1b34:	df 93       	push	r29
    1b36:	cf 93       	push	r28
    1b38:	cd b7       	in	r28, 0x3d	; 61
    1b3a:	de b7       	in	r29, 0x3e	; 62
    1b3c:	61 97       	sbiw	r28, 0x11	; 17
    1b3e:	0f b6       	in	r0, 0x3f	; 63
    1b40:	f8 94       	cli
    1b42:	de bf       	out	0x3e, r29	; 62
    1b44:	0f be       	out	0x3f, r0	; 63
    1b46:	cd bf       	out	0x3d, r28	; 61
    1b48:	8b 87       	std	Y+11, r24	; 0x0b
    1b4a:	4c 87       	std	Y+12, r20	; 0x0c
    1b4c:	5d 87       	std	Y+13, r21	; 0x0d
    1b4e:	6e 87       	std	Y+14, r22	; 0x0e
    1b50:	7f 87       	std	Y+15, r23	; 0x0f
    1b52:	39 8b       	std	Y+17, r19	; 0x11
    1b54:	28 8b       	std	Y+16, r18	; 0x10
	f32 TickTime = NUMBER_0;
    1b56:	80 e0       	ldi	r24, 0x00	; 0
    1b58:	90 e0       	ldi	r25, 0x00	; 0
    1b5a:	a0 e0       	ldi	r26, 0x00	; 0
    1b5c:	b0 e0       	ldi	r27, 0x00	; 0
    1b5e:	8f 83       	std	Y+7, r24	; 0x07
    1b60:	98 87       	std	Y+8, r25	; 0x08
    1b62:	a9 87       	std	Y+9, r26	; 0x09
    1b64:	ba 87       	std	Y+10, r27	; 0x0a
	f32 N = NUMBER_0;
    1b66:	80 e0       	ldi	r24, 0x00	; 0
    1b68:	90 e0       	ldi	r25, 0x00	; 0
    1b6a:	a0 e0       	ldi	r26, 0x00	; 0
    1b6c:	b0 e0       	ldi	r27, 0x00	; 0
    1b6e:	8b 83       	std	Y+3, r24	; 0x03
    1b70:	9c 83       	std	Y+4, r25	; 0x04
    1b72:	ad 83       	std	Y+5, r26	; 0x05
    1b74:	be 83       	std	Y+6, r27	; 0x06
	u16 counter = NUMBER_0;
    1b76:	1a 82       	std	Y+2, r1	; 0x02
    1b78:	19 82       	std	Y+1, r1	; 0x01
	MCAL_T1_u8T1Prescaler(LOC_u8Clock_Selection, &TickTime);
    1b7a:	9e 01       	movw	r18, r28
    1b7c:	29 5f       	subi	r18, 0xF9	; 249
    1b7e:	3f 4f       	sbci	r19, 0xFF	; 255
    1b80:	8b 85       	ldd	r24, Y+11	; 0x0b
    1b82:	b9 01       	movw	r22, r18
    1b84:	0e 94 2b 0a 	call	0x1456	; 0x1456 <MCAL_T1_u8T1Prescaler>
	MCAL_T1_voidSetOCR1AValue(CTC_DELAY_CONST);
    1b88:	87 ec       	ldi	r24, 0xC7	; 199
    1b8a:	90 e0       	ldi	r25, 0x00	; 0
    1b8c:	0e 94 02 0c 	call	0x1804	; 0x1804 <MCAL_T1_voidSetOCR1AValue>
	if (LOC_fl32NumOFSecond <= 0 || LOC_fl32NumOFSecond > 0) {
    1b90:	6c 85       	ldd	r22, Y+12	; 0x0c
    1b92:	7d 85       	ldd	r23, Y+13	; 0x0d
    1b94:	8e 85       	ldd	r24, Y+14	; 0x0e
    1b96:	9f 85       	ldd	r25, Y+15	; 0x0f
    1b98:	20 e0       	ldi	r18, 0x00	; 0
    1b9a:	30 e0       	ldi	r19, 0x00	; 0
    1b9c:	40 e0       	ldi	r20, 0x00	; 0
    1b9e:	50 e0       	ldi	r21, 0x00	; 0
    1ba0:	0e 94 55 04 	call	0x8aa	; 0x8aa <__lesf2>
    1ba4:	18 16       	cp	r1, r24
    1ba6:	64 f4       	brge	.+24     	; 0x1bc0 <MCAL_T1_voidDelayCTCMode+0x8c>
    1ba8:	6c 85       	ldd	r22, Y+12	; 0x0c
    1baa:	7d 85       	ldd	r23, Y+13	; 0x0d
    1bac:	8e 85       	ldd	r24, Y+14	; 0x0e
    1bae:	9f 85       	ldd	r25, Y+15	; 0x0f
    1bb0:	20 e0       	ldi	r18, 0x00	; 0
    1bb2:	30 e0       	ldi	r19, 0x00	; 0
    1bb4:	40 e0       	ldi	r20, 0x00	; 0
    1bb6:	50 e0       	ldi	r21, 0x00	; 0
    1bb8:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1bbc:	18 16       	cp	r1, r24
    1bbe:	64 f5       	brge	.+88     	; 0x1c18 <MCAL_T1_voidDelayCTCMode+0xe4>
		N = ((CTC_DELAY_CONST + NUMBER_1) * TickTime);
    1bc0:	8f 81       	ldd	r24, Y+7	; 0x07
    1bc2:	98 85       	ldd	r25, Y+8	; 0x08
    1bc4:	a9 85       	ldd	r26, Y+9	; 0x09
    1bc6:	ba 85       	ldd	r27, Y+10	; 0x0a
    1bc8:	bc 01       	movw	r22, r24
    1bca:	cd 01       	movw	r24, r26
    1bcc:	20 e0       	ldi	r18, 0x00	; 0
    1bce:	30 e0       	ldi	r19, 0x00	; 0
    1bd0:	48 e4       	ldi	r20, 0x48	; 72
    1bd2:	53 e4       	ldi	r21, 0x43	; 67
    1bd4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1bd8:	dc 01       	movw	r26, r24
    1bda:	cb 01       	movw	r24, r22
    1bdc:	8b 83       	std	Y+3, r24	; 0x03
    1bde:	9c 83       	std	Y+4, r25	; 0x04
    1be0:	ad 83       	std	Y+5, r26	; 0x05
    1be2:	be 83       	std	Y+6, r27	; 0x06
		counter = (LOC_fl32NumOFSecond / N);
    1be4:	6c 85       	ldd	r22, Y+12	; 0x0c
    1be6:	7d 85       	ldd	r23, Y+13	; 0x0d
    1be8:	8e 85       	ldd	r24, Y+14	; 0x0e
    1bea:	9f 85       	ldd	r25, Y+15	; 0x0f
    1bec:	2b 81       	ldd	r18, Y+3	; 0x03
    1bee:	3c 81       	ldd	r19, Y+4	; 0x04
    1bf0:	4d 81       	ldd	r20, Y+5	; 0x05
    1bf2:	5e 81       	ldd	r21, Y+6	; 0x06
    1bf4:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1bf8:	dc 01       	movw	r26, r24
    1bfa:	cb 01       	movw	r24, r22
    1bfc:	bc 01       	movw	r22, r24
    1bfe:	cd 01       	movw	r24, r26
    1c00:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1c04:	dc 01       	movw	r26, r24
    1c06:	cb 01       	movw	r24, r22
    1c08:	9a 83       	std	Y+2, r25	; 0x02
    1c0a:	89 83       	std	Y+1, r24	; 0x01
		*LOC_pu16Counter = counter;
    1c0c:	e8 89       	ldd	r30, Y+16	; 0x10
    1c0e:	f9 89       	ldd	r31, Y+17	; 0x11
    1c10:	89 81       	ldd	r24, Y+1	; 0x01
    1c12:	9a 81       	ldd	r25, Y+2	; 0x02
    1c14:	91 83       	std	Z+1, r25	; 0x01
    1c16:	80 83       	st	Z, r24
	} else {
		//NOTING
	}
}
    1c18:	61 96       	adiw	r28, 0x11	; 17
    1c1a:	0f b6       	in	r0, 0x3f	; 63
    1c1c:	f8 94       	cli
    1c1e:	de bf       	out	0x3e, r29	; 62
    1c20:	0f be       	out	0x3f, r0	; 63
    1c22:	cd bf       	out	0x3d, r28	; 61
    1c24:	cf 91       	pop	r28
    1c26:	df 91       	pop	r29
    1c28:	08 95       	ret

00001c2a <MCAL_T1_voidSetTriggerEdge>:
//ICU EDGE
void MCAL_T1_voidSetTriggerEdge(u8 LOC_u8TriggerEdge) {
    1c2a:	df 93       	push	r29
    1c2c:	cf 93       	push	r28
    1c2e:	0f 92       	push	r0
    1c30:	cd b7       	in	r28, 0x3d	; 61
    1c32:	de b7       	in	r29, 0x3e	; 62
    1c34:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_u8TriggerEdge <= RISING_EDGE) {
    1c36:	89 81       	ldd	r24, Y+1	; 0x01
    1c38:	82 30       	cpi	r24, 0x02	; 2
    1c3a:	a8 f4       	brcc	.+42     	; 0x1c66 <MCAL_T1_voidSetTriggerEdge+0x3c>
		if (LOC_u8TriggerEdge == RISING_EDGE) {
    1c3c:	89 81       	ldd	r24, Y+1	; 0x01
    1c3e:	81 30       	cpi	r24, 0x01	; 1
    1c40:	41 f4       	brne	.+16     	; 0x1c52 <MCAL_T1_voidSetTriggerEdge+0x28>
			SET_BIT(TCCR1B, PIN6);
    1c42:	ae e4       	ldi	r26, 0x4E	; 78
    1c44:	b0 e0       	ldi	r27, 0x00	; 0
    1c46:	ee e4       	ldi	r30, 0x4E	; 78
    1c48:	f0 e0       	ldi	r31, 0x00	; 0
    1c4a:	80 81       	ld	r24, Z
    1c4c:	80 64       	ori	r24, 0x40	; 64
    1c4e:	8c 93       	st	X, r24
    1c50:	0a c0       	rjmp	.+20     	; 0x1c66 <MCAL_T1_voidSetTriggerEdge+0x3c>
		} else if (LOC_u8TriggerEdge == FALLING_EDGE) {
    1c52:	89 81       	ldd	r24, Y+1	; 0x01
    1c54:	88 23       	and	r24, r24
    1c56:	39 f4       	brne	.+14     	; 0x1c66 <MCAL_T1_voidSetTriggerEdge+0x3c>
			CLR_BIT(TCCR1B, PIN6);
    1c58:	ae e4       	ldi	r26, 0x4E	; 78
    1c5a:	b0 e0       	ldi	r27, 0x00	; 0
    1c5c:	ee e4       	ldi	r30, 0x4E	; 78
    1c5e:	f0 e0       	ldi	r31, 0x00	; 0
    1c60:	80 81       	ld	r24, Z
    1c62:	8f 7b       	andi	r24, 0xBF	; 191
    1c64:	8c 93       	st	X, r24
			//NOTHING
		}
	} else {
		//NOTHING
	}
}
    1c66:	0f 90       	pop	r0
    1c68:	cf 91       	pop	r28
    1c6a:	df 91       	pop	r29
    1c6c:	08 95       	ret

00001c6e <MCAL_T1_u8T1_Callback>:
u8 MCAL_T1_u8T1_Callback(void (*ptr)(void)) {
    1c6e:	df 93       	push	r29
    1c70:	cf 93       	push	r28
    1c72:	00 d0       	rcall	.+0      	; 0x1c74 <MCAL_T1_u8T1_Callback+0x6>
    1c74:	0f 92       	push	r0
    1c76:	cd b7       	in	r28, 0x3d	; 61
    1c78:	de b7       	in	r29, 0x3e	; 62
    1c7a:	9b 83       	std	Y+3, r25	; 0x03
    1c7c:	8a 83       	std	Y+2, r24	; 0x02
	u8 LOC_u8ReturnValue = E_NOT_OK;
    1c7e:	81 e0       	ldi	r24, 0x01	; 1
    1c80:	89 83       	std	Y+1, r24	; 0x01
	if (ptr != '\0') {
    1c82:	8a 81       	ldd	r24, Y+2	; 0x02
    1c84:	9b 81       	ldd	r25, Y+3	; 0x03
    1c86:	00 97       	sbiw	r24, 0x00	; 0
    1c88:	39 f0       	breq	.+14     	; 0x1c98 <MCAL_T1_u8T1_Callback+0x2a>
		Gptr_3 = ptr;
    1c8a:	8a 81       	ldd	r24, Y+2	; 0x02
    1c8c:	9b 81       	ldd	r25, Y+3	; 0x03
    1c8e:	90 93 2f 02 	sts	0x022F, r25
    1c92:	80 93 2e 02 	sts	0x022E, r24
		LOC_u8ReturnValue = E_OK;
    1c96:	19 82       	std	Y+1, r1	; 0x01
	}
	return LOC_u8ReturnValue;
    1c98:	89 81       	ldd	r24, Y+1	; 0x01
}
    1c9a:	0f 90       	pop	r0
    1c9c:	0f 90       	pop	r0
    1c9e:	0f 90       	pop	r0
    1ca0:	cf 91       	pop	r28
    1ca2:	df 91       	pop	r29
    1ca4:	08 95       	ret

00001ca6 <__vector_9>:

ISR(TIMER1_OVF_vect) {
    1ca6:	1f 92       	push	r1
    1ca8:	0f 92       	push	r0
    1caa:	0f b6       	in	r0, 0x3f	; 63
    1cac:	0f 92       	push	r0
    1cae:	11 24       	eor	r1, r1
    1cb0:	2f 93       	push	r18
    1cb2:	3f 93       	push	r19
    1cb4:	4f 93       	push	r20
    1cb6:	5f 93       	push	r21
    1cb8:	6f 93       	push	r22
    1cba:	7f 93       	push	r23
    1cbc:	8f 93       	push	r24
    1cbe:	9f 93       	push	r25
    1cc0:	af 93       	push	r26
    1cc2:	bf 93       	push	r27
    1cc4:	ef 93       	push	r30
    1cc6:	ff 93       	push	r31
    1cc8:	df 93       	push	r29
    1cca:	cf 93       	push	r28
    1ccc:	cd b7       	in	r28, 0x3d	; 61
    1cce:	de b7       	in	r29, 0x3e	; 62
	if (Gptr_3 != '\0') {
    1cd0:	80 91 2e 02 	lds	r24, 0x022E
    1cd4:	90 91 2f 02 	lds	r25, 0x022F
    1cd8:	00 97       	sbiw	r24, 0x00	; 0
    1cda:	29 f0       	breq	.+10     	; 0x1ce6 <__vector_9+0x40>
		Gptr_3();
    1cdc:	e0 91 2e 02 	lds	r30, 0x022E
    1ce0:	f0 91 2f 02 	lds	r31, 0x022F
    1ce4:	09 95       	icall
	}
}
    1ce6:	cf 91       	pop	r28
    1ce8:	df 91       	pop	r29
    1cea:	ff 91       	pop	r31
    1cec:	ef 91       	pop	r30
    1cee:	bf 91       	pop	r27
    1cf0:	af 91       	pop	r26
    1cf2:	9f 91       	pop	r25
    1cf4:	8f 91       	pop	r24
    1cf6:	7f 91       	pop	r23
    1cf8:	6f 91       	pop	r22
    1cfa:	5f 91       	pop	r21
    1cfc:	4f 91       	pop	r20
    1cfe:	3f 91       	pop	r19
    1d00:	2f 91       	pop	r18
    1d02:	0f 90       	pop	r0
    1d04:	0f be       	out	0x3f, r0	; 63
    1d06:	0f 90       	pop	r0
    1d08:	1f 90       	pop	r1
    1d0a:	18 95       	reti

00001d0c <TIMER1_COMPA_vect>:
ISR(TIMER1_COMPA_vect) {
    1d0c:	1f 92       	push	r1
    1d0e:	0f 92       	push	r0
    1d10:	0f b6       	in	r0, 0x3f	; 63
    1d12:	0f 92       	push	r0
    1d14:	11 24       	eor	r1, r1
    1d16:	2f 93       	push	r18
    1d18:	3f 93       	push	r19
    1d1a:	4f 93       	push	r20
    1d1c:	5f 93       	push	r21
    1d1e:	6f 93       	push	r22
    1d20:	7f 93       	push	r23
    1d22:	8f 93       	push	r24
    1d24:	9f 93       	push	r25
    1d26:	af 93       	push	r26
    1d28:	bf 93       	push	r27
    1d2a:	ef 93       	push	r30
    1d2c:	ff 93       	push	r31
    1d2e:	df 93       	push	r29
    1d30:	cf 93       	push	r28
    1d32:	cd b7       	in	r28, 0x3d	; 61
    1d34:	de b7       	in	r29, 0x3e	; 62
	if (Gptr_3 != '\0') {
    1d36:	80 91 2e 02 	lds	r24, 0x022E
    1d3a:	90 91 2f 02 	lds	r25, 0x022F
    1d3e:	00 97       	sbiw	r24, 0x00	; 0
    1d40:	29 f0       	breq	.+10     	; 0x1d4c <TIMER1_COMPA_vect+0x40>
		Gptr_3();
    1d42:	e0 91 2e 02 	lds	r30, 0x022E
    1d46:	f0 91 2f 02 	lds	r31, 0x022F
    1d4a:	09 95       	icall
	}
}
    1d4c:	cf 91       	pop	r28
    1d4e:	df 91       	pop	r29
    1d50:	ff 91       	pop	r31
    1d52:	ef 91       	pop	r30
    1d54:	bf 91       	pop	r27
    1d56:	af 91       	pop	r26
    1d58:	9f 91       	pop	r25
    1d5a:	8f 91       	pop	r24
    1d5c:	7f 91       	pop	r23
    1d5e:	6f 91       	pop	r22
    1d60:	5f 91       	pop	r21
    1d62:	4f 91       	pop	r20
    1d64:	3f 91       	pop	r19
    1d66:	2f 91       	pop	r18
    1d68:	0f 90       	pop	r0
    1d6a:	0f be       	out	0x3f, r0	; 63
    1d6c:	0f 90       	pop	r0
    1d6e:	1f 90       	pop	r1
    1d70:	18 95       	reti

00001d72 <__vector_8>:
ISR(TIMER1_COMPB_vect) {
    1d72:	1f 92       	push	r1
    1d74:	0f 92       	push	r0
    1d76:	0f b6       	in	r0, 0x3f	; 63
    1d78:	0f 92       	push	r0
    1d7a:	11 24       	eor	r1, r1
    1d7c:	2f 93       	push	r18
    1d7e:	3f 93       	push	r19
    1d80:	4f 93       	push	r20
    1d82:	5f 93       	push	r21
    1d84:	6f 93       	push	r22
    1d86:	7f 93       	push	r23
    1d88:	8f 93       	push	r24
    1d8a:	9f 93       	push	r25
    1d8c:	af 93       	push	r26
    1d8e:	bf 93       	push	r27
    1d90:	ef 93       	push	r30
    1d92:	ff 93       	push	r31
    1d94:	df 93       	push	r29
    1d96:	cf 93       	push	r28
    1d98:	cd b7       	in	r28, 0x3d	; 61
    1d9a:	de b7       	in	r29, 0x3e	; 62
	if (Gptr_3 != '\0') {
    1d9c:	80 91 2e 02 	lds	r24, 0x022E
    1da0:	90 91 2f 02 	lds	r25, 0x022F
    1da4:	00 97       	sbiw	r24, 0x00	; 0
    1da6:	29 f0       	breq	.+10     	; 0x1db2 <__vector_8+0x40>
		Gptr_3();
    1da8:	e0 91 2e 02 	lds	r30, 0x022E
    1dac:	f0 91 2f 02 	lds	r31, 0x022F
    1db0:	09 95       	icall
	}
}
    1db2:	cf 91       	pop	r28
    1db4:	df 91       	pop	r29
    1db6:	ff 91       	pop	r31
    1db8:	ef 91       	pop	r30
    1dba:	bf 91       	pop	r27
    1dbc:	af 91       	pop	r26
    1dbe:	9f 91       	pop	r25
    1dc0:	8f 91       	pop	r24
    1dc2:	7f 91       	pop	r23
    1dc4:	6f 91       	pop	r22
    1dc6:	5f 91       	pop	r21
    1dc8:	4f 91       	pop	r20
    1dca:	3f 91       	pop	r19
    1dcc:	2f 91       	pop	r18
    1dce:	0f 90       	pop	r0
    1dd0:	0f be       	out	0x3f, r0	; 63
    1dd2:	0f 90       	pop	r0
    1dd4:	1f 90       	pop	r1
    1dd6:	18 95       	reti

00001dd8 <__vector_6>:
ISR(TIMER1_CAPT_vect) {
    1dd8:	1f 92       	push	r1
    1dda:	0f 92       	push	r0
    1ddc:	0f b6       	in	r0, 0x3f	; 63
    1dde:	0f 92       	push	r0
    1de0:	11 24       	eor	r1, r1
    1de2:	2f 93       	push	r18
    1de4:	3f 93       	push	r19
    1de6:	4f 93       	push	r20
    1de8:	5f 93       	push	r21
    1dea:	6f 93       	push	r22
    1dec:	7f 93       	push	r23
    1dee:	8f 93       	push	r24
    1df0:	9f 93       	push	r25
    1df2:	af 93       	push	r26
    1df4:	bf 93       	push	r27
    1df6:	ef 93       	push	r30
    1df8:	ff 93       	push	r31
    1dfa:	df 93       	push	r29
    1dfc:	cf 93       	push	r28
    1dfe:	cd b7       	in	r28, 0x3d	; 61
    1e00:	de b7       	in	r29, 0x3e	; 62
	if (Gptr_3 != '\0') {
    1e02:	80 91 2e 02 	lds	r24, 0x022E
    1e06:	90 91 2f 02 	lds	r25, 0x022F
    1e0a:	00 97       	sbiw	r24, 0x00	; 0
    1e0c:	29 f0       	breq	.+10     	; 0x1e18 <__vector_6+0x40>
		Gptr_3();
    1e0e:	e0 91 2e 02 	lds	r30, 0x022E
    1e12:	f0 91 2f 02 	lds	r31, 0x022F
    1e16:	09 95       	icall
	}
}
    1e18:	cf 91       	pop	r28
    1e1a:	df 91       	pop	r29
    1e1c:	ff 91       	pop	r31
    1e1e:	ef 91       	pop	r30
    1e20:	bf 91       	pop	r27
    1e22:	af 91       	pop	r26
    1e24:	9f 91       	pop	r25
    1e26:	8f 91       	pop	r24
    1e28:	7f 91       	pop	r23
    1e2a:	6f 91       	pop	r22
    1e2c:	5f 91       	pop	r21
    1e2e:	4f 91       	pop	r20
    1e30:	3f 91       	pop	r19
    1e32:	2f 91       	pop	r18
    1e34:	0f 90       	pop	r0
    1e36:	0f be       	out	0x3f, r0	; 63
    1e38:	0f 90       	pop	r0
    1e3a:	1f 90       	pop	r1
    1e3c:	18 95       	reti

00001e3e <MCAL_T1_FPWM_10bitRES>:

void MCAL_T1_FPWM_10bitRES(u8 copy_u8Channel, u8 copy_u8Duty) {
    1e3e:	0f 93       	push	r16
    1e40:	1f 93       	push	r17
    1e42:	df 93       	push	r29
    1e44:	cf 93       	push	r28
    1e46:	00 d0       	rcall	.+0      	; 0x1e48 <MCAL_T1_FPWM_10bitRES+0xa>
    1e48:	00 d0       	rcall	.+0      	; 0x1e4a <MCAL_T1_FPWM_10bitRES+0xc>
    1e4a:	00 d0       	rcall	.+0      	; 0x1e4c <MCAL_T1_FPWM_10bitRES+0xe>
    1e4c:	cd b7       	in	r28, 0x3d	; 61
    1e4e:	de b7       	in	r29, 0x3e	; 62
    1e50:	8d 83       	std	Y+5, r24	; 0x05
    1e52:	6e 83       	std	Y+6, r22	; 0x06
	f32 LOC_fl32tickTime = 0;
    1e54:	80 e0       	ldi	r24, 0x00	; 0
    1e56:	90 e0       	ldi	r25, 0x00	; 0
    1e58:	a0 e0       	ldi	r26, 0x00	; 0
    1e5a:	b0 e0       	ldi	r27, 0x00	; 0
    1e5c:	89 83       	std	Y+1, r24	; 0x01
    1e5e:	9a 83       	std	Y+2, r25	; 0x02
    1e60:	ab 83       	std	Y+3, r26	; 0x03
    1e62:	bc 83       	std	Y+4, r27	; 0x04
	//Set Mode
	MCAL_T1_u8T1Init(PWM_PHASE_CORRECT_10bit);
    1e64:	83 e0       	ldi	r24, 0x03	; 3
    1e66:	0e 94 0a 08 	call	0x1014	; 0x1014 <MCAL_T1_u8T1Init>
	//Select Prescaler
	MCAL_T1_u8T1Prescaler(PRESCALLING_64, &LOC_fl32tickTime);
    1e6a:	83 e0       	ldi	r24, 0x03	; 3
    1e6c:	9e 01       	movw	r18, r28
    1e6e:	2f 5f       	subi	r18, 0xFF	; 255
    1e70:	3f 4f       	sbci	r19, 0xFF	; 255
    1e72:	b9 01       	movw	r22, r18
    1e74:	0e 94 2b 0a 	call	0x1456	; 0x1456 <MCAL_T1_u8T1Prescaler>
	MCAL_T1_u8T1CompareOutputMode(NON_INVERTING_MODE, copy_u8Channel);
    1e78:	80 e0       	ldi	r24, 0x00	; 0
    1e7a:	6d 81       	ldd	r22, Y+5	; 0x05
    1e7c:	0e 94 43 0b 	call	0x1686	; 0x1686 <MCAL_T1_u8T1CompareOutputMode>
	if (copy_u8Channel == CHENNEL_A) {
    1e80:	8d 81       	ldd	r24, Y+5	; 0x05
    1e82:	88 23       	and	r24, r24
    1e84:	19 f5       	brne	.+70     	; 0x1ecc <MCAL_T1_FPWM_10bitRES+0x8e>
		OCR1A = copy_u8Duty * 10.23;
    1e86:	0a e4       	ldi	r16, 0x4A	; 74
    1e88:	10 e0       	ldi	r17, 0x00	; 0
    1e8a:	8e 81       	ldd	r24, Y+6	; 0x06
    1e8c:	88 2f       	mov	r24, r24
    1e8e:	90 e0       	ldi	r25, 0x00	; 0
    1e90:	aa 27       	eor	r26, r26
    1e92:	97 fd       	sbrc	r25, 7
    1e94:	a0 95       	com	r26
    1e96:	ba 2f       	mov	r27, r26
    1e98:	bc 01       	movw	r22, r24
    1e9a:	cd 01       	movw	r24, r26
    1e9c:	0e 94 85 04 	call	0x90a	; 0x90a <__floatsisf>
    1ea0:	dc 01       	movw	r26, r24
    1ea2:	cb 01       	movw	r24, r22
    1ea4:	bc 01       	movw	r22, r24
    1ea6:	cd 01       	movw	r24, r26
    1ea8:	24 e1       	ldi	r18, 0x14	; 20
    1eaa:	3e ea       	ldi	r19, 0xAE	; 174
    1eac:	43 e2       	ldi	r20, 0x23	; 35
    1eae:	51 e4       	ldi	r21, 0x41	; 65
    1eb0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1eb4:	dc 01       	movw	r26, r24
    1eb6:	cb 01       	movw	r24, r22
    1eb8:	bc 01       	movw	r22, r24
    1eba:	cd 01       	movw	r24, r26
    1ebc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1ec0:	dc 01       	movw	r26, r24
    1ec2:	cb 01       	movw	r24, r22
    1ec4:	f8 01       	movw	r30, r16
    1ec6:	91 83       	std	Z+1, r25	; 0x01
    1ec8:	80 83       	st	Z, r24
    1eca:	25 c0       	rjmp	.+74     	; 0x1f16 <MCAL_T1_FPWM_10bitRES+0xd8>
	} else if (copy_u8Channel == CHENNEL_B) {
    1ecc:	8d 81       	ldd	r24, Y+5	; 0x05
    1ece:	81 30       	cpi	r24, 0x01	; 1
    1ed0:	11 f5       	brne	.+68     	; 0x1f16 <MCAL_T1_FPWM_10bitRES+0xd8>
		OCR1B = copy_u8Duty * 10.23;
    1ed2:	08 e4       	ldi	r16, 0x48	; 72
    1ed4:	10 e0       	ldi	r17, 0x00	; 0
    1ed6:	8e 81       	ldd	r24, Y+6	; 0x06
    1ed8:	88 2f       	mov	r24, r24
    1eda:	90 e0       	ldi	r25, 0x00	; 0
    1edc:	aa 27       	eor	r26, r26
    1ede:	97 fd       	sbrc	r25, 7
    1ee0:	a0 95       	com	r26
    1ee2:	ba 2f       	mov	r27, r26
    1ee4:	bc 01       	movw	r22, r24
    1ee6:	cd 01       	movw	r24, r26
    1ee8:	0e 94 85 04 	call	0x90a	; 0x90a <__floatsisf>
    1eec:	dc 01       	movw	r26, r24
    1eee:	cb 01       	movw	r24, r22
    1ef0:	bc 01       	movw	r22, r24
    1ef2:	cd 01       	movw	r24, r26
    1ef4:	24 e1       	ldi	r18, 0x14	; 20
    1ef6:	3e ea       	ldi	r19, 0xAE	; 174
    1ef8:	43 e2       	ldi	r20, 0x23	; 35
    1efa:	51 e4       	ldi	r21, 0x41	; 65
    1efc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1f00:	dc 01       	movw	r26, r24
    1f02:	cb 01       	movw	r24, r22
    1f04:	bc 01       	movw	r22, r24
    1f06:	cd 01       	movw	r24, r26
    1f08:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1f0c:	dc 01       	movw	r26, r24
    1f0e:	cb 01       	movw	r24, r22
    1f10:	f8 01       	movw	r30, r16
    1f12:	91 83       	std	Z+1, r25	; 0x01
    1f14:	80 83       	st	Z, r24

	} else {
		//NOTHING
	}
}
    1f16:	26 96       	adiw	r28, 0x06	; 6
    1f18:	0f b6       	in	r0, 0x3f	; 63
    1f1a:	f8 94       	cli
    1f1c:	de bf       	out	0x3e, r29	; 62
    1f1e:	0f be       	out	0x3f, r0	; 63
    1f20:	cd bf       	out	0x3d, r28	; 61
    1f22:	cf 91       	pop	r28
    1f24:	df 91       	pop	r29
    1f26:	1f 91       	pop	r17
    1f28:	0f 91       	pop	r16
    1f2a:	08 95       	ret

00001f2c <MCAL_Timer0_Init>:
void (*Gptr3)(void)= '\0' ;
f32 Glob_TickTime;
u16 Start = 0;
u16 Counter = 0;

void MCAL_Timer0_Init(u8 Loc_u8Mode, u8 Loc_u8Prescaller,u8 Loc_u8OC0Mode) {
    1f2c:	df 93       	push	r29
    1f2e:	cf 93       	push	r28
    1f30:	00 d0       	rcall	.+0      	; 0x1f32 <MCAL_Timer0_Init+0x6>
    1f32:	00 d0       	rcall	.+0      	; 0x1f34 <MCAL_Timer0_Init+0x8>
    1f34:	cd b7       	in	r28, 0x3d	; 61
    1f36:	de b7       	in	r29, 0x3e	; 62
    1f38:	8a 83       	std	Y+2, r24	; 0x02
    1f3a:	6b 83       	std	Y+3, r22	; 0x03
    1f3c:	4c 83       	std	Y+4, r20	; 0x04
	u8 LOC_u8ReturnValue = E_NOT_OK;
    1f3e:	81 e0       	ldi	r24, 0x01	; 1
    1f40:	89 83       	std	Y+1, r24	; 0x01
	SET_BIT(SREG, 7);
    1f42:	af e5       	ldi	r26, 0x5F	; 95
    1f44:	b0 e0       	ldi	r27, 0x00	; 0
    1f46:	ef e5       	ldi	r30, 0x5F	; 95
    1f48:	f0 e0       	ldi	r31, 0x00	; 0
    1f4a:	80 81       	ld	r24, Z
    1f4c:	80 68       	ori	r24, 0x80	; 128
    1f4e:	8c 93       	st	X, r24
	if (Loc_u8Mode == Normal_Mode) {
    1f50:	8a 81       	ldd	r24, Y+2	; 0x02
    1f52:	88 23       	and	r24, r24
    1f54:	b1 f4       	brne	.+44     	; 0x1f82 <MCAL_Timer0_Init+0x56>
		CLR_BIT(TCCR0, 3);
    1f56:	a3 e5       	ldi	r26, 0x53	; 83
    1f58:	b0 e0       	ldi	r27, 0x00	; 0
    1f5a:	e3 e5       	ldi	r30, 0x53	; 83
    1f5c:	f0 e0       	ldi	r31, 0x00	; 0
    1f5e:	80 81       	ld	r24, Z
    1f60:	87 7f       	andi	r24, 0xF7	; 247
    1f62:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 6);
    1f64:	a3 e5       	ldi	r26, 0x53	; 83
    1f66:	b0 e0       	ldi	r27, 0x00	; 0
    1f68:	e3 e5       	ldi	r30, 0x53	; 83
    1f6a:	f0 e0       	ldi	r31, 0x00	; 0
    1f6c:	80 81       	ld	r24, Z
    1f6e:	8f 7b       	andi	r24, 0xBF	; 191
    1f70:	8c 93       	st	X, r24
		SET_BIT(TIMSK, 0);
    1f72:	a9 e5       	ldi	r26, 0x59	; 89
    1f74:	b0 e0       	ldi	r27, 0x00	; 0
    1f76:	e9 e5       	ldi	r30, 0x59	; 89
    1f78:	f0 e0       	ldi	r31, 0x00	; 0
    1f7a:	80 81       	ld	r24, Z
    1f7c:	81 60       	ori	r24, 0x01	; 1
    1f7e:	8c 93       	st	X, r24
    1f80:	35 c0       	rjmp	.+106    	; 0x1fec <MCAL_Timer0_Init+0xc0>
	} else if (Loc_u8Mode == CTC_Mode) {
    1f82:	8a 81       	ldd	r24, Y+2	; 0x02
    1f84:	81 30       	cpi	r24, 0x01	; 1
    1f86:	b1 f4       	brne	.+44     	; 0x1fb4 <MCAL_Timer0_Init+0x88>
		SET_BIT(TCCR0, 3);
    1f88:	a3 e5       	ldi	r26, 0x53	; 83
    1f8a:	b0 e0       	ldi	r27, 0x00	; 0
    1f8c:	e3 e5       	ldi	r30, 0x53	; 83
    1f8e:	f0 e0       	ldi	r31, 0x00	; 0
    1f90:	80 81       	ld	r24, Z
    1f92:	88 60       	ori	r24, 0x08	; 8
    1f94:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 6);
    1f96:	a3 e5       	ldi	r26, 0x53	; 83
    1f98:	b0 e0       	ldi	r27, 0x00	; 0
    1f9a:	e3 e5       	ldi	r30, 0x53	; 83
    1f9c:	f0 e0       	ldi	r31, 0x00	; 0
    1f9e:	80 81       	ld	r24, Z
    1fa0:	8f 7b       	andi	r24, 0xBF	; 191
    1fa2:	8c 93       	st	X, r24
		SET_BIT(TIMSK, 1);
    1fa4:	a9 e5       	ldi	r26, 0x59	; 89
    1fa6:	b0 e0       	ldi	r27, 0x00	; 0
    1fa8:	e9 e5       	ldi	r30, 0x59	; 89
    1faa:	f0 e0       	ldi	r31, 0x00	; 0
    1fac:	80 81       	ld	r24, Z
    1fae:	82 60       	ori	r24, 0x02	; 2
    1fb0:	8c 93       	st	X, r24
    1fb2:	1c c0       	rjmp	.+56     	; 0x1fec <MCAL_Timer0_Init+0xc0>
	} else if (Loc_u8Mode == PWM_Mode) {
    1fb4:	8a 81       	ldd	r24, Y+2	; 0x02
    1fb6:	82 30       	cpi	r24, 0x02	; 2
    1fb8:	79 f4       	brne	.+30     	; 0x1fd8 <MCAL_Timer0_Init+0xac>
		CLR_BIT(TCCR0, 3);
    1fba:	a3 e5       	ldi	r26, 0x53	; 83
    1fbc:	b0 e0       	ldi	r27, 0x00	; 0
    1fbe:	e3 e5       	ldi	r30, 0x53	; 83
    1fc0:	f0 e0       	ldi	r31, 0x00	; 0
    1fc2:	80 81       	ld	r24, Z
    1fc4:	87 7f       	andi	r24, 0xF7	; 247
    1fc6:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 6);
    1fc8:	a3 e5       	ldi	r26, 0x53	; 83
    1fca:	b0 e0       	ldi	r27, 0x00	; 0
    1fcc:	e3 e5       	ldi	r30, 0x53	; 83
    1fce:	f0 e0       	ldi	r31, 0x00	; 0
    1fd0:	80 81       	ld	r24, Z
    1fd2:	80 64       	ori	r24, 0x40	; 64
    1fd4:	8c 93       	st	X, r24
    1fd6:	0a c0       	rjmp	.+20     	; 0x1fec <MCAL_Timer0_Init+0xc0>
	} else if (Loc_u8Mode == FastPWM_Mode) {
    1fd8:	8a 81       	ldd	r24, Y+2	; 0x02
    1fda:	83 30       	cpi	r24, 0x03	; 3
    1fdc:	39 f4       	brne	.+14     	; 0x1fec <MCAL_Timer0_Init+0xc0>
//		SET_BIT(TCCR0, 3);
//		SET_BIT(TCCR0, 6);
		SET_BIT(TIMSK, 1);
    1fde:	a9 e5       	ldi	r26, 0x59	; 89
    1fe0:	b0 e0       	ldi	r27, 0x00	; 0
    1fe2:	e9 e5       	ldi	r30, 0x59	; 89
    1fe4:	f0 e0       	ldi	r31, 0x00	; 0
    1fe6:	80 81       	ld	r24, Z
    1fe8:	82 60       	ori	r24, 0x02	; 2
    1fea:	8c 93       	st	X, r24
	}
	if (Loc_u8Prescaller == NoPrescaller) {
    1fec:	8b 81       	ldd	r24, Y+3	; 0x03
    1fee:	88 23       	and	r24, r24
    1ff0:	b9 f4       	brne	.+46     	; 0x2020 <MCAL_Timer0_Init+0xf4>
		CLR_BIT(TCCR0, 0);
    1ff2:	a3 e5       	ldi	r26, 0x53	; 83
    1ff4:	b0 e0       	ldi	r27, 0x00	; 0
    1ff6:	e3 e5       	ldi	r30, 0x53	; 83
    1ff8:	f0 e0       	ldi	r31, 0x00	; 0
    1ffa:	80 81       	ld	r24, Z
    1ffc:	8e 7f       	andi	r24, 0xFE	; 254
    1ffe:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 1);
    2000:	a3 e5       	ldi	r26, 0x53	; 83
    2002:	b0 e0       	ldi	r27, 0x00	; 0
    2004:	e3 e5       	ldi	r30, 0x53	; 83
    2006:	f0 e0       	ldi	r31, 0x00	; 0
    2008:	80 81       	ld	r24, Z
    200a:	8d 7f       	andi	r24, 0xFD	; 253
    200c:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 2);
    200e:	a3 e5       	ldi	r26, 0x53	; 83
    2010:	b0 e0       	ldi	r27, 0x00	; 0
    2012:	e3 e5       	ldi	r30, 0x53	; 83
    2014:	f0 e0       	ldi	r31, 0x00	; 0
    2016:	80 81       	ld	r24, Z
    2018:	8b 7f       	andi	r24, 0xFB	; 251
    201a:	8c 93       	st	X, r24
		LOC_u8ReturnValue = E_OK;
    201c:	19 82       	std	Y+1, r1	; 0x01
    201e:	f1 c0       	rjmp	.+482    	; 0x2202 <MCAL_Timer0_Init+0x2d6>
	} else if (Loc_u8Prescaller == Prescaller_1) {
    2020:	8b 81       	ldd	r24, Y+3	; 0x03
    2022:	81 30       	cpi	r24, 0x01	; 1
    2024:	19 f5       	brne	.+70     	; 0x206c <MCAL_Timer0_Init+0x140>
		SET_BIT(TCCR0, 0);
    2026:	a3 e5       	ldi	r26, 0x53	; 83
    2028:	b0 e0       	ldi	r27, 0x00	; 0
    202a:	e3 e5       	ldi	r30, 0x53	; 83
    202c:	f0 e0       	ldi	r31, 0x00	; 0
    202e:	80 81       	ld	r24, Z
    2030:	81 60       	ori	r24, 0x01	; 1
    2032:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 1);
    2034:	a3 e5       	ldi	r26, 0x53	; 83
    2036:	b0 e0       	ldi	r27, 0x00	; 0
    2038:	e3 e5       	ldi	r30, 0x53	; 83
    203a:	f0 e0       	ldi	r31, 0x00	; 0
    203c:	80 81       	ld	r24, Z
    203e:	8d 7f       	andi	r24, 0xFD	; 253
    2040:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 2);
    2042:	a3 e5       	ldi	r26, 0x53	; 83
    2044:	b0 e0       	ldi	r27, 0x00	; 0
    2046:	e3 e5       	ldi	r30, 0x53	; 83
    2048:	f0 e0       	ldi	r31, 0x00	; 0
    204a:	80 81       	ld	r24, Z
    204c:	8b 7f       	andi	r24, 0xFB	; 251
    204e:	8c 93       	st	X, r24
		Glob_TickTime = Prescaller1_Value / (f32) CPU_Frequancy;
    2050:	8d eb       	ldi	r24, 0xBD	; 189
    2052:	97 e3       	ldi	r25, 0x37	; 55
    2054:	a6 e8       	ldi	r26, 0x86	; 134
    2056:	b3 e3       	ldi	r27, 0x33	; 51
    2058:	80 93 d6 06 	sts	0x06D6, r24
    205c:	90 93 d7 06 	sts	0x06D7, r25
    2060:	a0 93 d8 06 	sts	0x06D8, r26
    2064:	b0 93 d9 06 	sts	0x06D9, r27
		LOC_u8ReturnValue = E_OK;
    2068:	19 82       	std	Y+1, r1	; 0x01
    206a:	cb c0       	rjmp	.+406    	; 0x2202 <MCAL_Timer0_Init+0x2d6>
	} else if (Loc_u8Prescaller == Prescaller_8) {
    206c:	8b 81       	ldd	r24, Y+3	; 0x03
    206e:	82 30       	cpi	r24, 0x02	; 2
    2070:	19 f5       	brne	.+70     	; 0x20b8 <MCAL_Timer0_Init+0x18c>
		CLR_BIT(TCCR0, 0);
    2072:	a3 e5       	ldi	r26, 0x53	; 83
    2074:	b0 e0       	ldi	r27, 0x00	; 0
    2076:	e3 e5       	ldi	r30, 0x53	; 83
    2078:	f0 e0       	ldi	r31, 0x00	; 0
    207a:	80 81       	ld	r24, Z
    207c:	8e 7f       	andi	r24, 0xFE	; 254
    207e:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 1);
    2080:	a3 e5       	ldi	r26, 0x53	; 83
    2082:	b0 e0       	ldi	r27, 0x00	; 0
    2084:	e3 e5       	ldi	r30, 0x53	; 83
    2086:	f0 e0       	ldi	r31, 0x00	; 0
    2088:	80 81       	ld	r24, Z
    208a:	82 60       	ori	r24, 0x02	; 2
    208c:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 2);
    208e:	a3 e5       	ldi	r26, 0x53	; 83
    2090:	b0 e0       	ldi	r27, 0x00	; 0
    2092:	e3 e5       	ldi	r30, 0x53	; 83
    2094:	f0 e0       	ldi	r31, 0x00	; 0
    2096:	80 81       	ld	r24, Z
    2098:	8b 7f       	andi	r24, 0xFB	; 251
    209a:	8c 93       	st	X, r24
		Glob_TickTime = Prescaller8_Value / (f32) CPU_Frequancy;
    209c:	8d eb       	ldi	r24, 0xBD	; 189
    209e:	97 e3       	ldi	r25, 0x37	; 55
    20a0:	a6 e0       	ldi	r26, 0x06	; 6
    20a2:	b5 e3       	ldi	r27, 0x35	; 53
    20a4:	80 93 d6 06 	sts	0x06D6, r24
    20a8:	90 93 d7 06 	sts	0x06D7, r25
    20ac:	a0 93 d8 06 	sts	0x06D8, r26
    20b0:	b0 93 d9 06 	sts	0x06D9, r27
		LOC_u8ReturnValue = E_OK;
    20b4:	19 82       	std	Y+1, r1	; 0x01
    20b6:	a5 c0       	rjmp	.+330    	; 0x2202 <MCAL_Timer0_Init+0x2d6>
	} else if (Loc_u8Prescaller == Prescaller_64) {
    20b8:	8b 81       	ldd	r24, Y+3	; 0x03
    20ba:	83 30       	cpi	r24, 0x03	; 3
    20bc:	19 f5       	brne	.+70     	; 0x2104 <MCAL_Timer0_Init+0x1d8>
		SET_BIT(TCCR0, 0);
    20be:	a3 e5       	ldi	r26, 0x53	; 83
    20c0:	b0 e0       	ldi	r27, 0x00	; 0
    20c2:	e3 e5       	ldi	r30, 0x53	; 83
    20c4:	f0 e0       	ldi	r31, 0x00	; 0
    20c6:	80 81       	ld	r24, Z
    20c8:	81 60       	ori	r24, 0x01	; 1
    20ca:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 1);
    20cc:	a3 e5       	ldi	r26, 0x53	; 83
    20ce:	b0 e0       	ldi	r27, 0x00	; 0
    20d0:	e3 e5       	ldi	r30, 0x53	; 83
    20d2:	f0 e0       	ldi	r31, 0x00	; 0
    20d4:	80 81       	ld	r24, Z
    20d6:	82 60       	ori	r24, 0x02	; 2
    20d8:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 2);
    20da:	a3 e5       	ldi	r26, 0x53	; 83
    20dc:	b0 e0       	ldi	r27, 0x00	; 0
    20de:	e3 e5       	ldi	r30, 0x53	; 83
    20e0:	f0 e0       	ldi	r31, 0x00	; 0
    20e2:	80 81       	ld	r24, Z
    20e4:	8b 7f       	andi	r24, 0xFB	; 251
    20e6:	8c 93       	st	X, r24
		Glob_TickTime = Prescaller64_Value / (f32) CPU_Frequancy;
    20e8:	8d eb       	ldi	r24, 0xBD	; 189
    20ea:	97 e3       	ldi	r25, 0x37	; 55
    20ec:	a6 e8       	ldi	r26, 0x86	; 134
    20ee:	b6 e3       	ldi	r27, 0x36	; 54
    20f0:	80 93 d6 06 	sts	0x06D6, r24
    20f4:	90 93 d7 06 	sts	0x06D7, r25
    20f8:	a0 93 d8 06 	sts	0x06D8, r26
    20fc:	b0 93 d9 06 	sts	0x06D9, r27
		LOC_u8ReturnValue = E_OK;
    2100:	19 82       	std	Y+1, r1	; 0x01
    2102:	7f c0       	rjmp	.+254    	; 0x2202 <MCAL_Timer0_Init+0x2d6>
	} else if (Loc_u8Prescaller == Prescaller_256) {
    2104:	8b 81       	ldd	r24, Y+3	; 0x03
    2106:	84 30       	cpi	r24, 0x04	; 4
    2108:	19 f5       	brne	.+70     	; 0x2150 <MCAL_Timer0_Init+0x224>
		CLR_BIT(TCCR0, 0);
    210a:	a3 e5       	ldi	r26, 0x53	; 83
    210c:	b0 e0       	ldi	r27, 0x00	; 0
    210e:	e3 e5       	ldi	r30, 0x53	; 83
    2110:	f0 e0       	ldi	r31, 0x00	; 0
    2112:	80 81       	ld	r24, Z
    2114:	8e 7f       	andi	r24, 0xFE	; 254
    2116:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 1);
    2118:	a3 e5       	ldi	r26, 0x53	; 83
    211a:	b0 e0       	ldi	r27, 0x00	; 0
    211c:	e3 e5       	ldi	r30, 0x53	; 83
    211e:	f0 e0       	ldi	r31, 0x00	; 0
    2120:	80 81       	ld	r24, Z
    2122:	8d 7f       	andi	r24, 0xFD	; 253
    2124:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 2);
    2126:	a3 e5       	ldi	r26, 0x53	; 83
    2128:	b0 e0       	ldi	r27, 0x00	; 0
    212a:	e3 e5       	ldi	r30, 0x53	; 83
    212c:	f0 e0       	ldi	r31, 0x00	; 0
    212e:	80 81       	ld	r24, Z
    2130:	84 60       	ori	r24, 0x04	; 4
    2132:	8c 93       	st	X, r24
		Glob_TickTime = Prescaller256_Value / (f32) CPU_Frequancy;
    2134:	8d eb       	ldi	r24, 0xBD	; 189
    2136:	97 e3       	ldi	r25, 0x37	; 55
    2138:	a6 e8       	ldi	r26, 0x86	; 134
    213a:	b7 e3       	ldi	r27, 0x37	; 55
    213c:	80 93 d6 06 	sts	0x06D6, r24
    2140:	90 93 d7 06 	sts	0x06D7, r25
    2144:	a0 93 d8 06 	sts	0x06D8, r26
    2148:	b0 93 d9 06 	sts	0x06D9, r27
		LOC_u8ReturnValue = E_OK;
    214c:	19 82       	std	Y+1, r1	; 0x01
    214e:	59 c0       	rjmp	.+178    	; 0x2202 <MCAL_Timer0_Init+0x2d6>
	} else if (Loc_u8Prescaller == Prescaller_1024) {
    2150:	8b 81       	ldd	r24, Y+3	; 0x03
    2152:	85 30       	cpi	r24, 0x05	; 5
    2154:	19 f5       	brne	.+70     	; 0x219c <MCAL_Timer0_Init+0x270>
		SET_BIT(TCCR0, 0);
    2156:	a3 e5       	ldi	r26, 0x53	; 83
    2158:	b0 e0       	ldi	r27, 0x00	; 0
    215a:	e3 e5       	ldi	r30, 0x53	; 83
    215c:	f0 e0       	ldi	r31, 0x00	; 0
    215e:	80 81       	ld	r24, Z
    2160:	81 60       	ori	r24, 0x01	; 1
    2162:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 1);
    2164:	a3 e5       	ldi	r26, 0x53	; 83
    2166:	b0 e0       	ldi	r27, 0x00	; 0
    2168:	e3 e5       	ldi	r30, 0x53	; 83
    216a:	f0 e0       	ldi	r31, 0x00	; 0
    216c:	80 81       	ld	r24, Z
    216e:	8d 7f       	andi	r24, 0xFD	; 253
    2170:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 2);
    2172:	a3 e5       	ldi	r26, 0x53	; 83
    2174:	b0 e0       	ldi	r27, 0x00	; 0
    2176:	e3 e5       	ldi	r30, 0x53	; 83
    2178:	f0 e0       	ldi	r31, 0x00	; 0
    217a:	80 81       	ld	r24, Z
    217c:	84 60       	ori	r24, 0x04	; 4
    217e:	8c 93       	st	X, r24
		Glob_TickTime = Prescaller1024_Value / (f32) CPU_Frequancy;
    2180:	8d eb       	ldi	r24, 0xBD	; 189
    2182:	97 e3       	ldi	r25, 0x37	; 55
    2184:	a6 e8       	ldi	r26, 0x86	; 134
    2186:	b8 e3       	ldi	r27, 0x38	; 56
    2188:	80 93 d6 06 	sts	0x06D6, r24
    218c:	90 93 d7 06 	sts	0x06D7, r25
    2190:	a0 93 d8 06 	sts	0x06D8, r26
    2194:	b0 93 d9 06 	sts	0x06D9, r27
		LOC_u8ReturnValue = E_OK;
    2198:	19 82       	std	Y+1, r1	; 0x01
    219a:	33 c0       	rjmp	.+102    	; 0x2202 <MCAL_Timer0_Init+0x2d6>
	} else if (Loc_u8Prescaller == Clock_on_falling_edge) {
    219c:	8b 81       	ldd	r24, Y+3	; 0x03
    219e:	86 30       	cpi	r24, 0x06	; 6
    21a0:	b9 f4       	brne	.+46     	; 0x21d0 <MCAL_Timer0_Init+0x2a4>
		CLR_BIT(TCCR0, 0);
    21a2:	a3 e5       	ldi	r26, 0x53	; 83
    21a4:	b0 e0       	ldi	r27, 0x00	; 0
    21a6:	e3 e5       	ldi	r30, 0x53	; 83
    21a8:	f0 e0       	ldi	r31, 0x00	; 0
    21aa:	80 81       	ld	r24, Z
    21ac:	8e 7f       	andi	r24, 0xFE	; 254
    21ae:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 1);
    21b0:	a3 e5       	ldi	r26, 0x53	; 83
    21b2:	b0 e0       	ldi	r27, 0x00	; 0
    21b4:	e3 e5       	ldi	r30, 0x53	; 83
    21b6:	f0 e0       	ldi	r31, 0x00	; 0
    21b8:	80 81       	ld	r24, Z
    21ba:	82 60       	ori	r24, 0x02	; 2
    21bc:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 2);
    21be:	a3 e5       	ldi	r26, 0x53	; 83
    21c0:	b0 e0       	ldi	r27, 0x00	; 0
    21c2:	e3 e5       	ldi	r30, 0x53	; 83
    21c4:	f0 e0       	ldi	r31, 0x00	; 0
    21c6:	80 81       	ld	r24, Z
    21c8:	84 60       	ori	r24, 0x04	; 4
    21ca:	8c 93       	st	X, r24
		LOC_u8ReturnValue = E_OK;
    21cc:	19 82       	std	Y+1, r1	; 0x01
    21ce:	19 c0       	rjmp	.+50     	; 0x2202 <MCAL_Timer0_Init+0x2d6>
	} else if (Loc_u8Prescaller == Clock_on_rising_edge) {
    21d0:	8b 81       	ldd	r24, Y+3	; 0x03
    21d2:	87 30       	cpi	r24, 0x07	; 7
    21d4:	b1 f4       	brne	.+44     	; 0x2202 <MCAL_Timer0_Init+0x2d6>
		SET_BIT(TCCR0, 0);
    21d6:	a3 e5       	ldi	r26, 0x53	; 83
    21d8:	b0 e0       	ldi	r27, 0x00	; 0
    21da:	e3 e5       	ldi	r30, 0x53	; 83
    21dc:	f0 e0       	ldi	r31, 0x00	; 0
    21de:	80 81       	ld	r24, Z
    21e0:	81 60       	ori	r24, 0x01	; 1
    21e2:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 1);
    21e4:	a3 e5       	ldi	r26, 0x53	; 83
    21e6:	b0 e0       	ldi	r27, 0x00	; 0
    21e8:	e3 e5       	ldi	r30, 0x53	; 83
    21ea:	f0 e0       	ldi	r31, 0x00	; 0
    21ec:	80 81       	ld	r24, Z
    21ee:	82 60       	ori	r24, 0x02	; 2
    21f0:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 2);
    21f2:	a3 e5       	ldi	r26, 0x53	; 83
    21f4:	b0 e0       	ldi	r27, 0x00	; 0
    21f6:	e3 e5       	ldi	r30, 0x53	; 83
    21f8:	f0 e0       	ldi	r31, 0x00	; 0
    21fa:	80 81       	ld	r24, Z
    21fc:	84 60       	ori	r24, 0x04	; 4
    21fe:	8c 93       	st	X, r24
		LOC_u8ReturnValue = E_OK;
    2200:	19 82       	std	Y+1, r1	; 0x01
	} else {
		//NOTHING
	}
	if (Loc_u8OC0Mode == Disconnected) {
    2202:	8c 81       	ldd	r24, Y+4	; 0x04
    2204:	88 23       	and	r24, r24
    2206:	79 f4       	brne	.+30     	; 0x2226 <MCAL_Timer0_Init+0x2fa>
			CLR_BIT(TCCR0, 4);
    2208:	a3 e5       	ldi	r26, 0x53	; 83
    220a:	b0 e0       	ldi	r27, 0x00	; 0
    220c:	e3 e5       	ldi	r30, 0x53	; 83
    220e:	f0 e0       	ldi	r31, 0x00	; 0
    2210:	80 81       	ld	r24, Z
    2212:	8f 7e       	andi	r24, 0xEF	; 239
    2214:	8c 93       	st	X, r24
			CLR_BIT(TCCR0, 5);
    2216:	a3 e5       	ldi	r26, 0x53	; 83
    2218:	b0 e0       	ldi	r27, 0x00	; 0
    221a:	e3 e5       	ldi	r30, 0x53	; 83
    221c:	f0 e0       	ldi	r31, 0x00	; 0
    221e:	80 81       	ld	r24, Z
    2220:	8f 7d       	andi	r24, 0xDF	; 223
    2222:	8c 93       	st	X, r24
    2224:	43 c0       	rjmp	.+134    	; 0x22ac <MCAL_Timer0_Init+0x380>
		} else if (Loc_u8OC0Mode == Reserved) {
    2226:	8c 81       	ldd	r24, Y+4	; 0x04
    2228:	81 30       	cpi	r24, 0x01	; 1
    222a:	79 f4       	brne	.+30     	; 0x224a <MCAL_Timer0_Init+0x31e>
			SET_BIT(TCCR0, 4);
    222c:	a3 e5       	ldi	r26, 0x53	; 83
    222e:	b0 e0       	ldi	r27, 0x00	; 0
    2230:	e3 e5       	ldi	r30, 0x53	; 83
    2232:	f0 e0       	ldi	r31, 0x00	; 0
    2234:	80 81       	ld	r24, Z
    2236:	80 61       	ori	r24, 0x10	; 16
    2238:	8c 93       	st	X, r24
			CLR_BIT(TCCR0, 5);
    223a:	a3 e5       	ldi	r26, 0x53	; 83
    223c:	b0 e0       	ldi	r27, 0x00	; 0
    223e:	e3 e5       	ldi	r30, 0x53	; 83
    2240:	f0 e0       	ldi	r31, 0x00	; 0
    2242:	80 81       	ld	r24, Z
    2244:	8f 7d       	andi	r24, 0xDF	; 223
    2246:	8c 93       	st	X, r24
    2248:	31 c0       	rjmp	.+98     	; 0x22ac <MCAL_Timer0_Init+0x380>
			//PWM, Fast PWM
		} else if (Loc_u8OC0Mode == Non_Inverted) {
    224a:	8c 81       	ldd	r24, Y+4	; 0x04
    224c:	82 30       	cpi	r24, 0x02	; 2
    224e:	b1 f4       	brne	.+44     	; 0x227c <MCAL_Timer0_Init+0x350>
			SET_BIT(TCCR0, 5);
    2250:	a3 e5       	ldi	r26, 0x53	; 83
    2252:	b0 e0       	ldi	r27, 0x00	; 0
    2254:	e3 e5       	ldi	r30, 0x53	; 83
    2256:	f0 e0       	ldi	r31, 0x00	; 0
    2258:	80 81       	ld	r24, Z
    225a:	80 62       	ori	r24, 0x20	; 32
    225c:	8c 93       	st	X, r24
			CLR_BIT(TCCR0, 4);
    225e:	a3 e5       	ldi	r26, 0x53	; 83
    2260:	b0 e0       	ldi	r27, 0x00	; 0
    2262:	e3 e5       	ldi	r30, 0x53	; 83
    2264:	f0 e0       	ldi	r31, 0x00	; 0
    2266:	80 81       	ld	r24, Z
    2268:	8f 7e       	andi	r24, 0xEF	; 239
    226a:	8c 93       	st	X, r24
			// OC0
			SET_BIT(DDRB, 3);
    226c:	a7 e3       	ldi	r26, 0x37	; 55
    226e:	b0 e0       	ldi	r27, 0x00	; 0
    2270:	e7 e3       	ldi	r30, 0x37	; 55
    2272:	f0 e0       	ldi	r31, 0x00	; 0
    2274:	80 81       	ld	r24, Z
    2276:	88 60       	ori	r24, 0x08	; 8
    2278:	8c 93       	st	X, r24
    227a:	18 c0       	rjmp	.+48     	; 0x22ac <MCAL_Timer0_Init+0x380>
			//PWM, Fast PWM
		} else if (Loc_u8OC0Mode == Inverted) {
    227c:	8c 81       	ldd	r24, Y+4	; 0x04
    227e:	83 30       	cpi	r24, 0x03	; 3
    2280:	a9 f4       	brne	.+42     	; 0x22ac <MCAL_Timer0_Init+0x380>
			SET_BIT(TCCR0, 4);
    2282:	a3 e5       	ldi	r26, 0x53	; 83
    2284:	b0 e0       	ldi	r27, 0x00	; 0
    2286:	e3 e5       	ldi	r30, 0x53	; 83
    2288:	f0 e0       	ldi	r31, 0x00	; 0
    228a:	80 81       	ld	r24, Z
    228c:	80 61       	ori	r24, 0x10	; 16
    228e:	8c 93       	st	X, r24
			SET_BIT(TCCR0, 5);
    2290:	a3 e5       	ldi	r26, 0x53	; 83
    2292:	b0 e0       	ldi	r27, 0x00	; 0
    2294:	e3 e5       	ldi	r30, 0x53	; 83
    2296:	f0 e0       	ldi	r31, 0x00	; 0
    2298:	80 81       	ld	r24, Z
    229a:	80 62       	ori	r24, 0x20	; 32
    229c:	8c 93       	st	X, r24
			// OC0
			SET_BIT(DDRB, 3);
    229e:	a7 e3       	ldi	r26, 0x37	; 55
    22a0:	b0 e0       	ldi	r27, 0x00	; 0
    22a2:	e7 e3       	ldi	r30, 0x37	; 55
    22a4:	f0 e0       	ldi	r31, 0x00	; 0
    22a6:	80 81       	ld	r24, Z
    22a8:	88 60       	ori	r24, 0x08	; 8
    22aa:	8c 93       	st	X, r24
		}
}
    22ac:	0f 90       	pop	r0
    22ae:	0f 90       	pop	r0
    22b0:	0f 90       	pop	r0
    22b2:	0f 90       	pop	r0
    22b4:	cf 91       	pop	r28
    22b6:	df 91       	pop	r29
    22b8:	08 95       	ret

000022ba <MCAL_Timer0_SetPreloadValue>:
void MCAL_Timer0_SetPreloadValue(u8 Loc_u8Value) {
    22ba:	df 93       	push	r29
    22bc:	cf 93       	push	r28
    22be:	0f 92       	push	r0
    22c0:	cd b7       	in	r28, 0x3d	; 61
    22c2:	de b7       	in	r29, 0x3e	; 62
    22c4:	89 83       	std	Y+1, r24	; 0x01
	TCNT0 = Loc_u8Value;
    22c6:	e2 e5       	ldi	r30, 0x52	; 82
    22c8:	f0 e0       	ldi	r31, 0x00	; 0
    22ca:	89 81       	ldd	r24, Y+1	; 0x01
    22cc:	80 83       	st	Z, r24
}
    22ce:	0f 90       	pop	r0
    22d0:	cf 91       	pop	r28
    22d2:	df 91       	pop	r29
    22d4:	08 95       	ret

000022d6 <MCAL_Timer0_SetCompareValue>:
void MCAL_Timer0_SetCompareValue(u8 Loc_u8Value) {
    22d6:	df 93       	push	r29
    22d8:	cf 93       	push	r28
    22da:	0f 92       	push	r0
    22dc:	cd b7       	in	r28, 0x3d	; 61
    22de:	de b7       	in	r29, 0x3e	; 62
    22e0:	89 83       	std	Y+1, r24	; 0x01
	OCR0 = Loc_u8Value;
    22e2:	ec e5       	ldi	r30, 0x5C	; 92
    22e4:	f0 e0       	ldi	r31, 0x00	; 0
    22e6:	89 81       	ldd	r24, Y+1	; 0x01
    22e8:	80 83       	st	Z, r24
}
    22ea:	0f 90       	pop	r0
    22ec:	cf 91       	pop	r28
    22ee:	df 91       	pop	r29
    22f0:	08 95       	ret

000022f2 <MCAL_Timer0_EnableNormalMode>:
void MCAL_Timer0_EnableNormalMode() {
    22f2:	df 93       	push	r29
    22f4:	cf 93       	push	r28
    22f6:	cd b7       	in	r28, 0x3d	; 61
    22f8:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(TIMSK, 0);
    22fa:	a9 e5       	ldi	r26, 0x59	; 89
    22fc:	b0 e0       	ldi	r27, 0x00	; 0
    22fe:	e9 e5       	ldi	r30, 0x59	; 89
    2300:	f0 e0       	ldi	r31, 0x00	; 0
    2302:	80 81       	ld	r24, Z
    2304:	81 60       	ori	r24, 0x01	; 1
    2306:	8c 93       	st	X, r24
}
    2308:	cf 91       	pop	r28
    230a:	df 91       	pop	r29
    230c:	08 95       	ret

0000230e <MCAL_Timer0_DisableNormalMode>:
void MCAL_Timer0_DisableNormalMode() {
    230e:	df 93       	push	r29
    2310:	cf 93       	push	r28
    2312:	cd b7       	in	r28, 0x3d	; 61
    2314:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK, 0);
    2316:	a9 e5       	ldi	r26, 0x59	; 89
    2318:	b0 e0       	ldi	r27, 0x00	; 0
    231a:	e9 e5       	ldi	r30, 0x59	; 89
    231c:	f0 e0       	ldi	r31, 0x00	; 0
    231e:	80 81       	ld	r24, Z
    2320:	8e 7f       	andi	r24, 0xFE	; 254
    2322:	8c 93       	st	X, r24
}
    2324:	cf 91       	pop	r28
    2326:	df 91       	pop	r29
    2328:	08 95       	ret

0000232a <MCAL_Timer0_EnableCTCMode>:
void MCAL_Timer0_EnableCTCMode() {
    232a:	df 93       	push	r29
    232c:	cf 93       	push	r28
    232e:	cd b7       	in	r28, 0x3d	; 61
    2330:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(TIMSK, 1);
    2332:	a9 e5       	ldi	r26, 0x59	; 89
    2334:	b0 e0       	ldi	r27, 0x00	; 0
    2336:	e9 e5       	ldi	r30, 0x59	; 89
    2338:	f0 e0       	ldi	r31, 0x00	; 0
    233a:	80 81       	ld	r24, Z
    233c:	82 60       	ori	r24, 0x02	; 2
    233e:	8c 93       	st	X, r24
}
    2340:	cf 91       	pop	r28
    2342:	df 91       	pop	r29
    2344:	08 95       	ret

00002346 <MCAL_Timer0_DisableCTCMode>:
void MCAL_Timer0_DisableCTCMode() {
    2346:	df 93       	push	r29
    2348:	cf 93       	push	r28
    234a:	cd b7       	in	r28, 0x3d	; 61
    234c:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK, 1);
    234e:	a9 e5       	ldi	r26, 0x59	; 89
    2350:	b0 e0       	ldi	r27, 0x00	; 0
    2352:	e9 e5       	ldi	r30, 0x59	; 89
    2354:	f0 e0       	ldi	r31, 0x00	; 0
    2356:	80 81       	ld	r24, Z
    2358:	8d 7f       	andi	r24, 0xFD	; 253
    235a:	8c 93       	st	X, r24
}
    235c:	cf 91       	pop	r28
    235e:	df 91       	pop	r29
    2360:	08 95       	ret

00002362 <MCAL_Timer0_Delayms_NormalMode>:

void MCAL_Timer0_Delayms_NormalMode(u32 Loc_u32MilliSeconds) {
    2362:	df 93       	push	r29
    2364:	cf 93       	push	r28
    2366:	cd b7       	in	r28, 0x3d	; 61
    2368:	de b7       	in	r29, 0x3e	; 62
    236a:	28 97       	sbiw	r28, 0x08	; 8
    236c:	0f b6       	in	r0, 0x3f	; 63
    236e:	f8 94       	cli
    2370:	de bf       	out	0x3e, r29	; 62
    2372:	0f be       	out	0x3f, r0	; 63
    2374:	cd bf       	out	0x3d, r28	; 61
    2376:	6d 83       	std	Y+5, r22	; 0x05
    2378:	7e 83       	std	Y+6, r23	; 0x06
    237a:	8f 83       	std	Y+7, r24	; 0x07
    237c:	98 87       	std	Y+8, r25	; 0x08
	u32 N = 0;
    237e:	19 82       	std	Y+1, r1	; 0x01
    2380:	1a 82       	std	Y+2, r1	; 0x02
    2382:	1b 82       	std	Y+3, r1	; 0x03
    2384:	1c 82       	std	Y+4, r1	; 0x04
	N = (Loc_u32MilliSeconds / 1000.0) / (f32) Glob_TickTime;
    2386:	6d 81       	ldd	r22, Y+5	; 0x05
    2388:	7e 81       	ldd	r23, Y+6	; 0x06
    238a:	8f 81       	ldd	r24, Y+7	; 0x07
    238c:	98 85       	ldd	r25, Y+8	; 0x08
    238e:	0e 94 37 05 	call	0xa6e	; 0xa6e <__floatunsisf>
    2392:	dc 01       	movw	r26, r24
    2394:	cb 01       	movw	r24, r22
    2396:	bc 01       	movw	r22, r24
    2398:	cd 01       	movw	r24, r26
    239a:	20 e0       	ldi	r18, 0x00	; 0
    239c:	30 e0       	ldi	r19, 0x00	; 0
    239e:	4a e7       	ldi	r20, 0x7A	; 122
    23a0:	54 e4       	ldi	r21, 0x44	; 68
    23a2:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    23a6:	dc 01       	movw	r26, r24
    23a8:	cb 01       	movw	r24, r22
    23aa:	20 91 d6 06 	lds	r18, 0x06D6
    23ae:	30 91 d7 06 	lds	r19, 0x06D7
    23b2:	40 91 d8 06 	lds	r20, 0x06D8
    23b6:	50 91 d9 06 	lds	r21, 0x06D9
    23ba:	bc 01       	movw	r22, r24
    23bc:	cd 01       	movw	r24, r26
    23be:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    23c2:	dc 01       	movw	r26, r24
    23c4:	cb 01       	movw	r24, r22
    23c6:	bc 01       	movw	r22, r24
    23c8:	cd 01       	movw	r24, r26
    23ca:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    23ce:	dc 01       	movw	r26, r24
    23d0:	cb 01       	movw	r24, r22
    23d2:	89 83       	std	Y+1, r24	; 0x01
    23d4:	9a 83       	std	Y+2, r25	; 0x02
    23d6:	ab 83       	std	Y+3, r26	; 0x03
    23d8:	bc 83       	std	Y+4, r27	; 0x04
	Start = N % 256;
    23da:	89 81       	ldd	r24, Y+1	; 0x01
    23dc:	9a 81       	ldd	r25, Y+2	; 0x02
    23de:	90 70       	andi	r25, 0x00	; 0
    23e0:	90 93 35 02 	sts	0x0235, r25
    23e4:	80 93 34 02 	sts	0x0234, r24
	if (Start == 0) {
    23e8:	80 91 34 02 	lds	r24, 0x0234
    23ec:	90 91 35 02 	lds	r25, 0x0235
    23f0:	00 97       	sbiw	r24, 0x00	; 0
    23f2:	99 f4       	brne	.+38     	; 0x241a <MCAL_Timer0_Delayms_NormalMode+0xb8>
		MCAL_Timer0_SetPreloadValue(Start);
    23f4:	80 91 34 02 	lds	r24, 0x0234
    23f8:	90 91 35 02 	lds	r25, 0x0235
    23fc:	0e 94 5d 11 	call	0x22ba	; 0x22ba <MCAL_Timer0_SetPreloadValue>
		Counter = N / 256;
    2400:	89 81       	ldd	r24, Y+1	; 0x01
    2402:	9a 81       	ldd	r25, Y+2	; 0x02
    2404:	ab 81       	ldd	r26, Y+3	; 0x03
    2406:	bc 81       	ldd	r27, Y+4	; 0x04
    2408:	89 2f       	mov	r24, r25
    240a:	9a 2f       	mov	r25, r26
    240c:	ab 2f       	mov	r26, r27
    240e:	bb 27       	eor	r27, r27
    2410:	90 93 37 02 	sts	0x0237, r25
    2414:	80 93 36 02 	sts	0x0236, r24
    2418:	19 c0       	rjmp	.+50     	; 0x244c <MCAL_Timer0_Delayms_NormalMode+0xea>
	} else if (Start != 0) {
    241a:	80 91 34 02 	lds	r24, 0x0234
    241e:	90 91 35 02 	lds	r25, 0x0235
    2422:	00 97       	sbiw	r24, 0x00	; 0
    2424:	99 f0       	breq	.+38     	; 0x244c <MCAL_Timer0_Delayms_NormalMode+0xea>
		MCAL_Timer0_SetPreloadValue(Start);
    2426:	80 91 34 02 	lds	r24, 0x0234
    242a:	90 91 35 02 	lds	r25, 0x0235
    242e:	0e 94 5d 11 	call	0x22ba	; 0x22ba <MCAL_Timer0_SetPreloadValue>
		Counter = ((N / 256) + 1);
    2432:	89 81       	ldd	r24, Y+1	; 0x01
    2434:	9a 81       	ldd	r25, Y+2	; 0x02
    2436:	ab 81       	ldd	r26, Y+3	; 0x03
    2438:	bc 81       	ldd	r27, Y+4	; 0x04
    243a:	89 2f       	mov	r24, r25
    243c:	9a 2f       	mov	r25, r26
    243e:	ab 2f       	mov	r26, r27
    2440:	bb 27       	eor	r27, r27
    2442:	01 96       	adiw	r24, 0x01	; 1
    2444:	90 93 37 02 	sts	0x0237, r25
    2448:	80 93 36 02 	sts	0x0236, r24
	} else {
		//NOTHING
	}
}
    244c:	28 96       	adiw	r28, 0x08	; 8
    244e:	0f b6       	in	r0, 0x3f	; 63
    2450:	f8 94       	cli
    2452:	de bf       	out	0x3e, r29	; 62
    2454:	0f be       	out	0x3f, r0	; 63
    2456:	cd bf       	out	0x3d, r28	; 61
    2458:	cf 91       	pop	r28
    245a:	df 91       	pop	r29
    245c:	08 95       	ret

0000245e <MCAL_Timer0_Delayms_CTCMode>:
void MCAL_Timer0_Delayms_CTCMode(u32 Loc_u32MilliSeconds) {
    245e:	df 93       	push	r29
    2460:	cf 93       	push	r28
    2462:	cd b7       	in	r28, 0x3d	; 61
    2464:	de b7       	in	r29, 0x3e	; 62
    2466:	29 97       	sbiw	r28, 0x09	; 9
    2468:	0f b6       	in	r0, 0x3f	; 63
    246a:	f8 94       	cli
    246c:	de bf       	out	0x3e, r29	; 62
    246e:	0f be       	out	0x3f, r0	; 63
    2470:	cd bf       	out	0x3d, r28	; 61
    2472:	6e 83       	std	Y+6, r22	; 0x06
    2474:	7f 83       	std	Y+7, r23	; 0x07
    2476:	88 87       	std	Y+8, r24	; 0x08
    2478:	99 87       	std	Y+9, r25	; 0x09
	u8 LOC_u8ReturnValue = E_NOT_OK;
    247a:	81 e0       	ldi	r24, 0x01	; 1
    247c:	8d 83       	std	Y+5, r24	; 0x05
	f32 N = 0;
    247e:	80 e0       	ldi	r24, 0x00	; 0
    2480:	90 e0       	ldi	r25, 0x00	; 0
    2482:	a0 e0       	ldi	r26, 0x00	; 0
    2484:	b0 e0       	ldi	r27, 0x00	; 0
    2486:	89 83       	std	Y+1, r24	; 0x01
    2488:	9a 83       	std	Y+2, r25	; 0x02
    248a:	ab 83       	std	Y+3, r26	; 0x03
    248c:	bc 83       	std	Y+4, r27	; 0x04
	MCAL_Timer0_SetCompareValue(CompareStartValue);
    248e:	87 ec       	ldi	r24, 0xC7	; 199
    2490:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <MCAL_Timer0_SetCompareValue>
	N = ((CompareStartValue + 1) * Glob_TickTime);
    2494:	80 91 d6 06 	lds	r24, 0x06D6
    2498:	90 91 d7 06 	lds	r25, 0x06D7
    249c:	a0 91 d8 06 	lds	r26, 0x06D8
    24a0:	b0 91 d9 06 	lds	r27, 0x06D9
    24a4:	bc 01       	movw	r22, r24
    24a6:	cd 01       	movw	r24, r26
    24a8:	20 e0       	ldi	r18, 0x00	; 0
    24aa:	30 e0       	ldi	r19, 0x00	; 0
    24ac:	48 e4       	ldi	r20, 0x48	; 72
    24ae:	53 e4       	ldi	r21, 0x43	; 67
    24b0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    24b4:	dc 01       	movw	r26, r24
    24b6:	cb 01       	movw	r24, r22
    24b8:	89 83       	std	Y+1, r24	; 0x01
    24ba:	9a 83       	std	Y+2, r25	; 0x02
    24bc:	ab 83       	std	Y+3, r26	; 0x03
    24be:	bc 83       	std	Y+4, r27	; 0x04
	Counter = ((Loc_u32MilliSeconds/1000.0) / N);
    24c0:	6e 81       	ldd	r22, Y+6	; 0x06
    24c2:	7f 81       	ldd	r23, Y+7	; 0x07
    24c4:	88 85       	ldd	r24, Y+8	; 0x08
    24c6:	99 85       	ldd	r25, Y+9	; 0x09
    24c8:	0e 94 37 05 	call	0xa6e	; 0xa6e <__floatunsisf>
    24cc:	dc 01       	movw	r26, r24
    24ce:	cb 01       	movw	r24, r22
    24d0:	bc 01       	movw	r22, r24
    24d2:	cd 01       	movw	r24, r26
    24d4:	20 e0       	ldi	r18, 0x00	; 0
    24d6:	30 e0       	ldi	r19, 0x00	; 0
    24d8:	4a e7       	ldi	r20, 0x7A	; 122
    24da:	54 e4       	ldi	r21, 0x44	; 68
    24dc:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    24e0:	dc 01       	movw	r26, r24
    24e2:	cb 01       	movw	r24, r22
    24e4:	bc 01       	movw	r22, r24
    24e6:	cd 01       	movw	r24, r26
    24e8:	29 81       	ldd	r18, Y+1	; 0x01
    24ea:	3a 81       	ldd	r19, Y+2	; 0x02
    24ec:	4b 81       	ldd	r20, Y+3	; 0x03
    24ee:	5c 81       	ldd	r21, Y+4	; 0x04
    24f0:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    24f4:	dc 01       	movw	r26, r24
    24f6:	cb 01       	movw	r24, r22
    24f8:	bc 01       	movw	r22, r24
    24fa:	cd 01       	movw	r24, r26
    24fc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2500:	dc 01       	movw	r26, r24
    2502:	cb 01       	movw	r24, r22
    2504:	90 93 37 02 	sts	0x0237, r25
    2508:	80 93 36 02 	sts	0x0236, r24

	LOC_u8ReturnValue = E_OK;
    250c:	1d 82       	std	Y+5, r1	; 0x05
}
    250e:	29 96       	adiw	r28, 0x09	; 9
    2510:	0f b6       	in	r0, 0x3f	; 63
    2512:	f8 94       	cli
    2514:	de bf       	out	0x3e, r29	; 62
    2516:	0f be       	out	0x3f, r0	; 63
    2518:	cd bf       	out	0x3d, r28	; 61
    251a:	cf 91       	pop	r28
    251c:	df 91       	pop	r29
    251e:	08 95       	ret

00002520 <MCAL_Timer0_CallBack>:

void MCAL_Timer0_CallBack(void (*ptr)(void)) {
    2520:	df 93       	push	r29
    2522:	cf 93       	push	r28
    2524:	00 d0       	rcall	.+0      	; 0x2526 <MCAL_Timer0_CallBack+0x6>
    2526:	cd b7       	in	r28, 0x3d	; 61
    2528:	de b7       	in	r29, 0x3e	; 62
    252a:	9a 83       	std	Y+2, r25	; 0x02
    252c:	89 83       	std	Y+1, r24	; 0x01
	if (ptr != '\0')
    252e:	89 81       	ldd	r24, Y+1	; 0x01
    2530:	9a 81       	ldd	r25, Y+2	; 0x02
    2532:	00 97       	sbiw	r24, 0x00	; 0
    2534:	31 f0       	breq	.+12     	; 0x2542 <MCAL_Timer0_CallBack+0x22>
		Gptr3 = ptr;
    2536:	89 81       	ldd	r24, Y+1	; 0x01
    2538:	9a 81       	ldd	r25, Y+2	; 0x02
    253a:	90 93 33 02 	sts	0x0233, r25
    253e:	80 93 32 02 	sts	0x0232, r24
}
    2542:	0f 90       	pop	r0
    2544:	0f 90       	pop	r0
    2546:	cf 91       	pop	r28
    2548:	df 91       	pop	r29
    254a:	08 95       	ret

0000254c <__vector_11>:

ISR(TIMER0_OVF_vect) {
    254c:	1f 92       	push	r1
    254e:	0f 92       	push	r0
    2550:	0f b6       	in	r0, 0x3f	; 63
    2552:	0f 92       	push	r0
    2554:	11 24       	eor	r1, r1
    2556:	2f 93       	push	r18
    2558:	3f 93       	push	r19
    255a:	4f 93       	push	r20
    255c:	5f 93       	push	r21
    255e:	6f 93       	push	r22
    2560:	7f 93       	push	r23
    2562:	8f 93       	push	r24
    2564:	9f 93       	push	r25
    2566:	af 93       	push	r26
    2568:	bf 93       	push	r27
    256a:	ef 93       	push	r30
    256c:	ff 93       	push	r31
    256e:	df 93       	push	r29
    2570:	cf 93       	push	r28
    2572:	cd b7       	in	r28, 0x3d	; 61
    2574:	de b7       	in	r29, 0x3e	; 62
	if (Gptr3 != '\0')
    2576:	80 91 32 02 	lds	r24, 0x0232
    257a:	90 91 33 02 	lds	r25, 0x0233
    257e:	00 97       	sbiw	r24, 0x00	; 0
    2580:	29 f0       	breq	.+10     	; 0x258c <__vector_11+0x40>
		Gptr3();
    2582:	e0 91 32 02 	lds	r30, 0x0232
    2586:	f0 91 33 02 	lds	r31, 0x0233
    258a:	09 95       	icall
	Glob_u16OvfCounter++;
    258c:	80 91 30 02 	lds	r24, 0x0230
    2590:	90 91 31 02 	lds	r25, 0x0231
    2594:	01 96       	adiw	r24, 0x01	; 1
    2596:	90 93 31 02 	sts	0x0231, r25
    259a:	80 93 30 02 	sts	0x0230, r24
}
    259e:	cf 91       	pop	r28
    25a0:	df 91       	pop	r29
    25a2:	ff 91       	pop	r31
    25a4:	ef 91       	pop	r30
    25a6:	bf 91       	pop	r27
    25a8:	af 91       	pop	r26
    25aa:	9f 91       	pop	r25
    25ac:	8f 91       	pop	r24
    25ae:	7f 91       	pop	r23
    25b0:	6f 91       	pop	r22
    25b2:	5f 91       	pop	r21
    25b4:	4f 91       	pop	r20
    25b6:	3f 91       	pop	r19
    25b8:	2f 91       	pop	r18
    25ba:	0f 90       	pop	r0
    25bc:	0f be       	out	0x3f, r0	; 63
    25be:	0f 90       	pop	r0
    25c0:	1f 90       	pop	r1
    25c2:	18 95       	reti

000025c4 <__vector_10>:
ISR(TIMER0_COMP_vect) {
    25c4:	1f 92       	push	r1
    25c6:	0f 92       	push	r0
    25c8:	0f b6       	in	r0, 0x3f	; 63
    25ca:	0f 92       	push	r0
    25cc:	11 24       	eor	r1, r1
    25ce:	2f 93       	push	r18
    25d0:	3f 93       	push	r19
    25d2:	4f 93       	push	r20
    25d4:	5f 93       	push	r21
    25d6:	6f 93       	push	r22
    25d8:	7f 93       	push	r23
    25da:	8f 93       	push	r24
    25dc:	9f 93       	push	r25
    25de:	af 93       	push	r26
    25e0:	bf 93       	push	r27
    25e2:	ef 93       	push	r30
    25e4:	ff 93       	push	r31
    25e6:	df 93       	push	r29
    25e8:	cf 93       	push	r28
    25ea:	cd b7       	in	r28, 0x3d	; 61
    25ec:	de b7       	in	r29, 0x3e	; 62
	if (Gptr3 != '\0')
    25ee:	80 91 32 02 	lds	r24, 0x0232
    25f2:	90 91 33 02 	lds	r25, 0x0233
    25f6:	00 97       	sbiw	r24, 0x00	; 0
    25f8:	29 f0       	breq	.+10     	; 0x2604 <__vector_10+0x40>
		Gptr3();
    25fa:	e0 91 32 02 	lds	r30, 0x0232
    25fe:	f0 91 33 02 	lds	r31, 0x0233
    2602:	09 95       	icall
}
    2604:	cf 91       	pop	r28
    2606:	df 91       	pop	r29
    2608:	ff 91       	pop	r31
    260a:	ef 91       	pop	r30
    260c:	bf 91       	pop	r27
    260e:	af 91       	pop	r26
    2610:	9f 91       	pop	r25
    2612:	8f 91       	pop	r24
    2614:	7f 91       	pop	r23
    2616:	6f 91       	pop	r22
    2618:	5f 91       	pop	r21
    261a:	4f 91       	pop	r20
    261c:	3f 91       	pop	r19
    261e:	2f 91       	pop	r18
    2620:	0f 90       	pop	r0
    2622:	0f be       	out	0x3f, r0	; 63
    2624:	0f 90       	pop	r0
    2626:	1f 90       	pop	r1
    2628:	18 95       	reti

0000262a <MCAL_Interrupt_u8SetRegister>:

void (*Gptr0)(void)= '\0' ;
void (*Gptr1)(void)= '\0' ;
void (*Gptr2)(void)= '\0' ;

void MCAL_Interrupt_u8SetRegister(u8 Loc_u8PortID, u8 Loc_u8PortValue) {
    262a:	df 93       	push	r29
    262c:	cf 93       	push	r28
    262e:	00 d0       	rcall	.+0      	; 0x2630 <MCAL_Interrupt_u8SetRegister+0x6>
    2630:	cd b7       	in	r28, 0x3d	; 61
    2632:	de b7       	in	r29, 0x3e	; 62
    2634:	89 83       	std	Y+1, r24	; 0x01
    2636:	6a 83       	std	Y+2, r22	; 0x02
	if (Loc_u8PortValue == PORT_OUTPUT) {
    2638:	8a 81       	ldd	r24, Y+2	; 0x02
    263a:	8f 3f       	cpi	r24, 0xFF	; 255
    263c:	09 f5       	brne	.+66     	; 0x2680 <MCAL_Interrupt_u8SetRegister+0x56>
		if (Loc_u8PortID == Sreg) {
    263e:	89 81       	ldd	r24, Y+1	; 0x01
    2640:	88 23       	and	r24, r24
    2642:	29 f4       	brne	.+10     	; 0x264e <MCAL_Interrupt_u8SetRegister+0x24>
			SREG = PORT_OUTPUT;
    2644:	ef e5       	ldi	r30, 0x5F	; 95
    2646:	f0 e0       	ldi	r31, 0x00	; 0
    2648:	8f ef       	ldi	r24, 0xFF	; 255
    264a:	80 83       	st	Z, r24
    264c:	57 c0       	rjmp	.+174    	; 0x26fc <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Gicr) {
    264e:	89 81       	ldd	r24, Y+1	; 0x01
    2650:	81 30       	cpi	r24, 0x01	; 1
    2652:	29 f4       	brne	.+10     	; 0x265e <MCAL_Interrupt_u8SetRegister+0x34>
			GICR = PORT_OUTPUT;
    2654:	eb e5       	ldi	r30, 0x5B	; 91
    2656:	f0 e0       	ldi	r31, 0x00	; 0
    2658:	8f ef       	ldi	r24, 0xFF	; 255
    265a:	80 83       	st	Z, r24
    265c:	4f c0       	rjmp	.+158    	; 0x26fc <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Mcucr) {
    265e:	89 81       	ldd	r24, Y+1	; 0x01
    2660:	82 30       	cpi	r24, 0x02	; 2
    2662:	29 f4       	brne	.+10     	; 0x266e <MCAL_Interrupt_u8SetRegister+0x44>
			MCUCR = PORT_OUTPUT;
    2664:	e5 e5       	ldi	r30, 0x55	; 85
    2666:	f0 e0       	ldi	r31, 0x00	; 0
    2668:	8f ef       	ldi	r24, 0xFF	; 255
    266a:	80 83       	st	Z, r24
    266c:	47 c0       	rjmp	.+142    	; 0x26fc <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Mcucsr) {
    266e:	89 81       	ldd	r24, Y+1	; 0x01
    2670:	83 30       	cpi	r24, 0x03	; 3
    2672:	09 f0       	breq	.+2      	; 0x2676 <MCAL_Interrupt_u8SetRegister+0x4c>
    2674:	43 c0       	rjmp	.+134    	; 0x26fc <MCAL_Interrupt_u8SetRegister+0xd2>
			MCUCSR = PORT_OUTPUT;
    2676:	e4 e5       	ldi	r30, 0x54	; 84
    2678:	f0 e0       	ldi	r31, 0x00	; 0
    267a:	8f ef       	ldi	r24, 0xFF	; 255
    267c:	80 83       	st	Z, r24
    267e:	3e c0       	rjmp	.+124    	; 0x26fc <MCAL_Interrupt_u8SetRegister+0xd2>
		} else {
			//Do Nothing
		}
	} else if (Loc_u8PortValue == PORT_INPUT) {
    2680:	8a 81       	ldd	r24, Y+2	; 0x02
    2682:	88 23       	and	r24, r24
    2684:	e1 f4       	brne	.+56     	; 0x26be <MCAL_Interrupt_u8SetRegister+0x94>
		if (Loc_u8PortID == Sreg) {
    2686:	89 81       	ldd	r24, Y+1	; 0x01
    2688:	88 23       	and	r24, r24
    268a:	21 f4       	brne	.+8      	; 0x2694 <MCAL_Interrupt_u8SetRegister+0x6a>
			SREG = PORT_INPUT;
    268c:	ef e5       	ldi	r30, 0x5F	; 95
    268e:	f0 e0       	ldi	r31, 0x00	; 0
    2690:	10 82       	st	Z, r1
    2692:	34 c0       	rjmp	.+104    	; 0x26fc <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Gicr) {
    2694:	89 81       	ldd	r24, Y+1	; 0x01
    2696:	81 30       	cpi	r24, 0x01	; 1
    2698:	21 f4       	brne	.+8      	; 0x26a2 <MCAL_Interrupt_u8SetRegister+0x78>
			GICR = PORT_INPUT;
    269a:	eb e5       	ldi	r30, 0x5B	; 91
    269c:	f0 e0       	ldi	r31, 0x00	; 0
    269e:	10 82       	st	Z, r1
    26a0:	2d c0       	rjmp	.+90     	; 0x26fc <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Mcucr) {
    26a2:	89 81       	ldd	r24, Y+1	; 0x01
    26a4:	82 30       	cpi	r24, 0x02	; 2
    26a6:	21 f4       	brne	.+8      	; 0x26b0 <MCAL_Interrupt_u8SetRegister+0x86>
			MCUCR = PORT_INPUT;
    26a8:	e5 e5       	ldi	r30, 0x55	; 85
    26aa:	f0 e0       	ldi	r31, 0x00	; 0
    26ac:	10 82       	st	Z, r1
    26ae:	26 c0       	rjmp	.+76     	; 0x26fc <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Mcucsr) {
    26b0:	89 81       	ldd	r24, Y+1	; 0x01
    26b2:	83 30       	cpi	r24, 0x03	; 3
    26b4:	19 f5       	brne	.+70     	; 0x26fc <MCAL_Interrupt_u8SetRegister+0xd2>
			MCUCSR = PORT_INPUT;
    26b6:	e4 e5       	ldi	r30, 0x54	; 84
    26b8:	f0 e0       	ldi	r31, 0x00	; 0
    26ba:	10 82       	st	Z, r1
    26bc:	1f c0       	rjmp	.+62     	; 0x26fc <MCAL_Interrupt_u8SetRegister+0xd2>
		} else {
			//Do Nothing
		}
	} else {
		if (Loc_u8PortID == Sreg) {
    26be:	89 81       	ldd	r24, Y+1	; 0x01
    26c0:	88 23       	and	r24, r24
    26c2:	29 f4       	brne	.+10     	; 0x26ce <MCAL_Interrupt_u8SetRegister+0xa4>
			SREG = Loc_u8PortValue;
    26c4:	ef e5       	ldi	r30, 0x5F	; 95
    26c6:	f0 e0       	ldi	r31, 0x00	; 0
    26c8:	8a 81       	ldd	r24, Y+2	; 0x02
    26ca:	80 83       	st	Z, r24
    26cc:	17 c0       	rjmp	.+46     	; 0x26fc <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Gicr) {
    26ce:	89 81       	ldd	r24, Y+1	; 0x01
    26d0:	81 30       	cpi	r24, 0x01	; 1
    26d2:	29 f4       	brne	.+10     	; 0x26de <MCAL_Interrupt_u8SetRegister+0xb4>
			GICR = Loc_u8PortValue;
    26d4:	eb e5       	ldi	r30, 0x5B	; 91
    26d6:	f0 e0       	ldi	r31, 0x00	; 0
    26d8:	8a 81       	ldd	r24, Y+2	; 0x02
    26da:	80 83       	st	Z, r24
    26dc:	0f c0       	rjmp	.+30     	; 0x26fc <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Mcucr) {
    26de:	89 81       	ldd	r24, Y+1	; 0x01
    26e0:	82 30       	cpi	r24, 0x02	; 2
    26e2:	29 f4       	brne	.+10     	; 0x26ee <MCAL_Interrupt_u8SetRegister+0xc4>
			MCUCR = Loc_u8PortValue;
    26e4:	e5 e5       	ldi	r30, 0x55	; 85
    26e6:	f0 e0       	ldi	r31, 0x00	; 0
    26e8:	8a 81       	ldd	r24, Y+2	; 0x02
    26ea:	80 83       	st	Z, r24
    26ec:	07 c0       	rjmp	.+14     	; 0x26fc <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Mcucsr) {
    26ee:	89 81       	ldd	r24, Y+1	; 0x01
    26f0:	83 30       	cpi	r24, 0x03	; 3
    26f2:	21 f4       	brne	.+8      	; 0x26fc <MCAL_Interrupt_u8SetRegister+0xd2>
			MCUCSR = Loc_u8PortValue;
    26f4:	e4 e5       	ldi	r30, 0x54	; 84
    26f6:	f0 e0       	ldi	r31, 0x00	; 0
    26f8:	8a 81       	ldd	r24, Y+2	; 0x02
    26fa:	80 83       	st	Z, r24
		}
	}
}
    26fc:	0f 90       	pop	r0
    26fe:	0f 90       	pop	r0
    2700:	cf 91       	pop	r28
    2702:	df 91       	pop	r29
    2704:	08 95       	ret

00002706 <MCAL_Interrupt_u8SetRegisterPin>:

void MCAL_Interrupt_u8SetRegisterPin(u8 Loc_u8PortID, u8 Loc_u8PinID,
		u8 Loc_u8PinValue) {
    2706:	df 93       	push	r29
    2708:	cf 93       	push	r28
    270a:	00 d0       	rcall	.+0      	; 0x270c <MCAL_Interrupt_u8SetRegisterPin+0x6>
    270c:	0f 92       	push	r0
    270e:	cd b7       	in	r28, 0x3d	; 61
    2710:	de b7       	in	r29, 0x3e	; 62
    2712:	89 83       	std	Y+1, r24	; 0x01
    2714:	6a 83       	std	Y+2, r22	; 0x02
    2716:	4b 83       	std	Y+3, r20	; 0x03
	if (Loc_u8PinValue == Pin_High) {
    2718:	8b 81       	ldd	r24, Y+3	; 0x03
    271a:	81 30       	cpi	r24, 0x01	; 1
    271c:	09 f0       	breq	.+2      	; 0x2720 <MCAL_Interrupt_u8SetRegisterPin+0x1a>
    271e:	5d c0       	rjmp	.+186    	; 0x27da <MCAL_Interrupt_u8SetRegisterPin+0xd4>
		if (Loc_u8PortID == Sreg) {
    2720:	89 81       	ldd	r24, Y+1	; 0x01
    2722:	88 23       	and	r24, r24
    2724:	a1 f4       	brne	.+40     	; 0x274e <MCAL_Interrupt_u8SetRegisterPin+0x48>
			SET_BIT(SREG, Loc_u8PinID);
    2726:	af e5       	ldi	r26, 0x5F	; 95
    2728:	b0 e0       	ldi	r27, 0x00	; 0
    272a:	ef e5       	ldi	r30, 0x5F	; 95
    272c:	f0 e0       	ldi	r31, 0x00	; 0
    272e:	80 81       	ld	r24, Z
    2730:	48 2f       	mov	r20, r24
    2732:	8a 81       	ldd	r24, Y+2	; 0x02
    2734:	28 2f       	mov	r18, r24
    2736:	30 e0       	ldi	r19, 0x00	; 0
    2738:	81 e0       	ldi	r24, 0x01	; 1
    273a:	90 e0       	ldi	r25, 0x00	; 0
    273c:	02 2e       	mov	r0, r18
    273e:	02 c0       	rjmp	.+4      	; 0x2744 <MCAL_Interrupt_u8SetRegisterPin+0x3e>
    2740:	88 0f       	add	r24, r24
    2742:	99 1f       	adc	r25, r25
    2744:	0a 94       	dec	r0
    2746:	e2 f7       	brpl	.-8      	; 0x2740 <MCAL_Interrupt_u8SetRegisterPin+0x3a>
    2748:	84 2b       	or	r24, r20
    274a:	8c 93       	st	X, r24
    274c:	a9 c0       	rjmp	.+338    	; 0x28a0 <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		} else if (Loc_u8PortID == Gicr) {
    274e:	89 81       	ldd	r24, Y+1	; 0x01
    2750:	81 30       	cpi	r24, 0x01	; 1
    2752:	a1 f4       	brne	.+40     	; 0x277c <MCAL_Interrupt_u8SetRegisterPin+0x76>
			SET_BIT(GICR, Loc_u8PinID);
    2754:	ab e5       	ldi	r26, 0x5B	; 91
    2756:	b0 e0       	ldi	r27, 0x00	; 0
    2758:	eb e5       	ldi	r30, 0x5B	; 91
    275a:	f0 e0       	ldi	r31, 0x00	; 0
    275c:	80 81       	ld	r24, Z
    275e:	48 2f       	mov	r20, r24
    2760:	8a 81       	ldd	r24, Y+2	; 0x02
    2762:	28 2f       	mov	r18, r24
    2764:	30 e0       	ldi	r19, 0x00	; 0
    2766:	81 e0       	ldi	r24, 0x01	; 1
    2768:	90 e0       	ldi	r25, 0x00	; 0
    276a:	02 2e       	mov	r0, r18
    276c:	02 c0       	rjmp	.+4      	; 0x2772 <MCAL_Interrupt_u8SetRegisterPin+0x6c>
    276e:	88 0f       	add	r24, r24
    2770:	99 1f       	adc	r25, r25
    2772:	0a 94       	dec	r0
    2774:	e2 f7       	brpl	.-8      	; 0x276e <MCAL_Interrupt_u8SetRegisterPin+0x68>
    2776:	84 2b       	or	r24, r20
    2778:	8c 93       	st	X, r24
    277a:	92 c0       	rjmp	.+292    	; 0x28a0 <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		} else if (Loc_u8PortID == Mcucr) {
    277c:	89 81       	ldd	r24, Y+1	; 0x01
    277e:	82 30       	cpi	r24, 0x02	; 2
    2780:	a1 f4       	brne	.+40     	; 0x27aa <MCAL_Interrupt_u8SetRegisterPin+0xa4>
			SET_BIT(MCUCR, Loc_u8PinID);
    2782:	a5 e5       	ldi	r26, 0x55	; 85
    2784:	b0 e0       	ldi	r27, 0x00	; 0
    2786:	e5 e5       	ldi	r30, 0x55	; 85
    2788:	f0 e0       	ldi	r31, 0x00	; 0
    278a:	80 81       	ld	r24, Z
    278c:	48 2f       	mov	r20, r24
    278e:	8a 81       	ldd	r24, Y+2	; 0x02
    2790:	28 2f       	mov	r18, r24
    2792:	30 e0       	ldi	r19, 0x00	; 0
    2794:	81 e0       	ldi	r24, 0x01	; 1
    2796:	90 e0       	ldi	r25, 0x00	; 0
    2798:	02 2e       	mov	r0, r18
    279a:	02 c0       	rjmp	.+4      	; 0x27a0 <MCAL_Interrupt_u8SetRegisterPin+0x9a>
    279c:	88 0f       	add	r24, r24
    279e:	99 1f       	adc	r25, r25
    27a0:	0a 94       	dec	r0
    27a2:	e2 f7       	brpl	.-8      	; 0x279c <MCAL_Interrupt_u8SetRegisterPin+0x96>
    27a4:	84 2b       	or	r24, r20
    27a6:	8c 93       	st	X, r24
    27a8:	7b c0       	rjmp	.+246    	; 0x28a0 <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		} else if (Loc_u8PortID == Mcucsr) {
    27aa:	89 81       	ldd	r24, Y+1	; 0x01
    27ac:	83 30       	cpi	r24, 0x03	; 3
    27ae:	09 f0       	breq	.+2      	; 0x27b2 <MCAL_Interrupt_u8SetRegisterPin+0xac>
    27b0:	77 c0       	rjmp	.+238    	; 0x28a0 <MCAL_Interrupt_u8SetRegisterPin+0x19a>
			SET_BIT(MCUCSR, Loc_u8PinID);
    27b2:	a4 e5       	ldi	r26, 0x54	; 84
    27b4:	b0 e0       	ldi	r27, 0x00	; 0
    27b6:	e4 e5       	ldi	r30, 0x54	; 84
    27b8:	f0 e0       	ldi	r31, 0x00	; 0
    27ba:	80 81       	ld	r24, Z
    27bc:	48 2f       	mov	r20, r24
    27be:	8a 81       	ldd	r24, Y+2	; 0x02
    27c0:	28 2f       	mov	r18, r24
    27c2:	30 e0       	ldi	r19, 0x00	; 0
    27c4:	81 e0       	ldi	r24, 0x01	; 1
    27c6:	90 e0       	ldi	r25, 0x00	; 0
    27c8:	02 2e       	mov	r0, r18
    27ca:	02 c0       	rjmp	.+4      	; 0x27d0 <MCAL_Interrupt_u8SetRegisterPin+0xca>
    27cc:	88 0f       	add	r24, r24
    27ce:	99 1f       	adc	r25, r25
    27d0:	0a 94       	dec	r0
    27d2:	e2 f7       	brpl	.-8      	; 0x27cc <MCAL_Interrupt_u8SetRegisterPin+0xc6>
    27d4:	84 2b       	or	r24, r20
    27d6:	8c 93       	st	X, r24
    27d8:	63 c0       	rjmp	.+198    	; 0x28a0 <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		} else {
			//Do Nothing
		}
	} else if (Loc_u8PinValue == Pin_Low) {
    27da:	8b 81       	ldd	r24, Y+3	; 0x03
    27dc:	88 23       	and	r24, r24
    27de:	09 f0       	breq	.+2      	; 0x27e2 <MCAL_Interrupt_u8SetRegisterPin+0xdc>
    27e0:	5f c0       	rjmp	.+190    	; 0x28a0 <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		if (Loc_u8PortID == Sreg) {
    27e2:	89 81       	ldd	r24, Y+1	; 0x01
    27e4:	88 23       	and	r24, r24
    27e6:	a9 f4       	brne	.+42     	; 0x2812 <MCAL_Interrupt_u8SetRegisterPin+0x10c>
			CLR_BIT(SREG, Loc_u8PinID);
    27e8:	af e5       	ldi	r26, 0x5F	; 95
    27ea:	b0 e0       	ldi	r27, 0x00	; 0
    27ec:	ef e5       	ldi	r30, 0x5F	; 95
    27ee:	f0 e0       	ldi	r31, 0x00	; 0
    27f0:	80 81       	ld	r24, Z
    27f2:	48 2f       	mov	r20, r24
    27f4:	8a 81       	ldd	r24, Y+2	; 0x02
    27f6:	28 2f       	mov	r18, r24
    27f8:	30 e0       	ldi	r19, 0x00	; 0
    27fa:	81 e0       	ldi	r24, 0x01	; 1
    27fc:	90 e0       	ldi	r25, 0x00	; 0
    27fe:	02 2e       	mov	r0, r18
    2800:	02 c0       	rjmp	.+4      	; 0x2806 <MCAL_Interrupt_u8SetRegisterPin+0x100>
    2802:	88 0f       	add	r24, r24
    2804:	99 1f       	adc	r25, r25
    2806:	0a 94       	dec	r0
    2808:	e2 f7       	brpl	.-8      	; 0x2802 <MCAL_Interrupt_u8SetRegisterPin+0xfc>
    280a:	80 95       	com	r24
    280c:	84 23       	and	r24, r20
    280e:	8c 93       	st	X, r24
    2810:	47 c0       	rjmp	.+142    	; 0x28a0 <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		} else if (Loc_u8PortID == Gicr) {
    2812:	89 81       	ldd	r24, Y+1	; 0x01
    2814:	81 30       	cpi	r24, 0x01	; 1
    2816:	a9 f4       	brne	.+42     	; 0x2842 <MCAL_Interrupt_u8SetRegisterPin+0x13c>
			CLR_BIT(GICR, Loc_u8PinID);
    2818:	ab e5       	ldi	r26, 0x5B	; 91
    281a:	b0 e0       	ldi	r27, 0x00	; 0
    281c:	eb e5       	ldi	r30, 0x5B	; 91
    281e:	f0 e0       	ldi	r31, 0x00	; 0
    2820:	80 81       	ld	r24, Z
    2822:	48 2f       	mov	r20, r24
    2824:	8a 81       	ldd	r24, Y+2	; 0x02
    2826:	28 2f       	mov	r18, r24
    2828:	30 e0       	ldi	r19, 0x00	; 0
    282a:	81 e0       	ldi	r24, 0x01	; 1
    282c:	90 e0       	ldi	r25, 0x00	; 0
    282e:	02 2e       	mov	r0, r18
    2830:	02 c0       	rjmp	.+4      	; 0x2836 <MCAL_Interrupt_u8SetRegisterPin+0x130>
    2832:	88 0f       	add	r24, r24
    2834:	99 1f       	adc	r25, r25
    2836:	0a 94       	dec	r0
    2838:	e2 f7       	brpl	.-8      	; 0x2832 <MCAL_Interrupt_u8SetRegisterPin+0x12c>
    283a:	80 95       	com	r24
    283c:	84 23       	and	r24, r20
    283e:	8c 93       	st	X, r24
    2840:	2f c0       	rjmp	.+94     	; 0x28a0 <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		} else if (Loc_u8PortID == Mcucr) {
    2842:	89 81       	ldd	r24, Y+1	; 0x01
    2844:	82 30       	cpi	r24, 0x02	; 2
    2846:	a9 f4       	brne	.+42     	; 0x2872 <MCAL_Interrupt_u8SetRegisterPin+0x16c>
			CLR_BIT(MCUCR, Loc_u8PinID);
    2848:	a5 e5       	ldi	r26, 0x55	; 85
    284a:	b0 e0       	ldi	r27, 0x00	; 0
    284c:	e5 e5       	ldi	r30, 0x55	; 85
    284e:	f0 e0       	ldi	r31, 0x00	; 0
    2850:	80 81       	ld	r24, Z
    2852:	48 2f       	mov	r20, r24
    2854:	8a 81       	ldd	r24, Y+2	; 0x02
    2856:	28 2f       	mov	r18, r24
    2858:	30 e0       	ldi	r19, 0x00	; 0
    285a:	81 e0       	ldi	r24, 0x01	; 1
    285c:	90 e0       	ldi	r25, 0x00	; 0
    285e:	02 2e       	mov	r0, r18
    2860:	02 c0       	rjmp	.+4      	; 0x2866 <MCAL_Interrupt_u8SetRegisterPin+0x160>
    2862:	88 0f       	add	r24, r24
    2864:	99 1f       	adc	r25, r25
    2866:	0a 94       	dec	r0
    2868:	e2 f7       	brpl	.-8      	; 0x2862 <MCAL_Interrupt_u8SetRegisterPin+0x15c>
    286a:	80 95       	com	r24
    286c:	84 23       	and	r24, r20
    286e:	8c 93       	st	X, r24
    2870:	17 c0       	rjmp	.+46     	; 0x28a0 <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		} else if (Loc_u8PortID == Mcucsr) {
    2872:	89 81       	ldd	r24, Y+1	; 0x01
    2874:	83 30       	cpi	r24, 0x03	; 3
    2876:	a1 f4       	brne	.+40     	; 0x28a0 <MCAL_Interrupt_u8SetRegisterPin+0x19a>
			CLR_BIT(MCUCSR, Loc_u8PinID);
    2878:	a4 e5       	ldi	r26, 0x54	; 84
    287a:	b0 e0       	ldi	r27, 0x00	; 0
    287c:	e4 e5       	ldi	r30, 0x54	; 84
    287e:	f0 e0       	ldi	r31, 0x00	; 0
    2880:	80 81       	ld	r24, Z
    2882:	48 2f       	mov	r20, r24
    2884:	8a 81       	ldd	r24, Y+2	; 0x02
    2886:	28 2f       	mov	r18, r24
    2888:	30 e0       	ldi	r19, 0x00	; 0
    288a:	81 e0       	ldi	r24, 0x01	; 1
    288c:	90 e0       	ldi	r25, 0x00	; 0
    288e:	02 2e       	mov	r0, r18
    2890:	02 c0       	rjmp	.+4      	; 0x2896 <MCAL_Interrupt_u8SetRegisterPin+0x190>
    2892:	88 0f       	add	r24, r24
    2894:	99 1f       	adc	r25, r25
    2896:	0a 94       	dec	r0
    2898:	e2 f7       	brpl	.-8      	; 0x2892 <MCAL_Interrupt_u8SetRegisterPin+0x18c>
    289a:	80 95       	com	r24
    289c:	84 23       	and	r24, r20
    289e:	8c 93       	st	X, r24
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
}
    28a0:	0f 90       	pop	r0
    28a2:	0f 90       	pop	r0
    28a4:	0f 90       	pop	r0
    28a6:	cf 91       	pop	r28
    28a8:	df 91       	pop	r29
    28aa:	08 95       	ret

000028ac <MCAL_Interrupt_EXIT_CallBack_0>:

void MCAL_Interrupt_EXIT_CallBack_0(void (*ptr)(void)) {
    28ac:	df 93       	push	r29
    28ae:	cf 93       	push	r28
    28b0:	00 d0       	rcall	.+0      	; 0x28b2 <MCAL_Interrupt_EXIT_CallBack_0+0x6>
    28b2:	cd b7       	in	r28, 0x3d	; 61
    28b4:	de b7       	in	r29, 0x3e	; 62
    28b6:	9a 83       	std	Y+2, r25	; 0x02
    28b8:	89 83       	std	Y+1, r24	; 0x01
	if (ptr != '\0')
    28ba:	89 81       	ldd	r24, Y+1	; 0x01
    28bc:	9a 81       	ldd	r25, Y+2	; 0x02
    28be:	00 97       	sbiw	r24, 0x00	; 0
    28c0:	31 f0       	breq	.+12     	; 0x28ce <MCAL_Interrupt_EXIT_CallBack_0+0x22>
		Gptr0 = ptr;
    28c2:	89 81       	ldd	r24, Y+1	; 0x01
    28c4:	9a 81       	ldd	r25, Y+2	; 0x02
    28c6:	90 93 39 02 	sts	0x0239, r25
    28ca:	80 93 38 02 	sts	0x0238, r24
}
    28ce:	0f 90       	pop	r0
    28d0:	0f 90       	pop	r0
    28d2:	cf 91       	pop	r28
    28d4:	df 91       	pop	r29
    28d6:	08 95       	ret

000028d8 <MCAL_Interrupt_EXIT_CallBack_1>:
void MCAL_Interrupt_EXIT_CallBack_1(void (*ptr)(void)) {
    28d8:	df 93       	push	r29
    28da:	cf 93       	push	r28
    28dc:	00 d0       	rcall	.+0      	; 0x28de <MCAL_Interrupt_EXIT_CallBack_1+0x6>
    28de:	cd b7       	in	r28, 0x3d	; 61
    28e0:	de b7       	in	r29, 0x3e	; 62
    28e2:	9a 83       	std	Y+2, r25	; 0x02
    28e4:	89 83       	std	Y+1, r24	; 0x01
	if (ptr != '\0')
    28e6:	89 81       	ldd	r24, Y+1	; 0x01
    28e8:	9a 81       	ldd	r25, Y+2	; 0x02
    28ea:	00 97       	sbiw	r24, 0x00	; 0
    28ec:	31 f0       	breq	.+12     	; 0x28fa <MCAL_Interrupt_EXIT_CallBack_1+0x22>
		Gptr1 = ptr;
    28ee:	89 81       	ldd	r24, Y+1	; 0x01
    28f0:	9a 81       	ldd	r25, Y+2	; 0x02
    28f2:	90 93 3b 02 	sts	0x023B, r25
    28f6:	80 93 3a 02 	sts	0x023A, r24
}
    28fa:	0f 90       	pop	r0
    28fc:	0f 90       	pop	r0
    28fe:	cf 91       	pop	r28
    2900:	df 91       	pop	r29
    2902:	08 95       	ret

00002904 <MCAL_Interrupt_EXIT_CallBack_2>:
void MCAL_Interrupt_EXIT_CallBack_2(void (*ptr)(void)) {
    2904:	df 93       	push	r29
    2906:	cf 93       	push	r28
    2908:	00 d0       	rcall	.+0      	; 0x290a <MCAL_Interrupt_EXIT_CallBack_2+0x6>
    290a:	cd b7       	in	r28, 0x3d	; 61
    290c:	de b7       	in	r29, 0x3e	; 62
    290e:	9a 83       	std	Y+2, r25	; 0x02
    2910:	89 83       	std	Y+1, r24	; 0x01
	if (ptr != '\0')
    2912:	89 81       	ldd	r24, Y+1	; 0x01
    2914:	9a 81       	ldd	r25, Y+2	; 0x02
    2916:	00 97       	sbiw	r24, 0x00	; 0
    2918:	31 f0       	breq	.+12     	; 0x2926 <MCAL_Interrupt_EXIT_CallBack_2+0x22>
		Gptr2 = ptr;
    291a:	89 81       	ldd	r24, Y+1	; 0x01
    291c:	9a 81       	ldd	r25, Y+2	; 0x02
    291e:	90 93 3d 02 	sts	0x023D, r25
    2922:	80 93 3c 02 	sts	0x023C, r24
}
    2926:	0f 90       	pop	r0
    2928:	0f 90       	pop	r0
    292a:	cf 91       	pop	r28
    292c:	df 91       	pop	r29
    292e:	08 95       	ret

00002930 <MCAL_Interrupt_EnableGIE>:

void MCAL_Interrupt_EnableGIE(u8 Loc_u8value) {
    2930:	df 93       	push	r29
    2932:	cf 93       	push	r28
    2934:	0f 92       	push	r0
    2936:	cd b7       	in	r28, 0x3d	; 61
    2938:	de b7       	in	r29, 0x3e	; 62
    293a:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8value == Enable) {
    293c:	89 81       	ldd	r24, Y+1	; 0x01
    293e:	81 30       	cpi	r24, 0x01	; 1
    2940:	31 f4       	brne	.+12     	; 0x294e <MCAL_Interrupt_EnableGIE+0x1e>
		MCAL_Interrupt_u8SetRegisterPin(Sreg, SREG_Pin, Pin_High);
    2942:	80 e0       	ldi	r24, 0x00	; 0
    2944:	67 e0       	ldi	r22, 0x07	; 7
    2946:	41 e0       	ldi	r20, 0x01	; 1
    2948:	0e 94 83 13 	call	0x2706	; 0x2706 <MCAL_Interrupt_u8SetRegisterPin>
    294c:	08 c0       	rjmp	.+16     	; 0x295e <MCAL_Interrupt_EnableGIE+0x2e>
	} else if (Loc_u8value == Disable) {
    294e:	89 81       	ldd	r24, Y+1	; 0x01
    2950:	88 23       	and	r24, r24
    2952:	29 f4       	brne	.+10     	; 0x295e <MCAL_Interrupt_EnableGIE+0x2e>
		MCAL_Interrupt_u8SetRegisterPin(Sreg, SREG_Pin, Pin_Low);
    2954:	80 e0       	ldi	r24, 0x00	; 0
    2956:	67 e0       	ldi	r22, 0x07	; 7
    2958:	40 e0       	ldi	r20, 0x00	; 0
    295a:	0e 94 83 13 	call	0x2706	; 0x2706 <MCAL_Interrupt_u8SetRegisterPin>
	}
}
    295e:	0f 90       	pop	r0
    2960:	cf 91       	pop	r28
    2962:	df 91       	pop	r29
    2964:	08 95       	ret

00002966 <MCAL_Interrupt_InterruptRisingInit>:

void MCAL_Interrupt_InterruptRisingInit() {
    2966:	df 93       	push	r29
    2968:	cf 93       	push	r28
    296a:	cd b7       	in	r28, 0x3d	; 61
    296c:	de b7       	in	r29, 0x3e	; 62
	MCAL_Interrupt_u8SetRegisterPin(Gicr, GICR_Pin6, Pin_High);
    296e:	81 e0       	ldi	r24, 0x01	; 1
    2970:	66 e0       	ldi	r22, 0x06	; 6
    2972:	41 e0       	ldi	r20, 0x01	; 1
    2974:	0e 94 83 13 	call	0x2706	; 0x2706 <MCAL_Interrupt_u8SetRegisterPin>
	MCAL_Interrupt_u8SetRegisterPin(Mcucr,MCUCR_Pin0 , Pin_High);
    2978:	82 e0       	ldi	r24, 0x02	; 2
    297a:	60 e0       	ldi	r22, 0x00	; 0
    297c:	41 e0       	ldi	r20, 0x01	; 1
    297e:	0e 94 83 13 	call	0x2706	; 0x2706 <MCAL_Interrupt_u8SetRegisterPin>
	MCAL_Interrupt_u8SetRegisterPin(Mcucr,MCUCR_Pin1 , Pin_High);
    2982:	82 e0       	ldi	r24, 0x02	; 2
    2984:	61 e0       	ldi	r22, 0x01	; 1
    2986:	41 e0       	ldi	r20, 0x01	; 1
    2988:	0e 94 83 13 	call	0x2706	; 0x2706 <MCAL_Interrupt_u8SetRegisterPin>
}
    298c:	cf 91       	pop	r28
    298e:	df 91       	pop	r29
    2990:	08 95       	ret

00002992 <MCAL_Interrupt_InterruptFallingInit>:
void MCAL_Interrupt_InterruptFallingInit() {
    2992:	df 93       	push	r29
    2994:	cf 93       	push	r28
    2996:	cd b7       	in	r28, 0x3d	; 61
    2998:	de b7       	in	r29, 0x3e	; 62
	MCAL_Interrupt_u8SetRegisterPin(Gicr, GICR_Pin6, Pin_High);
    299a:	81 e0       	ldi	r24, 0x01	; 1
    299c:	66 e0       	ldi	r22, 0x06	; 6
    299e:	41 e0       	ldi	r20, 0x01	; 1
    29a0:	0e 94 83 13 	call	0x2706	; 0x2706 <MCAL_Interrupt_u8SetRegisterPin>
	MCAL_Interrupt_u8SetRegisterPin(Mcucr,MCUCR_Pin0 , Pin_Low);
    29a4:	82 e0       	ldi	r24, 0x02	; 2
    29a6:	60 e0       	ldi	r22, 0x00	; 0
    29a8:	40 e0       	ldi	r20, 0x00	; 0
    29aa:	0e 94 83 13 	call	0x2706	; 0x2706 <MCAL_Interrupt_u8SetRegisterPin>
	MCAL_Interrupt_u8SetRegisterPin(Mcucr,MCUCR_Pin1 , Pin_High);
    29ae:	82 e0       	ldi	r24, 0x02	; 2
    29b0:	61 e0       	ldi	r22, 0x01	; 1
    29b2:	41 e0       	ldi	r20, 0x01	; 1
    29b4:	0e 94 83 13 	call	0x2706	; 0x2706 <MCAL_Interrupt_u8SetRegisterPin>
}
    29b8:	cf 91       	pop	r28
    29ba:	df 91       	pop	r29
    29bc:	08 95       	ret

000029be <__vector_1>:

ISR(VECT_INT0) {
    29be:	1f 92       	push	r1
    29c0:	0f 92       	push	r0
    29c2:	0f b6       	in	r0, 0x3f	; 63
    29c4:	0f 92       	push	r0
    29c6:	11 24       	eor	r1, r1
    29c8:	2f 93       	push	r18
    29ca:	3f 93       	push	r19
    29cc:	4f 93       	push	r20
    29ce:	5f 93       	push	r21
    29d0:	6f 93       	push	r22
    29d2:	7f 93       	push	r23
    29d4:	8f 93       	push	r24
    29d6:	9f 93       	push	r25
    29d8:	af 93       	push	r26
    29da:	bf 93       	push	r27
    29dc:	ef 93       	push	r30
    29de:	ff 93       	push	r31
    29e0:	df 93       	push	r29
    29e2:	cf 93       	push	r28
    29e4:	cd b7       	in	r28, 0x3d	; 61
    29e6:	de b7       	in	r29, 0x3e	; 62
	if (Gptr0 != '\0')
    29e8:	80 91 38 02 	lds	r24, 0x0238
    29ec:	90 91 39 02 	lds	r25, 0x0239
    29f0:	00 97       	sbiw	r24, 0x00	; 0
    29f2:	29 f0       	breq	.+10     	; 0x29fe <__vector_1+0x40>
		Gptr0();
    29f4:	e0 91 38 02 	lds	r30, 0x0238
    29f8:	f0 91 39 02 	lds	r31, 0x0239
    29fc:	09 95       	icall
}
    29fe:	cf 91       	pop	r28
    2a00:	df 91       	pop	r29
    2a02:	ff 91       	pop	r31
    2a04:	ef 91       	pop	r30
    2a06:	bf 91       	pop	r27
    2a08:	af 91       	pop	r26
    2a0a:	9f 91       	pop	r25
    2a0c:	8f 91       	pop	r24
    2a0e:	7f 91       	pop	r23
    2a10:	6f 91       	pop	r22
    2a12:	5f 91       	pop	r21
    2a14:	4f 91       	pop	r20
    2a16:	3f 91       	pop	r19
    2a18:	2f 91       	pop	r18
    2a1a:	0f 90       	pop	r0
    2a1c:	0f be       	out	0x3f, r0	; 63
    2a1e:	0f 90       	pop	r0
    2a20:	1f 90       	pop	r1
    2a22:	18 95       	reti

00002a24 <__vector_2>:
ISR(VECT_INT1) {
    2a24:	1f 92       	push	r1
    2a26:	0f 92       	push	r0
    2a28:	0f b6       	in	r0, 0x3f	; 63
    2a2a:	0f 92       	push	r0
    2a2c:	11 24       	eor	r1, r1
    2a2e:	2f 93       	push	r18
    2a30:	3f 93       	push	r19
    2a32:	4f 93       	push	r20
    2a34:	5f 93       	push	r21
    2a36:	6f 93       	push	r22
    2a38:	7f 93       	push	r23
    2a3a:	8f 93       	push	r24
    2a3c:	9f 93       	push	r25
    2a3e:	af 93       	push	r26
    2a40:	bf 93       	push	r27
    2a42:	ef 93       	push	r30
    2a44:	ff 93       	push	r31
    2a46:	df 93       	push	r29
    2a48:	cf 93       	push	r28
    2a4a:	cd b7       	in	r28, 0x3d	; 61
    2a4c:	de b7       	in	r29, 0x3e	; 62
	if (Gptr1 != '\0')
    2a4e:	80 91 3a 02 	lds	r24, 0x023A
    2a52:	90 91 3b 02 	lds	r25, 0x023B
    2a56:	00 97       	sbiw	r24, 0x00	; 0
    2a58:	29 f0       	breq	.+10     	; 0x2a64 <__vector_2+0x40>
		Gptr1();
    2a5a:	e0 91 3a 02 	lds	r30, 0x023A
    2a5e:	f0 91 3b 02 	lds	r31, 0x023B
    2a62:	09 95       	icall
}
    2a64:	cf 91       	pop	r28
    2a66:	df 91       	pop	r29
    2a68:	ff 91       	pop	r31
    2a6a:	ef 91       	pop	r30
    2a6c:	bf 91       	pop	r27
    2a6e:	af 91       	pop	r26
    2a70:	9f 91       	pop	r25
    2a72:	8f 91       	pop	r24
    2a74:	7f 91       	pop	r23
    2a76:	6f 91       	pop	r22
    2a78:	5f 91       	pop	r21
    2a7a:	4f 91       	pop	r20
    2a7c:	3f 91       	pop	r19
    2a7e:	2f 91       	pop	r18
    2a80:	0f 90       	pop	r0
    2a82:	0f be       	out	0x3f, r0	; 63
    2a84:	0f 90       	pop	r0
    2a86:	1f 90       	pop	r1
    2a88:	18 95       	reti

00002a8a <__vector_3>:
ISR(VECT_INT2) {
    2a8a:	1f 92       	push	r1
    2a8c:	0f 92       	push	r0
    2a8e:	0f b6       	in	r0, 0x3f	; 63
    2a90:	0f 92       	push	r0
    2a92:	11 24       	eor	r1, r1
    2a94:	2f 93       	push	r18
    2a96:	3f 93       	push	r19
    2a98:	4f 93       	push	r20
    2a9a:	5f 93       	push	r21
    2a9c:	6f 93       	push	r22
    2a9e:	7f 93       	push	r23
    2aa0:	8f 93       	push	r24
    2aa2:	9f 93       	push	r25
    2aa4:	af 93       	push	r26
    2aa6:	bf 93       	push	r27
    2aa8:	ef 93       	push	r30
    2aaa:	ff 93       	push	r31
    2aac:	df 93       	push	r29
    2aae:	cf 93       	push	r28
    2ab0:	cd b7       	in	r28, 0x3d	; 61
    2ab2:	de b7       	in	r29, 0x3e	; 62
	if (Gptr2 != '\0')
    2ab4:	80 91 3c 02 	lds	r24, 0x023C
    2ab8:	90 91 3d 02 	lds	r25, 0x023D
    2abc:	00 97       	sbiw	r24, 0x00	; 0
    2abe:	29 f0       	breq	.+10     	; 0x2aca <__vector_3+0x40>
		Gptr2();
    2ac0:	e0 91 3c 02 	lds	r30, 0x023C
    2ac4:	f0 91 3d 02 	lds	r31, 0x023D
    2ac8:	09 95       	icall
}
    2aca:	cf 91       	pop	r28
    2acc:	df 91       	pop	r29
    2ace:	ff 91       	pop	r31
    2ad0:	ef 91       	pop	r30
    2ad2:	bf 91       	pop	r27
    2ad4:	af 91       	pop	r26
    2ad6:	9f 91       	pop	r25
    2ad8:	8f 91       	pop	r24
    2ada:	7f 91       	pop	r23
    2adc:	6f 91       	pop	r22
    2ade:	5f 91       	pop	r21
    2ae0:	4f 91       	pop	r20
    2ae2:	3f 91       	pop	r19
    2ae4:	2f 91       	pop	r18
    2ae6:	0f 90       	pop	r0
    2ae8:	0f be       	out	0x3f, r0	; 63
    2aea:	0f 90       	pop	r0
    2aec:	1f 90       	pop	r1
    2aee:	18 95       	reti

00002af0 <MCAL_DIO_u8SetPortDirection>:
 *      Author: Mohamed
 */

#include "DIO.h"

STD_Type MCAL_DIO_u8SetPortDirection(u8 Loc_u8PortID, u8 Loc_u8PortDirection) {
    2af0:	df 93       	push	r29
    2af2:	cf 93       	push	r28
    2af4:	00 d0       	rcall	.+0      	; 0x2af6 <MCAL_DIO_u8SetPortDirection+0x6>
    2af6:	0f 92       	push	r0
    2af8:	cd b7       	in	r28, 0x3d	; 61
    2afa:	de b7       	in	r29, 0x3e	; 62
    2afc:	8a 83       	std	Y+2, r24	; 0x02
    2afe:	6b 83       	std	Y+3, r22	; 0x03
	u8 Loc_u8Return_Value = E_NOT_OK;
    2b00:	81 e0       	ldi	r24, 0x01	; 1
    2b02:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD && Loc_u8PortDirection <= PORT_OUTPUT) {
    2b04:	8a 81       	ldd	r24, Y+2	; 0x02
    2b06:	84 30       	cpi	r24, 0x04	; 4
    2b08:	08 f0       	brcs	.+2      	; 0x2b0c <MCAL_DIO_u8SetPortDirection+0x1c>
    2b0a:	6e c0       	rjmp	.+220    	; 0x2be8 <MCAL_DIO_u8SetPortDirection+0xf8>
		if (Loc_u8PortDirection == PORT_OUTPUT) {
    2b0c:	8b 81       	ldd	r24, Y+3	; 0x03
    2b0e:	8f 3f       	cpi	r24, 0xFF	; 255
    2b10:	29 f5       	brne	.+74     	; 0x2b5c <MCAL_DIO_u8SetPortDirection+0x6c>
			if (Loc_u8PortID == PortA) {
    2b12:	8a 81       	ldd	r24, Y+2	; 0x02
    2b14:	88 23       	and	r24, r24
    2b16:	31 f4       	brne	.+12     	; 0x2b24 <MCAL_DIO_u8SetPortDirection+0x34>
				DDRA = PORT_OUTPUT;
    2b18:	ea e3       	ldi	r30, 0x3A	; 58
    2b1a:	f0 e0       	ldi	r31, 0x00	; 0
    2b1c:	8f ef       	ldi	r24, 0xFF	; 255
    2b1e:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    2b20:	19 82       	std	Y+1, r1	; 0x01
    2b22:	62 c0       	rjmp	.+196    	; 0x2be8 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortB) {
    2b24:	8a 81       	ldd	r24, Y+2	; 0x02
    2b26:	81 30       	cpi	r24, 0x01	; 1
    2b28:	31 f4       	brne	.+12     	; 0x2b36 <MCAL_DIO_u8SetPortDirection+0x46>
				DDRB = PORT_OUTPUT;
    2b2a:	e7 e3       	ldi	r30, 0x37	; 55
    2b2c:	f0 e0       	ldi	r31, 0x00	; 0
    2b2e:	8f ef       	ldi	r24, 0xFF	; 255
    2b30:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    2b32:	19 82       	std	Y+1, r1	; 0x01
    2b34:	59 c0       	rjmp	.+178    	; 0x2be8 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortC) {
    2b36:	8a 81       	ldd	r24, Y+2	; 0x02
    2b38:	82 30       	cpi	r24, 0x02	; 2
    2b3a:	31 f4       	brne	.+12     	; 0x2b48 <MCAL_DIO_u8SetPortDirection+0x58>
				DDRC = PORT_OUTPUT;
    2b3c:	e4 e3       	ldi	r30, 0x34	; 52
    2b3e:	f0 e0       	ldi	r31, 0x00	; 0
    2b40:	8f ef       	ldi	r24, 0xFF	; 255
    2b42:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    2b44:	19 82       	std	Y+1, r1	; 0x01
    2b46:	50 c0       	rjmp	.+160    	; 0x2be8 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortD) {
    2b48:	8a 81       	ldd	r24, Y+2	; 0x02
    2b4a:	83 30       	cpi	r24, 0x03	; 3
    2b4c:	09 f0       	breq	.+2      	; 0x2b50 <MCAL_DIO_u8SetPortDirection+0x60>
    2b4e:	4c c0       	rjmp	.+152    	; 0x2be8 <MCAL_DIO_u8SetPortDirection+0xf8>
				DDRD = PORT_OUTPUT;
    2b50:	e1 e3       	ldi	r30, 0x31	; 49
    2b52:	f0 e0       	ldi	r31, 0x00	; 0
    2b54:	8f ef       	ldi	r24, 0xFF	; 255
    2b56:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    2b58:	19 82       	std	Y+1, r1	; 0x01
    2b5a:	46 c0       	rjmp	.+140    	; 0x2be8 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else {
				//Do Nothing
			}
		} else if (Loc_u8PortDirection == PORT_INPUT) {
    2b5c:	8b 81       	ldd	r24, Y+3	; 0x03
    2b5e:	88 23       	and	r24, r24
    2b60:	01 f5       	brne	.+64     	; 0x2ba2 <MCAL_DIO_u8SetPortDirection+0xb2>
			if (Loc_u8PortID == PortA) {
    2b62:	8a 81       	ldd	r24, Y+2	; 0x02
    2b64:	88 23       	and	r24, r24
    2b66:	29 f4       	brne	.+10     	; 0x2b72 <MCAL_DIO_u8SetPortDirection+0x82>
				DDRA = PORT_INPUT;
    2b68:	ea e3       	ldi	r30, 0x3A	; 58
    2b6a:	f0 e0       	ldi	r31, 0x00	; 0
    2b6c:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    2b6e:	19 82       	std	Y+1, r1	; 0x01
    2b70:	3b c0       	rjmp	.+118    	; 0x2be8 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortB) {
    2b72:	8a 81       	ldd	r24, Y+2	; 0x02
    2b74:	81 30       	cpi	r24, 0x01	; 1
    2b76:	29 f4       	brne	.+10     	; 0x2b82 <MCAL_DIO_u8SetPortDirection+0x92>
				DDRB = PORT_INPUT;
    2b78:	e7 e3       	ldi	r30, 0x37	; 55
    2b7a:	f0 e0       	ldi	r31, 0x00	; 0
    2b7c:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    2b7e:	19 82       	std	Y+1, r1	; 0x01
    2b80:	33 c0       	rjmp	.+102    	; 0x2be8 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortC) {
    2b82:	8a 81       	ldd	r24, Y+2	; 0x02
    2b84:	82 30       	cpi	r24, 0x02	; 2
    2b86:	29 f4       	brne	.+10     	; 0x2b92 <MCAL_DIO_u8SetPortDirection+0xa2>
				DDRC = PORT_INPUT;
    2b88:	e4 e3       	ldi	r30, 0x34	; 52
    2b8a:	f0 e0       	ldi	r31, 0x00	; 0
    2b8c:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    2b8e:	19 82       	std	Y+1, r1	; 0x01
    2b90:	2b c0       	rjmp	.+86     	; 0x2be8 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortD) {
    2b92:	8a 81       	ldd	r24, Y+2	; 0x02
    2b94:	83 30       	cpi	r24, 0x03	; 3
    2b96:	41 f5       	brne	.+80     	; 0x2be8 <MCAL_DIO_u8SetPortDirection+0xf8>
				DDRD = PORT_INPUT;
    2b98:	e1 e3       	ldi	r30, 0x31	; 49
    2b9a:	f0 e0       	ldi	r31, 0x00	; 0
    2b9c:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    2b9e:	19 82       	std	Y+1, r1	; 0x01
    2ba0:	23 c0       	rjmp	.+70     	; 0x2be8 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else {
				//Do Nothing
			}
		} else {
			if (Loc_u8PortID == PortA) {
    2ba2:	8a 81       	ldd	r24, Y+2	; 0x02
    2ba4:	88 23       	and	r24, r24
    2ba6:	31 f4       	brne	.+12     	; 0x2bb4 <MCAL_DIO_u8SetPortDirection+0xc4>
				DDRA = Loc_u8PortDirection;
    2ba8:	ea e3       	ldi	r30, 0x3A	; 58
    2baa:	f0 e0       	ldi	r31, 0x00	; 0
    2bac:	8b 81       	ldd	r24, Y+3	; 0x03
    2bae:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    2bb0:	19 82       	std	Y+1, r1	; 0x01
    2bb2:	1a c0       	rjmp	.+52     	; 0x2be8 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortB) {
    2bb4:	8a 81       	ldd	r24, Y+2	; 0x02
    2bb6:	81 30       	cpi	r24, 0x01	; 1
    2bb8:	31 f4       	brne	.+12     	; 0x2bc6 <MCAL_DIO_u8SetPortDirection+0xd6>
				DDRB = Loc_u8PortDirection;
    2bba:	e7 e3       	ldi	r30, 0x37	; 55
    2bbc:	f0 e0       	ldi	r31, 0x00	; 0
    2bbe:	8b 81       	ldd	r24, Y+3	; 0x03
    2bc0:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    2bc2:	19 82       	std	Y+1, r1	; 0x01
    2bc4:	11 c0       	rjmp	.+34     	; 0x2be8 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortC) {
    2bc6:	8a 81       	ldd	r24, Y+2	; 0x02
    2bc8:	82 30       	cpi	r24, 0x02	; 2
    2bca:	31 f4       	brne	.+12     	; 0x2bd8 <MCAL_DIO_u8SetPortDirection+0xe8>
				DDRC = Loc_u8PortDirection;
    2bcc:	e4 e3       	ldi	r30, 0x34	; 52
    2bce:	f0 e0       	ldi	r31, 0x00	; 0
    2bd0:	8b 81       	ldd	r24, Y+3	; 0x03
    2bd2:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    2bd4:	19 82       	std	Y+1, r1	; 0x01
    2bd6:	08 c0       	rjmp	.+16     	; 0x2be8 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortD) {
    2bd8:	8a 81       	ldd	r24, Y+2	; 0x02
    2bda:	83 30       	cpi	r24, 0x03	; 3
    2bdc:	29 f4       	brne	.+10     	; 0x2be8 <MCAL_DIO_u8SetPortDirection+0xf8>
				DDRD = Loc_u8PortDirection;
    2bde:	e1 e3       	ldi	r30, 0x31	; 49
    2be0:	f0 e0       	ldi	r31, 0x00	; 0
    2be2:	8b 81       	ldd	r24, Y+3	; 0x03
    2be4:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    2be6:	19 82       	std	Y+1, r1	; 0x01
			}
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    2be8:	89 81       	ldd	r24, Y+1	; 0x01
}
    2bea:	0f 90       	pop	r0
    2bec:	0f 90       	pop	r0
    2bee:	0f 90       	pop	r0
    2bf0:	cf 91       	pop	r28
    2bf2:	df 91       	pop	r29
    2bf4:	08 95       	ret

00002bf6 <MCAL_DIO_u8SetPinDirection>:

STD_Type MCAL_DIO_u8SetPinDirection(u8 Loc_u8PortID, u8 Loc_u8PinID,
		u8 Loc_u8PinDirection) {
    2bf6:	df 93       	push	r29
    2bf8:	cf 93       	push	r28
    2bfa:	00 d0       	rcall	.+0      	; 0x2bfc <MCAL_DIO_u8SetPinDirection+0x6>
    2bfc:	00 d0       	rcall	.+0      	; 0x2bfe <MCAL_DIO_u8SetPinDirection+0x8>
    2bfe:	cd b7       	in	r28, 0x3d	; 61
    2c00:	de b7       	in	r29, 0x3e	; 62
    2c02:	8a 83       	std	Y+2, r24	; 0x02
    2c04:	6b 83       	std	Y+3, r22	; 0x03
    2c06:	4c 83       	std	Y+4, r20	; 0x04
	u8 Loc_u8Return_Value = E_NOT_OK;
    2c08:	81 e0       	ldi	r24, 0x01	; 1
    2c0a:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD && Loc_u8PinID <= Num_Of_Pins
    2c0c:	8a 81       	ldd	r24, Y+2	; 0x02
    2c0e:	84 30       	cpi	r24, 0x04	; 4
    2c10:	08 f0       	brcs	.+2      	; 0x2c14 <MCAL_DIO_u8SetPinDirection+0x1e>
    2c12:	d4 c0       	rjmp	.+424    	; 0x2dbc <MCAL_DIO_u8SetPinDirection+0x1c6>
    2c14:	8b 81       	ldd	r24, Y+3	; 0x03
    2c16:	88 30       	cpi	r24, 0x08	; 8
    2c18:	08 f0       	brcs	.+2      	; 0x2c1c <MCAL_DIO_u8SetPinDirection+0x26>
    2c1a:	d0 c0       	rjmp	.+416    	; 0x2dbc <MCAL_DIO_u8SetPinDirection+0x1c6>
    2c1c:	8c 81       	ldd	r24, Y+4	; 0x04
    2c1e:	82 30       	cpi	r24, 0x02	; 2
    2c20:	08 f0       	brcs	.+2      	; 0x2c24 <MCAL_DIO_u8SetPinDirection+0x2e>
    2c22:	cc c0       	rjmp	.+408    	; 0x2dbc <MCAL_DIO_u8SetPinDirection+0x1c6>
			&& Loc_u8PinDirection <= Pin_High) {
		if (Loc_u8PinDirection == Pin_High) {
    2c24:	8c 81       	ldd	r24, Y+4	; 0x04
    2c26:	81 30       	cpi	r24, 0x01	; 1
    2c28:	09 f0       	breq	.+2      	; 0x2c2c <MCAL_DIO_u8SetPinDirection+0x36>
    2c2a:	61 c0       	rjmp	.+194    	; 0x2cee <MCAL_DIO_u8SetPinDirection+0xf8>
			if (Loc_u8PortID == PortA) {
    2c2c:	8a 81       	ldd	r24, Y+2	; 0x02
    2c2e:	88 23       	and	r24, r24
    2c30:	a9 f4       	brne	.+42     	; 0x2c5c <MCAL_DIO_u8SetPinDirection+0x66>
				SET_BIT(DDRA, Loc_u8PinID);
    2c32:	aa e3       	ldi	r26, 0x3A	; 58
    2c34:	b0 e0       	ldi	r27, 0x00	; 0
    2c36:	ea e3       	ldi	r30, 0x3A	; 58
    2c38:	f0 e0       	ldi	r31, 0x00	; 0
    2c3a:	80 81       	ld	r24, Z
    2c3c:	48 2f       	mov	r20, r24
    2c3e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c40:	28 2f       	mov	r18, r24
    2c42:	30 e0       	ldi	r19, 0x00	; 0
    2c44:	81 e0       	ldi	r24, 0x01	; 1
    2c46:	90 e0       	ldi	r25, 0x00	; 0
    2c48:	02 2e       	mov	r0, r18
    2c4a:	02 c0       	rjmp	.+4      	; 0x2c50 <MCAL_DIO_u8SetPinDirection+0x5a>
    2c4c:	88 0f       	add	r24, r24
    2c4e:	99 1f       	adc	r25, r25
    2c50:	0a 94       	dec	r0
    2c52:	e2 f7       	brpl	.-8      	; 0x2c4c <MCAL_DIO_u8SetPinDirection+0x56>
    2c54:	84 2b       	or	r24, r20
    2c56:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2c58:	19 82       	std	Y+1, r1	; 0x01
    2c5a:	b0 c0       	rjmp	.+352    	; 0x2dbc <MCAL_DIO_u8SetPinDirection+0x1c6>
			} else if (Loc_u8PortID == PortB) {
    2c5c:	8a 81       	ldd	r24, Y+2	; 0x02
    2c5e:	81 30       	cpi	r24, 0x01	; 1
    2c60:	a9 f4       	brne	.+42     	; 0x2c8c <MCAL_DIO_u8SetPinDirection+0x96>
				SET_BIT(DDRB, Loc_u8PinID);
    2c62:	a7 e3       	ldi	r26, 0x37	; 55
    2c64:	b0 e0       	ldi	r27, 0x00	; 0
    2c66:	e7 e3       	ldi	r30, 0x37	; 55
    2c68:	f0 e0       	ldi	r31, 0x00	; 0
    2c6a:	80 81       	ld	r24, Z
    2c6c:	48 2f       	mov	r20, r24
    2c6e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c70:	28 2f       	mov	r18, r24
    2c72:	30 e0       	ldi	r19, 0x00	; 0
    2c74:	81 e0       	ldi	r24, 0x01	; 1
    2c76:	90 e0       	ldi	r25, 0x00	; 0
    2c78:	02 2e       	mov	r0, r18
    2c7a:	02 c0       	rjmp	.+4      	; 0x2c80 <MCAL_DIO_u8SetPinDirection+0x8a>
    2c7c:	88 0f       	add	r24, r24
    2c7e:	99 1f       	adc	r25, r25
    2c80:	0a 94       	dec	r0
    2c82:	e2 f7       	brpl	.-8      	; 0x2c7c <MCAL_DIO_u8SetPinDirection+0x86>
    2c84:	84 2b       	or	r24, r20
    2c86:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2c88:	19 82       	std	Y+1, r1	; 0x01
    2c8a:	98 c0       	rjmp	.+304    	; 0x2dbc <MCAL_DIO_u8SetPinDirection+0x1c6>
			} else if (Loc_u8PortID == PortC) {
    2c8c:	8a 81       	ldd	r24, Y+2	; 0x02
    2c8e:	82 30       	cpi	r24, 0x02	; 2
    2c90:	a9 f4       	brne	.+42     	; 0x2cbc <MCAL_DIO_u8SetPinDirection+0xc6>
				SET_BIT(DDRC, Loc_u8PinID);
    2c92:	a4 e3       	ldi	r26, 0x34	; 52
    2c94:	b0 e0       	ldi	r27, 0x00	; 0
    2c96:	e4 e3       	ldi	r30, 0x34	; 52
    2c98:	f0 e0       	ldi	r31, 0x00	; 0
    2c9a:	80 81       	ld	r24, Z
    2c9c:	48 2f       	mov	r20, r24
    2c9e:	8b 81       	ldd	r24, Y+3	; 0x03
    2ca0:	28 2f       	mov	r18, r24
    2ca2:	30 e0       	ldi	r19, 0x00	; 0
    2ca4:	81 e0       	ldi	r24, 0x01	; 1
    2ca6:	90 e0       	ldi	r25, 0x00	; 0
    2ca8:	02 2e       	mov	r0, r18
    2caa:	02 c0       	rjmp	.+4      	; 0x2cb0 <MCAL_DIO_u8SetPinDirection+0xba>
    2cac:	88 0f       	add	r24, r24
    2cae:	99 1f       	adc	r25, r25
    2cb0:	0a 94       	dec	r0
    2cb2:	e2 f7       	brpl	.-8      	; 0x2cac <MCAL_DIO_u8SetPinDirection+0xb6>
    2cb4:	84 2b       	or	r24, r20
    2cb6:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2cb8:	19 82       	std	Y+1, r1	; 0x01
    2cba:	80 c0       	rjmp	.+256    	; 0x2dbc <MCAL_DIO_u8SetPinDirection+0x1c6>
			} else if (Loc_u8PortID == PortD) {
    2cbc:	8a 81       	ldd	r24, Y+2	; 0x02
    2cbe:	83 30       	cpi	r24, 0x03	; 3
    2cc0:	09 f0       	breq	.+2      	; 0x2cc4 <MCAL_DIO_u8SetPinDirection+0xce>
    2cc2:	7c c0       	rjmp	.+248    	; 0x2dbc <MCAL_DIO_u8SetPinDirection+0x1c6>
				SET_BIT(DDRD, Loc_u8PinID);
    2cc4:	a1 e3       	ldi	r26, 0x31	; 49
    2cc6:	b0 e0       	ldi	r27, 0x00	; 0
    2cc8:	e1 e3       	ldi	r30, 0x31	; 49
    2cca:	f0 e0       	ldi	r31, 0x00	; 0
    2ccc:	80 81       	ld	r24, Z
    2cce:	48 2f       	mov	r20, r24
    2cd0:	8b 81       	ldd	r24, Y+3	; 0x03
    2cd2:	28 2f       	mov	r18, r24
    2cd4:	30 e0       	ldi	r19, 0x00	; 0
    2cd6:	81 e0       	ldi	r24, 0x01	; 1
    2cd8:	90 e0       	ldi	r25, 0x00	; 0
    2cda:	02 2e       	mov	r0, r18
    2cdc:	02 c0       	rjmp	.+4      	; 0x2ce2 <MCAL_DIO_u8SetPinDirection+0xec>
    2cde:	88 0f       	add	r24, r24
    2ce0:	99 1f       	adc	r25, r25
    2ce2:	0a 94       	dec	r0
    2ce4:	e2 f7       	brpl	.-8      	; 0x2cde <MCAL_DIO_u8SetPinDirection+0xe8>
    2ce6:	84 2b       	or	r24, r20
    2ce8:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2cea:	19 82       	std	Y+1, r1	; 0x01
    2cec:	67 c0       	rjmp	.+206    	; 0x2dbc <MCAL_DIO_u8SetPinDirection+0x1c6>
			} else {
				//Do Nothing
			}
		} else if (Loc_u8PinDirection == Pin_Low) {
    2cee:	8c 81       	ldd	r24, Y+4	; 0x04
    2cf0:	88 23       	and	r24, r24
    2cf2:	09 f0       	breq	.+2      	; 0x2cf6 <MCAL_DIO_u8SetPinDirection+0x100>
    2cf4:	63 c0       	rjmp	.+198    	; 0x2dbc <MCAL_DIO_u8SetPinDirection+0x1c6>
			if (Loc_u8PortID == PortA) {
    2cf6:	8a 81       	ldd	r24, Y+2	; 0x02
    2cf8:	88 23       	and	r24, r24
    2cfa:	b1 f4       	brne	.+44     	; 0x2d28 <MCAL_DIO_u8SetPinDirection+0x132>
				CLR_BIT(DDRA, Loc_u8PinID);
    2cfc:	aa e3       	ldi	r26, 0x3A	; 58
    2cfe:	b0 e0       	ldi	r27, 0x00	; 0
    2d00:	ea e3       	ldi	r30, 0x3A	; 58
    2d02:	f0 e0       	ldi	r31, 0x00	; 0
    2d04:	80 81       	ld	r24, Z
    2d06:	48 2f       	mov	r20, r24
    2d08:	8b 81       	ldd	r24, Y+3	; 0x03
    2d0a:	28 2f       	mov	r18, r24
    2d0c:	30 e0       	ldi	r19, 0x00	; 0
    2d0e:	81 e0       	ldi	r24, 0x01	; 1
    2d10:	90 e0       	ldi	r25, 0x00	; 0
    2d12:	02 2e       	mov	r0, r18
    2d14:	02 c0       	rjmp	.+4      	; 0x2d1a <MCAL_DIO_u8SetPinDirection+0x124>
    2d16:	88 0f       	add	r24, r24
    2d18:	99 1f       	adc	r25, r25
    2d1a:	0a 94       	dec	r0
    2d1c:	e2 f7       	brpl	.-8      	; 0x2d16 <MCAL_DIO_u8SetPinDirection+0x120>
    2d1e:	80 95       	com	r24
    2d20:	84 23       	and	r24, r20
    2d22:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2d24:	19 82       	std	Y+1, r1	; 0x01
    2d26:	4a c0       	rjmp	.+148    	; 0x2dbc <MCAL_DIO_u8SetPinDirection+0x1c6>
			} else if (Loc_u8PortID == PortB) {
    2d28:	8a 81       	ldd	r24, Y+2	; 0x02
    2d2a:	81 30       	cpi	r24, 0x01	; 1
    2d2c:	b1 f4       	brne	.+44     	; 0x2d5a <MCAL_DIO_u8SetPinDirection+0x164>
				CLR_BIT(DDRB, Loc_u8PinID);
    2d2e:	a7 e3       	ldi	r26, 0x37	; 55
    2d30:	b0 e0       	ldi	r27, 0x00	; 0
    2d32:	e7 e3       	ldi	r30, 0x37	; 55
    2d34:	f0 e0       	ldi	r31, 0x00	; 0
    2d36:	80 81       	ld	r24, Z
    2d38:	48 2f       	mov	r20, r24
    2d3a:	8b 81       	ldd	r24, Y+3	; 0x03
    2d3c:	28 2f       	mov	r18, r24
    2d3e:	30 e0       	ldi	r19, 0x00	; 0
    2d40:	81 e0       	ldi	r24, 0x01	; 1
    2d42:	90 e0       	ldi	r25, 0x00	; 0
    2d44:	02 2e       	mov	r0, r18
    2d46:	02 c0       	rjmp	.+4      	; 0x2d4c <MCAL_DIO_u8SetPinDirection+0x156>
    2d48:	88 0f       	add	r24, r24
    2d4a:	99 1f       	adc	r25, r25
    2d4c:	0a 94       	dec	r0
    2d4e:	e2 f7       	brpl	.-8      	; 0x2d48 <MCAL_DIO_u8SetPinDirection+0x152>
    2d50:	80 95       	com	r24
    2d52:	84 23       	and	r24, r20
    2d54:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2d56:	19 82       	std	Y+1, r1	; 0x01
    2d58:	31 c0       	rjmp	.+98     	; 0x2dbc <MCAL_DIO_u8SetPinDirection+0x1c6>
			} else if (Loc_u8PortID == PortC) {
    2d5a:	8a 81       	ldd	r24, Y+2	; 0x02
    2d5c:	82 30       	cpi	r24, 0x02	; 2
    2d5e:	b1 f4       	brne	.+44     	; 0x2d8c <MCAL_DIO_u8SetPinDirection+0x196>
				CLR_BIT(DDRC, Loc_u8PinID);
    2d60:	a4 e3       	ldi	r26, 0x34	; 52
    2d62:	b0 e0       	ldi	r27, 0x00	; 0
    2d64:	e4 e3       	ldi	r30, 0x34	; 52
    2d66:	f0 e0       	ldi	r31, 0x00	; 0
    2d68:	80 81       	ld	r24, Z
    2d6a:	48 2f       	mov	r20, r24
    2d6c:	8b 81       	ldd	r24, Y+3	; 0x03
    2d6e:	28 2f       	mov	r18, r24
    2d70:	30 e0       	ldi	r19, 0x00	; 0
    2d72:	81 e0       	ldi	r24, 0x01	; 1
    2d74:	90 e0       	ldi	r25, 0x00	; 0
    2d76:	02 2e       	mov	r0, r18
    2d78:	02 c0       	rjmp	.+4      	; 0x2d7e <MCAL_DIO_u8SetPinDirection+0x188>
    2d7a:	88 0f       	add	r24, r24
    2d7c:	99 1f       	adc	r25, r25
    2d7e:	0a 94       	dec	r0
    2d80:	e2 f7       	brpl	.-8      	; 0x2d7a <MCAL_DIO_u8SetPinDirection+0x184>
    2d82:	80 95       	com	r24
    2d84:	84 23       	and	r24, r20
    2d86:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2d88:	19 82       	std	Y+1, r1	; 0x01
    2d8a:	18 c0       	rjmp	.+48     	; 0x2dbc <MCAL_DIO_u8SetPinDirection+0x1c6>
			} else if (Loc_u8PortID == PortD) {
    2d8c:	8a 81       	ldd	r24, Y+2	; 0x02
    2d8e:	83 30       	cpi	r24, 0x03	; 3
    2d90:	a9 f4       	brne	.+42     	; 0x2dbc <MCAL_DIO_u8SetPinDirection+0x1c6>
				CLR_BIT(DDRD, Loc_u8PinID);
    2d92:	a1 e3       	ldi	r26, 0x31	; 49
    2d94:	b0 e0       	ldi	r27, 0x00	; 0
    2d96:	e1 e3       	ldi	r30, 0x31	; 49
    2d98:	f0 e0       	ldi	r31, 0x00	; 0
    2d9a:	80 81       	ld	r24, Z
    2d9c:	48 2f       	mov	r20, r24
    2d9e:	8b 81       	ldd	r24, Y+3	; 0x03
    2da0:	28 2f       	mov	r18, r24
    2da2:	30 e0       	ldi	r19, 0x00	; 0
    2da4:	81 e0       	ldi	r24, 0x01	; 1
    2da6:	90 e0       	ldi	r25, 0x00	; 0
    2da8:	02 2e       	mov	r0, r18
    2daa:	02 c0       	rjmp	.+4      	; 0x2db0 <MCAL_DIO_u8SetPinDirection+0x1ba>
    2dac:	88 0f       	add	r24, r24
    2dae:	99 1f       	adc	r25, r25
    2db0:	0a 94       	dec	r0
    2db2:	e2 f7       	brpl	.-8      	; 0x2dac <MCAL_DIO_u8SetPinDirection+0x1b6>
    2db4:	80 95       	com	r24
    2db6:	84 23       	and	r24, r20
    2db8:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2dba:	19 82       	std	Y+1, r1	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    2dbc:	89 81       	ldd	r24, Y+1	; 0x01

}
    2dbe:	0f 90       	pop	r0
    2dc0:	0f 90       	pop	r0
    2dc2:	0f 90       	pop	r0
    2dc4:	0f 90       	pop	r0
    2dc6:	cf 91       	pop	r28
    2dc8:	df 91       	pop	r29
    2dca:	08 95       	ret

00002dcc <MCAL_DIO_u8SetPortValue>:

STD_Type MCAL_DIO_u8SetPortValue(u8 Loc_u8PortID, u8 Loc_u8PortValue) {
    2dcc:	df 93       	push	r29
    2dce:	cf 93       	push	r28
    2dd0:	00 d0       	rcall	.+0      	; 0x2dd2 <MCAL_DIO_u8SetPortValue+0x6>
    2dd2:	0f 92       	push	r0
    2dd4:	cd b7       	in	r28, 0x3d	; 61
    2dd6:	de b7       	in	r29, 0x3e	; 62
    2dd8:	8a 83       	std	Y+2, r24	; 0x02
    2dda:	6b 83       	std	Y+3, r22	; 0x03
	u8 Loc_u8Return_Value = E_NOT_OK;
    2ddc:	81 e0       	ldi	r24, 0x01	; 1
    2dde:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD && Loc_u8PortValue <= PORT_OUTPUT) {
    2de0:	8a 81       	ldd	r24, Y+2	; 0x02
    2de2:	84 30       	cpi	r24, 0x04	; 4
    2de4:	08 f0       	brcs	.+2      	; 0x2de8 <MCAL_DIO_u8SetPortValue+0x1c>
    2de6:	6e c0       	rjmp	.+220    	; 0x2ec4 <MCAL_DIO_u8SetPortValue+0xf8>
		if (Loc_u8PortValue == PORT_OUTPUT) {
    2de8:	8b 81       	ldd	r24, Y+3	; 0x03
    2dea:	8f 3f       	cpi	r24, 0xFF	; 255
    2dec:	29 f5       	brne	.+74     	; 0x2e38 <MCAL_DIO_u8SetPortValue+0x6c>
			if (Loc_u8PortID == PortA) {
    2dee:	8a 81       	ldd	r24, Y+2	; 0x02
    2df0:	88 23       	and	r24, r24
    2df2:	31 f4       	brne	.+12     	; 0x2e00 <MCAL_DIO_u8SetPortValue+0x34>
				PORTA = PORT_OUTPUT;
    2df4:	eb e3       	ldi	r30, 0x3B	; 59
    2df6:	f0 e0       	ldi	r31, 0x00	; 0
    2df8:	8f ef       	ldi	r24, 0xFF	; 255
    2dfa:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    2dfc:	19 82       	std	Y+1, r1	; 0x01
    2dfe:	62 c0       	rjmp	.+196    	; 0x2ec4 <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortB) {
    2e00:	8a 81       	ldd	r24, Y+2	; 0x02
    2e02:	81 30       	cpi	r24, 0x01	; 1
    2e04:	31 f4       	brne	.+12     	; 0x2e12 <MCAL_DIO_u8SetPortValue+0x46>
				PORTB = PORT_OUTPUT;
    2e06:	e8 e3       	ldi	r30, 0x38	; 56
    2e08:	f0 e0       	ldi	r31, 0x00	; 0
    2e0a:	8f ef       	ldi	r24, 0xFF	; 255
    2e0c:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    2e0e:	19 82       	std	Y+1, r1	; 0x01
    2e10:	59 c0       	rjmp	.+178    	; 0x2ec4 <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortC) {
    2e12:	8a 81       	ldd	r24, Y+2	; 0x02
    2e14:	82 30       	cpi	r24, 0x02	; 2
    2e16:	31 f4       	brne	.+12     	; 0x2e24 <MCAL_DIO_u8SetPortValue+0x58>
				PORTC = PORT_OUTPUT;
    2e18:	e5 e3       	ldi	r30, 0x35	; 53
    2e1a:	f0 e0       	ldi	r31, 0x00	; 0
    2e1c:	8f ef       	ldi	r24, 0xFF	; 255
    2e1e:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    2e20:	19 82       	std	Y+1, r1	; 0x01
    2e22:	50 c0       	rjmp	.+160    	; 0x2ec4 <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortD) {
    2e24:	8a 81       	ldd	r24, Y+2	; 0x02
    2e26:	83 30       	cpi	r24, 0x03	; 3
    2e28:	09 f0       	breq	.+2      	; 0x2e2c <MCAL_DIO_u8SetPortValue+0x60>
    2e2a:	4c c0       	rjmp	.+152    	; 0x2ec4 <MCAL_DIO_u8SetPortValue+0xf8>
				PORTD = PORT_OUTPUT;
    2e2c:	e2 e3       	ldi	r30, 0x32	; 50
    2e2e:	f0 e0       	ldi	r31, 0x00	; 0
    2e30:	8f ef       	ldi	r24, 0xFF	; 255
    2e32:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    2e34:	19 82       	std	Y+1, r1	; 0x01
    2e36:	46 c0       	rjmp	.+140    	; 0x2ec4 <MCAL_DIO_u8SetPortValue+0xf8>
			} else {
				//Do Nothing
			}
		} else if (Loc_u8PortValue == PORT_INPUT) {
    2e38:	8b 81       	ldd	r24, Y+3	; 0x03
    2e3a:	88 23       	and	r24, r24
    2e3c:	01 f5       	brne	.+64     	; 0x2e7e <MCAL_DIO_u8SetPortValue+0xb2>
			if (Loc_u8PortID == PortA) {
    2e3e:	8a 81       	ldd	r24, Y+2	; 0x02
    2e40:	88 23       	and	r24, r24
    2e42:	29 f4       	brne	.+10     	; 0x2e4e <MCAL_DIO_u8SetPortValue+0x82>
				PORTA = PORT_INPUT;
    2e44:	eb e3       	ldi	r30, 0x3B	; 59
    2e46:	f0 e0       	ldi	r31, 0x00	; 0
    2e48:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    2e4a:	19 82       	std	Y+1, r1	; 0x01
    2e4c:	3b c0       	rjmp	.+118    	; 0x2ec4 <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortB) {
    2e4e:	8a 81       	ldd	r24, Y+2	; 0x02
    2e50:	81 30       	cpi	r24, 0x01	; 1
    2e52:	29 f4       	brne	.+10     	; 0x2e5e <MCAL_DIO_u8SetPortValue+0x92>
				PORTB = PORT_INPUT;
    2e54:	e8 e3       	ldi	r30, 0x38	; 56
    2e56:	f0 e0       	ldi	r31, 0x00	; 0
    2e58:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    2e5a:	19 82       	std	Y+1, r1	; 0x01
    2e5c:	33 c0       	rjmp	.+102    	; 0x2ec4 <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortC) {
    2e5e:	8a 81       	ldd	r24, Y+2	; 0x02
    2e60:	82 30       	cpi	r24, 0x02	; 2
    2e62:	29 f4       	brne	.+10     	; 0x2e6e <MCAL_DIO_u8SetPortValue+0xa2>
				PORTC = PORT_INPUT;
    2e64:	e5 e3       	ldi	r30, 0x35	; 53
    2e66:	f0 e0       	ldi	r31, 0x00	; 0
    2e68:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    2e6a:	19 82       	std	Y+1, r1	; 0x01
    2e6c:	2b c0       	rjmp	.+86     	; 0x2ec4 <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortD) {
    2e6e:	8a 81       	ldd	r24, Y+2	; 0x02
    2e70:	83 30       	cpi	r24, 0x03	; 3
    2e72:	41 f5       	brne	.+80     	; 0x2ec4 <MCAL_DIO_u8SetPortValue+0xf8>
				PORTD = PORT_INPUT;
    2e74:	e2 e3       	ldi	r30, 0x32	; 50
    2e76:	f0 e0       	ldi	r31, 0x00	; 0
    2e78:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    2e7a:	19 82       	std	Y+1, r1	; 0x01
    2e7c:	23 c0       	rjmp	.+70     	; 0x2ec4 <MCAL_DIO_u8SetPortValue+0xf8>
			} else {
				//Do Nothing
			}
		} else {
			if (Loc_u8PortID == PortA) {
    2e7e:	8a 81       	ldd	r24, Y+2	; 0x02
    2e80:	88 23       	and	r24, r24
    2e82:	31 f4       	brne	.+12     	; 0x2e90 <MCAL_DIO_u8SetPortValue+0xc4>
				PORTA = Loc_u8PortValue;
    2e84:	eb e3       	ldi	r30, 0x3B	; 59
    2e86:	f0 e0       	ldi	r31, 0x00	; 0
    2e88:	8b 81       	ldd	r24, Y+3	; 0x03
    2e8a:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    2e8c:	19 82       	std	Y+1, r1	; 0x01
    2e8e:	1a c0       	rjmp	.+52     	; 0x2ec4 <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortB) {
    2e90:	8a 81       	ldd	r24, Y+2	; 0x02
    2e92:	81 30       	cpi	r24, 0x01	; 1
    2e94:	31 f4       	brne	.+12     	; 0x2ea2 <MCAL_DIO_u8SetPortValue+0xd6>
				PORTB = Loc_u8PortValue;
    2e96:	e8 e3       	ldi	r30, 0x38	; 56
    2e98:	f0 e0       	ldi	r31, 0x00	; 0
    2e9a:	8b 81       	ldd	r24, Y+3	; 0x03
    2e9c:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    2e9e:	19 82       	std	Y+1, r1	; 0x01
    2ea0:	11 c0       	rjmp	.+34     	; 0x2ec4 <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortC) {
    2ea2:	8a 81       	ldd	r24, Y+2	; 0x02
    2ea4:	82 30       	cpi	r24, 0x02	; 2
    2ea6:	31 f4       	brne	.+12     	; 0x2eb4 <MCAL_DIO_u8SetPortValue+0xe8>
				PORTC = Loc_u8PortValue;
    2ea8:	e5 e3       	ldi	r30, 0x35	; 53
    2eaa:	f0 e0       	ldi	r31, 0x00	; 0
    2eac:	8b 81       	ldd	r24, Y+3	; 0x03
    2eae:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    2eb0:	19 82       	std	Y+1, r1	; 0x01
    2eb2:	08 c0       	rjmp	.+16     	; 0x2ec4 <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortD) {
    2eb4:	8a 81       	ldd	r24, Y+2	; 0x02
    2eb6:	83 30       	cpi	r24, 0x03	; 3
    2eb8:	29 f4       	brne	.+10     	; 0x2ec4 <MCAL_DIO_u8SetPortValue+0xf8>
				PORTD = Loc_u8PortValue;
    2eba:	e2 e3       	ldi	r30, 0x32	; 50
    2ebc:	f0 e0       	ldi	r31, 0x00	; 0
    2ebe:	8b 81       	ldd	r24, Y+3	; 0x03
    2ec0:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    2ec2:	19 82       	std	Y+1, r1	; 0x01
			}
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    2ec4:	89 81       	ldd	r24, Y+1	; 0x01
}
    2ec6:	0f 90       	pop	r0
    2ec8:	0f 90       	pop	r0
    2eca:	0f 90       	pop	r0
    2ecc:	cf 91       	pop	r28
    2ece:	df 91       	pop	r29
    2ed0:	08 95       	ret

00002ed2 <MCAL_DIO_u8SetPinValue>:

STD_Type MCAL_DIO_u8SetPinValue(u8 Loc_u8PortID, u8 Loc_u8PinID,
		u8 Loc_u8PinValue) {
    2ed2:	df 93       	push	r29
    2ed4:	cf 93       	push	r28
    2ed6:	00 d0       	rcall	.+0      	; 0x2ed8 <MCAL_DIO_u8SetPinValue+0x6>
    2ed8:	00 d0       	rcall	.+0      	; 0x2eda <MCAL_DIO_u8SetPinValue+0x8>
    2eda:	cd b7       	in	r28, 0x3d	; 61
    2edc:	de b7       	in	r29, 0x3e	; 62
    2ede:	8a 83       	std	Y+2, r24	; 0x02
    2ee0:	6b 83       	std	Y+3, r22	; 0x03
    2ee2:	4c 83       	std	Y+4, r20	; 0x04
	u8 Loc_u8Return_Value = E_NOT_OK;
    2ee4:	81 e0       	ldi	r24, 0x01	; 1
    2ee6:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD && Loc_u8PinID <= Num_Of_Pins
    2ee8:	8a 81       	ldd	r24, Y+2	; 0x02
    2eea:	84 30       	cpi	r24, 0x04	; 4
    2eec:	08 f0       	brcs	.+2      	; 0x2ef0 <MCAL_DIO_u8SetPinValue+0x1e>
    2eee:	d4 c0       	rjmp	.+424    	; 0x3098 <MCAL_DIO_u8SetPinValue+0x1c6>
    2ef0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ef2:	88 30       	cpi	r24, 0x08	; 8
    2ef4:	08 f0       	brcs	.+2      	; 0x2ef8 <MCAL_DIO_u8SetPinValue+0x26>
    2ef6:	d0 c0       	rjmp	.+416    	; 0x3098 <MCAL_DIO_u8SetPinValue+0x1c6>
    2ef8:	8c 81       	ldd	r24, Y+4	; 0x04
    2efa:	82 30       	cpi	r24, 0x02	; 2
    2efc:	08 f0       	brcs	.+2      	; 0x2f00 <MCAL_DIO_u8SetPinValue+0x2e>
    2efe:	cc c0       	rjmp	.+408    	; 0x3098 <MCAL_DIO_u8SetPinValue+0x1c6>
			&& Loc_u8PinValue <= Pin_High) {
		if (Loc_u8PinValue == Pin_High) {
    2f00:	8c 81       	ldd	r24, Y+4	; 0x04
    2f02:	81 30       	cpi	r24, 0x01	; 1
    2f04:	09 f0       	breq	.+2      	; 0x2f08 <MCAL_DIO_u8SetPinValue+0x36>
    2f06:	61 c0       	rjmp	.+194    	; 0x2fca <MCAL_DIO_u8SetPinValue+0xf8>
			if (Loc_u8PortID == PortA) {
    2f08:	8a 81       	ldd	r24, Y+2	; 0x02
    2f0a:	88 23       	and	r24, r24
    2f0c:	a9 f4       	brne	.+42     	; 0x2f38 <MCAL_DIO_u8SetPinValue+0x66>
				SET_BIT(PORTA, Loc_u8PinID);
    2f0e:	ab e3       	ldi	r26, 0x3B	; 59
    2f10:	b0 e0       	ldi	r27, 0x00	; 0
    2f12:	eb e3       	ldi	r30, 0x3B	; 59
    2f14:	f0 e0       	ldi	r31, 0x00	; 0
    2f16:	80 81       	ld	r24, Z
    2f18:	48 2f       	mov	r20, r24
    2f1a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f1c:	28 2f       	mov	r18, r24
    2f1e:	30 e0       	ldi	r19, 0x00	; 0
    2f20:	81 e0       	ldi	r24, 0x01	; 1
    2f22:	90 e0       	ldi	r25, 0x00	; 0
    2f24:	02 2e       	mov	r0, r18
    2f26:	02 c0       	rjmp	.+4      	; 0x2f2c <MCAL_DIO_u8SetPinValue+0x5a>
    2f28:	88 0f       	add	r24, r24
    2f2a:	99 1f       	adc	r25, r25
    2f2c:	0a 94       	dec	r0
    2f2e:	e2 f7       	brpl	.-8      	; 0x2f28 <MCAL_DIO_u8SetPinValue+0x56>
    2f30:	84 2b       	or	r24, r20
    2f32:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2f34:	19 82       	std	Y+1, r1	; 0x01
    2f36:	b0 c0       	rjmp	.+352    	; 0x3098 <MCAL_DIO_u8SetPinValue+0x1c6>
			} else if (Loc_u8PortID == PortB) {
    2f38:	8a 81       	ldd	r24, Y+2	; 0x02
    2f3a:	81 30       	cpi	r24, 0x01	; 1
    2f3c:	a9 f4       	brne	.+42     	; 0x2f68 <MCAL_DIO_u8SetPinValue+0x96>
				SET_BIT(PORTB, Loc_u8PinID);
    2f3e:	a8 e3       	ldi	r26, 0x38	; 56
    2f40:	b0 e0       	ldi	r27, 0x00	; 0
    2f42:	e8 e3       	ldi	r30, 0x38	; 56
    2f44:	f0 e0       	ldi	r31, 0x00	; 0
    2f46:	80 81       	ld	r24, Z
    2f48:	48 2f       	mov	r20, r24
    2f4a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f4c:	28 2f       	mov	r18, r24
    2f4e:	30 e0       	ldi	r19, 0x00	; 0
    2f50:	81 e0       	ldi	r24, 0x01	; 1
    2f52:	90 e0       	ldi	r25, 0x00	; 0
    2f54:	02 2e       	mov	r0, r18
    2f56:	02 c0       	rjmp	.+4      	; 0x2f5c <MCAL_DIO_u8SetPinValue+0x8a>
    2f58:	88 0f       	add	r24, r24
    2f5a:	99 1f       	adc	r25, r25
    2f5c:	0a 94       	dec	r0
    2f5e:	e2 f7       	brpl	.-8      	; 0x2f58 <MCAL_DIO_u8SetPinValue+0x86>
    2f60:	84 2b       	or	r24, r20
    2f62:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2f64:	19 82       	std	Y+1, r1	; 0x01
    2f66:	98 c0       	rjmp	.+304    	; 0x3098 <MCAL_DIO_u8SetPinValue+0x1c6>
			} else if (Loc_u8PortID == PortC) {
    2f68:	8a 81       	ldd	r24, Y+2	; 0x02
    2f6a:	82 30       	cpi	r24, 0x02	; 2
    2f6c:	a9 f4       	brne	.+42     	; 0x2f98 <MCAL_DIO_u8SetPinValue+0xc6>
				SET_BIT(PORTC, Loc_u8PinID);
    2f6e:	a5 e3       	ldi	r26, 0x35	; 53
    2f70:	b0 e0       	ldi	r27, 0x00	; 0
    2f72:	e5 e3       	ldi	r30, 0x35	; 53
    2f74:	f0 e0       	ldi	r31, 0x00	; 0
    2f76:	80 81       	ld	r24, Z
    2f78:	48 2f       	mov	r20, r24
    2f7a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f7c:	28 2f       	mov	r18, r24
    2f7e:	30 e0       	ldi	r19, 0x00	; 0
    2f80:	81 e0       	ldi	r24, 0x01	; 1
    2f82:	90 e0       	ldi	r25, 0x00	; 0
    2f84:	02 2e       	mov	r0, r18
    2f86:	02 c0       	rjmp	.+4      	; 0x2f8c <MCAL_DIO_u8SetPinValue+0xba>
    2f88:	88 0f       	add	r24, r24
    2f8a:	99 1f       	adc	r25, r25
    2f8c:	0a 94       	dec	r0
    2f8e:	e2 f7       	brpl	.-8      	; 0x2f88 <MCAL_DIO_u8SetPinValue+0xb6>
    2f90:	84 2b       	or	r24, r20
    2f92:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2f94:	19 82       	std	Y+1, r1	; 0x01
    2f96:	80 c0       	rjmp	.+256    	; 0x3098 <MCAL_DIO_u8SetPinValue+0x1c6>
			} else if (Loc_u8PortID == PortD) {
    2f98:	8a 81       	ldd	r24, Y+2	; 0x02
    2f9a:	83 30       	cpi	r24, 0x03	; 3
    2f9c:	09 f0       	breq	.+2      	; 0x2fa0 <MCAL_DIO_u8SetPinValue+0xce>
    2f9e:	7c c0       	rjmp	.+248    	; 0x3098 <MCAL_DIO_u8SetPinValue+0x1c6>
				SET_BIT(PORTD, Loc_u8PinID);
    2fa0:	a2 e3       	ldi	r26, 0x32	; 50
    2fa2:	b0 e0       	ldi	r27, 0x00	; 0
    2fa4:	e2 e3       	ldi	r30, 0x32	; 50
    2fa6:	f0 e0       	ldi	r31, 0x00	; 0
    2fa8:	80 81       	ld	r24, Z
    2faa:	48 2f       	mov	r20, r24
    2fac:	8b 81       	ldd	r24, Y+3	; 0x03
    2fae:	28 2f       	mov	r18, r24
    2fb0:	30 e0       	ldi	r19, 0x00	; 0
    2fb2:	81 e0       	ldi	r24, 0x01	; 1
    2fb4:	90 e0       	ldi	r25, 0x00	; 0
    2fb6:	02 2e       	mov	r0, r18
    2fb8:	02 c0       	rjmp	.+4      	; 0x2fbe <MCAL_DIO_u8SetPinValue+0xec>
    2fba:	88 0f       	add	r24, r24
    2fbc:	99 1f       	adc	r25, r25
    2fbe:	0a 94       	dec	r0
    2fc0:	e2 f7       	brpl	.-8      	; 0x2fba <MCAL_DIO_u8SetPinValue+0xe8>
    2fc2:	84 2b       	or	r24, r20
    2fc4:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2fc6:	19 82       	std	Y+1, r1	; 0x01
    2fc8:	67 c0       	rjmp	.+206    	; 0x3098 <MCAL_DIO_u8SetPinValue+0x1c6>
			} else {
				//Do Nothing
			}
		} else if (Loc_u8PinValue == Pin_Low) {
    2fca:	8c 81       	ldd	r24, Y+4	; 0x04
    2fcc:	88 23       	and	r24, r24
    2fce:	09 f0       	breq	.+2      	; 0x2fd2 <MCAL_DIO_u8SetPinValue+0x100>
    2fd0:	63 c0       	rjmp	.+198    	; 0x3098 <MCAL_DIO_u8SetPinValue+0x1c6>
			if (Loc_u8PortID == PortA) {
    2fd2:	8a 81       	ldd	r24, Y+2	; 0x02
    2fd4:	88 23       	and	r24, r24
    2fd6:	b1 f4       	brne	.+44     	; 0x3004 <MCAL_DIO_u8SetPinValue+0x132>
				CLR_BIT(PORTA, Loc_u8PinID);
    2fd8:	ab e3       	ldi	r26, 0x3B	; 59
    2fda:	b0 e0       	ldi	r27, 0x00	; 0
    2fdc:	eb e3       	ldi	r30, 0x3B	; 59
    2fde:	f0 e0       	ldi	r31, 0x00	; 0
    2fe0:	80 81       	ld	r24, Z
    2fe2:	48 2f       	mov	r20, r24
    2fe4:	8b 81       	ldd	r24, Y+3	; 0x03
    2fe6:	28 2f       	mov	r18, r24
    2fe8:	30 e0       	ldi	r19, 0x00	; 0
    2fea:	81 e0       	ldi	r24, 0x01	; 1
    2fec:	90 e0       	ldi	r25, 0x00	; 0
    2fee:	02 2e       	mov	r0, r18
    2ff0:	02 c0       	rjmp	.+4      	; 0x2ff6 <MCAL_DIO_u8SetPinValue+0x124>
    2ff2:	88 0f       	add	r24, r24
    2ff4:	99 1f       	adc	r25, r25
    2ff6:	0a 94       	dec	r0
    2ff8:	e2 f7       	brpl	.-8      	; 0x2ff2 <MCAL_DIO_u8SetPinValue+0x120>
    2ffa:	80 95       	com	r24
    2ffc:	84 23       	and	r24, r20
    2ffe:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    3000:	19 82       	std	Y+1, r1	; 0x01
    3002:	4a c0       	rjmp	.+148    	; 0x3098 <MCAL_DIO_u8SetPinValue+0x1c6>
			} else if (Loc_u8PortID == PortB) {
    3004:	8a 81       	ldd	r24, Y+2	; 0x02
    3006:	81 30       	cpi	r24, 0x01	; 1
    3008:	b1 f4       	brne	.+44     	; 0x3036 <MCAL_DIO_u8SetPinValue+0x164>
				CLR_BIT(PORTB, Loc_u8PinID);
    300a:	a8 e3       	ldi	r26, 0x38	; 56
    300c:	b0 e0       	ldi	r27, 0x00	; 0
    300e:	e8 e3       	ldi	r30, 0x38	; 56
    3010:	f0 e0       	ldi	r31, 0x00	; 0
    3012:	80 81       	ld	r24, Z
    3014:	48 2f       	mov	r20, r24
    3016:	8b 81       	ldd	r24, Y+3	; 0x03
    3018:	28 2f       	mov	r18, r24
    301a:	30 e0       	ldi	r19, 0x00	; 0
    301c:	81 e0       	ldi	r24, 0x01	; 1
    301e:	90 e0       	ldi	r25, 0x00	; 0
    3020:	02 2e       	mov	r0, r18
    3022:	02 c0       	rjmp	.+4      	; 0x3028 <MCAL_DIO_u8SetPinValue+0x156>
    3024:	88 0f       	add	r24, r24
    3026:	99 1f       	adc	r25, r25
    3028:	0a 94       	dec	r0
    302a:	e2 f7       	brpl	.-8      	; 0x3024 <MCAL_DIO_u8SetPinValue+0x152>
    302c:	80 95       	com	r24
    302e:	84 23       	and	r24, r20
    3030:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    3032:	19 82       	std	Y+1, r1	; 0x01
    3034:	31 c0       	rjmp	.+98     	; 0x3098 <MCAL_DIO_u8SetPinValue+0x1c6>
			} else if (Loc_u8PortID == PortC) {
    3036:	8a 81       	ldd	r24, Y+2	; 0x02
    3038:	82 30       	cpi	r24, 0x02	; 2
    303a:	b1 f4       	brne	.+44     	; 0x3068 <MCAL_DIO_u8SetPinValue+0x196>
				CLR_BIT(PORTC, Loc_u8PinID);
    303c:	a5 e3       	ldi	r26, 0x35	; 53
    303e:	b0 e0       	ldi	r27, 0x00	; 0
    3040:	e5 e3       	ldi	r30, 0x35	; 53
    3042:	f0 e0       	ldi	r31, 0x00	; 0
    3044:	80 81       	ld	r24, Z
    3046:	48 2f       	mov	r20, r24
    3048:	8b 81       	ldd	r24, Y+3	; 0x03
    304a:	28 2f       	mov	r18, r24
    304c:	30 e0       	ldi	r19, 0x00	; 0
    304e:	81 e0       	ldi	r24, 0x01	; 1
    3050:	90 e0       	ldi	r25, 0x00	; 0
    3052:	02 2e       	mov	r0, r18
    3054:	02 c0       	rjmp	.+4      	; 0x305a <MCAL_DIO_u8SetPinValue+0x188>
    3056:	88 0f       	add	r24, r24
    3058:	99 1f       	adc	r25, r25
    305a:	0a 94       	dec	r0
    305c:	e2 f7       	brpl	.-8      	; 0x3056 <MCAL_DIO_u8SetPinValue+0x184>
    305e:	80 95       	com	r24
    3060:	84 23       	and	r24, r20
    3062:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    3064:	19 82       	std	Y+1, r1	; 0x01
    3066:	18 c0       	rjmp	.+48     	; 0x3098 <MCAL_DIO_u8SetPinValue+0x1c6>
			} else if (Loc_u8PortID == PortD) {
    3068:	8a 81       	ldd	r24, Y+2	; 0x02
    306a:	83 30       	cpi	r24, 0x03	; 3
    306c:	a9 f4       	brne	.+42     	; 0x3098 <MCAL_DIO_u8SetPinValue+0x1c6>
				CLR_BIT(PORTD, Loc_u8PinID);
    306e:	a2 e3       	ldi	r26, 0x32	; 50
    3070:	b0 e0       	ldi	r27, 0x00	; 0
    3072:	e2 e3       	ldi	r30, 0x32	; 50
    3074:	f0 e0       	ldi	r31, 0x00	; 0
    3076:	80 81       	ld	r24, Z
    3078:	48 2f       	mov	r20, r24
    307a:	8b 81       	ldd	r24, Y+3	; 0x03
    307c:	28 2f       	mov	r18, r24
    307e:	30 e0       	ldi	r19, 0x00	; 0
    3080:	81 e0       	ldi	r24, 0x01	; 1
    3082:	90 e0       	ldi	r25, 0x00	; 0
    3084:	02 2e       	mov	r0, r18
    3086:	02 c0       	rjmp	.+4      	; 0x308c <MCAL_DIO_u8SetPinValue+0x1ba>
    3088:	88 0f       	add	r24, r24
    308a:	99 1f       	adc	r25, r25
    308c:	0a 94       	dec	r0
    308e:	e2 f7       	brpl	.-8      	; 0x3088 <MCAL_DIO_u8SetPinValue+0x1b6>
    3090:	80 95       	com	r24
    3092:	84 23       	and	r24, r20
    3094:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    3096:	19 82       	std	Y+1, r1	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    3098:	89 81       	ldd	r24, Y+1	; 0x01

}
    309a:	0f 90       	pop	r0
    309c:	0f 90       	pop	r0
    309e:	0f 90       	pop	r0
    30a0:	0f 90       	pop	r0
    30a2:	cf 91       	pop	r28
    30a4:	df 91       	pop	r29
    30a6:	08 95       	ret

000030a8 <MCAL_DIO_u8SGetPortValue>:

STD_Type MCAL_DIO_u8SGetPortValue(u8 Loc_u8PortID, u8* Loc_u8PortValue) {
    30a8:	df 93       	push	r29
    30aa:	cf 93       	push	r28
    30ac:	00 d0       	rcall	.+0      	; 0x30ae <MCAL_DIO_u8SGetPortValue+0x6>
    30ae:	00 d0       	rcall	.+0      	; 0x30b0 <MCAL_DIO_u8SGetPortValue+0x8>
    30b0:	cd b7       	in	r28, 0x3d	; 61
    30b2:	de b7       	in	r29, 0x3e	; 62
    30b4:	8a 83       	std	Y+2, r24	; 0x02
    30b6:	7c 83       	std	Y+4, r23	; 0x04
    30b8:	6b 83       	std	Y+3, r22	; 0x03
	u8 Loc_u8Return_Value = E_NOT_OK;
    30ba:	81 e0       	ldi	r24, 0x01	; 1
    30bc:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD) {
    30be:	8a 81       	ldd	r24, Y+2	; 0x02
    30c0:	84 30       	cpi	r24, 0x04	; 4
    30c2:	58 f5       	brcc	.+86     	; 0x311a <MCAL_DIO_u8SGetPortValue+0x72>
		if (Loc_u8PortID == PortA) {
    30c4:	8a 81       	ldd	r24, Y+2	; 0x02
    30c6:	88 23       	and	r24, r24
    30c8:	41 f4       	brne	.+16     	; 0x30da <MCAL_DIO_u8SGetPortValue+0x32>
			*Loc_u8PortValue = PORTA;
    30ca:	eb e3       	ldi	r30, 0x3B	; 59
    30cc:	f0 e0       	ldi	r31, 0x00	; 0
    30ce:	80 81       	ld	r24, Z
    30d0:	eb 81       	ldd	r30, Y+3	; 0x03
    30d2:	fc 81       	ldd	r31, Y+4	; 0x04
    30d4:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    30d6:	19 82       	std	Y+1, r1	; 0x01
    30d8:	20 c0       	rjmp	.+64     	; 0x311a <MCAL_DIO_u8SGetPortValue+0x72>
		} else if (Loc_u8PortID == PortB) {
    30da:	8a 81       	ldd	r24, Y+2	; 0x02
    30dc:	81 30       	cpi	r24, 0x01	; 1
    30de:	41 f4       	brne	.+16     	; 0x30f0 <MCAL_DIO_u8SGetPortValue+0x48>
			*Loc_u8PortValue = PORTB;
    30e0:	e8 e3       	ldi	r30, 0x38	; 56
    30e2:	f0 e0       	ldi	r31, 0x00	; 0
    30e4:	80 81       	ld	r24, Z
    30e6:	eb 81       	ldd	r30, Y+3	; 0x03
    30e8:	fc 81       	ldd	r31, Y+4	; 0x04
    30ea:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    30ec:	19 82       	std	Y+1, r1	; 0x01
    30ee:	15 c0       	rjmp	.+42     	; 0x311a <MCAL_DIO_u8SGetPortValue+0x72>
		} else if (Loc_u8PortID == PortC) {
    30f0:	8a 81       	ldd	r24, Y+2	; 0x02
    30f2:	82 30       	cpi	r24, 0x02	; 2
    30f4:	41 f4       	brne	.+16     	; 0x3106 <MCAL_DIO_u8SGetPortValue+0x5e>
			*Loc_u8PortValue = PORTC;
    30f6:	e5 e3       	ldi	r30, 0x35	; 53
    30f8:	f0 e0       	ldi	r31, 0x00	; 0
    30fa:	80 81       	ld	r24, Z
    30fc:	eb 81       	ldd	r30, Y+3	; 0x03
    30fe:	fc 81       	ldd	r31, Y+4	; 0x04
    3100:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    3102:	19 82       	std	Y+1, r1	; 0x01
    3104:	0a c0       	rjmp	.+20     	; 0x311a <MCAL_DIO_u8SGetPortValue+0x72>
		} else if (Loc_u8PortID == PortD) {
    3106:	8a 81       	ldd	r24, Y+2	; 0x02
    3108:	83 30       	cpi	r24, 0x03	; 3
    310a:	39 f4       	brne	.+14     	; 0x311a <MCAL_DIO_u8SGetPortValue+0x72>
			*Loc_u8PortValue = PORTD;
    310c:	e2 e3       	ldi	r30, 0x32	; 50
    310e:	f0 e0       	ldi	r31, 0x00	; 0
    3110:	80 81       	ld	r24, Z
    3112:	eb 81       	ldd	r30, Y+3	; 0x03
    3114:	fc 81       	ldd	r31, Y+4	; 0x04
    3116:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    3118:	19 82       	std	Y+1, r1	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    311a:	89 81       	ldd	r24, Y+1	; 0x01
}
    311c:	0f 90       	pop	r0
    311e:	0f 90       	pop	r0
    3120:	0f 90       	pop	r0
    3122:	0f 90       	pop	r0
    3124:	cf 91       	pop	r28
    3126:	df 91       	pop	r29
    3128:	08 95       	ret

0000312a <MCAL_DIO_u8GetPinValue>:

STD_Type MCAL_DIO_u8GetPinValue(u8 Loc_u8PortID, u8 Loc_u8PinID,
		u8* Loc_u8PinValue) {
    312a:	df 93       	push	r29
    312c:	cf 93       	push	r28
    312e:	00 d0       	rcall	.+0      	; 0x3130 <MCAL_DIO_u8GetPinValue+0x6>
    3130:	00 d0       	rcall	.+0      	; 0x3132 <MCAL_DIO_u8GetPinValue+0x8>
    3132:	0f 92       	push	r0
    3134:	cd b7       	in	r28, 0x3d	; 61
    3136:	de b7       	in	r29, 0x3e	; 62
    3138:	8a 83       	std	Y+2, r24	; 0x02
    313a:	6b 83       	std	Y+3, r22	; 0x03
    313c:	5d 83       	std	Y+5, r21	; 0x05
    313e:	4c 83       	std	Y+4, r20	; 0x04
	u8 Loc_u8Return_Value = E_NOT_OK;
    3140:	81 e0       	ldi	r24, 0x01	; 1
    3142:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD && Loc_u8PinID <= Num_Of_Pins) {
    3144:	8a 81       	ldd	r24, Y+2	; 0x02
    3146:	84 30       	cpi	r24, 0x04	; 4
    3148:	08 f0       	brcs	.+2      	; 0x314c <MCAL_DIO_u8GetPinValue+0x22>
    314a:	63 c0       	rjmp	.+198    	; 0x3212 <MCAL_DIO_u8GetPinValue+0xe8>
    314c:	8b 81       	ldd	r24, Y+3	; 0x03
    314e:	88 30       	cpi	r24, 0x08	; 8
    3150:	08 f0       	brcs	.+2      	; 0x3154 <MCAL_DIO_u8GetPinValue+0x2a>
    3152:	5f c0       	rjmp	.+190    	; 0x3212 <MCAL_DIO_u8GetPinValue+0xe8>
		if (Loc_u8PortID == PortA) {
    3154:	8a 81       	ldd	r24, Y+2	; 0x02
    3156:	88 23       	and	r24, r24
    3158:	a9 f4       	brne	.+42     	; 0x3184 <MCAL_DIO_u8GetPinValue+0x5a>
			*Loc_u8PinValue = GET_BIT(PINA, Loc_u8PinID);
    315a:	e9 e3       	ldi	r30, 0x39	; 57
    315c:	f0 e0       	ldi	r31, 0x00	; 0
    315e:	80 81       	ld	r24, Z
    3160:	28 2f       	mov	r18, r24
    3162:	30 e0       	ldi	r19, 0x00	; 0
    3164:	8b 81       	ldd	r24, Y+3	; 0x03
    3166:	88 2f       	mov	r24, r24
    3168:	90 e0       	ldi	r25, 0x00	; 0
    316a:	a9 01       	movw	r20, r18
    316c:	02 c0       	rjmp	.+4      	; 0x3172 <MCAL_DIO_u8GetPinValue+0x48>
    316e:	55 95       	asr	r21
    3170:	47 95       	ror	r20
    3172:	8a 95       	dec	r24
    3174:	e2 f7       	brpl	.-8      	; 0x316e <MCAL_DIO_u8GetPinValue+0x44>
    3176:	ca 01       	movw	r24, r20
    3178:	81 70       	andi	r24, 0x01	; 1
    317a:	ec 81       	ldd	r30, Y+4	; 0x04
    317c:	fd 81       	ldd	r31, Y+5	; 0x05
    317e:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    3180:	19 82       	std	Y+1, r1	; 0x01
    3182:	47 c0       	rjmp	.+142    	; 0x3212 <MCAL_DIO_u8GetPinValue+0xe8>
		} else if (Loc_u8PortID == PortB) {
    3184:	8a 81       	ldd	r24, Y+2	; 0x02
    3186:	81 30       	cpi	r24, 0x01	; 1
    3188:	a9 f4       	brne	.+42     	; 0x31b4 <MCAL_DIO_u8GetPinValue+0x8a>
			*Loc_u8PinValue = GET_BIT(PINB, Loc_u8PinID);
    318a:	e6 e3       	ldi	r30, 0x36	; 54
    318c:	f0 e0       	ldi	r31, 0x00	; 0
    318e:	80 81       	ld	r24, Z
    3190:	28 2f       	mov	r18, r24
    3192:	30 e0       	ldi	r19, 0x00	; 0
    3194:	8b 81       	ldd	r24, Y+3	; 0x03
    3196:	88 2f       	mov	r24, r24
    3198:	90 e0       	ldi	r25, 0x00	; 0
    319a:	a9 01       	movw	r20, r18
    319c:	02 c0       	rjmp	.+4      	; 0x31a2 <MCAL_DIO_u8GetPinValue+0x78>
    319e:	55 95       	asr	r21
    31a0:	47 95       	ror	r20
    31a2:	8a 95       	dec	r24
    31a4:	e2 f7       	brpl	.-8      	; 0x319e <MCAL_DIO_u8GetPinValue+0x74>
    31a6:	ca 01       	movw	r24, r20
    31a8:	81 70       	andi	r24, 0x01	; 1
    31aa:	ec 81       	ldd	r30, Y+4	; 0x04
    31ac:	fd 81       	ldd	r31, Y+5	; 0x05
    31ae:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    31b0:	19 82       	std	Y+1, r1	; 0x01
    31b2:	2f c0       	rjmp	.+94     	; 0x3212 <MCAL_DIO_u8GetPinValue+0xe8>
		} else if (Loc_u8PortID == PortC) {
    31b4:	8a 81       	ldd	r24, Y+2	; 0x02
    31b6:	82 30       	cpi	r24, 0x02	; 2
    31b8:	a9 f4       	brne	.+42     	; 0x31e4 <MCAL_DIO_u8GetPinValue+0xba>
			*Loc_u8PinValue = GET_BIT(PINC, Loc_u8PinID);
    31ba:	e3 e3       	ldi	r30, 0x33	; 51
    31bc:	f0 e0       	ldi	r31, 0x00	; 0
    31be:	80 81       	ld	r24, Z
    31c0:	28 2f       	mov	r18, r24
    31c2:	30 e0       	ldi	r19, 0x00	; 0
    31c4:	8b 81       	ldd	r24, Y+3	; 0x03
    31c6:	88 2f       	mov	r24, r24
    31c8:	90 e0       	ldi	r25, 0x00	; 0
    31ca:	a9 01       	movw	r20, r18
    31cc:	02 c0       	rjmp	.+4      	; 0x31d2 <MCAL_DIO_u8GetPinValue+0xa8>
    31ce:	55 95       	asr	r21
    31d0:	47 95       	ror	r20
    31d2:	8a 95       	dec	r24
    31d4:	e2 f7       	brpl	.-8      	; 0x31ce <MCAL_DIO_u8GetPinValue+0xa4>
    31d6:	ca 01       	movw	r24, r20
    31d8:	81 70       	andi	r24, 0x01	; 1
    31da:	ec 81       	ldd	r30, Y+4	; 0x04
    31dc:	fd 81       	ldd	r31, Y+5	; 0x05
    31de:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    31e0:	19 82       	std	Y+1, r1	; 0x01
    31e2:	17 c0       	rjmp	.+46     	; 0x3212 <MCAL_DIO_u8GetPinValue+0xe8>
		} else if (Loc_u8PortID == PortD) {
    31e4:	8a 81       	ldd	r24, Y+2	; 0x02
    31e6:	83 30       	cpi	r24, 0x03	; 3
    31e8:	a1 f4       	brne	.+40     	; 0x3212 <MCAL_DIO_u8GetPinValue+0xe8>
			*Loc_u8PinValue = GET_BIT(PIND, Loc_u8PinID);
    31ea:	e0 e3       	ldi	r30, 0x30	; 48
    31ec:	f0 e0       	ldi	r31, 0x00	; 0
    31ee:	80 81       	ld	r24, Z
    31f0:	28 2f       	mov	r18, r24
    31f2:	30 e0       	ldi	r19, 0x00	; 0
    31f4:	8b 81       	ldd	r24, Y+3	; 0x03
    31f6:	88 2f       	mov	r24, r24
    31f8:	90 e0       	ldi	r25, 0x00	; 0
    31fa:	a9 01       	movw	r20, r18
    31fc:	02 c0       	rjmp	.+4      	; 0x3202 <MCAL_DIO_u8GetPinValue+0xd8>
    31fe:	55 95       	asr	r21
    3200:	47 95       	ror	r20
    3202:	8a 95       	dec	r24
    3204:	e2 f7       	brpl	.-8      	; 0x31fe <MCAL_DIO_u8GetPinValue+0xd4>
    3206:	ca 01       	movw	r24, r20
    3208:	81 70       	andi	r24, 0x01	; 1
    320a:	ec 81       	ldd	r30, Y+4	; 0x04
    320c:	fd 81       	ldd	r31, Y+5	; 0x05
    320e:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    3210:	19 82       	std	Y+1, r1	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    3212:	89 81       	ldd	r24, Y+1	; 0x01
}
    3214:	0f 90       	pop	r0
    3216:	0f 90       	pop	r0
    3218:	0f 90       	pop	r0
    321a:	0f 90       	pop	r0
    321c:	0f 90       	pop	r0
    321e:	cf 91       	pop	r28
    3220:	df 91       	pop	r29
    3222:	08 95       	ret

00003224 <MCAL_DIO_u8TogglePortValue>:

STD_Type MCAL_DIO_u8TogglePortValue(u8 Loc_u8PortID) {
    3224:	df 93       	push	r29
    3226:	cf 93       	push	r28
    3228:	00 d0       	rcall	.+0      	; 0x322a <MCAL_DIO_u8TogglePortValue+0x6>
    322a:	cd b7       	in	r28, 0x3d	; 61
    322c:	de b7       	in	r29, 0x3e	; 62
    322e:	8a 83       	std	Y+2, r24	; 0x02
	u8 Loc_u8Return_Value = E_NOT_OK;
    3230:	81 e0       	ldi	r24, 0x01	; 1
    3232:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD) {
    3234:	8a 81       	ldd	r24, Y+2	; 0x02
    3236:	84 30       	cpi	r24, 0x04	; 4
    3238:	78 f5       	brcc	.+94     	; 0x3298 <MCAL_DIO_u8TogglePortValue+0x74>
		if (Loc_u8PortID == PortA) {
    323a:	8a 81       	ldd	r24, Y+2	; 0x02
    323c:	88 23       	and	r24, r24
    323e:	49 f4       	brne	.+18     	; 0x3252 <MCAL_DIO_u8TogglePortValue+0x2e>
			PORTA = ~PORTA;
    3240:	ab e3       	ldi	r26, 0x3B	; 59
    3242:	b0 e0       	ldi	r27, 0x00	; 0
    3244:	eb e3       	ldi	r30, 0x3B	; 59
    3246:	f0 e0       	ldi	r31, 0x00	; 0
    3248:	80 81       	ld	r24, Z
    324a:	80 95       	com	r24
    324c:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    324e:	19 82       	std	Y+1, r1	; 0x01
    3250:	23 c0       	rjmp	.+70     	; 0x3298 <MCAL_DIO_u8TogglePortValue+0x74>
		} else if (Loc_u8PortID == PortB) {
    3252:	8a 81       	ldd	r24, Y+2	; 0x02
    3254:	81 30       	cpi	r24, 0x01	; 1
    3256:	49 f4       	brne	.+18     	; 0x326a <MCAL_DIO_u8TogglePortValue+0x46>
			PORTB = ~PORTB;
    3258:	a8 e3       	ldi	r26, 0x38	; 56
    325a:	b0 e0       	ldi	r27, 0x00	; 0
    325c:	e8 e3       	ldi	r30, 0x38	; 56
    325e:	f0 e0       	ldi	r31, 0x00	; 0
    3260:	80 81       	ld	r24, Z
    3262:	80 95       	com	r24
    3264:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    3266:	19 82       	std	Y+1, r1	; 0x01
    3268:	17 c0       	rjmp	.+46     	; 0x3298 <MCAL_DIO_u8TogglePortValue+0x74>
		} else if (Loc_u8PortID == PortC) {
    326a:	8a 81       	ldd	r24, Y+2	; 0x02
    326c:	82 30       	cpi	r24, 0x02	; 2
    326e:	49 f4       	brne	.+18     	; 0x3282 <MCAL_DIO_u8TogglePortValue+0x5e>
			PORTC = ~PORTC;
    3270:	a5 e3       	ldi	r26, 0x35	; 53
    3272:	b0 e0       	ldi	r27, 0x00	; 0
    3274:	e5 e3       	ldi	r30, 0x35	; 53
    3276:	f0 e0       	ldi	r31, 0x00	; 0
    3278:	80 81       	ld	r24, Z
    327a:	80 95       	com	r24
    327c:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    327e:	19 82       	std	Y+1, r1	; 0x01
    3280:	0b c0       	rjmp	.+22     	; 0x3298 <MCAL_DIO_u8TogglePortValue+0x74>
		} else if (Loc_u8PortID == PortD) {
    3282:	8a 81       	ldd	r24, Y+2	; 0x02
    3284:	83 30       	cpi	r24, 0x03	; 3
    3286:	41 f4       	brne	.+16     	; 0x3298 <MCAL_DIO_u8TogglePortValue+0x74>
			PORTD = ~PORTD;
    3288:	a2 e3       	ldi	r26, 0x32	; 50
    328a:	b0 e0       	ldi	r27, 0x00	; 0
    328c:	e2 e3       	ldi	r30, 0x32	; 50
    328e:	f0 e0       	ldi	r31, 0x00	; 0
    3290:	80 81       	ld	r24, Z
    3292:	80 95       	com	r24
    3294:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    3296:	19 82       	std	Y+1, r1	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    3298:	89 81       	ldd	r24, Y+1	; 0x01
}
    329a:	0f 90       	pop	r0
    329c:	0f 90       	pop	r0
    329e:	cf 91       	pop	r28
    32a0:	df 91       	pop	r29
    32a2:	08 95       	ret

000032a4 <MCAL_DIO_u8TogglePinValue>:

STD_Type MCAL_DIO_u8TogglePinValue(u8 Loc_u8PortID, u8 Loc_u8PinID) {
    32a4:	df 93       	push	r29
    32a6:	cf 93       	push	r28
    32a8:	00 d0       	rcall	.+0      	; 0x32aa <MCAL_DIO_u8TogglePinValue+0x6>
    32aa:	0f 92       	push	r0
    32ac:	cd b7       	in	r28, 0x3d	; 61
    32ae:	de b7       	in	r29, 0x3e	; 62
    32b0:	8a 83       	std	Y+2, r24	; 0x02
    32b2:	6b 83       	std	Y+3, r22	; 0x03
	u8 Loc_u8Return_Value = E_NOT_OK;
    32b4:	81 e0       	ldi	r24, 0x01	; 1
    32b6:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD && Loc_u8PinID <= Num_Of_Pins) {
    32b8:	8a 81       	ldd	r24, Y+2	; 0x02
    32ba:	84 30       	cpi	r24, 0x04	; 4
    32bc:	08 f0       	brcs	.+2      	; 0x32c0 <MCAL_DIO_u8TogglePinValue+0x1c>
    32be:	63 c0       	rjmp	.+198    	; 0x3386 <MCAL_DIO_u8TogglePinValue+0xe2>
    32c0:	8b 81       	ldd	r24, Y+3	; 0x03
    32c2:	88 30       	cpi	r24, 0x08	; 8
    32c4:	08 f0       	brcs	.+2      	; 0x32c8 <MCAL_DIO_u8TogglePinValue+0x24>
    32c6:	5f c0       	rjmp	.+190    	; 0x3386 <MCAL_DIO_u8TogglePinValue+0xe2>
		if (Loc_u8PortID == PortA) {
    32c8:	8a 81       	ldd	r24, Y+2	; 0x02
    32ca:	88 23       	and	r24, r24
    32cc:	a9 f4       	brne	.+42     	; 0x32f8 <MCAL_DIO_u8TogglePinValue+0x54>
			TOGGLE_BIT(PORTA, Loc_u8PinID);
    32ce:	ab e3       	ldi	r26, 0x3B	; 59
    32d0:	b0 e0       	ldi	r27, 0x00	; 0
    32d2:	eb e3       	ldi	r30, 0x3B	; 59
    32d4:	f0 e0       	ldi	r31, 0x00	; 0
    32d6:	80 81       	ld	r24, Z
    32d8:	48 2f       	mov	r20, r24
    32da:	8b 81       	ldd	r24, Y+3	; 0x03
    32dc:	28 2f       	mov	r18, r24
    32de:	30 e0       	ldi	r19, 0x00	; 0
    32e0:	81 e0       	ldi	r24, 0x01	; 1
    32e2:	90 e0       	ldi	r25, 0x00	; 0
    32e4:	02 2e       	mov	r0, r18
    32e6:	02 c0       	rjmp	.+4      	; 0x32ec <MCAL_DIO_u8TogglePinValue+0x48>
    32e8:	88 0f       	add	r24, r24
    32ea:	99 1f       	adc	r25, r25
    32ec:	0a 94       	dec	r0
    32ee:	e2 f7       	brpl	.-8      	; 0x32e8 <MCAL_DIO_u8TogglePinValue+0x44>
    32f0:	84 27       	eor	r24, r20
    32f2:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    32f4:	19 82       	std	Y+1, r1	; 0x01
    32f6:	47 c0       	rjmp	.+142    	; 0x3386 <MCAL_DIO_u8TogglePinValue+0xe2>
		} else if (Loc_u8PortID == PortB) {
    32f8:	8a 81       	ldd	r24, Y+2	; 0x02
    32fa:	81 30       	cpi	r24, 0x01	; 1
    32fc:	a9 f4       	brne	.+42     	; 0x3328 <MCAL_DIO_u8TogglePinValue+0x84>
			TOGGLE_BIT(PORTB, Loc_u8PinID);
    32fe:	a8 e3       	ldi	r26, 0x38	; 56
    3300:	b0 e0       	ldi	r27, 0x00	; 0
    3302:	e8 e3       	ldi	r30, 0x38	; 56
    3304:	f0 e0       	ldi	r31, 0x00	; 0
    3306:	80 81       	ld	r24, Z
    3308:	48 2f       	mov	r20, r24
    330a:	8b 81       	ldd	r24, Y+3	; 0x03
    330c:	28 2f       	mov	r18, r24
    330e:	30 e0       	ldi	r19, 0x00	; 0
    3310:	81 e0       	ldi	r24, 0x01	; 1
    3312:	90 e0       	ldi	r25, 0x00	; 0
    3314:	02 2e       	mov	r0, r18
    3316:	02 c0       	rjmp	.+4      	; 0x331c <MCAL_DIO_u8TogglePinValue+0x78>
    3318:	88 0f       	add	r24, r24
    331a:	99 1f       	adc	r25, r25
    331c:	0a 94       	dec	r0
    331e:	e2 f7       	brpl	.-8      	; 0x3318 <MCAL_DIO_u8TogglePinValue+0x74>
    3320:	84 27       	eor	r24, r20
    3322:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    3324:	19 82       	std	Y+1, r1	; 0x01
    3326:	2f c0       	rjmp	.+94     	; 0x3386 <MCAL_DIO_u8TogglePinValue+0xe2>
		} else if (Loc_u8PortID == PortC) {
    3328:	8a 81       	ldd	r24, Y+2	; 0x02
    332a:	82 30       	cpi	r24, 0x02	; 2
    332c:	a9 f4       	brne	.+42     	; 0x3358 <MCAL_DIO_u8TogglePinValue+0xb4>
			TOGGLE_BIT(PORTC, Loc_u8PinID);
    332e:	a5 e3       	ldi	r26, 0x35	; 53
    3330:	b0 e0       	ldi	r27, 0x00	; 0
    3332:	e5 e3       	ldi	r30, 0x35	; 53
    3334:	f0 e0       	ldi	r31, 0x00	; 0
    3336:	80 81       	ld	r24, Z
    3338:	48 2f       	mov	r20, r24
    333a:	8b 81       	ldd	r24, Y+3	; 0x03
    333c:	28 2f       	mov	r18, r24
    333e:	30 e0       	ldi	r19, 0x00	; 0
    3340:	81 e0       	ldi	r24, 0x01	; 1
    3342:	90 e0       	ldi	r25, 0x00	; 0
    3344:	02 2e       	mov	r0, r18
    3346:	02 c0       	rjmp	.+4      	; 0x334c <MCAL_DIO_u8TogglePinValue+0xa8>
    3348:	88 0f       	add	r24, r24
    334a:	99 1f       	adc	r25, r25
    334c:	0a 94       	dec	r0
    334e:	e2 f7       	brpl	.-8      	; 0x3348 <MCAL_DIO_u8TogglePinValue+0xa4>
    3350:	84 27       	eor	r24, r20
    3352:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    3354:	19 82       	std	Y+1, r1	; 0x01
    3356:	17 c0       	rjmp	.+46     	; 0x3386 <MCAL_DIO_u8TogglePinValue+0xe2>
		} else if (Loc_u8PortID == PortD) {
    3358:	8a 81       	ldd	r24, Y+2	; 0x02
    335a:	83 30       	cpi	r24, 0x03	; 3
    335c:	a1 f4       	brne	.+40     	; 0x3386 <MCAL_DIO_u8TogglePinValue+0xe2>
			TOGGLE_BIT(PORTD, Loc_u8PinID);
    335e:	a2 e3       	ldi	r26, 0x32	; 50
    3360:	b0 e0       	ldi	r27, 0x00	; 0
    3362:	e2 e3       	ldi	r30, 0x32	; 50
    3364:	f0 e0       	ldi	r31, 0x00	; 0
    3366:	80 81       	ld	r24, Z
    3368:	48 2f       	mov	r20, r24
    336a:	8b 81       	ldd	r24, Y+3	; 0x03
    336c:	28 2f       	mov	r18, r24
    336e:	30 e0       	ldi	r19, 0x00	; 0
    3370:	81 e0       	ldi	r24, 0x01	; 1
    3372:	90 e0       	ldi	r25, 0x00	; 0
    3374:	02 2e       	mov	r0, r18
    3376:	02 c0       	rjmp	.+4      	; 0x337c <MCAL_DIO_u8TogglePinValue+0xd8>
    3378:	88 0f       	add	r24, r24
    337a:	99 1f       	adc	r25, r25
    337c:	0a 94       	dec	r0
    337e:	e2 f7       	brpl	.-8      	; 0x3378 <MCAL_DIO_u8TogglePinValue+0xd4>
    3380:	84 27       	eor	r24, r20
    3382:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    3384:	19 82       	std	Y+1, r1	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    3386:	89 81       	ldd	r24, Y+1	; 0x01
}
    3388:	0f 90       	pop	r0
    338a:	0f 90       	pop	r0
    338c:	0f 90       	pop	r0
    338e:	cf 91       	pop	r28
    3390:	df 91       	pop	r29
    3392:	08 95       	ret

00003394 <HAL_Ultrasonic_Sensor_voidInit>:
volatile f32 Glob_f32Distance = NUM0;
volatile u16 Glob_u16StartTime = NUM0, Glob_u16EndTime = NUM0, Glob_u16TimeDiff = NUM0;
volatile u16 Glob_u16OvfCounterStart, Glob_16OvfCounterEnd;
extern volatile u16 Glob_u16OvfCounter;

void HAL_Ultrasonic_Sensor_voidInit(void) {
    3394:	df 93       	push	r29
    3396:	cf 93       	push	r28
    3398:	cd b7       	in	r28, 0x3d	; 61
    339a:	de b7       	in	r29, 0x3e	; 62
	MCAL_DIO_u8SetPinDirection(ECHO_PORT, ECHO_PIN, Pin_Low);      //
    339c:	83 e0       	ldi	r24, 0x03	; 3
    339e:	62 e0       	ldi	r22, 0x02	; 2
    33a0:	40 e0       	ldi	r20, 0x00	; 0
    33a2:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(TRIG_PORT, TRIG_PIN, Pin_High);  //  trigger
    33a6:	83 e0       	ldi	r24, 0x03	; 3
    33a8:	66 e0       	ldi	r22, 0x06	; 6
    33aa:	41 e0       	ldi	r20, 0x01	; 1
    33ac:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <MCAL_DIO_u8SetPinDirection>
	MCAL_Interrupt_EXIT_CallBack_0(HAL_Ultrasonic_Sensor_voidInterrupt); // external interrupt call back
    33b0:	82 e6       	ldi	r24, 0x62	; 98
    33b2:	9b e1       	ldi	r25, 0x1B	; 27
    33b4:	0e 94 56 14 	call	0x28ac	; 0x28ac <MCAL_Interrupt_EXIT_CallBack_0>
	SET_BIT(SREG,Pin7);
    33b8:	af e5       	ldi	r26, 0x5F	; 95
    33ba:	b0 e0       	ldi	r27, 0x00	; 0
    33bc:	ef e5       	ldi	r30, 0x5F	; 95
    33be:	f0 e0       	ldi	r31, 0x00	; 0
    33c0:	80 81       	ld	r24, Z
    33c2:	80 68       	ori	r24, 0x80	; 128
    33c4:	8c 93       	st	X, r24
	MCAL_Timer0_Init(Normal_Mode,Prescaller_64,'\0');
    33c6:	80 e0       	ldi	r24, 0x00	; 0
    33c8:	63 e0       	ldi	r22, 0x03	; 3
    33ca:	40 e0       	ldi	r20, 0x00	; 0
    33cc:	0e 94 96 0f 	call	0x1f2c	; 0x1f2c <MCAL_Timer0_Init>
	MCAL_Timer0_SetPreloadValue(113);
    33d0:	81 e7       	ldi	r24, 0x71	; 113
    33d2:	0e 94 5d 11 	call	0x22ba	; 0x22ba <MCAL_Timer0_SetPreloadValue>
}
    33d6:	cf 91       	pop	r28
    33d8:	df 91       	pop	r29
    33da:	08 95       	ret

000033dc <HAL_Ultrasonic_Sensor_voidTrigger>:

void HAL_Ultrasonic_Sensor_voidTrigger(void) {
    33dc:	df 93       	push	r29
    33de:	cf 93       	push	r28
    33e0:	cd b7       	in	r28, 0x3d	; 61
    33e2:	de b7       	in	r29, 0x3e	; 62
    33e4:	68 97       	sbiw	r28, 0x18	; 24
    33e6:	0f b6       	in	r0, 0x3f	; 63
    33e8:	f8 94       	cli
    33ea:	de bf       	out	0x3e, r29	; 62
    33ec:	0f be       	out	0x3f, r0	; 63
    33ee:	cd bf       	out	0x3d, r28	; 61
	MCAL_DIO_u8SetPinValue(TRIG_PORT, TRIG_PIN, Pin_High);    // high
    33f0:	83 e0       	ldi	r24, 0x03	; 3
    33f2:	66 e0       	ldi	r22, 0x06	; 6
    33f4:	41 e0       	ldi	r20, 0x01	; 1
    33f6:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
    33fa:	80 e0       	ldi	r24, 0x00	; 0
    33fc:	90 e0       	ldi	r25, 0x00	; 0
    33fe:	a0 e2       	ldi	r26, 0x20	; 32
    3400:	b1 e4       	ldi	r27, 0x41	; 65
    3402:	8d 8b       	std	Y+21, r24	; 0x15
    3404:	9e 8b       	std	Y+22, r25	; 0x16
    3406:	af 8b       	std	Y+23, r26	; 0x17
    3408:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    340a:	6d 89       	ldd	r22, Y+21	; 0x15
    340c:	7e 89       	ldd	r23, Y+22	; 0x16
    340e:	8f 89       	ldd	r24, Y+23	; 0x17
    3410:	98 8d       	ldd	r25, Y+24	; 0x18
    3412:	2b ea       	ldi	r18, 0xAB	; 171
    3414:	3a ea       	ldi	r19, 0xAA	; 170
    3416:	4a ea       	ldi	r20, 0xAA	; 170
    3418:	50 e4       	ldi	r21, 0x40	; 64
    341a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    341e:	dc 01       	movw	r26, r24
    3420:	cb 01       	movw	r24, r22
    3422:	89 8b       	std	Y+17, r24	; 0x11
    3424:	9a 8b       	std	Y+18, r25	; 0x12
    3426:	ab 8b       	std	Y+19, r26	; 0x13
    3428:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    342a:	69 89       	ldd	r22, Y+17	; 0x11
    342c:	7a 89       	ldd	r23, Y+18	; 0x12
    342e:	8b 89       	ldd	r24, Y+19	; 0x13
    3430:	9c 89       	ldd	r25, Y+20	; 0x14
    3432:	20 e0       	ldi	r18, 0x00	; 0
    3434:	30 e0       	ldi	r19, 0x00	; 0
    3436:	40 e8       	ldi	r20, 0x80	; 128
    3438:	5f e3       	ldi	r21, 0x3F	; 63
    343a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    343e:	88 23       	and	r24, r24
    3440:	1c f4       	brge	.+6      	; 0x3448 <HAL_Ultrasonic_Sensor_voidTrigger+0x6c>
		__ticks = 1;
    3442:	81 e0       	ldi	r24, 0x01	; 1
    3444:	88 8b       	std	Y+16, r24	; 0x10
    3446:	91 c0       	rjmp	.+290    	; 0x356a <HAL_Ultrasonic_Sensor_voidTrigger+0x18e>
	else if (__tmp > 255)
    3448:	69 89       	ldd	r22, Y+17	; 0x11
    344a:	7a 89       	ldd	r23, Y+18	; 0x12
    344c:	8b 89       	ldd	r24, Y+19	; 0x13
    344e:	9c 89       	ldd	r25, Y+20	; 0x14
    3450:	20 e0       	ldi	r18, 0x00	; 0
    3452:	30 e0       	ldi	r19, 0x00	; 0
    3454:	4f e7       	ldi	r20, 0x7F	; 127
    3456:	53 e4       	ldi	r21, 0x43	; 67
    3458:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    345c:	18 16       	cp	r1, r24
    345e:	0c f0       	brlt	.+2      	; 0x3462 <HAL_Ultrasonic_Sensor_voidTrigger+0x86>
    3460:	7b c0       	rjmp	.+246    	; 0x3558 <HAL_Ultrasonic_Sensor_voidTrigger+0x17c>
	{
		_delay_ms(__us / 1000.0);
    3462:	6d 89       	ldd	r22, Y+21	; 0x15
    3464:	7e 89       	ldd	r23, Y+22	; 0x16
    3466:	8f 89       	ldd	r24, Y+23	; 0x17
    3468:	98 8d       	ldd	r25, Y+24	; 0x18
    346a:	20 e0       	ldi	r18, 0x00	; 0
    346c:	30 e0       	ldi	r19, 0x00	; 0
    346e:	4a e7       	ldi	r20, 0x7A	; 122
    3470:	54 e4       	ldi	r21, 0x44	; 68
    3472:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    3476:	dc 01       	movw	r26, r24
    3478:	cb 01       	movw	r24, r22
    347a:	8c 87       	std	Y+12, r24	; 0x0c
    347c:	9d 87       	std	Y+13, r25	; 0x0d
    347e:	ae 87       	std	Y+14, r26	; 0x0e
    3480:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3482:	6c 85       	ldd	r22, Y+12	; 0x0c
    3484:	7d 85       	ldd	r23, Y+13	; 0x0d
    3486:	8e 85       	ldd	r24, Y+14	; 0x0e
    3488:	9f 85       	ldd	r25, Y+15	; 0x0f
    348a:	20 e0       	ldi	r18, 0x00	; 0
    348c:	30 e0       	ldi	r19, 0x00	; 0
    348e:	4a e7       	ldi	r20, 0x7A	; 122
    3490:	55 e4       	ldi	r21, 0x45	; 69
    3492:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3496:	dc 01       	movw	r26, r24
    3498:	cb 01       	movw	r24, r22
    349a:	88 87       	std	Y+8, r24	; 0x08
    349c:	99 87       	std	Y+9, r25	; 0x09
    349e:	aa 87       	std	Y+10, r26	; 0x0a
    34a0:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    34a2:	68 85       	ldd	r22, Y+8	; 0x08
    34a4:	79 85       	ldd	r23, Y+9	; 0x09
    34a6:	8a 85       	ldd	r24, Y+10	; 0x0a
    34a8:	9b 85       	ldd	r25, Y+11	; 0x0b
    34aa:	20 e0       	ldi	r18, 0x00	; 0
    34ac:	30 e0       	ldi	r19, 0x00	; 0
    34ae:	40 e8       	ldi	r20, 0x80	; 128
    34b0:	5f e3       	ldi	r21, 0x3F	; 63
    34b2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    34b6:	88 23       	and	r24, r24
    34b8:	2c f4       	brge	.+10     	; 0x34c4 <HAL_Ultrasonic_Sensor_voidTrigger+0xe8>
		__ticks = 1;
    34ba:	81 e0       	ldi	r24, 0x01	; 1
    34bc:	90 e0       	ldi	r25, 0x00	; 0
    34be:	9f 83       	std	Y+7, r25	; 0x07
    34c0:	8e 83       	std	Y+6, r24	; 0x06
    34c2:	3f c0       	rjmp	.+126    	; 0x3542 <HAL_Ultrasonic_Sensor_voidTrigger+0x166>
	else if (__tmp > 65535)
    34c4:	68 85       	ldd	r22, Y+8	; 0x08
    34c6:	79 85       	ldd	r23, Y+9	; 0x09
    34c8:	8a 85       	ldd	r24, Y+10	; 0x0a
    34ca:	9b 85       	ldd	r25, Y+11	; 0x0b
    34cc:	20 e0       	ldi	r18, 0x00	; 0
    34ce:	3f ef       	ldi	r19, 0xFF	; 255
    34d0:	4f e7       	ldi	r20, 0x7F	; 127
    34d2:	57 e4       	ldi	r21, 0x47	; 71
    34d4:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    34d8:	18 16       	cp	r1, r24
    34da:	4c f5       	brge	.+82     	; 0x352e <HAL_Ultrasonic_Sensor_voidTrigger+0x152>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    34dc:	6c 85       	ldd	r22, Y+12	; 0x0c
    34de:	7d 85       	ldd	r23, Y+13	; 0x0d
    34e0:	8e 85       	ldd	r24, Y+14	; 0x0e
    34e2:	9f 85       	ldd	r25, Y+15	; 0x0f
    34e4:	20 e0       	ldi	r18, 0x00	; 0
    34e6:	30 e0       	ldi	r19, 0x00	; 0
    34e8:	40 e2       	ldi	r20, 0x20	; 32
    34ea:	51 e4       	ldi	r21, 0x41	; 65
    34ec:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    34f0:	dc 01       	movw	r26, r24
    34f2:	cb 01       	movw	r24, r22
    34f4:	bc 01       	movw	r22, r24
    34f6:	cd 01       	movw	r24, r26
    34f8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    34fc:	dc 01       	movw	r26, r24
    34fe:	cb 01       	movw	r24, r22
    3500:	9f 83       	std	Y+7, r25	; 0x07
    3502:	8e 83       	std	Y+6, r24	; 0x06
    3504:	0f c0       	rjmp	.+30     	; 0x3524 <HAL_Ultrasonic_Sensor_voidTrigger+0x148>
    3506:	80 e9       	ldi	r24, 0x90	; 144
    3508:	91 e0       	ldi	r25, 0x01	; 1
    350a:	9d 83       	std	Y+5, r25	; 0x05
    350c:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    350e:	8c 81       	ldd	r24, Y+4	; 0x04
    3510:	9d 81       	ldd	r25, Y+5	; 0x05
    3512:	01 97       	sbiw	r24, 0x01	; 1
    3514:	f1 f7       	brne	.-4      	; 0x3512 <HAL_Ultrasonic_Sensor_voidTrigger+0x136>
    3516:	9d 83       	std	Y+5, r25	; 0x05
    3518:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    351a:	8e 81       	ldd	r24, Y+6	; 0x06
    351c:	9f 81       	ldd	r25, Y+7	; 0x07
    351e:	01 97       	sbiw	r24, 0x01	; 1
    3520:	9f 83       	std	Y+7, r25	; 0x07
    3522:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3524:	8e 81       	ldd	r24, Y+6	; 0x06
    3526:	9f 81       	ldd	r25, Y+7	; 0x07
    3528:	00 97       	sbiw	r24, 0x00	; 0
    352a:	69 f7       	brne	.-38     	; 0x3506 <HAL_Ultrasonic_Sensor_voidTrigger+0x12a>
    352c:	24 c0       	rjmp	.+72     	; 0x3576 <HAL_Ultrasonic_Sensor_voidTrigger+0x19a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    352e:	68 85       	ldd	r22, Y+8	; 0x08
    3530:	79 85       	ldd	r23, Y+9	; 0x09
    3532:	8a 85       	ldd	r24, Y+10	; 0x0a
    3534:	9b 85       	ldd	r25, Y+11	; 0x0b
    3536:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    353a:	dc 01       	movw	r26, r24
    353c:	cb 01       	movw	r24, r22
    353e:	9f 83       	std	Y+7, r25	; 0x07
    3540:	8e 83       	std	Y+6, r24	; 0x06
    3542:	8e 81       	ldd	r24, Y+6	; 0x06
    3544:	9f 81       	ldd	r25, Y+7	; 0x07
    3546:	9b 83       	std	Y+3, r25	; 0x03
    3548:	8a 83       	std	Y+2, r24	; 0x02
    354a:	8a 81       	ldd	r24, Y+2	; 0x02
    354c:	9b 81       	ldd	r25, Y+3	; 0x03
    354e:	01 97       	sbiw	r24, 0x01	; 1
    3550:	f1 f7       	brne	.-4      	; 0x354e <HAL_Ultrasonic_Sensor_voidTrigger+0x172>
    3552:	9b 83       	std	Y+3, r25	; 0x03
    3554:	8a 83       	std	Y+2, r24	; 0x02
    3556:	0f c0       	rjmp	.+30     	; 0x3576 <HAL_Ultrasonic_Sensor_voidTrigger+0x19a>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3558:	69 89       	ldd	r22, Y+17	; 0x11
    355a:	7a 89       	ldd	r23, Y+18	; 0x12
    355c:	8b 89       	ldd	r24, Y+19	; 0x13
    355e:	9c 89       	ldd	r25, Y+20	; 0x14
    3560:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3564:	dc 01       	movw	r26, r24
    3566:	cb 01       	movw	r24, r22
    3568:	88 8b       	std	Y+16, r24	; 0x10
    356a:	88 89       	ldd	r24, Y+16	; 0x10
    356c:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    356e:	89 81       	ldd	r24, Y+1	; 0x01
    3570:	8a 95       	dec	r24
    3572:	f1 f7       	brne	.-4      	; 0x3570 <HAL_Ultrasonic_Sensor_voidTrigger+0x194>
    3574:	89 83       	std	Y+1, r24	; 0x01
	_delay_us(10);                                            // 10 micro seconds delay
	MCAL_DIO_u8SetPinValue(TRIG_PORT, TRIG_PIN, Pin_Low);     // low
    3576:	83 e0       	ldi	r24, 0x03	; 3
    3578:	66 e0       	ldi	r22, 0x06	; 6
    357a:	40 e0       	ldi	r20, 0x00	; 0
    357c:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
}
    3580:	68 96       	adiw	r28, 0x18	; 24
    3582:	0f b6       	in	r0, 0x3f	; 63
    3584:	f8 94       	cli
    3586:	de bf       	out	0x3e, r29	; 62
    3588:	0f be       	out	0x3f, r0	; 63
    358a:	cd bf       	out	0x3d, r28	; 61
    358c:	cf 91       	pop	r28
    358e:	df 91       	pop	r29
    3590:	08 95       	ret

00003592 <HAL_Ultrasonic_Sensor_voidCalcDistancse>:

void HAL_Ultrasonic_Sensor_voidCalcDistancse(f32* returned_distance) {
    3592:	df 93       	push	r29
    3594:	cf 93       	push	r28
    3596:	cd b7       	in	r28, 0x3d	; 61
    3598:	de b7       	in	r29, 0x3e	; 62
    359a:	60 97       	sbiw	r28, 0x10	; 16
    359c:	0f b6       	in	r0, 0x3f	; 63
    359e:	f8 94       	cli
    35a0:	de bf       	out	0x3e, r29	; 62
    35a2:	0f be       	out	0x3f, r0	; 63
    35a4:	cd bf       	out	0x3d, r28	; 61
    35a6:	98 8b       	std	Y+16, r25	; 0x10
    35a8:	8f 87       	std	Y+15, r24	; 0x0f
	HAL_Ultrasonic_Sensor_voidTrigger();                                  // send trigger
    35aa:	0e 94 ee 19 	call	0x33dc	; 0x33dc <HAL_Ultrasonic_Sensor_voidTrigger>
	MCAL_Interrupt_InterruptRisingInit();
    35ae:	0e 94 b3 14 	call	0x2966	; 0x2966 <MCAL_Interrupt_InterruptRisingInit>
    35b2:	80 e0       	ldi	r24, 0x00	; 0
    35b4:	90 e0       	ldi	r25, 0x00	; 0
    35b6:	a8 e4       	ldi	r26, 0x48	; 72
    35b8:	b2 e4       	ldi	r27, 0x42	; 66
    35ba:	8b 87       	std	Y+11, r24	; 0x0b
    35bc:	9c 87       	std	Y+12, r25	; 0x0c
    35be:	ad 87       	std	Y+13, r26	; 0x0d
    35c0:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    35c2:	6b 85       	ldd	r22, Y+11	; 0x0b
    35c4:	7c 85       	ldd	r23, Y+12	; 0x0c
    35c6:	8d 85       	ldd	r24, Y+13	; 0x0d
    35c8:	9e 85       	ldd	r25, Y+14	; 0x0e
    35ca:	20 e0       	ldi	r18, 0x00	; 0
    35cc:	30 e0       	ldi	r19, 0x00	; 0
    35ce:	4a e7       	ldi	r20, 0x7A	; 122
    35d0:	55 e4       	ldi	r21, 0x45	; 69
    35d2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    35d6:	dc 01       	movw	r26, r24
    35d8:	cb 01       	movw	r24, r22
    35da:	8f 83       	std	Y+7, r24	; 0x07
    35dc:	98 87       	std	Y+8, r25	; 0x08
    35de:	a9 87       	std	Y+9, r26	; 0x09
    35e0:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    35e2:	6f 81       	ldd	r22, Y+7	; 0x07
    35e4:	78 85       	ldd	r23, Y+8	; 0x08
    35e6:	89 85       	ldd	r24, Y+9	; 0x09
    35e8:	9a 85       	ldd	r25, Y+10	; 0x0a
    35ea:	20 e0       	ldi	r18, 0x00	; 0
    35ec:	30 e0       	ldi	r19, 0x00	; 0
    35ee:	40 e8       	ldi	r20, 0x80	; 128
    35f0:	5f e3       	ldi	r21, 0x3F	; 63
    35f2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    35f6:	88 23       	and	r24, r24
    35f8:	2c f4       	brge	.+10     	; 0x3604 <HAL_Ultrasonic_Sensor_voidCalcDistancse+0x72>
		__ticks = 1;
    35fa:	81 e0       	ldi	r24, 0x01	; 1
    35fc:	90 e0       	ldi	r25, 0x00	; 0
    35fe:	9e 83       	std	Y+6, r25	; 0x06
    3600:	8d 83       	std	Y+5, r24	; 0x05
    3602:	3f c0       	rjmp	.+126    	; 0x3682 <HAL_Ultrasonic_Sensor_voidCalcDistancse+0xf0>
	else if (__tmp > 65535)
    3604:	6f 81       	ldd	r22, Y+7	; 0x07
    3606:	78 85       	ldd	r23, Y+8	; 0x08
    3608:	89 85       	ldd	r24, Y+9	; 0x09
    360a:	9a 85       	ldd	r25, Y+10	; 0x0a
    360c:	20 e0       	ldi	r18, 0x00	; 0
    360e:	3f ef       	ldi	r19, 0xFF	; 255
    3610:	4f e7       	ldi	r20, 0x7F	; 127
    3612:	57 e4       	ldi	r21, 0x47	; 71
    3614:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3618:	18 16       	cp	r1, r24
    361a:	4c f5       	brge	.+82     	; 0x366e <HAL_Ultrasonic_Sensor_voidCalcDistancse+0xdc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    361c:	6b 85       	ldd	r22, Y+11	; 0x0b
    361e:	7c 85       	ldd	r23, Y+12	; 0x0c
    3620:	8d 85       	ldd	r24, Y+13	; 0x0d
    3622:	9e 85       	ldd	r25, Y+14	; 0x0e
    3624:	20 e0       	ldi	r18, 0x00	; 0
    3626:	30 e0       	ldi	r19, 0x00	; 0
    3628:	40 e2       	ldi	r20, 0x20	; 32
    362a:	51 e4       	ldi	r21, 0x41	; 65
    362c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3630:	dc 01       	movw	r26, r24
    3632:	cb 01       	movw	r24, r22
    3634:	bc 01       	movw	r22, r24
    3636:	cd 01       	movw	r24, r26
    3638:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    363c:	dc 01       	movw	r26, r24
    363e:	cb 01       	movw	r24, r22
    3640:	9e 83       	std	Y+6, r25	; 0x06
    3642:	8d 83       	std	Y+5, r24	; 0x05
    3644:	0f c0       	rjmp	.+30     	; 0x3664 <HAL_Ultrasonic_Sensor_voidCalcDistancse+0xd2>
    3646:	80 e9       	ldi	r24, 0x90	; 144
    3648:	91 e0       	ldi	r25, 0x01	; 1
    364a:	9c 83       	std	Y+4, r25	; 0x04
    364c:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    364e:	8b 81       	ldd	r24, Y+3	; 0x03
    3650:	9c 81       	ldd	r25, Y+4	; 0x04
    3652:	01 97       	sbiw	r24, 0x01	; 1
    3654:	f1 f7       	brne	.-4      	; 0x3652 <HAL_Ultrasonic_Sensor_voidCalcDistancse+0xc0>
    3656:	9c 83       	std	Y+4, r25	; 0x04
    3658:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    365a:	8d 81       	ldd	r24, Y+5	; 0x05
    365c:	9e 81       	ldd	r25, Y+6	; 0x06
    365e:	01 97       	sbiw	r24, 0x01	; 1
    3660:	9e 83       	std	Y+6, r25	; 0x06
    3662:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3664:	8d 81       	ldd	r24, Y+5	; 0x05
    3666:	9e 81       	ldd	r25, Y+6	; 0x06
    3668:	00 97       	sbiw	r24, 0x00	; 0
    366a:	69 f7       	brne	.-38     	; 0x3646 <HAL_Ultrasonic_Sensor_voidCalcDistancse+0xb4>
    366c:	14 c0       	rjmp	.+40     	; 0x3696 <HAL_Ultrasonic_Sensor_voidCalcDistancse+0x104>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    366e:	6f 81       	ldd	r22, Y+7	; 0x07
    3670:	78 85       	ldd	r23, Y+8	; 0x08
    3672:	89 85       	ldd	r24, Y+9	; 0x09
    3674:	9a 85       	ldd	r25, Y+10	; 0x0a
    3676:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    367a:	dc 01       	movw	r26, r24
    367c:	cb 01       	movw	r24, r22
    367e:	9e 83       	std	Y+6, r25	; 0x06
    3680:	8d 83       	std	Y+5, r24	; 0x05
    3682:	8d 81       	ldd	r24, Y+5	; 0x05
    3684:	9e 81       	ldd	r25, Y+6	; 0x06
    3686:	9a 83       	std	Y+2, r25	; 0x02
    3688:	89 83       	std	Y+1, r24	; 0x01
    368a:	89 81       	ldd	r24, Y+1	; 0x01
    368c:	9a 81       	ldd	r25, Y+2	; 0x02
    368e:	01 97       	sbiw	r24, 0x01	; 1
    3690:	f1 f7       	brne	.-4      	; 0x368e <HAL_Ultrasonic_Sensor_voidCalcDistancse+0xfc>
    3692:	9a 83       	std	Y+2, r25	; 0x02
    3694:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(50);                                            // stability delay
	*returned_distance = Glob_f32Distance;                           // get the distance
    3696:	80 91 3e 02 	lds	r24, 0x023E
    369a:	90 91 3f 02 	lds	r25, 0x023F
    369e:	a0 91 40 02 	lds	r26, 0x0240
    36a2:	b0 91 41 02 	lds	r27, 0x0241
    36a6:	ef 85       	ldd	r30, Y+15	; 0x0f
    36a8:	f8 89       	ldd	r31, Y+16	; 0x10
    36aa:	80 83       	st	Z, r24
    36ac:	91 83       	std	Z+1, r25	; 0x01
    36ae:	a2 83       	std	Z+2, r26	; 0x02
    36b0:	b3 83       	std	Z+3, r27	; 0x03
}
    36b2:	60 96       	adiw	r28, 0x10	; 16
    36b4:	0f b6       	in	r0, 0x3f	; 63
    36b6:	f8 94       	cli
    36b8:	de bf       	out	0x3e, r29	; 62
    36ba:	0f be       	out	0x3f, r0	; 63
    36bc:	cd bf       	out	0x3d, r28	; 61
    36be:	cf 91       	pop	r28
    36c0:	df 91       	pop	r29
    36c2:	08 95       	ret

000036c4 <HAL_Ultrasonic_Sensor_voidInterrupt>:
void HAL_Ultrasonic_Sensor_voidInterrupt(void)                                     // call back function
{
    36c4:	df 93       	push	r29
    36c6:	cf 93       	push	r28
    36c8:	cd b7       	in	r28, 0x3d	; 61
    36ca:	de b7       	in	r29, 0x3e	; 62

	if (Glob_u8Counter <= 2)          // check for counter status
    36cc:	80 91 27 02 	lds	r24, 0x0227
    36d0:	83 30       	cpi	r24, 0x03	; 3
    36d2:	08 f0       	brcs	.+2      	; 0x36d6 <HAL_Ultrasonic_Sensor_voidInterrupt+0x12>
    36d4:	75 c0       	rjmp	.+234    	; 0x37c0 <HAL_Ultrasonic_Sensor_voidInterrupt+0xfc>
			{
		if (Glob_u8Counter == NUM1)      // check if it is the first entry
    36d6:	80 91 27 02 	lds	r24, 0x0227
    36da:	81 30       	cpi	r24, 0x01	; 1
    36dc:	a1 f4       	brne	.+40     	; 0x3706 <HAL_Ultrasonic_Sensor_voidInterrupt+0x42>
		{
			// store the start time value
			Glob_u16StartTime = TCNT0;
    36de:	e2 e5       	ldi	r30, 0x52	; 82
    36e0:	f0 e0       	ldi	r31, 0x00	; 0
    36e2:	80 81       	ld	r24, Z
    36e4:	88 2f       	mov	r24, r24
    36e6:	90 e0       	ldi	r25, 0x00	; 0
    36e8:	90 93 43 02 	sts	0x0243, r25
    36ec:	80 93 42 02 	sts	0x0242, r24

			// store number of OVFs at the start of the signal
			Glob_u16OvfCounterStart = Glob_u16OvfCounter;
    36f0:	80 91 30 02 	lds	r24, 0x0230
    36f4:	90 91 31 02 	lds	r25, 0x0231
    36f8:	90 93 dd 06 	sts	0x06DD, r25
    36fc:	80 93 dc 06 	sts	0x06DC, r24

			// at the first entry  we change the capture edge to falling edge to capture echo signal
			MCAL_Interrupt_InterruptFallingInit();
    3700:	0e 94 c9 14 	call	0x2992	; 0x2992 <MCAL_Interrupt_InterruptFallingInit>
    3704:	58 c0       	rjmp	.+176    	; 0x37b6 <HAL_Ultrasonic_Sensor_voidInterrupt+0xf2>
		}

		else if (Glob_u8Counter == 2) // check if it's the second entry
    3706:	80 91 27 02 	lds	r24, 0x0227
    370a:	82 30       	cpi	r24, 0x02	; 2
    370c:	09 f0       	breq	.+2      	; 0x3710 <HAL_Ultrasonic_Sensor_voidInterrupt+0x4c>
    370e:	53 c0       	rjmp	.+166    	; 0x37b6 <HAL_Ultrasonic_Sensor_voidInterrupt+0xf2>
				{
			//store end time value
			Glob_u16EndTime = TCNT0;
    3710:	e2 e5       	ldi	r30, 0x52	; 82
    3712:	f0 e0       	ldi	r31, 0x00	; 0
    3714:	80 81       	ld	r24, Z
    3716:	88 2f       	mov	r24, r24
    3718:	90 e0       	ldi	r25, 0x00	; 0
    371a:	90 93 45 02 	sts	0x0245, r25
    371e:	80 93 44 02 	sts	0x0244, r24

			//store number of OVFs at the end of signal
			Glob_16OvfCounterEnd = Glob_u16OvfCounter;
    3722:	80 91 30 02 	lds	r24, 0x0230
    3726:	90 91 31 02 	lds	r25, 0x0231
    372a:	90 93 db 06 	sts	0x06DB, r25
    372e:	80 93 da 06 	sts	0x06DA, r24

			//calculate the time difference between start and end
			Glob_u16TimeDiff = (Glob_u16EndTime + (256 * Glob_16OvfCounterEnd))
    3732:	80 91 da 06 	lds	r24, 0x06DA
    3736:	90 91 db 06 	lds	r25, 0x06DB
    373a:	38 2f       	mov	r19, r24
    373c:	22 27       	eor	r18, r18
    373e:	80 91 44 02 	lds	r24, 0x0244
    3742:	90 91 45 02 	lds	r25, 0x0245
    3746:	a9 01       	movw	r20, r18
    3748:	48 0f       	add	r20, r24
    374a:	59 1f       	adc	r21, r25
    374c:	80 91 dc 06 	lds	r24, 0x06DC
    3750:	90 91 dd 06 	lds	r25, 0x06DD
    3754:	38 2f       	mov	r19, r24
    3756:	22 27       	eor	r18, r18
    3758:	80 91 42 02 	lds	r24, 0x0242
    375c:	90 91 43 02 	lds	r25, 0x0243
    3760:	82 0f       	add	r24, r18
    3762:	93 1f       	adc	r25, r19
    3764:	9a 01       	movw	r18, r20
    3766:	28 1b       	sub	r18, r24
    3768:	39 0b       	sbc	r19, r25
    376a:	c9 01       	movw	r24, r18
    376c:	90 93 47 02 	sts	0x0247, r25
    3770:	80 93 46 02 	sts	0x0246, r24
					- (Glob_u16StartTime + (256 * Glob_u16OvfCounterStart));

			//calculate the distance
			Glob_f32Distance = Glob_u16TimeDiff * 0.068; //     f32 ton=(h(64/16000000))/2 >>     distance=ton34000;
    3774:	80 91 46 02 	lds	r24, 0x0246
    3778:	90 91 47 02 	lds	r25, 0x0247
    377c:	cc 01       	movw	r24, r24
    377e:	a0 e0       	ldi	r26, 0x00	; 0
    3780:	b0 e0       	ldi	r27, 0x00	; 0
    3782:	bc 01       	movw	r22, r24
    3784:	cd 01       	movw	r24, r26
    3786:	0e 94 37 05 	call	0xa6e	; 0xa6e <__floatunsisf>
    378a:	dc 01       	movw	r26, r24
    378c:	cb 01       	movw	r24, r22
    378e:	bc 01       	movw	r22, r24
    3790:	cd 01       	movw	r24, r26
    3792:	26 e9       	ldi	r18, 0x96	; 150
    3794:	33 e4       	ldi	r19, 0x43	; 67
    3796:	4b e8       	ldi	r20, 0x8B	; 139
    3798:	5d e3       	ldi	r21, 0x3D	; 61
    379a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    379e:	dc 01       	movw	r26, r24
    37a0:	cb 01       	movw	r24, r22
    37a2:	80 93 3e 02 	sts	0x023E, r24
    37a6:	90 93 3f 02 	sts	0x023F, r25
    37aa:	a0 93 40 02 	sts	0x0240, r26
    37ae:	b0 93 41 02 	sts	0x0241, r27

			//reset the counter to calculate new signal
			Glob_u8Counter = NUM0;
    37b2:	10 92 27 02 	sts	0x0227, r1

		}

		//increase the counter to sync with the entry state
		Glob_u8Counter++;
    37b6:	80 91 27 02 	lds	r24, 0x0227
    37ba:	8f 5f       	subi	r24, 0xFF	; 255
    37bc:	80 93 27 02 	sts	0x0227, r24
	}

}
    37c0:	cf 91       	pop	r28
    37c2:	df 91       	pop	r29
    37c4:	08 95       	ret

000037c6 <HAL_SM_voidSMInit>:
 *
 *  Created on: Oct 29, 2023
 *      Author: TOP_WORLD
 */
#include "Servo_Motor.h"
void HAL_SM_voidSMInit(void) {
    37c6:	df 93       	push	r29
    37c8:	cf 93       	push	r28
    37ca:	cd b7       	in	r28, 0x3d	; 61
    37cc:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(DDRD,Pin7);
    37ce:	a1 e3       	ldi	r26, 0x31	; 49
    37d0:	b0 e0       	ldi	r27, 0x00	; 0
    37d2:	e1 e3       	ldi	r30, 0x31	; 49
    37d4:	f0 e0       	ldi	r31, 0x00	; 0
    37d6:	80 81       	ld	r24, Z
    37d8:	80 68       	ori	r24, 0x80	; 128
    37da:	8c 93       	st	X, r24
}
    37dc:	cf 91       	pop	r28
    37de:	df 91       	pop	r29
    37e0:	08 95       	ret

000037e2 <HAL_SM_voidSMSetAngle>:
void HAL_SM_voidSMSetAngle(u8 LOC_u8Angle) {
    37e2:	df 93       	push	r29
    37e4:	cf 93       	push	r28
    37e6:	cd b7       	in	r28, 0x3d	; 61
    37e8:	de b7       	in	r29, 0x3e	; 62
    37ea:	e5 97       	sbiw	r28, 0x35	; 53
    37ec:	0f b6       	in	r0, 0x3f	; 63
    37ee:	f8 94       	cli
    37f0:	de bf       	out	0x3e, r29	; 62
    37f2:	0f be       	out	0x3f, r0	; 63
    37f4:	cd bf       	out	0x3d, r28	; 61
    37f6:	8d ab       	std	Y+53, r24	; 0x35
	u16 LOC_u16Time=(32.0/3)*(LOC_u8Angle-90)+1100;
    37f8:	8d a9       	ldd	r24, Y+53	; 0x35
    37fa:	88 2f       	mov	r24, r24
    37fc:	90 e0       	ldi	r25, 0x00	; 0
    37fe:	8a 55       	subi	r24, 0x5A	; 90
    3800:	90 40       	sbci	r25, 0x00	; 0
    3802:	aa 27       	eor	r26, r26
    3804:	97 fd       	sbrc	r25, 7
    3806:	a0 95       	com	r26
    3808:	ba 2f       	mov	r27, r26
    380a:	bc 01       	movw	r22, r24
    380c:	cd 01       	movw	r24, r26
    380e:	0e 94 85 04 	call	0x90a	; 0x90a <__floatsisf>
    3812:	dc 01       	movw	r26, r24
    3814:	cb 01       	movw	r24, r22
    3816:	bc 01       	movw	r22, r24
    3818:	cd 01       	movw	r24, r26
    381a:	2b ea       	ldi	r18, 0xAB	; 171
    381c:	3a ea       	ldi	r19, 0xAA	; 170
    381e:	4a e2       	ldi	r20, 0x2A	; 42
    3820:	51 e4       	ldi	r21, 0x41	; 65
    3822:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3826:	dc 01       	movw	r26, r24
    3828:	cb 01       	movw	r24, r22
    382a:	bc 01       	movw	r22, r24
    382c:	cd 01       	movw	r24, r26
    382e:	20 e0       	ldi	r18, 0x00	; 0
    3830:	30 e8       	ldi	r19, 0x80	; 128
    3832:	49 e8       	ldi	r20, 0x89	; 137
    3834:	54 e4       	ldi	r21, 0x44	; 68
    3836:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <__addsf3>
    383a:	dc 01       	movw	r26, r24
    383c:	cb 01       	movw	r24, r22
    383e:	bc 01       	movw	r22, r24
    3840:	cd 01       	movw	r24, r26
    3842:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3846:	dc 01       	movw	r26, r24
    3848:	cb 01       	movw	r24, r22
    384a:	9c ab       	std	Y+52, r25	; 0x34
    384c:	8b ab       	std	Y+51, r24	; 0x33
	u16 LOC_u16OffTime=(20000-LOC_u16Time);
    384e:	20 e2       	ldi	r18, 0x20	; 32
    3850:	3e e4       	ldi	r19, 0x4E	; 78
    3852:	8b a9       	ldd	r24, Y+51	; 0x33
    3854:	9c a9       	ldd	r25, Y+52	; 0x34
    3856:	a9 01       	movw	r20, r18
    3858:	48 1b       	sub	r20, r24
    385a:	59 0b       	sbc	r21, r25
    385c:	ca 01       	movw	r24, r20
    385e:	9a ab       	std	Y+50, r25	; 0x32
    3860:	89 ab       	std	Y+49, r24	; 0x31
	if (LOC_u8Angle <= MAX_ANGLE && LOC_u8Angle >= MIN_ANGLE) {
    3862:	8d a9       	ldd	r24, Y+53	; 0x35
    3864:	88 2f       	mov	r24, r24
    3866:	90 e0       	ldi	r25, 0x00	; 0
    3868:	aa 27       	eor	r26, r26
    386a:	97 fd       	sbrc	r25, 7
    386c:	a0 95       	com	r26
    386e:	ba 2f       	mov	r27, r26
    3870:	bc 01       	movw	r22, r24
    3872:	cd 01       	movw	r24, r26
    3874:	0e 94 85 04 	call	0x90a	; 0x90a <__floatsisf>
    3878:	dc 01       	movw	r26, r24
    387a:	cb 01       	movw	r24, r22
    387c:	bc 01       	movw	r22, r24
    387e:	cd 01       	movw	r24, r26
    3880:	20 e0       	ldi	r18, 0x00	; 0
    3882:	30 e0       	ldi	r19, 0x00	; 0
    3884:	44 e3       	ldi	r20, 0x34	; 52
    3886:	53 e4       	ldi	r21, 0x43	; 67
    3888:	0e 94 55 04 	call	0x8aa	; 0x8aa <__lesf2>
    388c:	18 16       	cp	r1, r24
    388e:	0c f4       	brge	.+2      	; 0x3892 <HAL_SM_voidSMSetAngle+0xb0>
    3890:	98 c1       	rjmp	.+816    	; 0x3bc2 <HAL_SM_voidSMSetAngle+0x3e0>
		SET_BIT(PORTD,Pin7);
    3892:	a2 e3       	ldi	r26, 0x32	; 50
    3894:	b0 e0       	ldi	r27, 0x00	; 0
    3896:	e2 e3       	ldi	r30, 0x32	; 50
    3898:	f0 e0       	ldi	r31, 0x00	; 0
    389a:	80 81       	ld	r24, Z
    389c:	80 68       	ori	r24, 0x80	; 128
    389e:	8c 93       	st	X, r24
		_delay_us(LOC_u16Time);
    38a0:	8b a9       	ldd	r24, Y+51	; 0x33
    38a2:	9c a9       	ldd	r25, Y+52	; 0x34
    38a4:	cc 01       	movw	r24, r24
    38a6:	a0 e0       	ldi	r26, 0x00	; 0
    38a8:	b0 e0       	ldi	r27, 0x00	; 0
    38aa:	bc 01       	movw	r22, r24
    38ac:	cd 01       	movw	r24, r26
    38ae:	0e 94 37 05 	call	0xa6e	; 0xa6e <__floatunsisf>
    38b2:	dc 01       	movw	r26, r24
    38b4:	cb 01       	movw	r24, r22
    38b6:	8d a7       	std	Y+45, r24	; 0x2d
    38b8:	9e a7       	std	Y+46, r25	; 0x2e
    38ba:	af a7       	std	Y+47, r26	; 0x2f
    38bc:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    38be:	6d a5       	ldd	r22, Y+45	; 0x2d
    38c0:	7e a5       	ldd	r23, Y+46	; 0x2e
    38c2:	8f a5       	ldd	r24, Y+47	; 0x2f
    38c4:	98 a9       	ldd	r25, Y+48	; 0x30
    38c6:	2b ea       	ldi	r18, 0xAB	; 171
    38c8:	3a ea       	ldi	r19, 0xAA	; 170
    38ca:	4a ea       	ldi	r20, 0xAA	; 170
    38cc:	50 e4       	ldi	r21, 0x40	; 64
    38ce:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    38d2:	dc 01       	movw	r26, r24
    38d4:	cb 01       	movw	r24, r22
    38d6:	89 a7       	std	Y+41, r24	; 0x29
    38d8:	9a a7       	std	Y+42, r25	; 0x2a
    38da:	ab a7       	std	Y+43, r26	; 0x2b
    38dc:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    38de:	69 a5       	ldd	r22, Y+41	; 0x29
    38e0:	7a a5       	ldd	r23, Y+42	; 0x2a
    38e2:	8b a5       	ldd	r24, Y+43	; 0x2b
    38e4:	9c a5       	ldd	r25, Y+44	; 0x2c
    38e6:	20 e0       	ldi	r18, 0x00	; 0
    38e8:	30 e0       	ldi	r19, 0x00	; 0
    38ea:	40 e8       	ldi	r20, 0x80	; 128
    38ec:	5f e3       	ldi	r21, 0x3F	; 63
    38ee:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    38f2:	88 23       	and	r24, r24
    38f4:	1c f4       	brge	.+6      	; 0x38fc <HAL_SM_voidSMSetAngle+0x11a>
		__ticks = 1;
    38f6:	81 e0       	ldi	r24, 0x01	; 1
    38f8:	88 a7       	std	Y+40, r24	; 0x28
    38fa:	91 c0       	rjmp	.+290    	; 0x3a1e <HAL_SM_voidSMSetAngle+0x23c>
	else if (__tmp > 255)
    38fc:	69 a5       	ldd	r22, Y+41	; 0x29
    38fe:	7a a5       	ldd	r23, Y+42	; 0x2a
    3900:	8b a5       	ldd	r24, Y+43	; 0x2b
    3902:	9c a5       	ldd	r25, Y+44	; 0x2c
    3904:	20 e0       	ldi	r18, 0x00	; 0
    3906:	30 e0       	ldi	r19, 0x00	; 0
    3908:	4f e7       	ldi	r20, 0x7F	; 127
    390a:	53 e4       	ldi	r21, 0x43	; 67
    390c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3910:	18 16       	cp	r1, r24
    3912:	0c f0       	brlt	.+2      	; 0x3916 <HAL_SM_voidSMSetAngle+0x134>
    3914:	7b c0       	rjmp	.+246    	; 0x3a0c <HAL_SM_voidSMSetAngle+0x22a>
	{
		_delay_ms(__us / 1000.0);
    3916:	6d a5       	ldd	r22, Y+45	; 0x2d
    3918:	7e a5       	ldd	r23, Y+46	; 0x2e
    391a:	8f a5       	ldd	r24, Y+47	; 0x2f
    391c:	98 a9       	ldd	r25, Y+48	; 0x30
    391e:	20 e0       	ldi	r18, 0x00	; 0
    3920:	30 e0       	ldi	r19, 0x00	; 0
    3922:	4a e7       	ldi	r20, 0x7A	; 122
    3924:	54 e4       	ldi	r21, 0x44	; 68
    3926:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    392a:	dc 01       	movw	r26, r24
    392c:	cb 01       	movw	r24, r22
    392e:	8c a3       	std	Y+36, r24	; 0x24
    3930:	9d a3       	std	Y+37, r25	; 0x25
    3932:	ae a3       	std	Y+38, r26	; 0x26
    3934:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3936:	6c a1       	ldd	r22, Y+36	; 0x24
    3938:	7d a1       	ldd	r23, Y+37	; 0x25
    393a:	8e a1       	ldd	r24, Y+38	; 0x26
    393c:	9f a1       	ldd	r25, Y+39	; 0x27
    393e:	20 e0       	ldi	r18, 0x00	; 0
    3940:	30 e0       	ldi	r19, 0x00	; 0
    3942:	4a e7       	ldi	r20, 0x7A	; 122
    3944:	55 e4       	ldi	r21, 0x45	; 69
    3946:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    394a:	dc 01       	movw	r26, r24
    394c:	cb 01       	movw	r24, r22
    394e:	88 a3       	std	Y+32, r24	; 0x20
    3950:	99 a3       	std	Y+33, r25	; 0x21
    3952:	aa a3       	std	Y+34, r26	; 0x22
    3954:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    3956:	68 a1       	ldd	r22, Y+32	; 0x20
    3958:	79 a1       	ldd	r23, Y+33	; 0x21
    395a:	8a a1       	ldd	r24, Y+34	; 0x22
    395c:	9b a1       	ldd	r25, Y+35	; 0x23
    395e:	20 e0       	ldi	r18, 0x00	; 0
    3960:	30 e0       	ldi	r19, 0x00	; 0
    3962:	40 e8       	ldi	r20, 0x80	; 128
    3964:	5f e3       	ldi	r21, 0x3F	; 63
    3966:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    396a:	88 23       	and	r24, r24
    396c:	2c f4       	brge	.+10     	; 0x3978 <HAL_SM_voidSMSetAngle+0x196>
		__ticks = 1;
    396e:	81 e0       	ldi	r24, 0x01	; 1
    3970:	90 e0       	ldi	r25, 0x00	; 0
    3972:	9f 8f       	std	Y+31, r25	; 0x1f
    3974:	8e 8f       	std	Y+30, r24	; 0x1e
    3976:	3f c0       	rjmp	.+126    	; 0x39f6 <HAL_SM_voidSMSetAngle+0x214>
	else if (__tmp > 65535)
    3978:	68 a1       	ldd	r22, Y+32	; 0x20
    397a:	79 a1       	ldd	r23, Y+33	; 0x21
    397c:	8a a1       	ldd	r24, Y+34	; 0x22
    397e:	9b a1       	ldd	r25, Y+35	; 0x23
    3980:	20 e0       	ldi	r18, 0x00	; 0
    3982:	3f ef       	ldi	r19, 0xFF	; 255
    3984:	4f e7       	ldi	r20, 0x7F	; 127
    3986:	57 e4       	ldi	r21, 0x47	; 71
    3988:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    398c:	18 16       	cp	r1, r24
    398e:	4c f5       	brge	.+82     	; 0x39e2 <HAL_SM_voidSMSetAngle+0x200>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3990:	6c a1       	ldd	r22, Y+36	; 0x24
    3992:	7d a1       	ldd	r23, Y+37	; 0x25
    3994:	8e a1       	ldd	r24, Y+38	; 0x26
    3996:	9f a1       	ldd	r25, Y+39	; 0x27
    3998:	20 e0       	ldi	r18, 0x00	; 0
    399a:	30 e0       	ldi	r19, 0x00	; 0
    399c:	40 e2       	ldi	r20, 0x20	; 32
    399e:	51 e4       	ldi	r21, 0x41	; 65
    39a0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    39a4:	dc 01       	movw	r26, r24
    39a6:	cb 01       	movw	r24, r22
    39a8:	bc 01       	movw	r22, r24
    39aa:	cd 01       	movw	r24, r26
    39ac:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    39b0:	dc 01       	movw	r26, r24
    39b2:	cb 01       	movw	r24, r22
    39b4:	9f 8f       	std	Y+31, r25	; 0x1f
    39b6:	8e 8f       	std	Y+30, r24	; 0x1e
    39b8:	0f c0       	rjmp	.+30     	; 0x39d8 <HAL_SM_voidSMSetAngle+0x1f6>
    39ba:	80 e9       	ldi	r24, 0x90	; 144
    39bc:	91 e0       	ldi	r25, 0x01	; 1
    39be:	9d 8f       	std	Y+29, r25	; 0x1d
    39c0:	8c 8f       	std	Y+28, r24	; 0x1c
    39c2:	8c 8d       	ldd	r24, Y+28	; 0x1c
    39c4:	9d 8d       	ldd	r25, Y+29	; 0x1d
    39c6:	01 97       	sbiw	r24, 0x01	; 1
    39c8:	f1 f7       	brne	.-4      	; 0x39c6 <HAL_SM_voidSMSetAngle+0x1e4>
    39ca:	9d 8f       	std	Y+29, r25	; 0x1d
    39cc:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    39ce:	8e 8d       	ldd	r24, Y+30	; 0x1e
    39d0:	9f 8d       	ldd	r25, Y+31	; 0x1f
    39d2:	01 97       	sbiw	r24, 0x01	; 1
    39d4:	9f 8f       	std	Y+31, r25	; 0x1f
    39d6:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    39d8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    39da:	9f 8d       	ldd	r25, Y+31	; 0x1f
    39dc:	00 97       	sbiw	r24, 0x00	; 0
    39de:	69 f7       	brne	.-38     	; 0x39ba <HAL_SM_voidSMSetAngle+0x1d8>
    39e0:	24 c0       	rjmp	.+72     	; 0x3a2a <HAL_SM_voidSMSetAngle+0x248>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    39e2:	68 a1       	ldd	r22, Y+32	; 0x20
    39e4:	79 a1       	ldd	r23, Y+33	; 0x21
    39e6:	8a a1       	ldd	r24, Y+34	; 0x22
    39e8:	9b a1       	ldd	r25, Y+35	; 0x23
    39ea:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    39ee:	dc 01       	movw	r26, r24
    39f0:	cb 01       	movw	r24, r22
    39f2:	9f 8f       	std	Y+31, r25	; 0x1f
    39f4:	8e 8f       	std	Y+30, r24	; 0x1e
    39f6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    39f8:	9f 8d       	ldd	r25, Y+31	; 0x1f
    39fa:	9b 8f       	std	Y+27, r25	; 0x1b
    39fc:	8a 8f       	std	Y+26, r24	; 0x1a
    39fe:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3a00:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3a02:	01 97       	sbiw	r24, 0x01	; 1
    3a04:	f1 f7       	brne	.-4      	; 0x3a02 <HAL_SM_voidSMSetAngle+0x220>
    3a06:	9b 8f       	std	Y+27, r25	; 0x1b
    3a08:	8a 8f       	std	Y+26, r24	; 0x1a
    3a0a:	0f c0       	rjmp	.+30     	; 0x3a2a <HAL_SM_voidSMSetAngle+0x248>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3a0c:	69 a5       	ldd	r22, Y+41	; 0x29
    3a0e:	7a a5       	ldd	r23, Y+42	; 0x2a
    3a10:	8b a5       	ldd	r24, Y+43	; 0x2b
    3a12:	9c a5       	ldd	r25, Y+44	; 0x2c
    3a14:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3a18:	dc 01       	movw	r26, r24
    3a1a:	cb 01       	movw	r24, r22
    3a1c:	88 a7       	std	Y+40, r24	; 0x28
    3a1e:	88 a5       	ldd	r24, Y+40	; 0x28
    3a20:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3a22:	89 8d       	ldd	r24, Y+25	; 0x19
    3a24:	8a 95       	dec	r24
    3a26:	f1 f7       	brne	.-4      	; 0x3a24 <HAL_SM_voidSMSetAngle+0x242>
    3a28:	89 8f       	std	Y+25, r24	; 0x19
		CLR_BIT(PORTD,Pin7);
    3a2a:	a2 e3       	ldi	r26, 0x32	; 50
    3a2c:	b0 e0       	ldi	r27, 0x00	; 0
    3a2e:	e2 e3       	ldi	r30, 0x32	; 50
    3a30:	f0 e0       	ldi	r31, 0x00	; 0
    3a32:	80 81       	ld	r24, Z
    3a34:	8f 77       	andi	r24, 0x7F	; 127
    3a36:	8c 93       	st	X, r24
		_delay_us(LOC_u16OffTime);
    3a38:	89 a9       	ldd	r24, Y+49	; 0x31
    3a3a:	9a a9       	ldd	r25, Y+50	; 0x32
    3a3c:	cc 01       	movw	r24, r24
    3a3e:	a0 e0       	ldi	r26, 0x00	; 0
    3a40:	b0 e0       	ldi	r27, 0x00	; 0
    3a42:	bc 01       	movw	r22, r24
    3a44:	cd 01       	movw	r24, r26
    3a46:	0e 94 37 05 	call	0xa6e	; 0xa6e <__floatunsisf>
    3a4a:	dc 01       	movw	r26, r24
    3a4c:	cb 01       	movw	r24, r22
    3a4e:	8d 8b       	std	Y+21, r24	; 0x15
    3a50:	9e 8b       	std	Y+22, r25	; 0x16
    3a52:	af 8b       	std	Y+23, r26	; 0x17
    3a54:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    3a56:	6d 89       	ldd	r22, Y+21	; 0x15
    3a58:	7e 89       	ldd	r23, Y+22	; 0x16
    3a5a:	8f 89       	ldd	r24, Y+23	; 0x17
    3a5c:	98 8d       	ldd	r25, Y+24	; 0x18
    3a5e:	2b ea       	ldi	r18, 0xAB	; 171
    3a60:	3a ea       	ldi	r19, 0xAA	; 170
    3a62:	4a ea       	ldi	r20, 0xAA	; 170
    3a64:	50 e4       	ldi	r21, 0x40	; 64
    3a66:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3a6a:	dc 01       	movw	r26, r24
    3a6c:	cb 01       	movw	r24, r22
    3a6e:	89 8b       	std	Y+17, r24	; 0x11
    3a70:	9a 8b       	std	Y+18, r25	; 0x12
    3a72:	ab 8b       	std	Y+19, r26	; 0x13
    3a74:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    3a76:	69 89       	ldd	r22, Y+17	; 0x11
    3a78:	7a 89       	ldd	r23, Y+18	; 0x12
    3a7a:	8b 89       	ldd	r24, Y+19	; 0x13
    3a7c:	9c 89       	ldd	r25, Y+20	; 0x14
    3a7e:	20 e0       	ldi	r18, 0x00	; 0
    3a80:	30 e0       	ldi	r19, 0x00	; 0
    3a82:	40 e8       	ldi	r20, 0x80	; 128
    3a84:	5f e3       	ldi	r21, 0x3F	; 63
    3a86:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3a8a:	88 23       	and	r24, r24
    3a8c:	1c f4       	brge	.+6      	; 0x3a94 <HAL_SM_voidSMSetAngle+0x2b2>
		__ticks = 1;
    3a8e:	81 e0       	ldi	r24, 0x01	; 1
    3a90:	88 8b       	std	Y+16, r24	; 0x10
    3a92:	91 c0       	rjmp	.+290    	; 0x3bb6 <HAL_SM_voidSMSetAngle+0x3d4>
	else if (__tmp > 255)
    3a94:	69 89       	ldd	r22, Y+17	; 0x11
    3a96:	7a 89       	ldd	r23, Y+18	; 0x12
    3a98:	8b 89       	ldd	r24, Y+19	; 0x13
    3a9a:	9c 89       	ldd	r25, Y+20	; 0x14
    3a9c:	20 e0       	ldi	r18, 0x00	; 0
    3a9e:	30 e0       	ldi	r19, 0x00	; 0
    3aa0:	4f e7       	ldi	r20, 0x7F	; 127
    3aa2:	53 e4       	ldi	r21, 0x43	; 67
    3aa4:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3aa8:	18 16       	cp	r1, r24
    3aaa:	0c f0       	brlt	.+2      	; 0x3aae <HAL_SM_voidSMSetAngle+0x2cc>
    3aac:	7b c0       	rjmp	.+246    	; 0x3ba4 <HAL_SM_voidSMSetAngle+0x3c2>
	{
		_delay_ms(__us / 1000.0);
    3aae:	6d 89       	ldd	r22, Y+21	; 0x15
    3ab0:	7e 89       	ldd	r23, Y+22	; 0x16
    3ab2:	8f 89       	ldd	r24, Y+23	; 0x17
    3ab4:	98 8d       	ldd	r25, Y+24	; 0x18
    3ab6:	20 e0       	ldi	r18, 0x00	; 0
    3ab8:	30 e0       	ldi	r19, 0x00	; 0
    3aba:	4a e7       	ldi	r20, 0x7A	; 122
    3abc:	54 e4       	ldi	r21, 0x44	; 68
    3abe:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    3ac2:	dc 01       	movw	r26, r24
    3ac4:	cb 01       	movw	r24, r22
    3ac6:	8c 87       	std	Y+12, r24	; 0x0c
    3ac8:	9d 87       	std	Y+13, r25	; 0x0d
    3aca:	ae 87       	std	Y+14, r26	; 0x0e
    3acc:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3ace:	6c 85       	ldd	r22, Y+12	; 0x0c
    3ad0:	7d 85       	ldd	r23, Y+13	; 0x0d
    3ad2:	8e 85       	ldd	r24, Y+14	; 0x0e
    3ad4:	9f 85       	ldd	r25, Y+15	; 0x0f
    3ad6:	20 e0       	ldi	r18, 0x00	; 0
    3ad8:	30 e0       	ldi	r19, 0x00	; 0
    3ada:	4a e7       	ldi	r20, 0x7A	; 122
    3adc:	55 e4       	ldi	r21, 0x45	; 69
    3ade:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3ae2:	dc 01       	movw	r26, r24
    3ae4:	cb 01       	movw	r24, r22
    3ae6:	88 87       	std	Y+8, r24	; 0x08
    3ae8:	99 87       	std	Y+9, r25	; 0x09
    3aea:	aa 87       	std	Y+10, r26	; 0x0a
    3aec:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    3aee:	68 85       	ldd	r22, Y+8	; 0x08
    3af0:	79 85       	ldd	r23, Y+9	; 0x09
    3af2:	8a 85       	ldd	r24, Y+10	; 0x0a
    3af4:	9b 85       	ldd	r25, Y+11	; 0x0b
    3af6:	20 e0       	ldi	r18, 0x00	; 0
    3af8:	30 e0       	ldi	r19, 0x00	; 0
    3afa:	40 e8       	ldi	r20, 0x80	; 128
    3afc:	5f e3       	ldi	r21, 0x3F	; 63
    3afe:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3b02:	88 23       	and	r24, r24
    3b04:	2c f4       	brge	.+10     	; 0x3b10 <HAL_SM_voidSMSetAngle+0x32e>
		__ticks = 1;
    3b06:	81 e0       	ldi	r24, 0x01	; 1
    3b08:	90 e0       	ldi	r25, 0x00	; 0
    3b0a:	9f 83       	std	Y+7, r25	; 0x07
    3b0c:	8e 83       	std	Y+6, r24	; 0x06
    3b0e:	3f c0       	rjmp	.+126    	; 0x3b8e <HAL_SM_voidSMSetAngle+0x3ac>
	else if (__tmp > 65535)
    3b10:	68 85       	ldd	r22, Y+8	; 0x08
    3b12:	79 85       	ldd	r23, Y+9	; 0x09
    3b14:	8a 85       	ldd	r24, Y+10	; 0x0a
    3b16:	9b 85       	ldd	r25, Y+11	; 0x0b
    3b18:	20 e0       	ldi	r18, 0x00	; 0
    3b1a:	3f ef       	ldi	r19, 0xFF	; 255
    3b1c:	4f e7       	ldi	r20, 0x7F	; 127
    3b1e:	57 e4       	ldi	r21, 0x47	; 71
    3b20:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3b24:	18 16       	cp	r1, r24
    3b26:	4c f5       	brge	.+82     	; 0x3b7a <HAL_SM_voidSMSetAngle+0x398>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3b28:	6c 85       	ldd	r22, Y+12	; 0x0c
    3b2a:	7d 85       	ldd	r23, Y+13	; 0x0d
    3b2c:	8e 85       	ldd	r24, Y+14	; 0x0e
    3b2e:	9f 85       	ldd	r25, Y+15	; 0x0f
    3b30:	20 e0       	ldi	r18, 0x00	; 0
    3b32:	30 e0       	ldi	r19, 0x00	; 0
    3b34:	40 e2       	ldi	r20, 0x20	; 32
    3b36:	51 e4       	ldi	r21, 0x41	; 65
    3b38:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3b3c:	dc 01       	movw	r26, r24
    3b3e:	cb 01       	movw	r24, r22
    3b40:	bc 01       	movw	r22, r24
    3b42:	cd 01       	movw	r24, r26
    3b44:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3b48:	dc 01       	movw	r26, r24
    3b4a:	cb 01       	movw	r24, r22
    3b4c:	9f 83       	std	Y+7, r25	; 0x07
    3b4e:	8e 83       	std	Y+6, r24	; 0x06
    3b50:	0f c0       	rjmp	.+30     	; 0x3b70 <HAL_SM_voidSMSetAngle+0x38e>
    3b52:	80 e9       	ldi	r24, 0x90	; 144
    3b54:	91 e0       	ldi	r25, 0x01	; 1
    3b56:	9d 83       	std	Y+5, r25	; 0x05
    3b58:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3b5a:	8c 81       	ldd	r24, Y+4	; 0x04
    3b5c:	9d 81       	ldd	r25, Y+5	; 0x05
    3b5e:	01 97       	sbiw	r24, 0x01	; 1
    3b60:	f1 f7       	brne	.-4      	; 0x3b5e <HAL_SM_voidSMSetAngle+0x37c>
    3b62:	9d 83       	std	Y+5, r25	; 0x05
    3b64:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3b66:	8e 81       	ldd	r24, Y+6	; 0x06
    3b68:	9f 81       	ldd	r25, Y+7	; 0x07
    3b6a:	01 97       	sbiw	r24, 0x01	; 1
    3b6c:	9f 83       	std	Y+7, r25	; 0x07
    3b6e:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3b70:	8e 81       	ldd	r24, Y+6	; 0x06
    3b72:	9f 81       	ldd	r25, Y+7	; 0x07
    3b74:	00 97       	sbiw	r24, 0x00	; 0
    3b76:	69 f7       	brne	.-38     	; 0x3b52 <HAL_SM_voidSMSetAngle+0x370>
    3b78:	24 c0       	rjmp	.+72     	; 0x3bc2 <HAL_SM_voidSMSetAngle+0x3e0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3b7a:	68 85       	ldd	r22, Y+8	; 0x08
    3b7c:	79 85       	ldd	r23, Y+9	; 0x09
    3b7e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3b80:	9b 85       	ldd	r25, Y+11	; 0x0b
    3b82:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3b86:	dc 01       	movw	r26, r24
    3b88:	cb 01       	movw	r24, r22
    3b8a:	9f 83       	std	Y+7, r25	; 0x07
    3b8c:	8e 83       	std	Y+6, r24	; 0x06
    3b8e:	8e 81       	ldd	r24, Y+6	; 0x06
    3b90:	9f 81       	ldd	r25, Y+7	; 0x07
    3b92:	9b 83       	std	Y+3, r25	; 0x03
    3b94:	8a 83       	std	Y+2, r24	; 0x02
    3b96:	8a 81       	ldd	r24, Y+2	; 0x02
    3b98:	9b 81       	ldd	r25, Y+3	; 0x03
    3b9a:	01 97       	sbiw	r24, 0x01	; 1
    3b9c:	f1 f7       	brne	.-4      	; 0x3b9a <HAL_SM_voidSMSetAngle+0x3b8>
    3b9e:	9b 83       	std	Y+3, r25	; 0x03
    3ba0:	8a 83       	std	Y+2, r24	; 0x02
    3ba2:	0f c0       	rjmp	.+30     	; 0x3bc2 <HAL_SM_voidSMSetAngle+0x3e0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3ba4:	69 89       	ldd	r22, Y+17	; 0x11
    3ba6:	7a 89       	ldd	r23, Y+18	; 0x12
    3ba8:	8b 89       	ldd	r24, Y+19	; 0x13
    3baa:	9c 89       	ldd	r25, Y+20	; 0x14
    3bac:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3bb0:	dc 01       	movw	r26, r24
    3bb2:	cb 01       	movw	r24, r22
    3bb4:	88 8b       	std	Y+16, r24	; 0x10
    3bb6:	88 89       	ldd	r24, Y+16	; 0x10
    3bb8:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3bba:	89 81       	ldd	r24, Y+1	; 0x01
    3bbc:	8a 95       	dec	r24
    3bbe:	f1 f7       	brne	.-4      	; 0x3bbc <HAL_SM_voidSMSetAngle+0x3da>
    3bc0:	89 83       	std	Y+1, r24	; 0x01
	} else {
		//NOTHING
	}
}
    3bc2:	e5 96       	adiw	r28, 0x35	; 53
    3bc4:	0f b6       	in	r0, 0x3f	; 63
    3bc6:	f8 94       	cli
    3bc8:	de bf       	out	0x3e, r29	; 62
    3bca:	0f be       	out	0x3f, r0	; 63
    3bcc:	cd bf       	out	0x3d, r28	; 61
    3bce:	cf 91       	pop	r28
    3bd0:	df 91       	pop	r29
    3bd2:	08 95       	ret

00003bd4 <HAL_LED_u8LedInit>:
 *  Created on: Sep 25, 2023
 *      Author: Mohamed
 */
#include "LED.h"

STD_Type HAL_LED_u8LedInit(u8 Loc_u8LEDPortID, u8 Loc_u8LEDPinID) {
    3bd4:	df 93       	push	r29
    3bd6:	cf 93       	push	r28
    3bd8:	00 d0       	rcall	.+0      	; 0x3bda <HAL_LED_u8LedInit+0x6>
    3bda:	0f 92       	push	r0
    3bdc:	cd b7       	in	r28, 0x3d	; 61
    3bde:	de b7       	in	r29, 0x3e	; 62
    3be0:	8a 83       	std	Y+2, r24	; 0x02
    3be2:	6b 83       	std	Y+3, r22	; 0x03
	u8 Loc_u8Return_Value = E_NOT_OK;
    3be4:	81 e0       	ldi	r24, 0x01	; 1
    3be6:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8LEDPortID <= PortD && Loc_u8LEDPinID <= Num_Of_Pins) {
    3be8:	8a 81       	ldd	r24, Y+2	; 0x02
    3bea:	84 30       	cpi	r24, 0x04	; 4
    3bec:	48 f4       	brcc	.+18     	; 0x3c00 <HAL_LED_u8LedInit+0x2c>
    3bee:	8b 81       	ldd	r24, Y+3	; 0x03
    3bf0:	88 30       	cpi	r24, 0x08	; 8
    3bf2:	30 f4       	brcc	.+12     	; 0x3c00 <HAL_LED_u8LedInit+0x2c>
		Loc_u8Return_Value = MCAL_DIO_u8SetPinDirection(Loc_u8LEDPortID,
    3bf4:	8a 81       	ldd	r24, Y+2	; 0x02
    3bf6:	6b 81       	ldd	r22, Y+3	; 0x03
    3bf8:	41 e0       	ldi	r20, 0x01	; 1
    3bfa:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <MCAL_DIO_u8SetPinDirection>
    3bfe:	89 83       	std	Y+1, r24	; 0x01
				Loc_u8LEDPinID, Pin_High);
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    3c00:	89 81       	ldd	r24, Y+1	; 0x01
}
    3c02:	0f 90       	pop	r0
    3c04:	0f 90       	pop	r0
    3c06:	0f 90       	pop	r0
    3c08:	cf 91       	pop	r28
    3c0a:	df 91       	pop	r29
    3c0c:	08 95       	ret

00003c0e <HAL_LED_u8LedMode>:

STD_Type HAL_LED_u8LedMode(u8 Loc_u8LEDPortID, u8 Loc_u8LEDPinID,
		u8 Loc_u8LEDMode) {
    3c0e:	df 93       	push	r29
    3c10:	cf 93       	push	r28
    3c12:	00 d0       	rcall	.+0      	; 0x3c14 <HAL_LED_u8LedMode+0x6>
    3c14:	00 d0       	rcall	.+0      	; 0x3c16 <HAL_LED_u8LedMode+0x8>
    3c16:	cd b7       	in	r28, 0x3d	; 61
    3c18:	de b7       	in	r29, 0x3e	; 62
    3c1a:	8a 83       	std	Y+2, r24	; 0x02
    3c1c:	6b 83       	std	Y+3, r22	; 0x03
    3c1e:	4c 83       	std	Y+4, r20	; 0x04
	u8 Loc_u8Return_Value = E_NOT_OK;
    3c20:	81 e0       	ldi	r24, 0x01	; 1
    3c22:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8LEDPortID <= PortD && Loc_u8LEDPinID <= Num_Of_Pins
    3c24:	8a 81       	ldd	r24, Y+2	; 0x02
    3c26:	84 30       	cpi	r24, 0x04	; 4
    3c28:	10 f5       	brcc	.+68     	; 0x3c6e <HAL_LED_u8LedMode+0x60>
    3c2a:	8b 81       	ldd	r24, Y+3	; 0x03
    3c2c:	88 30       	cpi	r24, 0x08	; 8
    3c2e:	f8 f4       	brcc	.+62     	; 0x3c6e <HAL_LED_u8LedMode+0x60>
    3c30:	8c 81       	ldd	r24, Y+4	; 0x04
    3c32:	83 30       	cpi	r24, 0x03	; 3
    3c34:	e0 f4       	brcc	.+56     	; 0x3c6e <HAL_LED_u8LedMode+0x60>
			&& Loc_u8LEDMode <= LED_TOG) {
		if (Loc_u8LEDMode == LED_ON) {
    3c36:	8c 81       	ldd	r24, Y+4	; 0x04
    3c38:	81 30       	cpi	r24, 0x01	; 1
    3c3a:	39 f4       	brne	.+14     	; 0x3c4a <HAL_LED_u8LedMode+0x3c>
			Loc_u8Return_Value = MCAL_DIO_u8SetPinValue(Loc_u8LEDPortID,
    3c3c:	8a 81       	ldd	r24, Y+2	; 0x02
    3c3e:	6b 81       	ldd	r22, Y+3	; 0x03
    3c40:	41 e0       	ldi	r20, 0x01	; 1
    3c42:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
    3c46:	89 83       	std	Y+1, r24	; 0x01
    3c48:	12 c0       	rjmp	.+36     	; 0x3c6e <HAL_LED_u8LedMode+0x60>
					Loc_u8LEDPinID, Pin_High);
		} else if (Loc_u8LEDMode == LED_OFF) {
    3c4a:	8c 81       	ldd	r24, Y+4	; 0x04
    3c4c:	88 23       	and	r24, r24
    3c4e:	39 f4       	brne	.+14     	; 0x3c5e <HAL_LED_u8LedMode+0x50>
			Loc_u8Return_Value = MCAL_DIO_u8SetPinValue(Loc_u8LEDPortID,
    3c50:	8a 81       	ldd	r24, Y+2	; 0x02
    3c52:	6b 81       	ldd	r22, Y+3	; 0x03
    3c54:	40 e0       	ldi	r20, 0x00	; 0
    3c56:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
    3c5a:	89 83       	std	Y+1, r24	; 0x01
    3c5c:	08 c0       	rjmp	.+16     	; 0x3c6e <HAL_LED_u8LedMode+0x60>
					Loc_u8LEDPinID, Pin_Low);
		} else if (Loc_u8LEDMode == LED_TOG) {
    3c5e:	8c 81       	ldd	r24, Y+4	; 0x04
    3c60:	82 30       	cpi	r24, 0x02	; 2
    3c62:	29 f4       	brne	.+10     	; 0x3c6e <HAL_LED_u8LedMode+0x60>
			Loc_u8Return_Value = MCAL_DIO_u8TogglePinValue(Loc_u8LEDPortID,
    3c64:	8a 81       	ldd	r24, Y+2	; 0x02
    3c66:	6b 81       	ldd	r22, Y+3	; 0x03
    3c68:	0e 94 52 19 	call	0x32a4	; 0x32a4 <MCAL_DIO_u8TogglePinValue>
    3c6c:	89 83       	std	Y+1, r24	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    3c6e:	89 81       	ldd	r24, Y+1	; 0x01
}
    3c70:	0f 90       	pop	r0
    3c72:	0f 90       	pop	r0
    3c74:	0f 90       	pop	r0
    3c76:	0f 90       	pop	r0
    3c78:	cf 91       	pop	r28
    3c7a:	df 91       	pop	r29
    3c7c:	08 95       	ret

00003c7e <HAL_LCD_u8LCDInit>:

#include "LCD.h"

//static u32 Counter = 0;

void HAL_LCD_u8LCDInit() {
    3c7e:	0f 93       	push	r16
    3c80:	1f 93       	push	r17
    3c82:	df 93       	push	r29
    3c84:	cf 93       	push	r28
    3c86:	cd b7       	in	r28, 0x3d	; 61
    3c88:	de b7       	in	r29, 0x3e	; 62
    3c8a:	c4 55       	subi	r28, 0x54	; 84
    3c8c:	d0 40       	sbci	r29, 0x00	; 0
    3c8e:	0f b6       	in	r0, 0x3f	; 63
    3c90:	f8 94       	cli
    3c92:	de bf       	out	0x3e, r29	; 62
    3c94:	0f be       	out	0x3f, r0	; 63
    3c96:	cd bf       	out	0x3d, r28	; 61
	MCAL_DIO_u8SetPinDirection(LCD_D_PORT, LCD_D7_PIN, Pin_High);
    3c98:	80 e0       	ldi	r24, 0x00	; 0
    3c9a:	67 e0       	ldi	r22, 0x07	; 7
    3c9c:	41 e0       	ldi	r20, 0x01	; 1
    3c9e:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(LCD_D_PORT, LCD_D6_PIN, Pin_High);
    3ca2:	80 e0       	ldi	r24, 0x00	; 0
    3ca4:	66 e0       	ldi	r22, 0x06	; 6
    3ca6:	41 e0       	ldi	r20, 0x01	; 1
    3ca8:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(LCD_D_PORT, LCD_D5_PIN, Pin_High);
    3cac:	80 e0       	ldi	r24, 0x00	; 0
    3cae:	65 e0       	ldi	r22, 0x05	; 5
    3cb0:	41 e0       	ldi	r20, 0x01	; 1
    3cb2:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(LCD_D_PORT, LCD_D4_PIN, Pin_High);
    3cb6:	80 e0       	ldi	r24, 0x00	; 0
    3cb8:	64 e0       	ldi	r22, 0x04	; 4
    3cba:	41 e0       	ldi	r20, 0x01	; 1
    3cbc:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(RS_Port, RS_Pin, Pin_High);
    3cc0:	81 e0       	ldi	r24, 0x01	; 1
    3cc2:	61 e0       	ldi	r22, 0x01	; 1
    3cc4:	41 e0       	ldi	r20, 0x01	; 1
    3cc6:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(RW_Port, RW_Pin, Pin_High);
    3cca:	81 e0       	ldi	r24, 0x01	; 1
    3ccc:	62 e0       	ldi	r22, 0x02	; 2
    3cce:	41 e0       	ldi	r20, 0x01	; 1
    3cd0:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(Enable_PORT, Enable_PIN, Pin_High);
    3cd4:	81 e0       	ldi	r24, 0x01	; 1
    3cd6:	63 e0       	ldi	r22, 0x03	; 3
    3cd8:	41 e0       	ldi	r20, 0x01	; 1
    3cda:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <MCAL_DIO_u8SetPinDirection>
    3cde:	fe 01       	movw	r30, r28
    3ce0:	ef 5a       	subi	r30, 0xAF	; 175
    3ce2:	ff 4f       	sbci	r31, 0xFF	; 255
    3ce4:	80 e0       	ldi	r24, 0x00	; 0
    3ce6:	90 e0       	ldi	r25, 0x00	; 0
    3ce8:	a0 e0       	ldi	r26, 0x00	; 0
    3cea:	b0 e4       	ldi	r27, 0x40	; 64
    3cec:	80 83       	st	Z, r24
    3cee:	91 83       	std	Z+1, r25	; 0x01
    3cf0:	a2 83       	std	Z+2, r26	; 0x02
    3cf2:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3cf4:	8e 01       	movw	r16, r28
    3cf6:	03 5b       	subi	r16, 0xB3	; 179
    3cf8:	1f 4f       	sbci	r17, 0xFF	; 255
    3cfa:	fe 01       	movw	r30, r28
    3cfc:	ef 5a       	subi	r30, 0xAF	; 175
    3cfe:	ff 4f       	sbci	r31, 0xFF	; 255
    3d00:	60 81       	ld	r22, Z
    3d02:	71 81       	ldd	r23, Z+1	; 0x01
    3d04:	82 81       	ldd	r24, Z+2	; 0x02
    3d06:	93 81       	ldd	r25, Z+3	; 0x03
    3d08:	20 e0       	ldi	r18, 0x00	; 0
    3d0a:	30 e0       	ldi	r19, 0x00	; 0
    3d0c:	4a e7       	ldi	r20, 0x7A	; 122
    3d0e:	55 e4       	ldi	r21, 0x45	; 69
    3d10:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3d14:	dc 01       	movw	r26, r24
    3d16:	cb 01       	movw	r24, r22
    3d18:	f8 01       	movw	r30, r16
    3d1a:	80 83       	st	Z, r24
    3d1c:	91 83       	std	Z+1, r25	; 0x01
    3d1e:	a2 83       	std	Z+2, r26	; 0x02
    3d20:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    3d22:	fe 01       	movw	r30, r28
    3d24:	e3 5b       	subi	r30, 0xB3	; 179
    3d26:	ff 4f       	sbci	r31, 0xFF	; 255
    3d28:	60 81       	ld	r22, Z
    3d2a:	71 81       	ldd	r23, Z+1	; 0x01
    3d2c:	82 81       	ldd	r24, Z+2	; 0x02
    3d2e:	93 81       	ldd	r25, Z+3	; 0x03
    3d30:	20 e0       	ldi	r18, 0x00	; 0
    3d32:	30 e0       	ldi	r19, 0x00	; 0
    3d34:	40 e8       	ldi	r20, 0x80	; 128
    3d36:	5f e3       	ldi	r21, 0x3F	; 63
    3d38:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3d3c:	88 23       	and	r24, r24
    3d3e:	44 f4       	brge	.+16     	; 0x3d50 <HAL_LCD_u8LCDInit+0xd2>
		__ticks = 1;
    3d40:	fe 01       	movw	r30, r28
    3d42:	e5 5b       	subi	r30, 0xB5	; 181
    3d44:	ff 4f       	sbci	r31, 0xFF	; 255
    3d46:	81 e0       	ldi	r24, 0x01	; 1
    3d48:	90 e0       	ldi	r25, 0x00	; 0
    3d4a:	91 83       	std	Z+1, r25	; 0x01
    3d4c:	80 83       	st	Z, r24
    3d4e:	64 c0       	rjmp	.+200    	; 0x3e18 <HAL_LCD_u8LCDInit+0x19a>
	else if (__tmp > 65535)
    3d50:	fe 01       	movw	r30, r28
    3d52:	e3 5b       	subi	r30, 0xB3	; 179
    3d54:	ff 4f       	sbci	r31, 0xFF	; 255
    3d56:	60 81       	ld	r22, Z
    3d58:	71 81       	ldd	r23, Z+1	; 0x01
    3d5a:	82 81       	ldd	r24, Z+2	; 0x02
    3d5c:	93 81       	ldd	r25, Z+3	; 0x03
    3d5e:	20 e0       	ldi	r18, 0x00	; 0
    3d60:	3f ef       	ldi	r19, 0xFF	; 255
    3d62:	4f e7       	ldi	r20, 0x7F	; 127
    3d64:	57 e4       	ldi	r21, 0x47	; 71
    3d66:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3d6a:	18 16       	cp	r1, r24
    3d6c:	0c f0       	brlt	.+2      	; 0x3d70 <HAL_LCD_u8LCDInit+0xf2>
    3d6e:	43 c0       	rjmp	.+134    	; 0x3df6 <HAL_LCD_u8LCDInit+0x178>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3d70:	fe 01       	movw	r30, r28
    3d72:	ef 5a       	subi	r30, 0xAF	; 175
    3d74:	ff 4f       	sbci	r31, 0xFF	; 255
    3d76:	60 81       	ld	r22, Z
    3d78:	71 81       	ldd	r23, Z+1	; 0x01
    3d7a:	82 81       	ldd	r24, Z+2	; 0x02
    3d7c:	93 81       	ldd	r25, Z+3	; 0x03
    3d7e:	20 e0       	ldi	r18, 0x00	; 0
    3d80:	30 e0       	ldi	r19, 0x00	; 0
    3d82:	40 e2       	ldi	r20, 0x20	; 32
    3d84:	51 e4       	ldi	r21, 0x41	; 65
    3d86:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3d8a:	dc 01       	movw	r26, r24
    3d8c:	cb 01       	movw	r24, r22
    3d8e:	8e 01       	movw	r16, r28
    3d90:	05 5b       	subi	r16, 0xB5	; 181
    3d92:	1f 4f       	sbci	r17, 0xFF	; 255
    3d94:	bc 01       	movw	r22, r24
    3d96:	cd 01       	movw	r24, r26
    3d98:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3d9c:	dc 01       	movw	r26, r24
    3d9e:	cb 01       	movw	r24, r22
    3da0:	f8 01       	movw	r30, r16
    3da2:	91 83       	std	Z+1, r25	; 0x01
    3da4:	80 83       	st	Z, r24
    3da6:	1f c0       	rjmp	.+62     	; 0x3de6 <HAL_LCD_u8LCDInit+0x168>
    3da8:	fe 01       	movw	r30, r28
    3daa:	e7 5b       	subi	r30, 0xB7	; 183
    3dac:	ff 4f       	sbci	r31, 0xFF	; 255
    3dae:	80 e9       	ldi	r24, 0x90	; 144
    3db0:	91 e0       	ldi	r25, 0x01	; 1
    3db2:	91 83       	std	Z+1, r25	; 0x01
    3db4:	80 83       	st	Z, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3db6:	fe 01       	movw	r30, r28
    3db8:	e7 5b       	subi	r30, 0xB7	; 183
    3dba:	ff 4f       	sbci	r31, 0xFF	; 255
    3dbc:	80 81       	ld	r24, Z
    3dbe:	91 81       	ldd	r25, Z+1	; 0x01
    3dc0:	01 97       	sbiw	r24, 0x01	; 1
    3dc2:	f1 f7       	brne	.-4      	; 0x3dc0 <HAL_LCD_u8LCDInit+0x142>
    3dc4:	fe 01       	movw	r30, r28
    3dc6:	e7 5b       	subi	r30, 0xB7	; 183
    3dc8:	ff 4f       	sbci	r31, 0xFF	; 255
    3dca:	91 83       	std	Z+1, r25	; 0x01
    3dcc:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3dce:	de 01       	movw	r26, r28
    3dd0:	a5 5b       	subi	r26, 0xB5	; 181
    3dd2:	bf 4f       	sbci	r27, 0xFF	; 255
    3dd4:	fe 01       	movw	r30, r28
    3dd6:	e5 5b       	subi	r30, 0xB5	; 181
    3dd8:	ff 4f       	sbci	r31, 0xFF	; 255
    3dda:	80 81       	ld	r24, Z
    3ddc:	91 81       	ldd	r25, Z+1	; 0x01
    3dde:	01 97       	sbiw	r24, 0x01	; 1
    3de0:	11 96       	adiw	r26, 0x01	; 1
    3de2:	9c 93       	st	X, r25
    3de4:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3de6:	fe 01       	movw	r30, r28
    3de8:	e5 5b       	subi	r30, 0xB5	; 181
    3dea:	ff 4f       	sbci	r31, 0xFF	; 255
    3dec:	80 81       	ld	r24, Z
    3dee:	91 81       	ldd	r25, Z+1	; 0x01
    3df0:	00 97       	sbiw	r24, 0x00	; 0
    3df2:	d1 f6       	brne	.-76     	; 0x3da8 <HAL_LCD_u8LCDInit+0x12a>
    3df4:	27 c0       	rjmp	.+78     	; 0x3e44 <HAL_LCD_u8LCDInit+0x1c6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3df6:	8e 01       	movw	r16, r28
    3df8:	05 5b       	subi	r16, 0xB5	; 181
    3dfa:	1f 4f       	sbci	r17, 0xFF	; 255
    3dfc:	fe 01       	movw	r30, r28
    3dfe:	e3 5b       	subi	r30, 0xB3	; 179
    3e00:	ff 4f       	sbci	r31, 0xFF	; 255
    3e02:	60 81       	ld	r22, Z
    3e04:	71 81       	ldd	r23, Z+1	; 0x01
    3e06:	82 81       	ldd	r24, Z+2	; 0x02
    3e08:	93 81       	ldd	r25, Z+3	; 0x03
    3e0a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3e0e:	dc 01       	movw	r26, r24
    3e10:	cb 01       	movw	r24, r22
    3e12:	f8 01       	movw	r30, r16
    3e14:	91 83       	std	Z+1, r25	; 0x01
    3e16:	80 83       	st	Z, r24
    3e18:	de 01       	movw	r26, r28
    3e1a:	a9 5b       	subi	r26, 0xB9	; 185
    3e1c:	bf 4f       	sbci	r27, 0xFF	; 255
    3e1e:	fe 01       	movw	r30, r28
    3e20:	e5 5b       	subi	r30, 0xB5	; 181
    3e22:	ff 4f       	sbci	r31, 0xFF	; 255
    3e24:	80 81       	ld	r24, Z
    3e26:	91 81       	ldd	r25, Z+1	; 0x01
    3e28:	8d 93       	st	X+, r24
    3e2a:	9c 93       	st	X, r25
    3e2c:	fe 01       	movw	r30, r28
    3e2e:	e9 5b       	subi	r30, 0xB9	; 185
    3e30:	ff 4f       	sbci	r31, 0xFF	; 255
    3e32:	80 81       	ld	r24, Z
    3e34:	91 81       	ldd	r25, Z+1	; 0x01
    3e36:	01 97       	sbiw	r24, 0x01	; 1
    3e38:	f1 f7       	brne	.-4      	; 0x3e36 <HAL_LCD_u8LCDInit+0x1b8>
    3e3a:	fe 01       	movw	r30, r28
    3e3c:	e9 5b       	subi	r30, 0xB9	; 185
    3e3e:	ff 4f       	sbci	r31, 0xFF	; 255
    3e40:	91 83       	std	Z+1, r25	; 0x01
    3e42:	80 83       	st	Z, r24
	_delay_ms(2);
	HAL_LCD_u8SendCommands(Reset);
    3e44:	82 e0       	ldi	r24, 0x02	; 2
    3e46:	0e 94 8d 21 	call	0x431a	; 0x431a <HAL_LCD_u8SendCommands>
    3e4a:	fe 01       	movw	r30, r28
    3e4c:	ed 5b       	subi	r30, 0xBD	; 189
    3e4e:	ff 4f       	sbci	r31, 0xFF	; 255
    3e50:	80 e0       	ldi	r24, 0x00	; 0
    3e52:	90 e0       	ldi	r25, 0x00	; 0
    3e54:	a0 e0       	ldi	r26, 0x00	; 0
    3e56:	b0 e4       	ldi	r27, 0x40	; 64
    3e58:	80 83       	st	Z, r24
    3e5a:	91 83       	std	Z+1, r25	; 0x01
    3e5c:	a2 83       	std	Z+2, r26	; 0x02
    3e5e:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3e60:	8e 01       	movw	r16, r28
    3e62:	01 5c       	subi	r16, 0xC1	; 193
    3e64:	1f 4f       	sbci	r17, 0xFF	; 255
    3e66:	fe 01       	movw	r30, r28
    3e68:	ed 5b       	subi	r30, 0xBD	; 189
    3e6a:	ff 4f       	sbci	r31, 0xFF	; 255
    3e6c:	60 81       	ld	r22, Z
    3e6e:	71 81       	ldd	r23, Z+1	; 0x01
    3e70:	82 81       	ldd	r24, Z+2	; 0x02
    3e72:	93 81       	ldd	r25, Z+3	; 0x03
    3e74:	20 e0       	ldi	r18, 0x00	; 0
    3e76:	30 e0       	ldi	r19, 0x00	; 0
    3e78:	4a e7       	ldi	r20, 0x7A	; 122
    3e7a:	55 e4       	ldi	r21, 0x45	; 69
    3e7c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3e80:	dc 01       	movw	r26, r24
    3e82:	cb 01       	movw	r24, r22
    3e84:	f8 01       	movw	r30, r16
    3e86:	80 83       	st	Z, r24
    3e88:	91 83       	std	Z+1, r25	; 0x01
    3e8a:	a2 83       	std	Z+2, r26	; 0x02
    3e8c:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    3e8e:	fe 01       	movw	r30, r28
    3e90:	ff 96       	adiw	r30, 0x3f	; 63
    3e92:	60 81       	ld	r22, Z
    3e94:	71 81       	ldd	r23, Z+1	; 0x01
    3e96:	82 81       	ldd	r24, Z+2	; 0x02
    3e98:	93 81       	ldd	r25, Z+3	; 0x03
    3e9a:	20 e0       	ldi	r18, 0x00	; 0
    3e9c:	30 e0       	ldi	r19, 0x00	; 0
    3e9e:	40 e8       	ldi	r20, 0x80	; 128
    3ea0:	5f e3       	ldi	r21, 0x3F	; 63
    3ea2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3ea6:	88 23       	and	r24, r24
    3ea8:	2c f4       	brge	.+10     	; 0x3eb4 <HAL_LCD_u8LCDInit+0x236>
		__ticks = 1;
    3eaa:	81 e0       	ldi	r24, 0x01	; 1
    3eac:	90 e0       	ldi	r25, 0x00	; 0
    3eae:	9e af       	std	Y+62, r25	; 0x3e
    3eb0:	8d af       	std	Y+61, r24	; 0x3d
    3eb2:	46 c0       	rjmp	.+140    	; 0x3f40 <HAL_LCD_u8LCDInit+0x2c2>
	else if (__tmp > 65535)
    3eb4:	fe 01       	movw	r30, r28
    3eb6:	ff 96       	adiw	r30, 0x3f	; 63
    3eb8:	60 81       	ld	r22, Z
    3eba:	71 81       	ldd	r23, Z+1	; 0x01
    3ebc:	82 81       	ldd	r24, Z+2	; 0x02
    3ebe:	93 81       	ldd	r25, Z+3	; 0x03
    3ec0:	20 e0       	ldi	r18, 0x00	; 0
    3ec2:	3f ef       	ldi	r19, 0xFF	; 255
    3ec4:	4f e7       	ldi	r20, 0x7F	; 127
    3ec6:	57 e4       	ldi	r21, 0x47	; 71
    3ec8:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3ecc:	18 16       	cp	r1, r24
    3ece:	64 f5       	brge	.+88     	; 0x3f28 <HAL_LCD_u8LCDInit+0x2aa>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3ed0:	fe 01       	movw	r30, r28
    3ed2:	ed 5b       	subi	r30, 0xBD	; 189
    3ed4:	ff 4f       	sbci	r31, 0xFF	; 255
    3ed6:	60 81       	ld	r22, Z
    3ed8:	71 81       	ldd	r23, Z+1	; 0x01
    3eda:	82 81       	ldd	r24, Z+2	; 0x02
    3edc:	93 81       	ldd	r25, Z+3	; 0x03
    3ede:	20 e0       	ldi	r18, 0x00	; 0
    3ee0:	30 e0       	ldi	r19, 0x00	; 0
    3ee2:	40 e2       	ldi	r20, 0x20	; 32
    3ee4:	51 e4       	ldi	r21, 0x41	; 65
    3ee6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3eea:	dc 01       	movw	r26, r24
    3eec:	cb 01       	movw	r24, r22
    3eee:	bc 01       	movw	r22, r24
    3ef0:	cd 01       	movw	r24, r26
    3ef2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3ef6:	dc 01       	movw	r26, r24
    3ef8:	cb 01       	movw	r24, r22
    3efa:	9e af       	std	Y+62, r25	; 0x3e
    3efc:	8d af       	std	Y+61, r24	; 0x3d
    3efe:	0f c0       	rjmp	.+30     	; 0x3f1e <HAL_LCD_u8LCDInit+0x2a0>
    3f00:	80 e9       	ldi	r24, 0x90	; 144
    3f02:	91 e0       	ldi	r25, 0x01	; 1
    3f04:	9c af       	std	Y+60, r25	; 0x3c
    3f06:	8b af       	std	Y+59, r24	; 0x3b
    3f08:	8b ad       	ldd	r24, Y+59	; 0x3b
    3f0a:	9c ad       	ldd	r25, Y+60	; 0x3c
    3f0c:	01 97       	sbiw	r24, 0x01	; 1
    3f0e:	f1 f7       	brne	.-4      	; 0x3f0c <HAL_LCD_u8LCDInit+0x28e>
    3f10:	9c af       	std	Y+60, r25	; 0x3c
    3f12:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3f14:	8d ad       	ldd	r24, Y+61	; 0x3d
    3f16:	9e ad       	ldd	r25, Y+62	; 0x3e
    3f18:	01 97       	sbiw	r24, 0x01	; 1
    3f1a:	9e af       	std	Y+62, r25	; 0x3e
    3f1c:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3f1e:	8d ad       	ldd	r24, Y+61	; 0x3d
    3f20:	9e ad       	ldd	r25, Y+62	; 0x3e
    3f22:	00 97       	sbiw	r24, 0x00	; 0
    3f24:	69 f7       	brne	.-38     	; 0x3f00 <HAL_LCD_u8LCDInit+0x282>
    3f26:	16 c0       	rjmp	.+44     	; 0x3f54 <HAL_LCD_u8LCDInit+0x2d6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3f28:	fe 01       	movw	r30, r28
    3f2a:	ff 96       	adiw	r30, 0x3f	; 63
    3f2c:	60 81       	ld	r22, Z
    3f2e:	71 81       	ldd	r23, Z+1	; 0x01
    3f30:	82 81       	ldd	r24, Z+2	; 0x02
    3f32:	93 81       	ldd	r25, Z+3	; 0x03
    3f34:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3f38:	dc 01       	movw	r26, r24
    3f3a:	cb 01       	movw	r24, r22
    3f3c:	9e af       	std	Y+62, r25	; 0x3e
    3f3e:	8d af       	std	Y+61, r24	; 0x3d
    3f40:	8d ad       	ldd	r24, Y+61	; 0x3d
    3f42:	9e ad       	ldd	r25, Y+62	; 0x3e
    3f44:	9a af       	std	Y+58, r25	; 0x3a
    3f46:	89 af       	std	Y+57, r24	; 0x39
    3f48:	89 ad       	ldd	r24, Y+57	; 0x39
    3f4a:	9a ad       	ldd	r25, Y+58	; 0x3a
    3f4c:	01 97       	sbiw	r24, 0x01	; 1
    3f4e:	f1 f7       	brne	.-4      	; 0x3f4c <HAL_LCD_u8LCDInit+0x2ce>
    3f50:	9a af       	std	Y+58, r25	; 0x3a
    3f52:	89 af       	std	Y+57, r24	; 0x39
	_delay_ms(2);
	HAL_LCD_u8SendCommands(Function_Set);
    3f54:	88 e2       	ldi	r24, 0x28	; 40
    3f56:	0e 94 8d 21 	call	0x431a	; 0x431a <HAL_LCD_u8SendCommands>
    3f5a:	80 e0       	ldi	r24, 0x00	; 0
    3f5c:	90 e0       	ldi	r25, 0x00	; 0
    3f5e:	a0 e0       	ldi	r26, 0x00	; 0
    3f60:	b0 e4       	ldi	r27, 0x40	; 64
    3f62:	8d ab       	std	Y+53, r24	; 0x35
    3f64:	9e ab       	std	Y+54, r25	; 0x36
    3f66:	af ab       	std	Y+55, r26	; 0x37
    3f68:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3f6a:	6d a9       	ldd	r22, Y+53	; 0x35
    3f6c:	7e a9       	ldd	r23, Y+54	; 0x36
    3f6e:	8f a9       	ldd	r24, Y+55	; 0x37
    3f70:	98 ad       	ldd	r25, Y+56	; 0x38
    3f72:	20 e0       	ldi	r18, 0x00	; 0
    3f74:	30 e0       	ldi	r19, 0x00	; 0
    3f76:	4a e7       	ldi	r20, 0x7A	; 122
    3f78:	55 e4       	ldi	r21, 0x45	; 69
    3f7a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3f7e:	dc 01       	movw	r26, r24
    3f80:	cb 01       	movw	r24, r22
    3f82:	89 ab       	std	Y+49, r24	; 0x31
    3f84:	9a ab       	std	Y+50, r25	; 0x32
    3f86:	ab ab       	std	Y+51, r26	; 0x33
    3f88:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    3f8a:	69 a9       	ldd	r22, Y+49	; 0x31
    3f8c:	7a a9       	ldd	r23, Y+50	; 0x32
    3f8e:	8b a9       	ldd	r24, Y+51	; 0x33
    3f90:	9c a9       	ldd	r25, Y+52	; 0x34
    3f92:	20 e0       	ldi	r18, 0x00	; 0
    3f94:	30 e0       	ldi	r19, 0x00	; 0
    3f96:	40 e8       	ldi	r20, 0x80	; 128
    3f98:	5f e3       	ldi	r21, 0x3F	; 63
    3f9a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3f9e:	88 23       	and	r24, r24
    3fa0:	2c f4       	brge	.+10     	; 0x3fac <HAL_LCD_u8LCDInit+0x32e>
		__ticks = 1;
    3fa2:	81 e0       	ldi	r24, 0x01	; 1
    3fa4:	90 e0       	ldi	r25, 0x00	; 0
    3fa6:	98 ab       	std	Y+48, r25	; 0x30
    3fa8:	8f a7       	std	Y+47, r24	; 0x2f
    3faa:	3f c0       	rjmp	.+126    	; 0x402a <HAL_LCD_u8LCDInit+0x3ac>
	else if (__tmp > 65535)
    3fac:	69 a9       	ldd	r22, Y+49	; 0x31
    3fae:	7a a9       	ldd	r23, Y+50	; 0x32
    3fb0:	8b a9       	ldd	r24, Y+51	; 0x33
    3fb2:	9c a9       	ldd	r25, Y+52	; 0x34
    3fb4:	20 e0       	ldi	r18, 0x00	; 0
    3fb6:	3f ef       	ldi	r19, 0xFF	; 255
    3fb8:	4f e7       	ldi	r20, 0x7F	; 127
    3fba:	57 e4       	ldi	r21, 0x47	; 71
    3fbc:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3fc0:	18 16       	cp	r1, r24
    3fc2:	4c f5       	brge	.+82     	; 0x4016 <HAL_LCD_u8LCDInit+0x398>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3fc4:	6d a9       	ldd	r22, Y+53	; 0x35
    3fc6:	7e a9       	ldd	r23, Y+54	; 0x36
    3fc8:	8f a9       	ldd	r24, Y+55	; 0x37
    3fca:	98 ad       	ldd	r25, Y+56	; 0x38
    3fcc:	20 e0       	ldi	r18, 0x00	; 0
    3fce:	30 e0       	ldi	r19, 0x00	; 0
    3fd0:	40 e2       	ldi	r20, 0x20	; 32
    3fd2:	51 e4       	ldi	r21, 0x41	; 65
    3fd4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3fd8:	dc 01       	movw	r26, r24
    3fda:	cb 01       	movw	r24, r22
    3fdc:	bc 01       	movw	r22, r24
    3fde:	cd 01       	movw	r24, r26
    3fe0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3fe4:	dc 01       	movw	r26, r24
    3fe6:	cb 01       	movw	r24, r22
    3fe8:	98 ab       	std	Y+48, r25	; 0x30
    3fea:	8f a7       	std	Y+47, r24	; 0x2f
    3fec:	0f c0       	rjmp	.+30     	; 0x400c <HAL_LCD_u8LCDInit+0x38e>
    3fee:	80 e9       	ldi	r24, 0x90	; 144
    3ff0:	91 e0       	ldi	r25, 0x01	; 1
    3ff2:	9e a7       	std	Y+46, r25	; 0x2e
    3ff4:	8d a7       	std	Y+45, r24	; 0x2d
    3ff6:	8d a5       	ldd	r24, Y+45	; 0x2d
    3ff8:	9e a5       	ldd	r25, Y+46	; 0x2e
    3ffa:	01 97       	sbiw	r24, 0x01	; 1
    3ffc:	f1 f7       	brne	.-4      	; 0x3ffa <HAL_LCD_u8LCDInit+0x37c>
    3ffe:	9e a7       	std	Y+46, r25	; 0x2e
    4000:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4002:	8f a5       	ldd	r24, Y+47	; 0x2f
    4004:	98 a9       	ldd	r25, Y+48	; 0x30
    4006:	01 97       	sbiw	r24, 0x01	; 1
    4008:	98 ab       	std	Y+48, r25	; 0x30
    400a:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    400c:	8f a5       	ldd	r24, Y+47	; 0x2f
    400e:	98 a9       	ldd	r25, Y+48	; 0x30
    4010:	00 97       	sbiw	r24, 0x00	; 0
    4012:	69 f7       	brne	.-38     	; 0x3fee <HAL_LCD_u8LCDInit+0x370>
    4014:	14 c0       	rjmp	.+40     	; 0x403e <HAL_LCD_u8LCDInit+0x3c0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4016:	69 a9       	ldd	r22, Y+49	; 0x31
    4018:	7a a9       	ldd	r23, Y+50	; 0x32
    401a:	8b a9       	ldd	r24, Y+51	; 0x33
    401c:	9c a9       	ldd	r25, Y+52	; 0x34
    401e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4022:	dc 01       	movw	r26, r24
    4024:	cb 01       	movw	r24, r22
    4026:	98 ab       	std	Y+48, r25	; 0x30
    4028:	8f a7       	std	Y+47, r24	; 0x2f
    402a:	8f a5       	ldd	r24, Y+47	; 0x2f
    402c:	98 a9       	ldd	r25, Y+48	; 0x30
    402e:	9c a7       	std	Y+44, r25	; 0x2c
    4030:	8b a7       	std	Y+43, r24	; 0x2b
    4032:	8b a5       	ldd	r24, Y+43	; 0x2b
    4034:	9c a5       	ldd	r25, Y+44	; 0x2c
    4036:	01 97       	sbiw	r24, 0x01	; 1
    4038:	f1 f7       	brne	.-4      	; 0x4036 <HAL_LCD_u8LCDInit+0x3b8>
    403a:	9c a7       	std	Y+44, r25	; 0x2c
    403c:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(2);
	HAL_LCD_u8SendCommands(Display_Mode);
    403e:	8f e0       	ldi	r24, 0x0F	; 15
    4040:	0e 94 8d 21 	call	0x431a	; 0x431a <HAL_LCD_u8SendCommands>
    4044:	80 e0       	ldi	r24, 0x00	; 0
    4046:	90 e0       	ldi	r25, 0x00	; 0
    4048:	a0 e0       	ldi	r26, 0x00	; 0
    404a:	b0 e4       	ldi	r27, 0x40	; 64
    404c:	8f a3       	std	Y+39, r24	; 0x27
    404e:	98 a7       	std	Y+40, r25	; 0x28
    4050:	a9 a7       	std	Y+41, r26	; 0x29
    4052:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4054:	6f a1       	ldd	r22, Y+39	; 0x27
    4056:	78 a5       	ldd	r23, Y+40	; 0x28
    4058:	89 a5       	ldd	r24, Y+41	; 0x29
    405a:	9a a5       	ldd	r25, Y+42	; 0x2a
    405c:	20 e0       	ldi	r18, 0x00	; 0
    405e:	30 e0       	ldi	r19, 0x00	; 0
    4060:	4a e7       	ldi	r20, 0x7A	; 122
    4062:	55 e4       	ldi	r21, 0x45	; 69
    4064:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4068:	dc 01       	movw	r26, r24
    406a:	cb 01       	movw	r24, r22
    406c:	8b a3       	std	Y+35, r24	; 0x23
    406e:	9c a3       	std	Y+36, r25	; 0x24
    4070:	ad a3       	std	Y+37, r26	; 0x25
    4072:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    4074:	6b a1       	ldd	r22, Y+35	; 0x23
    4076:	7c a1       	ldd	r23, Y+36	; 0x24
    4078:	8d a1       	ldd	r24, Y+37	; 0x25
    407a:	9e a1       	ldd	r25, Y+38	; 0x26
    407c:	20 e0       	ldi	r18, 0x00	; 0
    407e:	30 e0       	ldi	r19, 0x00	; 0
    4080:	40 e8       	ldi	r20, 0x80	; 128
    4082:	5f e3       	ldi	r21, 0x3F	; 63
    4084:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4088:	88 23       	and	r24, r24
    408a:	2c f4       	brge	.+10     	; 0x4096 <HAL_LCD_u8LCDInit+0x418>
		__ticks = 1;
    408c:	81 e0       	ldi	r24, 0x01	; 1
    408e:	90 e0       	ldi	r25, 0x00	; 0
    4090:	9a a3       	std	Y+34, r25	; 0x22
    4092:	89 a3       	std	Y+33, r24	; 0x21
    4094:	3f c0       	rjmp	.+126    	; 0x4114 <HAL_LCD_u8LCDInit+0x496>
	else if (__tmp > 65535)
    4096:	6b a1       	ldd	r22, Y+35	; 0x23
    4098:	7c a1       	ldd	r23, Y+36	; 0x24
    409a:	8d a1       	ldd	r24, Y+37	; 0x25
    409c:	9e a1       	ldd	r25, Y+38	; 0x26
    409e:	20 e0       	ldi	r18, 0x00	; 0
    40a0:	3f ef       	ldi	r19, 0xFF	; 255
    40a2:	4f e7       	ldi	r20, 0x7F	; 127
    40a4:	57 e4       	ldi	r21, 0x47	; 71
    40a6:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    40aa:	18 16       	cp	r1, r24
    40ac:	4c f5       	brge	.+82     	; 0x4100 <HAL_LCD_u8LCDInit+0x482>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    40ae:	6f a1       	ldd	r22, Y+39	; 0x27
    40b0:	78 a5       	ldd	r23, Y+40	; 0x28
    40b2:	89 a5       	ldd	r24, Y+41	; 0x29
    40b4:	9a a5       	ldd	r25, Y+42	; 0x2a
    40b6:	20 e0       	ldi	r18, 0x00	; 0
    40b8:	30 e0       	ldi	r19, 0x00	; 0
    40ba:	40 e2       	ldi	r20, 0x20	; 32
    40bc:	51 e4       	ldi	r21, 0x41	; 65
    40be:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    40c2:	dc 01       	movw	r26, r24
    40c4:	cb 01       	movw	r24, r22
    40c6:	bc 01       	movw	r22, r24
    40c8:	cd 01       	movw	r24, r26
    40ca:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    40ce:	dc 01       	movw	r26, r24
    40d0:	cb 01       	movw	r24, r22
    40d2:	9a a3       	std	Y+34, r25	; 0x22
    40d4:	89 a3       	std	Y+33, r24	; 0x21
    40d6:	0f c0       	rjmp	.+30     	; 0x40f6 <HAL_LCD_u8LCDInit+0x478>
    40d8:	80 e9       	ldi	r24, 0x90	; 144
    40da:	91 e0       	ldi	r25, 0x01	; 1
    40dc:	98 a3       	std	Y+32, r25	; 0x20
    40de:	8f 8f       	std	Y+31, r24	; 0x1f
    40e0:	8f 8d       	ldd	r24, Y+31	; 0x1f
    40e2:	98 a1       	ldd	r25, Y+32	; 0x20
    40e4:	01 97       	sbiw	r24, 0x01	; 1
    40e6:	f1 f7       	brne	.-4      	; 0x40e4 <HAL_LCD_u8LCDInit+0x466>
    40e8:	98 a3       	std	Y+32, r25	; 0x20
    40ea:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    40ec:	89 a1       	ldd	r24, Y+33	; 0x21
    40ee:	9a a1       	ldd	r25, Y+34	; 0x22
    40f0:	01 97       	sbiw	r24, 0x01	; 1
    40f2:	9a a3       	std	Y+34, r25	; 0x22
    40f4:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    40f6:	89 a1       	ldd	r24, Y+33	; 0x21
    40f8:	9a a1       	ldd	r25, Y+34	; 0x22
    40fa:	00 97       	sbiw	r24, 0x00	; 0
    40fc:	69 f7       	brne	.-38     	; 0x40d8 <HAL_LCD_u8LCDInit+0x45a>
    40fe:	14 c0       	rjmp	.+40     	; 0x4128 <HAL_LCD_u8LCDInit+0x4aa>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4100:	6b a1       	ldd	r22, Y+35	; 0x23
    4102:	7c a1       	ldd	r23, Y+36	; 0x24
    4104:	8d a1       	ldd	r24, Y+37	; 0x25
    4106:	9e a1       	ldd	r25, Y+38	; 0x26
    4108:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    410c:	dc 01       	movw	r26, r24
    410e:	cb 01       	movw	r24, r22
    4110:	9a a3       	std	Y+34, r25	; 0x22
    4112:	89 a3       	std	Y+33, r24	; 0x21
    4114:	89 a1       	ldd	r24, Y+33	; 0x21
    4116:	9a a1       	ldd	r25, Y+34	; 0x22
    4118:	9e 8f       	std	Y+30, r25	; 0x1e
    411a:	8d 8f       	std	Y+29, r24	; 0x1d
    411c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    411e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    4120:	01 97       	sbiw	r24, 0x01	; 1
    4122:	f1 f7       	brne	.-4      	; 0x4120 <HAL_LCD_u8LCDInit+0x4a2>
    4124:	9e 8f       	std	Y+30, r25	; 0x1e
    4126:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(2);
	HAL_LCD_u8SendCommands(Display_Clear);
    4128:	81 e0       	ldi	r24, 0x01	; 1
    412a:	0e 94 8d 21 	call	0x431a	; 0x431a <HAL_LCD_u8SendCommands>
    412e:	80 e0       	ldi	r24, 0x00	; 0
    4130:	90 e0       	ldi	r25, 0x00	; 0
    4132:	a0 e0       	ldi	r26, 0x00	; 0
    4134:	b0 e4       	ldi	r27, 0x40	; 64
    4136:	89 8f       	std	Y+25, r24	; 0x19
    4138:	9a 8f       	std	Y+26, r25	; 0x1a
    413a:	ab 8f       	std	Y+27, r26	; 0x1b
    413c:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    413e:	69 8d       	ldd	r22, Y+25	; 0x19
    4140:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4142:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4144:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4146:	20 e0       	ldi	r18, 0x00	; 0
    4148:	30 e0       	ldi	r19, 0x00	; 0
    414a:	4a e7       	ldi	r20, 0x7A	; 122
    414c:	55 e4       	ldi	r21, 0x45	; 69
    414e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4152:	dc 01       	movw	r26, r24
    4154:	cb 01       	movw	r24, r22
    4156:	8d 8b       	std	Y+21, r24	; 0x15
    4158:	9e 8b       	std	Y+22, r25	; 0x16
    415a:	af 8b       	std	Y+23, r26	; 0x17
    415c:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    415e:	6d 89       	ldd	r22, Y+21	; 0x15
    4160:	7e 89       	ldd	r23, Y+22	; 0x16
    4162:	8f 89       	ldd	r24, Y+23	; 0x17
    4164:	98 8d       	ldd	r25, Y+24	; 0x18
    4166:	20 e0       	ldi	r18, 0x00	; 0
    4168:	30 e0       	ldi	r19, 0x00	; 0
    416a:	40 e8       	ldi	r20, 0x80	; 128
    416c:	5f e3       	ldi	r21, 0x3F	; 63
    416e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4172:	88 23       	and	r24, r24
    4174:	2c f4       	brge	.+10     	; 0x4180 <HAL_LCD_u8LCDInit+0x502>
		__ticks = 1;
    4176:	81 e0       	ldi	r24, 0x01	; 1
    4178:	90 e0       	ldi	r25, 0x00	; 0
    417a:	9c 8b       	std	Y+20, r25	; 0x14
    417c:	8b 8b       	std	Y+19, r24	; 0x13
    417e:	3f c0       	rjmp	.+126    	; 0x41fe <HAL_LCD_u8LCDInit+0x580>
	else if (__tmp > 65535)
    4180:	6d 89       	ldd	r22, Y+21	; 0x15
    4182:	7e 89       	ldd	r23, Y+22	; 0x16
    4184:	8f 89       	ldd	r24, Y+23	; 0x17
    4186:	98 8d       	ldd	r25, Y+24	; 0x18
    4188:	20 e0       	ldi	r18, 0x00	; 0
    418a:	3f ef       	ldi	r19, 0xFF	; 255
    418c:	4f e7       	ldi	r20, 0x7F	; 127
    418e:	57 e4       	ldi	r21, 0x47	; 71
    4190:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4194:	18 16       	cp	r1, r24
    4196:	4c f5       	brge	.+82     	; 0x41ea <HAL_LCD_u8LCDInit+0x56c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4198:	69 8d       	ldd	r22, Y+25	; 0x19
    419a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    419c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    419e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    41a0:	20 e0       	ldi	r18, 0x00	; 0
    41a2:	30 e0       	ldi	r19, 0x00	; 0
    41a4:	40 e2       	ldi	r20, 0x20	; 32
    41a6:	51 e4       	ldi	r21, 0x41	; 65
    41a8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    41ac:	dc 01       	movw	r26, r24
    41ae:	cb 01       	movw	r24, r22
    41b0:	bc 01       	movw	r22, r24
    41b2:	cd 01       	movw	r24, r26
    41b4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    41b8:	dc 01       	movw	r26, r24
    41ba:	cb 01       	movw	r24, r22
    41bc:	9c 8b       	std	Y+20, r25	; 0x14
    41be:	8b 8b       	std	Y+19, r24	; 0x13
    41c0:	0f c0       	rjmp	.+30     	; 0x41e0 <HAL_LCD_u8LCDInit+0x562>
    41c2:	80 e9       	ldi	r24, 0x90	; 144
    41c4:	91 e0       	ldi	r25, 0x01	; 1
    41c6:	9a 8b       	std	Y+18, r25	; 0x12
    41c8:	89 8b       	std	Y+17, r24	; 0x11
    41ca:	89 89       	ldd	r24, Y+17	; 0x11
    41cc:	9a 89       	ldd	r25, Y+18	; 0x12
    41ce:	01 97       	sbiw	r24, 0x01	; 1
    41d0:	f1 f7       	brne	.-4      	; 0x41ce <HAL_LCD_u8LCDInit+0x550>
    41d2:	9a 8b       	std	Y+18, r25	; 0x12
    41d4:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    41d6:	8b 89       	ldd	r24, Y+19	; 0x13
    41d8:	9c 89       	ldd	r25, Y+20	; 0x14
    41da:	01 97       	sbiw	r24, 0x01	; 1
    41dc:	9c 8b       	std	Y+20, r25	; 0x14
    41de:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    41e0:	8b 89       	ldd	r24, Y+19	; 0x13
    41e2:	9c 89       	ldd	r25, Y+20	; 0x14
    41e4:	00 97       	sbiw	r24, 0x00	; 0
    41e6:	69 f7       	brne	.-38     	; 0x41c2 <HAL_LCD_u8LCDInit+0x544>
    41e8:	14 c0       	rjmp	.+40     	; 0x4212 <HAL_LCD_u8LCDInit+0x594>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    41ea:	6d 89       	ldd	r22, Y+21	; 0x15
    41ec:	7e 89       	ldd	r23, Y+22	; 0x16
    41ee:	8f 89       	ldd	r24, Y+23	; 0x17
    41f0:	98 8d       	ldd	r25, Y+24	; 0x18
    41f2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    41f6:	dc 01       	movw	r26, r24
    41f8:	cb 01       	movw	r24, r22
    41fa:	9c 8b       	std	Y+20, r25	; 0x14
    41fc:	8b 8b       	std	Y+19, r24	; 0x13
    41fe:	8b 89       	ldd	r24, Y+19	; 0x13
    4200:	9c 89       	ldd	r25, Y+20	; 0x14
    4202:	98 8b       	std	Y+16, r25	; 0x10
    4204:	8f 87       	std	Y+15, r24	; 0x0f
    4206:	8f 85       	ldd	r24, Y+15	; 0x0f
    4208:	98 89       	ldd	r25, Y+16	; 0x10
    420a:	01 97       	sbiw	r24, 0x01	; 1
    420c:	f1 f7       	brne	.-4      	; 0x420a <HAL_LCD_u8LCDInit+0x58c>
    420e:	98 8b       	std	Y+16, r25	; 0x10
    4210:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(2);
	HAL_LCD_u8SendCommands(Entry_Mode);
    4212:	86 e0       	ldi	r24, 0x06	; 6
    4214:	0e 94 8d 21 	call	0x431a	; 0x431a <HAL_LCD_u8SendCommands>
    4218:	80 e0       	ldi	r24, 0x00	; 0
    421a:	90 e0       	ldi	r25, 0x00	; 0
    421c:	a0 e0       	ldi	r26, 0x00	; 0
    421e:	b0 e4       	ldi	r27, 0x40	; 64
    4220:	8b 87       	std	Y+11, r24	; 0x0b
    4222:	9c 87       	std	Y+12, r25	; 0x0c
    4224:	ad 87       	std	Y+13, r26	; 0x0d
    4226:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4228:	6b 85       	ldd	r22, Y+11	; 0x0b
    422a:	7c 85       	ldd	r23, Y+12	; 0x0c
    422c:	8d 85       	ldd	r24, Y+13	; 0x0d
    422e:	9e 85       	ldd	r25, Y+14	; 0x0e
    4230:	20 e0       	ldi	r18, 0x00	; 0
    4232:	30 e0       	ldi	r19, 0x00	; 0
    4234:	4a e7       	ldi	r20, 0x7A	; 122
    4236:	55 e4       	ldi	r21, 0x45	; 69
    4238:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    423c:	dc 01       	movw	r26, r24
    423e:	cb 01       	movw	r24, r22
    4240:	8f 83       	std	Y+7, r24	; 0x07
    4242:	98 87       	std	Y+8, r25	; 0x08
    4244:	a9 87       	std	Y+9, r26	; 0x09
    4246:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    4248:	6f 81       	ldd	r22, Y+7	; 0x07
    424a:	78 85       	ldd	r23, Y+8	; 0x08
    424c:	89 85       	ldd	r24, Y+9	; 0x09
    424e:	9a 85       	ldd	r25, Y+10	; 0x0a
    4250:	20 e0       	ldi	r18, 0x00	; 0
    4252:	30 e0       	ldi	r19, 0x00	; 0
    4254:	40 e8       	ldi	r20, 0x80	; 128
    4256:	5f e3       	ldi	r21, 0x3F	; 63
    4258:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    425c:	88 23       	and	r24, r24
    425e:	2c f4       	brge	.+10     	; 0x426a <HAL_LCD_u8LCDInit+0x5ec>
		__ticks = 1;
    4260:	81 e0       	ldi	r24, 0x01	; 1
    4262:	90 e0       	ldi	r25, 0x00	; 0
    4264:	9e 83       	std	Y+6, r25	; 0x06
    4266:	8d 83       	std	Y+5, r24	; 0x05
    4268:	3f c0       	rjmp	.+126    	; 0x42e8 <HAL_LCD_u8LCDInit+0x66a>
	else if (__tmp > 65535)
    426a:	6f 81       	ldd	r22, Y+7	; 0x07
    426c:	78 85       	ldd	r23, Y+8	; 0x08
    426e:	89 85       	ldd	r24, Y+9	; 0x09
    4270:	9a 85       	ldd	r25, Y+10	; 0x0a
    4272:	20 e0       	ldi	r18, 0x00	; 0
    4274:	3f ef       	ldi	r19, 0xFF	; 255
    4276:	4f e7       	ldi	r20, 0x7F	; 127
    4278:	57 e4       	ldi	r21, 0x47	; 71
    427a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    427e:	18 16       	cp	r1, r24
    4280:	4c f5       	brge	.+82     	; 0x42d4 <HAL_LCD_u8LCDInit+0x656>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4282:	6b 85       	ldd	r22, Y+11	; 0x0b
    4284:	7c 85       	ldd	r23, Y+12	; 0x0c
    4286:	8d 85       	ldd	r24, Y+13	; 0x0d
    4288:	9e 85       	ldd	r25, Y+14	; 0x0e
    428a:	20 e0       	ldi	r18, 0x00	; 0
    428c:	30 e0       	ldi	r19, 0x00	; 0
    428e:	40 e2       	ldi	r20, 0x20	; 32
    4290:	51 e4       	ldi	r21, 0x41	; 65
    4292:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4296:	dc 01       	movw	r26, r24
    4298:	cb 01       	movw	r24, r22
    429a:	bc 01       	movw	r22, r24
    429c:	cd 01       	movw	r24, r26
    429e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    42a2:	dc 01       	movw	r26, r24
    42a4:	cb 01       	movw	r24, r22
    42a6:	9e 83       	std	Y+6, r25	; 0x06
    42a8:	8d 83       	std	Y+5, r24	; 0x05
    42aa:	0f c0       	rjmp	.+30     	; 0x42ca <HAL_LCD_u8LCDInit+0x64c>
    42ac:	80 e9       	ldi	r24, 0x90	; 144
    42ae:	91 e0       	ldi	r25, 0x01	; 1
    42b0:	9c 83       	std	Y+4, r25	; 0x04
    42b2:	8b 83       	std	Y+3, r24	; 0x03
    42b4:	8b 81       	ldd	r24, Y+3	; 0x03
    42b6:	9c 81       	ldd	r25, Y+4	; 0x04
    42b8:	01 97       	sbiw	r24, 0x01	; 1
    42ba:	f1 f7       	brne	.-4      	; 0x42b8 <HAL_LCD_u8LCDInit+0x63a>
    42bc:	9c 83       	std	Y+4, r25	; 0x04
    42be:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    42c0:	8d 81       	ldd	r24, Y+5	; 0x05
    42c2:	9e 81       	ldd	r25, Y+6	; 0x06
    42c4:	01 97       	sbiw	r24, 0x01	; 1
    42c6:	9e 83       	std	Y+6, r25	; 0x06
    42c8:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    42ca:	8d 81       	ldd	r24, Y+5	; 0x05
    42cc:	9e 81       	ldd	r25, Y+6	; 0x06
    42ce:	00 97       	sbiw	r24, 0x00	; 0
    42d0:	69 f7       	brne	.-38     	; 0x42ac <HAL_LCD_u8LCDInit+0x62e>
    42d2:	14 c0       	rjmp	.+40     	; 0x42fc <HAL_LCD_u8LCDInit+0x67e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    42d4:	6f 81       	ldd	r22, Y+7	; 0x07
    42d6:	78 85       	ldd	r23, Y+8	; 0x08
    42d8:	89 85       	ldd	r24, Y+9	; 0x09
    42da:	9a 85       	ldd	r25, Y+10	; 0x0a
    42dc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    42e0:	dc 01       	movw	r26, r24
    42e2:	cb 01       	movw	r24, r22
    42e4:	9e 83       	std	Y+6, r25	; 0x06
    42e6:	8d 83       	std	Y+5, r24	; 0x05
    42e8:	8d 81       	ldd	r24, Y+5	; 0x05
    42ea:	9e 81       	ldd	r25, Y+6	; 0x06
    42ec:	9a 83       	std	Y+2, r25	; 0x02
    42ee:	89 83       	std	Y+1, r24	; 0x01
    42f0:	89 81       	ldd	r24, Y+1	; 0x01
    42f2:	9a 81       	ldd	r25, Y+2	; 0x02
    42f4:	01 97       	sbiw	r24, 0x01	; 1
    42f6:	f1 f7       	brne	.-4      	; 0x42f4 <HAL_LCD_u8LCDInit+0x676>
    42f8:	9a 83       	std	Y+2, r25	; 0x02
    42fa:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	HAL_LCD_u8SendCommands(CURSOR_OFF);
    42fc:	8c e0       	ldi	r24, 0x0C	; 12
    42fe:	0e 94 8d 21 	call	0x431a	; 0x431a <HAL_LCD_u8SendCommands>
}
    4302:	cc 5a       	subi	r28, 0xAC	; 172
    4304:	df 4f       	sbci	r29, 0xFF	; 255
    4306:	0f b6       	in	r0, 0x3f	; 63
    4308:	f8 94       	cli
    430a:	de bf       	out	0x3e, r29	; 62
    430c:	0f be       	out	0x3f, r0	; 63
    430e:	cd bf       	out	0x3d, r28	; 61
    4310:	cf 91       	pop	r28
    4312:	df 91       	pop	r29
    4314:	1f 91       	pop	r17
    4316:	0f 91       	pop	r16
    4318:	08 95       	ret

0000431a <HAL_LCD_u8SendCommands>:

void HAL_LCD_u8SendCommands(u8 Loc_u8LCD_Command) {
    431a:	df 93       	push	r29
    431c:	cf 93       	push	r28
    431e:	cd b7       	in	r28, 0x3d	; 61
    4320:	de b7       	in	r29, 0x3e	; 62
    4322:	6d 97       	sbiw	r28, 0x1d	; 29
    4324:	0f b6       	in	r0, 0x3f	; 63
    4326:	f8 94       	cli
    4328:	de bf       	out	0x3e, r29	; 62
    432a:	0f be       	out	0x3f, r0	; 63
    432c:	cd bf       	out	0x3d, r28	; 61
    432e:	8d 8f       	std	Y+29, r24	; 0x1d
	MCAL_DIO_u8SetPinValue(RS_Port, RS_Pin, RS_Low);
    4330:	81 e0       	ldi	r24, 0x01	; 1
    4332:	61 e0       	ldi	r22, 0x01	; 1
    4334:	40 e0       	ldi	r20, 0x00	; 0
    4336:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(RW_Port, RW_Pin, RW_Low);
    433a:	81 e0       	ldi	r24, 0x01	; 1
    433c:	62 e0       	ldi	r22, 0x02	; 2
    433e:	40 e0       	ldi	r20, 0x00	; 0
    4340:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
	   HAL_LCD_voidData( Loc_u8LCD_Command>>4);
    4344:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4346:	82 95       	swap	r24
    4348:	8f 70       	andi	r24, 0x0F	; 15
    434a:	0e 94 3b 27 	call	0x4e76	; 0x4e76 <HAL_LCD_voidData>
	MCAL_DIO_u8SetPinValue(Enable_PORT, Enable_PIN, Enable_High);
    434e:	81 e0       	ldi	r24, 0x01	; 1
    4350:	63 e0       	ldi	r22, 0x03	; 3
    4352:	41 e0       	ldi	r20, 0x01	; 1
    4354:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
    4358:	80 e0       	ldi	r24, 0x00	; 0
    435a:	90 e0       	ldi	r25, 0x00	; 0
    435c:	a0 e0       	ldi	r26, 0x00	; 0
    435e:	b0 e4       	ldi	r27, 0x40	; 64
    4360:	89 8f       	std	Y+25, r24	; 0x19
    4362:	9a 8f       	std	Y+26, r25	; 0x1a
    4364:	ab 8f       	std	Y+27, r26	; 0x1b
    4366:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4368:	69 8d       	ldd	r22, Y+25	; 0x19
    436a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    436c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    436e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4370:	20 e0       	ldi	r18, 0x00	; 0
    4372:	30 e0       	ldi	r19, 0x00	; 0
    4374:	4a e7       	ldi	r20, 0x7A	; 122
    4376:	55 e4       	ldi	r21, 0x45	; 69
    4378:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    437c:	dc 01       	movw	r26, r24
    437e:	cb 01       	movw	r24, r22
    4380:	8d 8b       	std	Y+21, r24	; 0x15
    4382:	9e 8b       	std	Y+22, r25	; 0x16
    4384:	af 8b       	std	Y+23, r26	; 0x17
    4386:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    4388:	6d 89       	ldd	r22, Y+21	; 0x15
    438a:	7e 89       	ldd	r23, Y+22	; 0x16
    438c:	8f 89       	ldd	r24, Y+23	; 0x17
    438e:	98 8d       	ldd	r25, Y+24	; 0x18
    4390:	20 e0       	ldi	r18, 0x00	; 0
    4392:	30 e0       	ldi	r19, 0x00	; 0
    4394:	40 e8       	ldi	r20, 0x80	; 128
    4396:	5f e3       	ldi	r21, 0x3F	; 63
    4398:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    439c:	88 23       	and	r24, r24
    439e:	2c f4       	brge	.+10     	; 0x43aa <HAL_LCD_u8SendCommands+0x90>
		__ticks = 1;
    43a0:	81 e0       	ldi	r24, 0x01	; 1
    43a2:	90 e0       	ldi	r25, 0x00	; 0
    43a4:	9c 8b       	std	Y+20, r25	; 0x14
    43a6:	8b 8b       	std	Y+19, r24	; 0x13
    43a8:	3f c0       	rjmp	.+126    	; 0x4428 <HAL_LCD_u8SendCommands+0x10e>
	else if (__tmp > 65535)
    43aa:	6d 89       	ldd	r22, Y+21	; 0x15
    43ac:	7e 89       	ldd	r23, Y+22	; 0x16
    43ae:	8f 89       	ldd	r24, Y+23	; 0x17
    43b0:	98 8d       	ldd	r25, Y+24	; 0x18
    43b2:	20 e0       	ldi	r18, 0x00	; 0
    43b4:	3f ef       	ldi	r19, 0xFF	; 255
    43b6:	4f e7       	ldi	r20, 0x7F	; 127
    43b8:	57 e4       	ldi	r21, 0x47	; 71
    43ba:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    43be:	18 16       	cp	r1, r24
    43c0:	4c f5       	brge	.+82     	; 0x4414 <HAL_LCD_u8SendCommands+0xfa>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    43c2:	69 8d       	ldd	r22, Y+25	; 0x19
    43c4:	7a 8d       	ldd	r23, Y+26	; 0x1a
    43c6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    43c8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    43ca:	20 e0       	ldi	r18, 0x00	; 0
    43cc:	30 e0       	ldi	r19, 0x00	; 0
    43ce:	40 e2       	ldi	r20, 0x20	; 32
    43d0:	51 e4       	ldi	r21, 0x41	; 65
    43d2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    43d6:	dc 01       	movw	r26, r24
    43d8:	cb 01       	movw	r24, r22
    43da:	bc 01       	movw	r22, r24
    43dc:	cd 01       	movw	r24, r26
    43de:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    43e2:	dc 01       	movw	r26, r24
    43e4:	cb 01       	movw	r24, r22
    43e6:	9c 8b       	std	Y+20, r25	; 0x14
    43e8:	8b 8b       	std	Y+19, r24	; 0x13
    43ea:	0f c0       	rjmp	.+30     	; 0x440a <HAL_LCD_u8SendCommands+0xf0>
    43ec:	80 e9       	ldi	r24, 0x90	; 144
    43ee:	91 e0       	ldi	r25, 0x01	; 1
    43f0:	9a 8b       	std	Y+18, r25	; 0x12
    43f2:	89 8b       	std	Y+17, r24	; 0x11
    43f4:	89 89       	ldd	r24, Y+17	; 0x11
    43f6:	9a 89       	ldd	r25, Y+18	; 0x12
    43f8:	01 97       	sbiw	r24, 0x01	; 1
    43fa:	f1 f7       	brne	.-4      	; 0x43f8 <HAL_LCD_u8SendCommands+0xde>
    43fc:	9a 8b       	std	Y+18, r25	; 0x12
    43fe:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4400:	8b 89       	ldd	r24, Y+19	; 0x13
    4402:	9c 89       	ldd	r25, Y+20	; 0x14
    4404:	01 97       	sbiw	r24, 0x01	; 1
    4406:	9c 8b       	std	Y+20, r25	; 0x14
    4408:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    440a:	8b 89       	ldd	r24, Y+19	; 0x13
    440c:	9c 89       	ldd	r25, Y+20	; 0x14
    440e:	00 97       	sbiw	r24, 0x00	; 0
    4410:	69 f7       	brne	.-38     	; 0x43ec <HAL_LCD_u8SendCommands+0xd2>
    4412:	14 c0       	rjmp	.+40     	; 0x443c <HAL_LCD_u8SendCommands+0x122>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4414:	6d 89       	ldd	r22, Y+21	; 0x15
    4416:	7e 89       	ldd	r23, Y+22	; 0x16
    4418:	8f 89       	ldd	r24, Y+23	; 0x17
    441a:	98 8d       	ldd	r25, Y+24	; 0x18
    441c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4420:	dc 01       	movw	r26, r24
    4422:	cb 01       	movw	r24, r22
    4424:	9c 8b       	std	Y+20, r25	; 0x14
    4426:	8b 8b       	std	Y+19, r24	; 0x13
    4428:	8b 89       	ldd	r24, Y+19	; 0x13
    442a:	9c 89       	ldd	r25, Y+20	; 0x14
    442c:	98 8b       	std	Y+16, r25	; 0x10
    442e:	8f 87       	std	Y+15, r24	; 0x0f
    4430:	8f 85       	ldd	r24, Y+15	; 0x0f
    4432:	98 89       	ldd	r25, Y+16	; 0x10
    4434:	01 97       	sbiw	r24, 0x01	; 1
    4436:	f1 f7       	brne	.-4      	; 0x4434 <HAL_LCD_u8SendCommands+0x11a>
    4438:	98 8b       	std	Y+16, r25	; 0x10
    443a:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(2);
	MCAL_DIO_u8SetPinValue(Enable_PORT, Enable_PIN, Enable_Low);
    443c:	81 e0       	ldi	r24, 0x01	; 1
    443e:	63 e0       	ldi	r22, 0x03	; 3
    4440:	40 e0       	ldi	r20, 0x00	; 0
    4442:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
	   HAL_LCD_voidData( Loc_u8LCD_Command);
    4446:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4448:	0e 94 3b 27 	call	0x4e76	; 0x4e76 <HAL_LCD_voidData>
	MCAL_DIO_u8SetPinValue(Enable_PORT, Enable_PIN, Enable_High);
    444c:	81 e0       	ldi	r24, 0x01	; 1
    444e:	63 e0       	ldi	r22, 0x03	; 3
    4450:	41 e0       	ldi	r20, 0x01	; 1
    4452:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
    4456:	80 e0       	ldi	r24, 0x00	; 0
    4458:	90 e0       	ldi	r25, 0x00	; 0
    445a:	a0 e0       	ldi	r26, 0x00	; 0
    445c:	b0 e4       	ldi	r27, 0x40	; 64
    445e:	8b 87       	std	Y+11, r24	; 0x0b
    4460:	9c 87       	std	Y+12, r25	; 0x0c
    4462:	ad 87       	std	Y+13, r26	; 0x0d
    4464:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4466:	6b 85       	ldd	r22, Y+11	; 0x0b
    4468:	7c 85       	ldd	r23, Y+12	; 0x0c
    446a:	8d 85       	ldd	r24, Y+13	; 0x0d
    446c:	9e 85       	ldd	r25, Y+14	; 0x0e
    446e:	20 e0       	ldi	r18, 0x00	; 0
    4470:	30 e0       	ldi	r19, 0x00	; 0
    4472:	4a e7       	ldi	r20, 0x7A	; 122
    4474:	55 e4       	ldi	r21, 0x45	; 69
    4476:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    447a:	dc 01       	movw	r26, r24
    447c:	cb 01       	movw	r24, r22
    447e:	8f 83       	std	Y+7, r24	; 0x07
    4480:	98 87       	std	Y+8, r25	; 0x08
    4482:	a9 87       	std	Y+9, r26	; 0x09
    4484:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    4486:	6f 81       	ldd	r22, Y+7	; 0x07
    4488:	78 85       	ldd	r23, Y+8	; 0x08
    448a:	89 85       	ldd	r24, Y+9	; 0x09
    448c:	9a 85       	ldd	r25, Y+10	; 0x0a
    448e:	20 e0       	ldi	r18, 0x00	; 0
    4490:	30 e0       	ldi	r19, 0x00	; 0
    4492:	40 e8       	ldi	r20, 0x80	; 128
    4494:	5f e3       	ldi	r21, 0x3F	; 63
    4496:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    449a:	88 23       	and	r24, r24
    449c:	2c f4       	brge	.+10     	; 0x44a8 <HAL_LCD_u8SendCommands+0x18e>
		__ticks = 1;
    449e:	81 e0       	ldi	r24, 0x01	; 1
    44a0:	90 e0       	ldi	r25, 0x00	; 0
    44a2:	9e 83       	std	Y+6, r25	; 0x06
    44a4:	8d 83       	std	Y+5, r24	; 0x05
    44a6:	3f c0       	rjmp	.+126    	; 0x4526 <HAL_LCD_u8SendCommands+0x20c>
	else if (__tmp > 65535)
    44a8:	6f 81       	ldd	r22, Y+7	; 0x07
    44aa:	78 85       	ldd	r23, Y+8	; 0x08
    44ac:	89 85       	ldd	r24, Y+9	; 0x09
    44ae:	9a 85       	ldd	r25, Y+10	; 0x0a
    44b0:	20 e0       	ldi	r18, 0x00	; 0
    44b2:	3f ef       	ldi	r19, 0xFF	; 255
    44b4:	4f e7       	ldi	r20, 0x7F	; 127
    44b6:	57 e4       	ldi	r21, 0x47	; 71
    44b8:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    44bc:	18 16       	cp	r1, r24
    44be:	4c f5       	brge	.+82     	; 0x4512 <HAL_LCD_u8SendCommands+0x1f8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    44c0:	6b 85       	ldd	r22, Y+11	; 0x0b
    44c2:	7c 85       	ldd	r23, Y+12	; 0x0c
    44c4:	8d 85       	ldd	r24, Y+13	; 0x0d
    44c6:	9e 85       	ldd	r25, Y+14	; 0x0e
    44c8:	20 e0       	ldi	r18, 0x00	; 0
    44ca:	30 e0       	ldi	r19, 0x00	; 0
    44cc:	40 e2       	ldi	r20, 0x20	; 32
    44ce:	51 e4       	ldi	r21, 0x41	; 65
    44d0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    44d4:	dc 01       	movw	r26, r24
    44d6:	cb 01       	movw	r24, r22
    44d8:	bc 01       	movw	r22, r24
    44da:	cd 01       	movw	r24, r26
    44dc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    44e0:	dc 01       	movw	r26, r24
    44e2:	cb 01       	movw	r24, r22
    44e4:	9e 83       	std	Y+6, r25	; 0x06
    44e6:	8d 83       	std	Y+5, r24	; 0x05
    44e8:	0f c0       	rjmp	.+30     	; 0x4508 <HAL_LCD_u8SendCommands+0x1ee>
    44ea:	80 e9       	ldi	r24, 0x90	; 144
    44ec:	91 e0       	ldi	r25, 0x01	; 1
    44ee:	9c 83       	std	Y+4, r25	; 0x04
    44f0:	8b 83       	std	Y+3, r24	; 0x03
    44f2:	8b 81       	ldd	r24, Y+3	; 0x03
    44f4:	9c 81       	ldd	r25, Y+4	; 0x04
    44f6:	01 97       	sbiw	r24, 0x01	; 1
    44f8:	f1 f7       	brne	.-4      	; 0x44f6 <HAL_LCD_u8SendCommands+0x1dc>
    44fa:	9c 83       	std	Y+4, r25	; 0x04
    44fc:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    44fe:	8d 81       	ldd	r24, Y+5	; 0x05
    4500:	9e 81       	ldd	r25, Y+6	; 0x06
    4502:	01 97       	sbiw	r24, 0x01	; 1
    4504:	9e 83       	std	Y+6, r25	; 0x06
    4506:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4508:	8d 81       	ldd	r24, Y+5	; 0x05
    450a:	9e 81       	ldd	r25, Y+6	; 0x06
    450c:	00 97       	sbiw	r24, 0x00	; 0
    450e:	69 f7       	brne	.-38     	; 0x44ea <HAL_LCD_u8SendCommands+0x1d0>
    4510:	14 c0       	rjmp	.+40     	; 0x453a <HAL_LCD_u8SendCommands+0x220>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4512:	6f 81       	ldd	r22, Y+7	; 0x07
    4514:	78 85       	ldd	r23, Y+8	; 0x08
    4516:	89 85       	ldd	r24, Y+9	; 0x09
    4518:	9a 85       	ldd	r25, Y+10	; 0x0a
    451a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    451e:	dc 01       	movw	r26, r24
    4520:	cb 01       	movw	r24, r22
    4522:	9e 83       	std	Y+6, r25	; 0x06
    4524:	8d 83       	std	Y+5, r24	; 0x05
    4526:	8d 81       	ldd	r24, Y+5	; 0x05
    4528:	9e 81       	ldd	r25, Y+6	; 0x06
    452a:	9a 83       	std	Y+2, r25	; 0x02
    452c:	89 83       	std	Y+1, r24	; 0x01
    452e:	89 81       	ldd	r24, Y+1	; 0x01
    4530:	9a 81       	ldd	r25, Y+2	; 0x02
    4532:	01 97       	sbiw	r24, 0x01	; 1
    4534:	f1 f7       	brne	.-4      	; 0x4532 <HAL_LCD_u8SendCommands+0x218>
    4536:	9a 83       	std	Y+2, r25	; 0x02
    4538:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	MCAL_DIO_u8SetPinValue(Enable_PORT, Enable_PIN, Enable_Low);
    453a:	81 e0       	ldi	r24, 0x01	; 1
    453c:	63 e0       	ldi	r22, 0x03	; 3
    453e:	40 e0       	ldi	r20, 0x00	; 0
    4540:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
}
    4544:	6d 96       	adiw	r28, 0x1d	; 29
    4546:	0f b6       	in	r0, 0x3f	; 63
    4548:	f8 94       	cli
    454a:	de bf       	out	0x3e, r29	; 62
    454c:	0f be       	out	0x3f, r0	; 63
    454e:	cd bf       	out	0x3d, r28	; 61
    4550:	cf 91       	pop	r28
    4552:	df 91       	pop	r29
    4554:	08 95       	ret

00004556 <HAL_LCD_u8SendChar>:

void HAL_LCD_u8SendChar(u8 Loc_u8LCD_Char) {
    4556:	df 93       	push	r29
    4558:	cf 93       	push	r28
    455a:	cd b7       	in	r28, 0x3d	; 61
    455c:	de b7       	in	r29, 0x3e	; 62
    455e:	6d 97       	sbiw	r28, 0x1d	; 29
    4560:	0f b6       	in	r0, 0x3f	; 63
    4562:	f8 94       	cli
    4564:	de bf       	out	0x3e, r29	; 62
    4566:	0f be       	out	0x3f, r0	; 63
    4568:	cd bf       	out	0x3d, r28	; 61
    456a:	8d 8f       	std	Y+29, r24	; 0x1d
	MCAL_DIO_u8SetPinValue(RS_Port, RS_Pin, RS_High);
    456c:	81 e0       	ldi	r24, 0x01	; 1
    456e:	61 e0       	ldi	r22, 0x01	; 1
    4570:	41 e0       	ldi	r20, 0x01	; 1
    4572:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(RW_Port, RW_Pin, RW_Low);
    4576:	81 e0       	ldi	r24, 0x01	; 1
    4578:	62 e0       	ldi	r22, 0x02	; 2
    457a:	40 e0       	ldi	r20, 0x00	; 0
    457c:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
	   HAL_LCD_voidData( Loc_u8LCD_Char>>4);
    4580:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4582:	82 95       	swap	r24
    4584:	8f 70       	andi	r24, 0x0F	; 15
    4586:	0e 94 3b 27 	call	0x4e76	; 0x4e76 <HAL_LCD_voidData>
	MCAL_DIO_u8SetPinValue(Enable_PORT, Enable_PIN, Enable_High);
    458a:	81 e0       	ldi	r24, 0x01	; 1
    458c:	63 e0       	ldi	r22, 0x03	; 3
    458e:	41 e0       	ldi	r20, 0x01	; 1
    4590:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
    4594:	80 e0       	ldi	r24, 0x00	; 0
    4596:	90 e0       	ldi	r25, 0x00	; 0
    4598:	a0 e0       	ldi	r26, 0x00	; 0
    459a:	b0 e4       	ldi	r27, 0x40	; 64
    459c:	89 8f       	std	Y+25, r24	; 0x19
    459e:	9a 8f       	std	Y+26, r25	; 0x1a
    45a0:	ab 8f       	std	Y+27, r26	; 0x1b
    45a2:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    45a4:	69 8d       	ldd	r22, Y+25	; 0x19
    45a6:	7a 8d       	ldd	r23, Y+26	; 0x1a
    45a8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    45aa:	9c 8d       	ldd	r25, Y+28	; 0x1c
    45ac:	20 e0       	ldi	r18, 0x00	; 0
    45ae:	30 e0       	ldi	r19, 0x00	; 0
    45b0:	4a e7       	ldi	r20, 0x7A	; 122
    45b2:	55 e4       	ldi	r21, 0x45	; 69
    45b4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    45b8:	dc 01       	movw	r26, r24
    45ba:	cb 01       	movw	r24, r22
    45bc:	8d 8b       	std	Y+21, r24	; 0x15
    45be:	9e 8b       	std	Y+22, r25	; 0x16
    45c0:	af 8b       	std	Y+23, r26	; 0x17
    45c2:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    45c4:	6d 89       	ldd	r22, Y+21	; 0x15
    45c6:	7e 89       	ldd	r23, Y+22	; 0x16
    45c8:	8f 89       	ldd	r24, Y+23	; 0x17
    45ca:	98 8d       	ldd	r25, Y+24	; 0x18
    45cc:	20 e0       	ldi	r18, 0x00	; 0
    45ce:	30 e0       	ldi	r19, 0x00	; 0
    45d0:	40 e8       	ldi	r20, 0x80	; 128
    45d2:	5f e3       	ldi	r21, 0x3F	; 63
    45d4:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    45d8:	88 23       	and	r24, r24
    45da:	2c f4       	brge	.+10     	; 0x45e6 <HAL_LCD_u8SendChar+0x90>
		__ticks = 1;
    45dc:	81 e0       	ldi	r24, 0x01	; 1
    45de:	90 e0       	ldi	r25, 0x00	; 0
    45e0:	9c 8b       	std	Y+20, r25	; 0x14
    45e2:	8b 8b       	std	Y+19, r24	; 0x13
    45e4:	3f c0       	rjmp	.+126    	; 0x4664 <HAL_LCD_u8SendChar+0x10e>
	else if (__tmp > 65535)
    45e6:	6d 89       	ldd	r22, Y+21	; 0x15
    45e8:	7e 89       	ldd	r23, Y+22	; 0x16
    45ea:	8f 89       	ldd	r24, Y+23	; 0x17
    45ec:	98 8d       	ldd	r25, Y+24	; 0x18
    45ee:	20 e0       	ldi	r18, 0x00	; 0
    45f0:	3f ef       	ldi	r19, 0xFF	; 255
    45f2:	4f e7       	ldi	r20, 0x7F	; 127
    45f4:	57 e4       	ldi	r21, 0x47	; 71
    45f6:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    45fa:	18 16       	cp	r1, r24
    45fc:	4c f5       	brge	.+82     	; 0x4650 <HAL_LCD_u8SendChar+0xfa>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    45fe:	69 8d       	ldd	r22, Y+25	; 0x19
    4600:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4602:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4604:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4606:	20 e0       	ldi	r18, 0x00	; 0
    4608:	30 e0       	ldi	r19, 0x00	; 0
    460a:	40 e2       	ldi	r20, 0x20	; 32
    460c:	51 e4       	ldi	r21, 0x41	; 65
    460e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4612:	dc 01       	movw	r26, r24
    4614:	cb 01       	movw	r24, r22
    4616:	bc 01       	movw	r22, r24
    4618:	cd 01       	movw	r24, r26
    461a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    461e:	dc 01       	movw	r26, r24
    4620:	cb 01       	movw	r24, r22
    4622:	9c 8b       	std	Y+20, r25	; 0x14
    4624:	8b 8b       	std	Y+19, r24	; 0x13
    4626:	0f c0       	rjmp	.+30     	; 0x4646 <HAL_LCD_u8SendChar+0xf0>
    4628:	80 e9       	ldi	r24, 0x90	; 144
    462a:	91 e0       	ldi	r25, 0x01	; 1
    462c:	9a 8b       	std	Y+18, r25	; 0x12
    462e:	89 8b       	std	Y+17, r24	; 0x11
    4630:	89 89       	ldd	r24, Y+17	; 0x11
    4632:	9a 89       	ldd	r25, Y+18	; 0x12
    4634:	01 97       	sbiw	r24, 0x01	; 1
    4636:	f1 f7       	brne	.-4      	; 0x4634 <HAL_LCD_u8SendChar+0xde>
    4638:	9a 8b       	std	Y+18, r25	; 0x12
    463a:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    463c:	8b 89       	ldd	r24, Y+19	; 0x13
    463e:	9c 89       	ldd	r25, Y+20	; 0x14
    4640:	01 97       	sbiw	r24, 0x01	; 1
    4642:	9c 8b       	std	Y+20, r25	; 0x14
    4644:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4646:	8b 89       	ldd	r24, Y+19	; 0x13
    4648:	9c 89       	ldd	r25, Y+20	; 0x14
    464a:	00 97       	sbiw	r24, 0x00	; 0
    464c:	69 f7       	brne	.-38     	; 0x4628 <HAL_LCD_u8SendChar+0xd2>
    464e:	14 c0       	rjmp	.+40     	; 0x4678 <HAL_LCD_u8SendChar+0x122>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4650:	6d 89       	ldd	r22, Y+21	; 0x15
    4652:	7e 89       	ldd	r23, Y+22	; 0x16
    4654:	8f 89       	ldd	r24, Y+23	; 0x17
    4656:	98 8d       	ldd	r25, Y+24	; 0x18
    4658:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    465c:	dc 01       	movw	r26, r24
    465e:	cb 01       	movw	r24, r22
    4660:	9c 8b       	std	Y+20, r25	; 0x14
    4662:	8b 8b       	std	Y+19, r24	; 0x13
    4664:	8b 89       	ldd	r24, Y+19	; 0x13
    4666:	9c 89       	ldd	r25, Y+20	; 0x14
    4668:	98 8b       	std	Y+16, r25	; 0x10
    466a:	8f 87       	std	Y+15, r24	; 0x0f
    466c:	8f 85       	ldd	r24, Y+15	; 0x0f
    466e:	98 89       	ldd	r25, Y+16	; 0x10
    4670:	01 97       	sbiw	r24, 0x01	; 1
    4672:	f1 f7       	brne	.-4      	; 0x4670 <HAL_LCD_u8SendChar+0x11a>
    4674:	98 8b       	std	Y+16, r25	; 0x10
    4676:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(2);
	MCAL_DIO_u8SetPinValue(Enable_PORT, Enable_PIN, Enable_Low);
    4678:	81 e0       	ldi	r24, 0x01	; 1
    467a:	63 e0       	ldi	r22, 0x03	; 3
    467c:	40 e0       	ldi	r20, 0x00	; 0
    467e:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
	   HAL_LCD_voidData( Loc_u8LCD_Char);
    4682:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4684:	0e 94 3b 27 	call	0x4e76	; 0x4e76 <HAL_LCD_voidData>
	MCAL_DIO_u8SetPinValue(Enable_PORT, Enable_PIN, Enable_High);
    4688:	81 e0       	ldi	r24, 0x01	; 1
    468a:	63 e0       	ldi	r22, 0x03	; 3
    468c:	41 e0       	ldi	r20, 0x01	; 1
    468e:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
    4692:	80 e0       	ldi	r24, 0x00	; 0
    4694:	90 e0       	ldi	r25, 0x00	; 0
    4696:	a0 e0       	ldi	r26, 0x00	; 0
    4698:	b0 e4       	ldi	r27, 0x40	; 64
    469a:	8b 87       	std	Y+11, r24	; 0x0b
    469c:	9c 87       	std	Y+12, r25	; 0x0c
    469e:	ad 87       	std	Y+13, r26	; 0x0d
    46a0:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    46a2:	6b 85       	ldd	r22, Y+11	; 0x0b
    46a4:	7c 85       	ldd	r23, Y+12	; 0x0c
    46a6:	8d 85       	ldd	r24, Y+13	; 0x0d
    46a8:	9e 85       	ldd	r25, Y+14	; 0x0e
    46aa:	20 e0       	ldi	r18, 0x00	; 0
    46ac:	30 e0       	ldi	r19, 0x00	; 0
    46ae:	4a e7       	ldi	r20, 0x7A	; 122
    46b0:	55 e4       	ldi	r21, 0x45	; 69
    46b2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    46b6:	dc 01       	movw	r26, r24
    46b8:	cb 01       	movw	r24, r22
    46ba:	8f 83       	std	Y+7, r24	; 0x07
    46bc:	98 87       	std	Y+8, r25	; 0x08
    46be:	a9 87       	std	Y+9, r26	; 0x09
    46c0:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    46c2:	6f 81       	ldd	r22, Y+7	; 0x07
    46c4:	78 85       	ldd	r23, Y+8	; 0x08
    46c6:	89 85       	ldd	r24, Y+9	; 0x09
    46c8:	9a 85       	ldd	r25, Y+10	; 0x0a
    46ca:	20 e0       	ldi	r18, 0x00	; 0
    46cc:	30 e0       	ldi	r19, 0x00	; 0
    46ce:	40 e8       	ldi	r20, 0x80	; 128
    46d0:	5f e3       	ldi	r21, 0x3F	; 63
    46d2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    46d6:	88 23       	and	r24, r24
    46d8:	2c f4       	brge	.+10     	; 0x46e4 <HAL_LCD_u8SendChar+0x18e>
		__ticks = 1;
    46da:	81 e0       	ldi	r24, 0x01	; 1
    46dc:	90 e0       	ldi	r25, 0x00	; 0
    46de:	9e 83       	std	Y+6, r25	; 0x06
    46e0:	8d 83       	std	Y+5, r24	; 0x05
    46e2:	3f c0       	rjmp	.+126    	; 0x4762 <HAL_LCD_u8SendChar+0x20c>
	else if (__tmp > 65535)
    46e4:	6f 81       	ldd	r22, Y+7	; 0x07
    46e6:	78 85       	ldd	r23, Y+8	; 0x08
    46e8:	89 85       	ldd	r24, Y+9	; 0x09
    46ea:	9a 85       	ldd	r25, Y+10	; 0x0a
    46ec:	20 e0       	ldi	r18, 0x00	; 0
    46ee:	3f ef       	ldi	r19, 0xFF	; 255
    46f0:	4f e7       	ldi	r20, 0x7F	; 127
    46f2:	57 e4       	ldi	r21, 0x47	; 71
    46f4:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    46f8:	18 16       	cp	r1, r24
    46fa:	4c f5       	brge	.+82     	; 0x474e <HAL_LCD_u8SendChar+0x1f8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    46fc:	6b 85       	ldd	r22, Y+11	; 0x0b
    46fe:	7c 85       	ldd	r23, Y+12	; 0x0c
    4700:	8d 85       	ldd	r24, Y+13	; 0x0d
    4702:	9e 85       	ldd	r25, Y+14	; 0x0e
    4704:	20 e0       	ldi	r18, 0x00	; 0
    4706:	30 e0       	ldi	r19, 0x00	; 0
    4708:	40 e2       	ldi	r20, 0x20	; 32
    470a:	51 e4       	ldi	r21, 0x41	; 65
    470c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4710:	dc 01       	movw	r26, r24
    4712:	cb 01       	movw	r24, r22
    4714:	bc 01       	movw	r22, r24
    4716:	cd 01       	movw	r24, r26
    4718:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    471c:	dc 01       	movw	r26, r24
    471e:	cb 01       	movw	r24, r22
    4720:	9e 83       	std	Y+6, r25	; 0x06
    4722:	8d 83       	std	Y+5, r24	; 0x05
    4724:	0f c0       	rjmp	.+30     	; 0x4744 <HAL_LCD_u8SendChar+0x1ee>
    4726:	80 e9       	ldi	r24, 0x90	; 144
    4728:	91 e0       	ldi	r25, 0x01	; 1
    472a:	9c 83       	std	Y+4, r25	; 0x04
    472c:	8b 83       	std	Y+3, r24	; 0x03
    472e:	8b 81       	ldd	r24, Y+3	; 0x03
    4730:	9c 81       	ldd	r25, Y+4	; 0x04
    4732:	01 97       	sbiw	r24, 0x01	; 1
    4734:	f1 f7       	brne	.-4      	; 0x4732 <HAL_LCD_u8SendChar+0x1dc>
    4736:	9c 83       	std	Y+4, r25	; 0x04
    4738:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    473a:	8d 81       	ldd	r24, Y+5	; 0x05
    473c:	9e 81       	ldd	r25, Y+6	; 0x06
    473e:	01 97       	sbiw	r24, 0x01	; 1
    4740:	9e 83       	std	Y+6, r25	; 0x06
    4742:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4744:	8d 81       	ldd	r24, Y+5	; 0x05
    4746:	9e 81       	ldd	r25, Y+6	; 0x06
    4748:	00 97       	sbiw	r24, 0x00	; 0
    474a:	69 f7       	brne	.-38     	; 0x4726 <HAL_LCD_u8SendChar+0x1d0>
    474c:	14 c0       	rjmp	.+40     	; 0x4776 <HAL_LCD_u8SendChar+0x220>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    474e:	6f 81       	ldd	r22, Y+7	; 0x07
    4750:	78 85       	ldd	r23, Y+8	; 0x08
    4752:	89 85       	ldd	r24, Y+9	; 0x09
    4754:	9a 85       	ldd	r25, Y+10	; 0x0a
    4756:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    475a:	dc 01       	movw	r26, r24
    475c:	cb 01       	movw	r24, r22
    475e:	9e 83       	std	Y+6, r25	; 0x06
    4760:	8d 83       	std	Y+5, r24	; 0x05
    4762:	8d 81       	ldd	r24, Y+5	; 0x05
    4764:	9e 81       	ldd	r25, Y+6	; 0x06
    4766:	9a 83       	std	Y+2, r25	; 0x02
    4768:	89 83       	std	Y+1, r24	; 0x01
    476a:	89 81       	ldd	r24, Y+1	; 0x01
    476c:	9a 81       	ldd	r25, Y+2	; 0x02
    476e:	01 97       	sbiw	r24, 0x01	; 1
    4770:	f1 f7       	brne	.-4      	; 0x476e <HAL_LCD_u8SendChar+0x218>
    4772:	9a 83       	std	Y+2, r25	; 0x02
    4774:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	MCAL_DIO_u8SetPinValue(Enable_PORT, Enable_PIN, Enable_Low);
    4776:	81 e0       	ldi	r24, 0x01	; 1
    4778:	63 e0       	ldi	r22, 0x03	; 3
    477a:	40 e0       	ldi	r20, 0x00	; 0
    477c:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
}
    4780:	6d 96       	adiw	r28, 0x1d	; 29
    4782:	0f b6       	in	r0, 0x3f	; 63
    4784:	f8 94       	cli
    4786:	de bf       	out	0x3e, r29	; 62
    4788:	0f be       	out	0x3f, r0	; 63
    478a:	cd bf       	out	0x3d, r28	; 61
    478c:	cf 91       	pop	r28
    478e:	df 91       	pop	r29
    4790:	08 95       	ret

00004792 <HAL_LCD_u8SendString>:

void HAL_LCD_u8SendString(u8 * Loc_u8LCD_String) {
    4792:	df 93       	push	r29
    4794:	cf 93       	push	r28
    4796:	00 d0       	rcall	.+0      	; 0x4798 <HAL_LCD_u8SendString+0x6>
    4798:	00 d0       	rcall	.+0      	; 0x479a <HAL_LCD_u8SendString+0x8>
    479a:	00 d0       	rcall	.+0      	; 0x479c <HAL_LCD_u8SendString+0xa>
    479c:	cd b7       	in	r28, 0x3d	; 61
    479e:	de b7       	in	r29, 0x3e	; 62
    47a0:	9e 83       	std	Y+6, r25	; 0x06
    47a2:	8d 83       	std	Y+5, r24	; 0x05
	for (u32 count = 0; Loc_u8LCD_String[count] != '\0'; count++) {
    47a4:	19 82       	std	Y+1, r1	; 0x01
    47a6:	1a 82       	std	Y+2, r1	; 0x02
    47a8:	1b 82       	std	Y+3, r1	; 0x03
    47aa:	1c 82       	std	Y+4, r1	; 0x04
    47ac:	15 c0       	rjmp	.+42     	; 0x47d8 <HAL_LCD_u8SendString+0x46>
		HAL_LCD_u8SendChar(Loc_u8LCD_String[count]);
    47ae:	29 81       	ldd	r18, Y+1	; 0x01
    47b0:	3a 81       	ldd	r19, Y+2	; 0x02
    47b2:	8d 81       	ldd	r24, Y+5	; 0x05
    47b4:	9e 81       	ldd	r25, Y+6	; 0x06
    47b6:	fc 01       	movw	r30, r24
    47b8:	e2 0f       	add	r30, r18
    47ba:	f3 1f       	adc	r31, r19
    47bc:	80 81       	ld	r24, Z
    47be:	0e 94 ab 22 	call	0x4556	; 0x4556 <HAL_LCD_u8SendChar>
	_delay_ms(2);
	MCAL_DIO_u8SetPinValue(Enable_PORT, Enable_PIN, Enable_Low);
}

void HAL_LCD_u8SendString(u8 * Loc_u8LCD_String) {
	for (u32 count = 0; Loc_u8LCD_String[count] != '\0'; count++) {
    47c2:	89 81       	ldd	r24, Y+1	; 0x01
    47c4:	9a 81       	ldd	r25, Y+2	; 0x02
    47c6:	ab 81       	ldd	r26, Y+3	; 0x03
    47c8:	bc 81       	ldd	r27, Y+4	; 0x04
    47ca:	01 96       	adiw	r24, 0x01	; 1
    47cc:	a1 1d       	adc	r26, r1
    47ce:	b1 1d       	adc	r27, r1
    47d0:	89 83       	std	Y+1, r24	; 0x01
    47d2:	9a 83       	std	Y+2, r25	; 0x02
    47d4:	ab 83       	std	Y+3, r26	; 0x03
    47d6:	bc 83       	std	Y+4, r27	; 0x04
    47d8:	29 81       	ldd	r18, Y+1	; 0x01
    47da:	3a 81       	ldd	r19, Y+2	; 0x02
    47dc:	8d 81       	ldd	r24, Y+5	; 0x05
    47de:	9e 81       	ldd	r25, Y+6	; 0x06
    47e0:	fc 01       	movw	r30, r24
    47e2:	e2 0f       	add	r30, r18
    47e4:	f3 1f       	adc	r31, r19
    47e6:	80 81       	ld	r24, Z
    47e8:	88 23       	and	r24, r24
    47ea:	09 f7       	brne	.-62     	; 0x47ae <HAL_LCD_u8SendString+0x1c>
		HAL_LCD_u8SendChar(Loc_u8LCD_String[count]);
	}
}
    47ec:	26 96       	adiw	r28, 0x06	; 6
    47ee:	0f b6       	in	r0, 0x3f	; 63
    47f0:	f8 94       	cli
    47f2:	de bf       	out	0x3e, r29	; 62
    47f4:	0f be       	out	0x3f, r0	; 63
    47f6:	cd bf       	out	0x3d, r28	; 61
    47f8:	cf 91       	pop	r28
    47fa:	df 91       	pop	r29
    47fc:	08 95       	ret

000047fe <HAL_LCD_u8SendNumber>:

void HAL_LCD_u8SendNumber(u16 Loc_u8LCD_Number) {
    47fe:	df 93       	push	r29
    4800:	cf 93       	push	r28
    4802:	cd b7       	in	r28, 0x3d	; 61
    4804:	de b7       	in	r29, 0x3e	; 62
    4806:	2c 97       	sbiw	r28, 0x0c	; 12
    4808:	0f b6       	in	r0, 0x3f	; 63
    480a:	f8 94       	cli
    480c:	de bf       	out	0x3e, r29	; 62
    480e:	0f be       	out	0x3f, r0	; 63
    4810:	cd bf       	out	0x3d, r28	; 61
    4812:	9c 87       	std	Y+12, r25	; 0x0c
    4814:	8b 87       	std	Y+11, r24	; 0x0b
	u8 str[10];
	itoa(Loc_u8LCD_Number, str, 10);
    4816:	8b 85       	ldd	r24, Y+11	; 0x0b
    4818:	9c 85       	ldd	r25, Y+12	; 0x0c
    481a:	9e 01       	movw	r18, r28
    481c:	2f 5f       	subi	r18, 0xFF	; 255
    481e:	3f 4f       	sbci	r19, 0xFF	; 255
    4820:	b9 01       	movw	r22, r18
    4822:	4a e0       	ldi	r20, 0x0A	; 10
    4824:	50 e0       	ldi	r21, 0x00	; 0
    4826:	0e 94 5e 4c 	call	0x98bc	; 0x98bc <itoa>
	HAL_LCD_u8SendString(str);
    482a:	ce 01       	movw	r24, r28
    482c:	01 96       	adiw	r24, 0x01	; 1
    482e:	0e 94 c9 23 	call	0x4792	; 0x4792 <HAL_LCD_u8SendString>
}
    4832:	2c 96       	adiw	r28, 0x0c	; 12
    4834:	0f b6       	in	r0, 0x3f	; 63
    4836:	f8 94       	cli
    4838:	de bf       	out	0x3e, r29	; 62
    483a:	0f be       	out	0x3f, r0	; 63
    483c:	cd bf       	out	0x3d, r28	; 61
    483e:	cf 91       	pop	r28
    4840:	df 91       	pop	r29
    4842:	08 95       	ret

00004844 <HAL_LCD_u8GoTo>:

void HAL_LCD_u8GoTo(u8 Loc_u8TypeOfShift, u8 Loc_u8NumOfShift) {
    4844:	df 93       	push	r29
    4846:	cf 93       	push	r28
    4848:	cd b7       	in	r28, 0x3d	; 61
    484a:	de b7       	in	r29, 0x3e	; 62
    484c:	c2 54       	subi	r28, 0x42	; 66
    484e:	d0 40       	sbci	r29, 0x00	; 0
    4850:	0f b6       	in	r0, 0x3f	; 63
    4852:	f8 94       	cli
    4854:	de bf       	out	0x3e, r29	; 62
    4856:	0f be       	out	0x3f, r0	; 63
    4858:	cd bf       	out	0x3d, r28	; 61
    485a:	fe 01       	movw	r30, r28
    485c:	ef 5b       	subi	r30, 0xBF	; 191
    485e:	ff 4f       	sbci	r31, 0xFF	; 255
    4860:	80 83       	st	Z, r24
    4862:	fe 01       	movw	r30, r28
    4864:	ee 5b       	subi	r30, 0xBE	; 190
    4866:	ff 4f       	sbci	r31, 0xFF	; 255
    4868:	60 83       	st	Z, r22
	if (Loc_u8TypeOfShift == Right_Shift) {
    486a:	fe 01       	movw	r30, r28
    486c:	ef 5b       	subi	r30, 0xBF	; 191
    486e:	ff 4f       	sbci	r31, 0xFF	; 255
    4870:	80 81       	ld	r24, Z
    4872:	81 30       	cpi	r24, 0x01	; 1
    4874:	09 f0       	breq	.+2      	; 0x4878 <HAL_LCD_u8GoTo+0x34>
    4876:	a0 c0       	rjmp	.+320    	; 0x49b8 <HAL_LCD_u8GoTo+0x174>
		for (u32 count = 0; count < Loc_u8NumOfShift; count++) {
    4878:	fe 01       	movw	r30, r28
    487a:	fd 96       	adiw	r30, 0x3d	; 61
    487c:	10 82       	st	Z, r1
    487e:	11 82       	std	Z+1, r1	; 0x01
    4880:	12 82       	std	Z+2, r1	; 0x02
    4882:	13 82       	std	Z+3, r1	; 0x03
    4884:	84 c0       	rjmp	.+264    	; 0x498e <HAL_LCD_u8GoTo+0x14a>
    4886:	80 e0       	ldi	r24, 0x00	; 0
    4888:	90 e0       	ldi	r25, 0x00	; 0
    488a:	a0 e0       	ldi	r26, 0x00	; 0
    488c:	b0 e4       	ldi	r27, 0x40	; 64
    488e:	8d ab       	std	Y+53, r24	; 0x35
    4890:	9e ab       	std	Y+54, r25	; 0x36
    4892:	af ab       	std	Y+55, r26	; 0x37
    4894:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4896:	6d a9       	ldd	r22, Y+53	; 0x35
    4898:	7e a9       	ldd	r23, Y+54	; 0x36
    489a:	8f a9       	ldd	r24, Y+55	; 0x37
    489c:	98 ad       	ldd	r25, Y+56	; 0x38
    489e:	20 e0       	ldi	r18, 0x00	; 0
    48a0:	30 e0       	ldi	r19, 0x00	; 0
    48a2:	4a e7       	ldi	r20, 0x7A	; 122
    48a4:	55 e4       	ldi	r21, 0x45	; 69
    48a6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    48aa:	dc 01       	movw	r26, r24
    48ac:	cb 01       	movw	r24, r22
    48ae:	89 ab       	std	Y+49, r24	; 0x31
    48b0:	9a ab       	std	Y+50, r25	; 0x32
    48b2:	ab ab       	std	Y+51, r26	; 0x33
    48b4:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    48b6:	69 a9       	ldd	r22, Y+49	; 0x31
    48b8:	7a a9       	ldd	r23, Y+50	; 0x32
    48ba:	8b a9       	ldd	r24, Y+51	; 0x33
    48bc:	9c a9       	ldd	r25, Y+52	; 0x34
    48be:	20 e0       	ldi	r18, 0x00	; 0
    48c0:	30 e0       	ldi	r19, 0x00	; 0
    48c2:	40 e8       	ldi	r20, 0x80	; 128
    48c4:	5f e3       	ldi	r21, 0x3F	; 63
    48c6:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    48ca:	88 23       	and	r24, r24
    48cc:	2c f4       	brge	.+10     	; 0x48d8 <HAL_LCD_u8GoTo+0x94>
		__ticks = 1;
    48ce:	81 e0       	ldi	r24, 0x01	; 1
    48d0:	90 e0       	ldi	r25, 0x00	; 0
    48d2:	98 ab       	std	Y+48, r25	; 0x30
    48d4:	8f a7       	std	Y+47, r24	; 0x2f
    48d6:	3f c0       	rjmp	.+126    	; 0x4956 <HAL_LCD_u8GoTo+0x112>
	else if (__tmp > 65535)
    48d8:	69 a9       	ldd	r22, Y+49	; 0x31
    48da:	7a a9       	ldd	r23, Y+50	; 0x32
    48dc:	8b a9       	ldd	r24, Y+51	; 0x33
    48de:	9c a9       	ldd	r25, Y+52	; 0x34
    48e0:	20 e0       	ldi	r18, 0x00	; 0
    48e2:	3f ef       	ldi	r19, 0xFF	; 255
    48e4:	4f e7       	ldi	r20, 0x7F	; 127
    48e6:	57 e4       	ldi	r21, 0x47	; 71
    48e8:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    48ec:	18 16       	cp	r1, r24
    48ee:	4c f5       	brge	.+82     	; 0x4942 <HAL_LCD_u8GoTo+0xfe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    48f0:	6d a9       	ldd	r22, Y+53	; 0x35
    48f2:	7e a9       	ldd	r23, Y+54	; 0x36
    48f4:	8f a9       	ldd	r24, Y+55	; 0x37
    48f6:	98 ad       	ldd	r25, Y+56	; 0x38
    48f8:	20 e0       	ldi	r18, 0x00	; 0
    48fa:	30 e0       	ldi	r19, 0x00	; 0
    48fc:	40 e2       	ldi	r20, 0x20	; 32
    48fe:	51 e4       	ldi	r21, 0x41	; 65
    4900:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4904:	dc 01       	movw	r26, r24
    4906:	cb 01       	movw	r24, r22
    4908:	bc 01       	movw	r22, r24
    490a:	cd 01       	movw	r24, r26
    490c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4910:	dc 01       	movw	r26, r24
    4912:	cb 01       	movw	r24, r22
    4914:	98 ab       	std	Y+48, r25	; 0x30
    4916:	8f a7       	std	Y+47, r24	; 0x2f
    4918:	0f c0       	rjmp	.+30     	; 0x4938 <HAL_LCD_u8GoTo+0xf4>
    491a:	80 e9       	ldi	r24, 0x90	; 144
    491c:	91 e0       	ldi	r25, 0x01	; 1
    491e:	9e a7       	std	Y+46, r25	; 0x2e
    4920:	8d a7       	std	Y+45, r24	; 0x2d
    4922:	8d a5       	ldd	r24, Y+45	; 0x2d
    4924:	9e a5       	ldd	r25, Y+46	; 0x2e
    4926:	01 97       	sbiw	r24, 0x01	; 1
    4928:	f1 f7       	brne	.-4      	; 0x4926 <HAL_LCD_u8GoTo+0xe2>
    492a:	9e a7       	std	Y+46, r25	; 0x2e
    492c:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    492e:	8f a5       	ldd	r24, Y+47	; 0x2f
    4930:	98 a9       	ldd	r25, Y+48	; 0x30
    4932:	01 97       	sbiw	r24, 0x01	; 1
    4934:	98 ab       	std	Y+48, r25	; 0x30
    4936:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4938:	8f a5       	ldd	r24, Y+47	; 0x2f
    493a:	98 a9       	ldd	r25, Y+48	; 0x30
    493c:	00 97       	sbiw	r24, 0x00	; 0
    493e:	69 f7       	brne	.-38     	; 0x491a <HAL_LCD_u8GoTo+0xd6>
    4940:	14 c0       	rjmp	.+40     	; 0x496a <HAL_LCD_u8GoTo+0x126>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4942:	69 a9       	ldd	r22, Y+49	; 0x31
    4944:	7a a9       	ldd	r23, Y+50	; 0x32
    4946:	8b a9       	ldd	r24, Y+51	; 0x33
    4948:	9c a9       	ldd	r25, Y+52	; 0x34
    494a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    494e:	dc 01       	movw	r26, r24
    4950:	cb 01       	movw	r24, r22
    4952:	98 ab       	std	Y+48, r25	; 0x30
    4954:	8f a7       	std	Y+47, r24	; 0x2f
    4956:	8f a5       	ldd	r24, Y+47	; 0x2f
    4958:	98 a9       	ldd	r25, Y+48	; 0x30
    495a:	9c a7       	std	Y+44, r25	; 0x2c
    495c:	8b a7       	std	Y+43, r24	; 0x2b
    495e:	8b a5       	ldd	r24, Y+43	; 0x2b
    4960:	9c a5       	ldd	r25, Y+44	; 0x2c
    4962:	01 97       	sbiw	r24, 0x01	; 1
    4964:	f1 f7       	brne	.-4      	; 0x4962 <HAL_LCD_u8GoTo+0x11e>
    4966:	9c a7       	std	Y+44, r25	; 0x2c
    4968:	8b a7       	std	Y+43, r24	; 0x2b
			_delay_ms(2);
			HAL_LCD_u8SendCommands(Right_Shift_Command);
    496a:	8c e1       	ldi	r24, 0x1C	; 28
    496c:	0e 94 8d 21 	call	0x431a	; 0x431a <HAL_LCD_u8SendCommands>
	HAL_LCD_u8SendString(str);
}

void HAL_LCD_u8GoTo(u8 Loc_u8TypeOfShift, u8 Loc_u8NumOfShift) {
	if (Loc_u8TypeOfShift == Right_Shift) {
		for (u32 count = 0; count < Loc_u8NumOfShift; count++) {
    4970:	fe 01       	movw	r30, r28
    4972:	fd 96       	adiw	r30, 0x3d	; 61
    4974:	80 81       	ld	r24, Z
    4976:	91 81       	ldd	r25, Z+1	; 0x01
    4978:	a2 81       	ldd	r26, Z+2	; 0x02
    497a:	b3 81       	ldd	r27, Z+3	; 0x03
    497c:	01 96       	adiw	r24, 0x01	; 1
    497e:	a1 1d       	adc	r26, r1
    4980:	b1 1d       	adc	r27, r1
    4982:	fe 01       	movw	r30, r28
    4984:	fd 96       	adiw	r30, 0x3d	; 61
    4986:	80 83       	st	Z, r24
    4988:	91 83       	std	Z+1, r25	; 0x01
    498a:	a2 83       	std	Z+2, r26	; 0x02
    498c:	b3 83       	std	Z+3, r27	; 0x03
    498e:	fe 01       	movw	r30, r28
    4990:	ee 5b       	subi	r30, 0xBE	; 190
    4992:	ff 4f       	sbci	r31, 0xFF	; 255
    4994:	80 81       	ld	r24, Z
    4996:	28 2f       	mov	r18, r24
    4998:	30 e0       	ldi	r19, 0x00	; 0
    499a:	40 e0       	ldi	r20, 0x00	; 0
    499c:	50 e0       	ldi	r21, 0x00	; 0
    499e:	fe 01       	movw	r30, r28
    49a0:	fd 96       	adiw	r30, 0x3d	; 61
    49a2:	80 81       	ld	r24, Z
    49a4:	91 81       	ldd	r25, Z+1	; 0x01
    49a6:	a2 81       	ldd	r26, Z+2	; 0x02
    49a8:	b3 81       	ldd	r27, Z+3	; 0x03
    49aa:	82 17       	cp	r24, r18
    49ac:	93 07       	cpc	r25, r19
    49ae:	a4 07       	cpc	r26, r20
    49b0:	b5 07       	cpc	r27, r21
    49b2:	08 f4       	brcc	.+2      	; 0x49b6 <HAL_LCD_u8GoTo+0x172>
    49b4:	68 cf       	rjmp	.-304    	; 0x4886 <HAL_LCD_u8GoTo+0x42>
    49b6:	98 c1       	rjmp	.+816    	; 0x4ce8 <HAL_LCD_u8GoTo+0x4a4>
			_delay_ms(2);
			HAL_LCD_u8SendCommands(Right_Shift_Command);
		}
	} else if (Loc_u8TypeOfShift == Left_Shift) {
    49b8:	fe 01       	movw	r30, r28
    49ba:	ef 5b       	subi	r30, 0xBF	; 191
    49bc:	ff 4f       	sbci	r31, 0xFF	; 255
    49be:	80 81       	ld	r24, Z
    49c0:	88 23       	and	r24, r24
    49c2:	09 f0       	breq	.+2      	; 0x49c6 <HAL_LCD_u8GoTo+0x182>
    49c4:	98 c0       	rjmp	.+304    	; 0x4af6 <HAL_LCD_u8GoTo+0x2b2>
		for (u32 count = 0; count < Loc_u8NumOfShift; count++) {
    49c6:	19 ae       	std	Y+57, r1	; 0x39
    49c8:	1a ae       	std	Y+58, r1	; 0x3a
    49ca:	1b ae       	std	Y+59, r1	; 0x3b
    49cc:	1c ae       	std	Y+60, r1	; 0x3c
    49ce:	80 c0       	rjmp	.+256    	; 0x4ad0 <HAL_LCD_u8GoTo+0x28c>
    49d0:	80 e0       	ldi	r24, 0x00	; 0
    49d2:	90 e0       	ldi	r25, 0x00	; 0
    49d4:	a0 e0       	ldi	r26, 0x00	; 0
    49d6:	b0 e4       	ldi	r27, 0x40	; 64
    49d8:	8f a3       	std	Y+39, r24	; 0x27
    49da:	98 a7       	std	Y+40, r25	; 0x28
    49dc:	a9 a7       	std	Y+41, r26	; 0x29
    49de:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    49e0:	6f a1       	ldd	r22, Y+39	; 0x27
    49e2:	78 a5       	ldd	r23, Y+40	; 0x28
    49e4:	89 a5       	ldd	r24, Y+41	; 0x29
    49e6:	9a a5       	ldd	r25, Y+42	; 0x2a
    49e8:	20 e0       	ldi	r18, 0x00	; 0
    49ea:	30 e0       	ldi	r19, 0x00	; 0
    49ec:	4a e7       	ldi	r20, 0x7A	; 122
    49ee:	55 e4       	ldi	r21, 0x45	; 69
    49f0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    49f4:	dc 01       	movw	r26, r24
    49f6:	cb 01       	movw	r24, r22
    49f8:	8b a3       	std	Y+35, r24	; 0x23
    49fa:	9c a3       	std	Y+36, r25	; 0x24
    49fc:	ad a3       	std	Y+37, r26	; 0x25
    49fe:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    4a00:	6b a1       	ldd	r22, Y+35	; 0x23
    4a02:	7c a1       	ldd	r23, Y+36	; 0x24
    4a04:	8d a1       	ldd	r24, Y+37	; 0x25
    4a06:	9e a1       	ldd	r25, Y+38	; 0x26
    4a08:	20 e0       	ldi	r18, 0x00	; 0
    4a0a:	30 e0       	ldi	r19, 0x00	; 0
    4a0c:	40 e8       	ldi	r20, 0x80	; 128
    4a0e:	5f e3       	ldi	r21, 0x3F	; 63
    4a10:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4a14:	88 23       	and	r24, r24
    4a16:	2c f4       	brge	.+10     	; 0x4a22 <HAL_LCD_u8GoTo+0x1de>
		__ticks = 1;
    4a18:	81 e0       	ldi	r24, 0x01	; 1
    4a1a:	90 e0       	ldi	r25, 0x00	; 0
    4a1c:	9a a3       	std	Y+34, r25	; 0x22
    4a1e:	89 a3       	std	Y+33, r24	; 0x21
    4a20:	3f c0       	rjmp	.+126    	; 0x4aa0 <HAL_LCD_u8GoTo+0x25c>
	else if (__tmp > 65535)
    4a22:	6b a1       	ldd	r22, Y+35	; 0x23
    4a24:	7c a1       	ldd	r23, Y+36	; 0x24
    4a26:	8d a1       	ldd	r24, Y+37	; 0x25
    4a28:	9e a1       	ldd	r25, Y+38	; 0x26
    4a2a:	20 e0       	ldi	r18, 0x00	; 0
    4a2c:	3f ef       	ldi	r19, 0xFF	; 255
    4a2e:	4f e7       	ldi	r20, 0x7F	; 127
    4a30:	57 e4       	ldi	r21, 0x47	; 71
    4a32:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4a36:	18 16       	cp	r1, r24
    4a38:	4c f5       	brge	.+82     	; 0x4a8c <HAL_LCD_u8GoTo+0x248>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4a3a:	6f a1       	ldd	r22, Y+39	; 0x27
    4a3c:	78 a5       	ldd	r23, Y+40	; 0x28
    4a3e:	89 a5       	ldd	r24, Y+41	; 0x29
    4a40:	9a a5       	ldd	r25, Y+42	; 0x2a
    4a42:	20 e0       	ldi	r18, 0x00	; 0
    4a44:	30 e0       	ldi	r19, 0x00	; 0
    4a46:	40 e2       	ldi	r20, 0x20	; 32
    4a48:	51 e4       	ldi	r21, 0x41	; 65
    4a4a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4a4e:	dc 01       	movw	r26, r24
    4a50:	cb 01       	movw	r24, r22
    4a52:	bc 01       	movw	r22, r24
    4a54:	cd 01       	movw	r24, r26
    4a56:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4a5a:	dc 01       	movw	r26, r24
    4a5c:	cb 01       	movw	r24, r22
    4a5e:	9a a3       	std	Y+34, r25	; 0x22
    4a60:	89 a3       	std	Y+33, r24	; 0x21
    4a62:	0f c0       	rjmp	.+30     	; 0x4a82 <HAL_LCD_u8GoTo+0x23e>
    4a64:	80 e9       	ldi	r24, 0x90	; 144
    4a66:	91 e0       	ldi	r25, 0x01	; 1
    4a68:	98 a3       	std	Y+32, r25	; 0x20
    4a6a:	8f 8f       	std	Y+31, r24	; 0x1f
    4a6c:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4a6e:	98 a1       	ldd	r25, Y+32	; 0x20
    4a70:	01 97       	sbiw	r24, 0x01	; 1
    4a72:	f1 f7       	brne	.-4      	; 0x4a70 <HAL_LCD_u8GoTo+0x22c>
    4a74:	98 a3       	std	Y+32, r25	; 0x20
    4a76:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4a78:	89 a1       	ldd	r24, Y+33	; 0x21
    4a7a:	9a a1       	ldd	r25, Y+34	; 0x22
    4a7c:	01 97       	sbiw	r24, 0x01	; 1
    4a7e:	9a a3       	std	Y+34, r25	; 0x22
    4a80:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4a82:	89 a1       	ldd	r24, Y+33	; 0x21
    4a84:	9a a1       	ldd	r25, Y+34	; 0x22
    4a86:	00 97       	sbiw	r24, 0x00	; 0
    4a88:	69 f7       	brne	.-38     	; 0x4a64 <HAL_LCD_u8GoTo+0x220>
    4a8a:	14 c0       	rjmp	.+40     	; 0x4ab4 <HAL_LCD_u8GoTo+0x270>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4a8c:	6b a1       	ldd	r22, Y+35	; 0x23
    4a8e:	7c a1       	ldd	r23, Y+36	; 0x24
    4a90:	8d a1       	ldd	r24, Y+37	; 0x25
    4a92:	9e a1       	ldd	r25, Y+38	; 0x26
    4a94:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4a98:	dc 01       	movw	r26, r24
    4a9a:	cb 01       	movw	r24, r22
    4a9c:	9a a3       	std	Y+34, r25	; 0x22
    4a9e:	89 a3       	std	Y+33, r24	; 0x21
    4aa0:	89 a1       	ldd	r24, Y+33	; 0x21
    4aa2:	9a a1       	ldd	r25, Y+34	; 0x22
    4aa4:	9e 8f       	std	Y+30, r25	; 0x1e
    4aa6:	8d 8f       	std	Y+29, r24	; 0x1d
    4aa8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4aaa:	9e 8d       	ldd	r25, Y+30	; 0x1e
    4aac:	01 97       	sbiw	r24, 0x01	; 1
    4aae:	f1 f7       	brne	.-4      	; 0x4aac <HAL_LCD_u8GoTo+0x268>
    4ab0:	9e 8f       	std	Y+30, r25	; 0x1e
    4ab2:	8d 8f       	std	Y+29, r24	; 0x1d
			_delay_ms(2);
			HAL_LCD_u8SendCommands(Left_Shift_Command);
    4ab4:	88 e1       	ldi	r24, 0x18	; 24
    4ab6:	0e 94 8d 21 	call	0x431a	; 0x431a <HAL_LCD_u8SendCommands>
		for (u32 count = 0; count < Loc_u8NumOfShift; count++) {
			_delay_ms(2);
			HAL_LCD_u8SendCommands(Right_Shift_Command);
		}
	} else if (Loc_u8TypeOfShift == Left_Shift) {
		for (u32 count = 0; count < Loc_u8NumOfShift; count++) {
    4aba:	89 ad       	ldd	r24, Y+57	; 0x39
    4abc:	9a ad       	ldd	r25, Y+58	; 0x3a
    4abe:	ab ad       	ldd	r26, Y+59	; 0x3b
    4ac0:	bc ad       	ldd	r27, Y+60	; 0x3c
    4ac2:	01 96       	adiw	r24, 0x01	; 1
    4ac4:	a1 1d       	adc	r26, r1
    4ac6:	b1 1d       	adc	r27, r1
    4ac8:	89 af       	std	Y+57, r24	; 0x39
    4aca:	9a af       	std	Y+58, r25	; 0x3a
    4acc:	ab af       	std	Y+59, r26	; 0x3b
    4ace:	bc af       	std	Y+60, r27	; 0x3c
    4ad0:	fe 01       	movw	r30, r28
    4ad2:	ee 5b       	subi	r30, 0xBE	; 190
    4ad4:	ff 4f       	sbci	r31, 0xFF	; 255
    4ad6:	80 81       	ld	r24, Z
    4ad8:	28 2f       	mov	r18, r24
    4ada:	30 e0       	ldi	r19, 0x00	; 0
    4adc:	40 e0       	ldi	r20, 0x00	; 0
    4ade:	50 e0       	ldi	r21, 0x00	; 0
    4ae0:	89 ad       	ldd	r24, Y+57	; 0x39
    4ae2:	9a ad       	ldd	r25, Y+58	; 0x3a
    4ae4:	ab ad       	ldd	r26, Y+59	; 0x3b
    4ae6:	bc ad       	ldd	r27, Y+60	; 0x3c
    4ae8:	82 17       	cp	r24, r18
    4aea:	93 07       	cpc	r25, r19
    4aec:	a4 07       	cpc	r26, r20
    4aee:	b5 07       	cpc	r27, r21
    4af0:	08 f4       	brcc	.+2      	; 0x4af4 <HAL_LCD_u8GoTo+0x2b0>
    4af2:	6e cf       	rjmp	.-292    	; 0x49d0 <HAL_LCD_u8GoTo+0x18c>
    4af4:	f9 c0       	rjmp	.+498    	; 0x4ce8 <HAL_LCD_u8GoTo+0x4a4>
			_delay_ms(2);
			HAL_LCD_u8SendCommands(Left_Shift_Command);
		}
	} else if (Loc_u8TypeOfShift == First_Line) {
    4af6:	fe 01       	movw	r30, r28
    4af8:	ef 5b       	subi	r30, 0xBF	; 191
    4afa:	ff 4f       	sbci	r31, 0xFF	; 255
    4afc:	80 81       	ld	r24, Z
    4afe:	82 30       	cpi	r24, 0x02	; 2
    4b00:	09 f0       	breq	.+2      	; 0x4b04 <HAL_LCD_u8GoTo+0x2c0>
    4b02:	76 c0       	rjmp	.+236    	; 0x4bf0 <HAL_LCD_u8GoTo+0x3ac>
    4b04:	80 e0       	ldi	r24, 0x00	; 0
    4b06:	90 e0       	ldi	r25, 0x00	; 0
    4b08:	a0 e0       	ldi	r26, 0x00	; 0
    4b0a:	b0 e4       	ldi	r27, 0x40	; 64
    4b0c:	89 8f       	std	Y+25, r24	; 0x19
    4b0e:	9a 8f       	std	Y+26, r25	; 0x1a
    4b10:	ab 8f       	std	Y+27, r26	; 0x1b
    4b12:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4b14:	69 8d       	ldd	r22, Y+25	; 0x19
    4b16:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4b18:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4b1a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4b1c:	20 e0       	ldi	r18, 0x00	; 0
    4b1e:	30 e0       	ldi	r19, 0x00	; 0
    4b20:	4a e7       	ldi	r20, 0x7A	; 122
    4b22:	55 e4       	ldi	r21, 0x45	; 69
    4b24:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4b28:	dc 01       	movw	r26, r24
    4b2a:	cb 01       	movw	r24, r22
    4b2c:	8d 8b       	std	Y+21, r24	; 0x15
    4b2e:	9e 8b       	std	Y+22, r25	; 0x16
    4b30:	af 8b       	std	Y+23, r26	; 0x17
    4b32:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    4b34:	6d 89       	ldd	r22, Y+21	; 0x15
    4b36:	7e 89       	ldd	r23, Y+22	; 0x16
    4b38:	8f 89       	ldd	r24, Y+23	; 0x17
    4b3a:	98 8d       	ldd	r25, Y+24	; 0x18
    4b3c:	20 e0       	ldi	r18, 0x00	; 0
    4b3e:	30 e0       	ldi	r19, 0x00	; 0
    4b40:	40 e8       	ldi	r20, 0x80	; 128
    4b42:	5f e3       	ldi	r21, 0x3F	; 63
    4b44:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4b48:	88 23       	and	r24, r24
    4b4a:	2c f4       	brge	.+10     	; 0x4b56 <HAL_LCD_u8GoTo+0x312>
		__ticks = 1;
    4b4c:	81 e0       	ldi	r24, 0x01	; 1
    4b4e:	90 e0       	ldi	r25, 0x00	; 0
    4b50:	9c 8b       	std	Y+20, r25	; 0x14
    4b52:	8b 8b       	std	Y+19, r24	; 0x13
    4b54:	3f c0       	rjmp	.+126    	; 0x4bd4 <HAL_LCD_u8GoTo+0x390>
	else if (__tmp > 65535)
    4b56:	6d 89       	ldd	r22, Y+21	; 0x15
    4b58:	7e 89       	ldd	r23, Y+22	; 0x16
    4b5a:	8f 89       	ldd	r24, Y+23	; 0x17
    4b5c:	98 8d       	ldd	r25, Y+24	; 0x18
    4b5e:	20 e0       	ldi	r18, 0x00	; 0
    4b60:	3f ef       	ldi	r19, 0xFF	; 255
    4b62:	4f e7       	ldi	r20, 0x7F	; 127
    4b64:	57 e4       	ldi	r21, 0x47	; 71
    4b66:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4b6a:	18 16       	cp	r1, r24
    4b6c:	4c f5       	brge	.+82     	; 0x4bc0 <HAL_LCD_u8GoTo+0x37c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4b6e:	69 8d       	ldd	r22, Y+25	; 0x19
    4b70:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4b72:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4b74:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4b76:	20 e0       	ldi	r18, 0x00	; 0
    4b78:	30 e0       	ldi	r19, 0x00	; 0
    4b7a:	40 e2       	ldi	r20, 0x20	; 32
    4b7c:	51 e4       	ldi	r21, 0x41	; 65
    4b7e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4b82:	dc 01       	movw	r26, r24
    4b84:	cb 01       	movw	r24, r22
    4b86:	bc 01       	movw	r22, r24
    4b88:	cd 01       	movw	r24, r26
    4b8a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4b8e:	dc 01       	movw	r26, r24
    4b90:	cb 01       	movw	r24, r22
    4b92:	9c 8b       	std	Y+20, r25	; 0x14
    4b94:	8b 8b       	std	Y+19, r24	; 0x13
    4b96:	0f c0       	rjmp	.+30     	; 0x4bb6 <HAL_LCD_u8GoTo+0x372>
    4b98:	80 e9       	ldi	r24, 0x90	; 144
    4b9a:	91 e0       	ldi	r25, 0x01	; 1
    4b9c:	9a 8b       	std	Y+18, r25	; 0x12
    4b9e:	89 8b       	std	Y+17, r24	; 0x11
    4ba0:	89 89       	ldd	r24, Y+17	; 0x11
    4ba2:	9a 89       	ldd	r25, Y+18	; 0x12
    4ba4:	01 97       	sbiw	r24, 0x01	; 1
    4ba6:	f1 f7       	brne	.-4      	; 0x4ba4 <HAL_LCD_u8GoTo+0x360>
    4ba8:	9a 8b       	std	Y+18, r25	; 0x12
    4baa:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4bac:	8b 89       	ldd	r24, Y+19	; 0x13
    4bae:	9c 89       	ldd	r25, Y+20	; 0x14
    4bb0:	01 97       	sbiw	r24, 0x01	; 1
    4bb2:	9c 8b       	std	Y+20, r25	; 0x14
    4bb4:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4bb6:	8b 89       	ldd	r24, Y+19	; 0x13
    4bb8:	9c 89       	ldd	r25, Y+20	; 0x14
    4bba:	00 97       	sbiw	r24, 0x00	; 0
    4bbc:	69 f7       	brne	.-38     	; 0x4b98 <HAL_LCD_u8GoTo+0x354>
    4bbe:	14 c0       	rjmp	.+40     	; 0x4be8 <HAL_LCD_u8GoTo+0x3a4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4bc0:	6d 89       	ldd	r22, Y+21	; 0x15
    4bc2:	7e 89       	ldd	r23, Y+22	; 0x16
    4bc4:	8f 89       	ldd	r24, Y+23	; 0x17
    4bc6:	98 8d       	ldd	r25, Y+24	; 0x18
    4bc8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4bcc:	dc 01       	movw	r26, r24
    4bce:	cb 01       	movw	r24, r22
    4bd0:	9c 8b       	std	Y+20, r25	; 0x14
    4bd2:	8b 8b       	std	Y+19, r24	; 0x13
    4bd4:	8b 89       	ldd	r24, Y+19	; 0x13
    4bd6:	9c 89       	ldd	r25, Y+20	; 0x14
    4bd8:	98 8b       	std	Y+16, r25	; 0x10
    4bda:	8f 87       	std	Y+15, r24	; 0x0f
    4bdc:	8f 85       	ldd	r24, Y+15	; 0x0f
    4bde:	98 89       	ldd	r25, Y+16	; 0x10
    4be0:	01 97       	sbiw	r24, 0x01	; 1
    4be2:	f1 f7       	brne	.-4      	; 0x4be0 <HAL_LCD_u8GoTo+0x39c>
    4be4:	98 8b       	std	Y+16, r25	; 0x10
    4be6:	8f 87       	std	Y+15, r24	; 0x0f
		_delay_ms(2);
		HAL_LCD_u8SendCommands(beginning_1stLine);
    4be8:	80 e8       	ldi	r24, 0x80	; 128
    4bea:	0e 94 8d 21 	call	0x431a	; 0x431a <HAL_LCD_u8SendCommands>
    4bee:	7c c0       	rjmp	.+248    	; 0x4ce8 <HAL_LCD_u8GoTo+0x4a4>
	} else if (Loc_u8TypeOfShift == Second_Line) {
    4bf0:	fe 01       	movw	r30, r28
    4bf2:	ef 5b       	subi	r30, 0xBF	; 191
    4bf4:	ff 4f       	sbci	r31, 0xFF	; 255
    4bf6:	80 81       	ld	r24, Z
    4bf8:	83 30       	cpi	r24, 0x03	; 3
    4bfa:	09 f0       	breq	.+2      	; 0x4bfe <HAL_LCD_u8GoTo+0x3ba>
    4bfc:	75 c0       	rjmp	.+234    	; 0x4ce8 <HAL_LCD_u8GoTo+0x4a4>
    4bfe:	80 e0       	ldi	r24, 0x00	; 0
    4c00:	90 e0       	ldi	r25, 0x00	; 0
    4c02:	a0 e0       	ldi	r26, 0x00	; 0
    4c04:	b0 e4       	ldi	r27, 0x40	; 64
    4c06:	8b 87       	std	Y+11, r24	; 0x0b
    4c08:	9c 87       	std	Y+12, r25	; 0x0c
    4c0a:	ad 87       	std	Y+13, r26	; 0x0d
    4c0c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4c0e:	6b 85       	ldd	r22, Y+11	; 0x0b
    4c10:	7c 85       	ldd	r23, Y+12	; 0x0c
    4c12:	8d 85       	ldd	r24, Y+13	; 0x0d
    4c14:	9e 85       	ldd	r25, Y+14	; 0x0e
    4c16:	20 e0       	ldi	r18, 0x00	; 0
    4c18:	30 e0       	ldi	r19, 0x00	; 0
    4c1a:	4a e7       	ldi	r20, 0x7A	; 122
    4c1c:	55 e4       	ldi	r21, 0x45	; 69
    4c1e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4c22:	dc 01       	movw	r26, r24
    4c24:	cb 01       	movw	r24, r22
    4c26:	8f 83       	std	Y+7, r24	; 0x07
    4c28:	98 87       	std	Y+8, r25	; 0x08
    4c2a:	a9 87       	std	Y+9, r26	; 0x09
    4c2c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    4c2e:	6f 81       	ldd	r22, Y+7	; 0x07
    4c30:	78 85       	ldd	r23, Y+8	; 0x08
    4c32:	89 85       	ldd	r24, Y+9	; 0x09
    4c34:	9a 85       	ldd	r25, Y+10	; 0x0a
    4c36:	20 e0       	ldi	r18, 0x00	; 0
    4c38:	30 e0       	ldi	r19, 0x00	; 0
    4c3a:	40 e8       	ldi	r20, 0x80	; 128
    4c3c:	5f e3       	ldi	r21, 0x3F	; 63
    4c3e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4c42:	88 23       	and	r24, r24
    4c44:	2c f4       	brge	.+10     	; 0x4c50 <HAL_LCD_u8GoTo+0x40c>
		__ticks = 1;
    4c46:	81 e0       	ldi	r24, 0x01	; 1
    4c48:	90 e0       	ldi	r25, 0x00	; 0
    4c4a:	9e 83       	std	Y+6, r25	; 0x06
    4c4c:	8d 83       	std	Y+5, r24	; 0x05
    4c4e:	3f c0       	rjmp	.+126    	; 0x4cce <HAL_LCD_u8GoTo+0x48a>
	else if (__tmp > 65535)
    4c50:	6f 81       	ldd	r22, Y+7	; 0x07
    4c52:	78 85       	ldd	r23, Y+8	; 0x08
    4c54:	89 85       	ldd	r24, Y+9	; 0x09
    4c56:	9a 85       	ldd	r25, Y+10	; 0x0a
    4c58:	20 e0       	ldi	r18, 0x00	; 0
    4c5a:	3f ef       	ldi	r19, 0xFF	; 255
    4c5c:	4f e7       	ldi	r20, 0x7F	; 127
    4c5e:	57 e4       	ldi	r21, 0x47	; 71
    4c60:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4c64:	18 16       	cp	r1, r24
    4c66:	4c f5       	brge	.+82     	; 0x4cba <HAL_LCD_u8GoTo+0x476>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4c68:	6b 85       	ldd	r22, Y+11	; 0x0b
    4c6a:	7c 85       	ldd	r23, Y+12	; 0x0c
    4c6c:	8d 85       	ldd	r24, Y+13	; 0x0d
    4c6e:	9e 85       	ldd	r25, Y+14	; 0x0e
    4c70:	20 e0       	ldi	r18, 0x00	; 0
    4c72:	30 e0       	ldi	r19, 0x00	; 0
    4c74:	40 e2       	ldi	r20, 0x20	; 32
    4c76:	51 e4       	ldi	r21, 0x41	; 65
    4c78:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4c7c:	dc 01       	movw	r26, r24
    4c7e:	cb 01       	movw	r24, r22
    4c80:	bc 01       	movw	r22, r24
    4c82:	cd 01       	movw	r24, r26
    4c84:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4c88:	dc 01       	movw	r26, r24
    4c8a:	cb 01       	movw	r24, r22
    4c8c:	9e 83       	std	Y+6, r25	; 0x06
    4c8e:	8d 83       	std	Y+5, r24	; 0x05
    4c90:	0f c0       	rjmp	.+30     	; 0x4cb0 <HAL_LCD_u8GoTo+0x46c>
    4c92:	80 e9       	ldi	r24, 0x90	; 144
    4c94:	91 e0       	ldi	r25, 0x01	; 1
    4c96:	9c 83       	std	Y+4, r25	; 0x04
    4c98:	8b 83       	std	Y+3, r24	; 0x03
    4c9a:	8b 81       	ldd	r24, Y+3	; 0x03
    4c9c:	9c 81       	ldd	r25, Y+4	; 0x04
    4c9e:	01 97       	sbiw	r24, 0x01	; 1
    4ca0:	f1 f7       	brne	.-4      	; 0x4c9e <HAL_LCD_u8GoTo+0x45a>
    4ca2:	9c 83       	std	Y+4, r25	; 0x04
    4ca4:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4ca6:	8d 81       	ldd	r24, Y+5	; 0x05
    4ca8:	9e 81       	ldd	r25, Y+6	; 0x06
    4caa:	01 97       	sbiw	r24, 0x01	; 1
    4cac:	9e 83       	std	Y+6, r25	; 0x06
    4cae:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4cb0:	8d 81       	ldd	r24, Y+5	; 0x05
    4cb2:	9e 81       	ldd	r25, Y+6	; 0x06
    4cb4:	00 97       	sbiw	r24, 0x00	; 0
    4cb6:	69 f7       	brne	.-38     	; 0x4c92 <HAL_LCD_u8GoTo+0x44e>
    4cb8:	14 c0       	rjmp	.+40     	; 0x4ce2 <HAL_LCD_u8GoTo+0x49e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4cba:	6f 81       	ldd	r22, Y+7	; 0x07
    4cbc:	78 85       	ldd	r23, Y+8	; 0x08
    4cbe:	89 85       	ldd	r24, Y+9	; 0x09
    4cc0:	9a 85       	ldd	r25, Y+10	; 0x0a
    4cc2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4cc6:	dc 01       	movw	r26, r24
    4cc8:	cb 01       	movw	r24, r22
    4cca:	9e 83       	std	Y+6, r25	; 0x06
    4ccc:	8d 83       	std	Y+5, r24	; 0x05
    4cce:	8d 81       	ldd	r24, Y+5	; 0x05
    4cd0:	9e 81       	ldd	r25, Y+6	; 0x06
    4cd2:	9a 83       	std	Y+2, r25	; 0x02
    4cd4:	89 83       	std	Y+1, r24	; 0x01
    4cd6:	89 81       	ldd	r24, Y+1	; 0x01
    4cd8:	9a 81       	ldd	r25, Y+2	; 0x02
    4cda:	01 97       	sbiw	r24, 0x01	; 1
    4cdc:	f1 f7       	brne	.-4      	; 0x4cda <HAL_LCD_u8GoTo+0x496>
    4cde:	9a 83       	std	Y+2, r25	; 0x02
    4ce0:	89 83       	std	Y+1, r24	; 0x01
		_delay_ms(2);
		HAL_LCD_u8SendCommands(beginning_2stLine);
    4ce2:	80 ec       	ldi	r24, 0xC0	; 192
    4ce4:	0e 94 8d 21 	call	0x431a	; 0x431a <HAL_LCD_u8SendCommands>
	}
}
    4ce8:	ce 5b       	subi	r28, 0xBE	; 190
    4cea:	df 4f       	sbci	r29, 0xFF	; 255
    4cec:	0f b6       	in	r0, 0x3f	; 63
    4cee:	f8 94       	cli
    4cf0:	de bf       	out	0x3e, r29	; 62
    4cf2:	0f be       	out	0x3f, r0	; 63
    4cf4:	cd bf       	out	0x3d, r28	; 61
    4cf6:	cf 91       	pop	r28
    4cf8:	df 91       	pop	r29
    4cfa:	08 95       	ret

00004cfc <HAL_LCD_u8Clear>:

void HAL_LCD_u8Clear() {
    4cfc:	df 93       	push	r29
    4cfe:	cf 93       	push	r28
    4d00:	cd b7       	in	r28, 0x3d	; 61
    4d02:	de b7       	in	r29, 0x3e	; 62
    4d04:	2e 97       	sbiw	r28, 0x0e	; 14
    4d06:	0f b6       	in	r0, 0x3f	; 63
    4d08:	f8 94       	cli
    4d0a:	de bf       	out	0x3e, r29	; 62
    4d0c:	0f be       	out	0x3f, r0	; 63
    4d0e:	cd bf       	out	0x3d, r28	; 61
    4d10:	80 e0       	ldi	r24, 0x00	; 0
    4d12:	90 e0       	ldi	r25, 0x00	; 0
    4d14:	a0 e0       	ldi	r26, 0x00	; 0
    4d16:	b0 e4       	ldi	r27, 0x40	; 64
    4d18:	8b 87       	std	Y+11, r24	; 0x0b
    4d1a:	9c 87       	std	Y+12, r25	; 0x0c
    4d1c:	ad 87       	std	Y+13, r26	; 0x0d
    4d1e:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4d20:	6b 85       	ldd	r22, Y+11	; 0x0b
    4d22:	7c 85       	ldd	r23, Y+12	; 0x0c
    4d24:	8d 85       	ldd	r24, Y+13	; 0x0d
    4d26:	9e 85       	ldd	r25, Y+14	; 0x0e
    4d28:	20 e0       	ldi	r18, 0x00	; 0
    4d2a:	30 e0       	ldi	r19, 0x00	; 0
    4d2c:	4a e7       	ldi	r20, 0x7A	; 122
    4d2e:	55 e4       	ldi	r21, 0x45	; 69
    4d30:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4d34:	dc 01       	movw	r26, r24
    4d36:	cb 01       	movw	r24, r22
    4d38:	8f 83       	std	Y+7, r24	; 0x07
    4d3a:	98 87       	std	Y+8, r25	; 0x08
    4d3c:	a9 87       	std	Y+9, r26	; 0x09
    4d3e:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    4d40:	6f 81       	ldd	r22, Y+7	; 0x07
    4d42:	78 85       	ldd	r23, Y+8	; 0x08
    4d44:	89 85       	ldd	r24, Y+9	; 0x09
    4d46:	9a 85       	ldd	r25, Y+10	; 0x0a
    4d48:	20 e0       	ldi	r18, 0x00	; 0
    4d4a:	30 e0       	ldi	r19, 0x00	; 0
    4d4c:	40 e8       	ldi	r20, 0x80	; 128
    4d4e:	5f e3       	ldi	r21, 0x3F	; 63
    4d50:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4d54:	88 23       	and	r24, r24
    4d56:	2c f4       	brge	.+10     	; 0x4d62 <HAL_LCD_u8Clear+0x66>
		__ticks = 1;
    4d58:	81 e0       	ldi	r24, 0x01	; 1
    4d5a:	90 e0       	ldi	r25, 0x00	; 0
    4d5c:	9e 83       	std	Y+6, r25	; 0x06
    4d5e:	8d 83       	std	Y+5, r24	; 0x05
    4d60:	3f c0       	rjmp	.+126    	; 0x4de0 <HAL_LCD_u8Clear+0xe4>
	else if (__tmp > 65535)
    4d62:	6f 81       	ldd	r22, Y+7	; 0x07
    4d64:	78 85       	ldd	r23, Y+8	; 0x08
    4d66:	89 85       	ldd	r24, Y+9	; 0x09
    4d68:	9a 85       	ldd	r25, Y+10	; 0x0a
    4d6a:	20 e0       	ldi	r18, 0x00	; 0
    4d6c:	3f ef       	ldi	r19, 0xFF	; 255
    4d6e:	4f e7       	ldi	r20, 0x7F	; 127
    4d70:	57 e4       	ldi	r21, 0x47	; 71
    4d72:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4d76:	18 16       	cp	r1, r24
    4d78:	4c f5       	brge	.+82     	; 0x4dcc <HAL_LCD_u8Clear+0xd0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4d7a:	6b 85       	ldd	r22, Y+11	; 0x0b
    4d7c:	7c 85       	ldd	r23, Y+12	; 0x0c
    4d7e:	8d 85       	ldd	r24, Y+13	; 0x0d
    4d80:	9e 85       	ldd	r25, Y+14	; 0x0e
    4d82:	20 e0       	ldi	r18, 0x00	; 0
    4d84:	30 e0       	ldi	r19, 0x00	; 0
    4d86:	40 e2       	ldi	r20, 0x20	; 32
    4d88:	51 e4       	ldi	r21, 0x41	; 65
    4d8a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4d8e:	dc 01       	movw	r26, r24
    4d90:	cb 01       	movw	r24, r22
    4d92:	bc 01       	movw	r22, r24
    4d94:	cd 01       	movw	r24, r26
    4d96:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4d9a:	dc 01       	movw	r26, r24
    4d9c:	cb 01       	movw	r24, r22
    4d9e:	9e 83       	std	Y+6, r25	; 0x06
    4da0:	8d 83       	std	Y+5, r24	; 0x05
    4da2:	0f c0       	rjmp	.+30     	; 0x4dc2 <HAL_LCD_u8Clear+0xc6>
    4da4:	80 e9       	ldi	r24, 0x90	; 144
    4da6:	91 e0       	ldi	r25, 0x01	; 1
    4da8:	9c 83       	std	Y+4, r25	; 0x04
    4daa:	8b 83       	std	Y+3, r24	; 0x03
    4dac:	8b 81       	ldd	r24, Y+3	; 0x03
    4dae:	9c 81       	ldd	r25, Y+4	; 0x04
    4db0:	01 97       	sbiw	r24, 0x01	; 1
    4db2:	f1 f7       	brne	.-4      	; 0x4db0 <HAL_LCD_u8Clear+0xb4>
    4db4:	9c 83       	std	Y+4, r25	; 0x04
    4db6:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4db8:	8d 81       	ldd	r24, Y+5	; 0x05
    4dba:	9e 81       	ldd	r25, Y+6	; 0x06
    4dbc:	01 97       	sbiw	r24, 0x01	; 1
    4dbe:	9e 83       	std	Y+6, r25	; 0x06
    4dc0:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4dc2:	8d 81       	ldd	r24, Y+5	; 0x05
    4dc4:	9e 81       	ldd	r25, Y+6	; 0x06
    4dc6:	00 97       	sbiw	r24, 0x00	; 0
    4dc8:	69 f7       	brne	.-38     	; 0x4da4 <HAL_LCD_u8Clear+0xa8>
    4dca:	14 c0       	rjmp	.+40     	; 0x4df4 <HAL_LCD_u8Clear+0xf8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4dcc:	6f 81       	ldd	r22, Y+7	; 0x07
    4dce:	78 85       	ldd	r23, Y+8	; 0x08
    4dd0:	89 85       	ldd	r24, Y+9	; 0x09
    4dd2:	9a 85       	ldd	r25, Y+10	; 0x0a
    4dd4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4dd8:	dc 01       	movw	r26, r24
    4dda:	cb 01       	movw	r24, r22
    4ddc:	9e 83       	std	Y+6, r25	; 0x06
    4dde:	8d 83       	std	Y+5, r24	; 0x05
    4de0:	8d 81       	ldd	r24, Y+5	; 0x05
    4de2:	9e 81       	ldd	r25, Y+6	; 0x06
    4de4:	9a 83       	std	Y+2, r25	; 0x02
    4de6:	89 83       	std	Y+1, r24	; 0x01
    4de8:	89 81       	ldd	r24, Y+1	; 0x01
    4dea:	9a 81       	ldd	r25, Y+2	; 0x02
    4dec:	01 97       	sbiw	r24, 0x01	; 1
    4dee:	f1 f7       	brne	.-4      	; 0x4dec <HAL_LCD_u8Clear+0xf0>
    4df0:	9a 83       	std	Y+2, r25	; 0x02
    4df2:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	HAL_LCD_u8SendCommands(Display_Clear);
    4df4:	81 e0       	ldi	r24, 0x01	; 1
    4df6:	0e 94 8d 21 	call	0x431a	; 0x431a <HAL_LCD_u8SendCommands>
}
    4dfa:	2e 96       	adiw	r28, 0x0e	; 14
    4dfc:	0f b6       	in	r0, 0x3f	; 63
    4dfe:	f8 94       	cli
    4e00:	de bf       	out	0x3e, r29	; 62
    4e02:	0f be       	out	0x3f, r0	; 63
    4e04:	cd bf       	out	0x3d, r28	; 61
    4e06:	cf 91       	pop	r28
    4e08:	df 91       	pop	r29
    4e0a:	08 95       	ret

00004e0c <HAL_LCD_u8CustomChar>:

void HAL_LCD_u8CustomChar(u8 Loc_u8Location, u8* Loc_u8msg) {
    4e0c:	df 93       	push	r29
    4e0e:	cf 93       	push	r28
    4e10:	00 d0       	rcall	.+0      	; 0x4e12 <HAL_LCD_u8CustomChar+0x6>
    4e12:	00 d0       	rcall	.+0      	; 0x4e14 <HAL_LCD_u8CustomChar+0x8>
    4e14:	cd b7       	in	r28, 0x3d	; 61
    4e16:	de b7       	in	r29, 0x3e	; 62
    4e18:	8a 83       	std	Y+2, r24	; 0x02
    4e1a:	7c 83       	std	Y+4, r23	; 0x04
    4e1c:	6b 83       	std	Y+3, r22	; 0x03
	if (Loc_u8Location < 8) {
    4e1e:	8a 81       	ldd	r24, Y+2	; 0x02
    4e20:	88 30       	cpi	r24, 0x08	; 8
    4e22:	f8 f4       	brcc	.+62     	; 0x4e62 <HAL_LCD_u8CustomChar+0x56>
		HAL_LCD_u8SendCommands(0x40 + (Loc_u8Location*8));
    4e24:	8a 81       	ldd	r24, Y+2	; 0x02
    4e26:	88 2f       	mov	r24, r24
    4e28:	90 e0       	ldi	r25, 0x00	; 0
    4e2a:	08 96       	adiw	r24, 0x08	; 8
    4e2c:	88 0f       	add	r24, r24
    4e2e:	99 1f       	adc	r25, r25
    4e30:	88 0f       	add	r24, r24
    4e32:	99 1f       	adc	r25, r25
    4e34:	88 0f       	add	r24, r24
    4e36:	99 1f       	adc	r25, r25
    4e38:	0e 94 8d 21 	call	0x431a	; 0x431a <HAL_LCD_u8SendCommands>
		for( u8 count = 0; count < 8; count++)
    4e3c:	19 82       	std	Y+1, r1	; 0x01
    4e3e:	0e c0       	rjmp	.+28     	; 0x4e5c <HAL_LCD_u8CustomChar+0x50>
			HAL_LCD_u8SendChar(Loc_u8msg[count]);
    4e40:	89 81       	ldd	r24, Y+1	; 0x01
    4e42:	28 2f       	mov	r18, r24
    4e44:	30 e0       	ldi	r19, 0x00	; 0
    4e46:	8b 81       	ldd	r24, Y+3	; 0x03
    4e48:	9c 81       	ldd	r25, Y+4	; 0x04
    4e4a:	fc 01       	movw	r30, r24
    4e4c:	e2 0f       	add	r30, r18
    4e4e:	f3 1f       	adc	r31, r19
    4e50:	80 81       	ld	r24, Z
    4e52:	0e 94 ab 22 	call	0x4556	; 0x4556 <HAL_LCD_u8SendChar>
}

void HAL_LCD_u8CustomChar(u8 Loc_u8Location, u8* Loc_u8msg) {
	if (Loc_u8Location < 8) {
		HAL_LCD_u8SendCommands(0x40 + (Loc_u8Location*8));
		for( u8 count = 0; count < 8; count++)
    4e56:	89 81       	ldd	r24, Y+1	; 0x01
    4e58:	8f 5f       	subi	r24, 0xFF	; 255
    4e5a:	89 83       	std	Y+1, r24	; 0x01
    4e5c:	89 81       	ldd	r24, Y+1	; 0x01
    4e5e:	88 30       	cpi	r24, 0x08	; 8
    4e60:	78 f3       	brcs	.-34     	; 0x4e40 <HAL_LCD_u8CustomChar+0x34>
			HAL_LCD_u8SendChar(Loc_u8msg[count]);
	}
	HAL_LCD_u8SendCommands(0x02);
    4e62:	82 e0       	ldi	r24, 0x02	; 2
    4e64:	0e 94 8d 21 	call	0x431a	; 0x431a <HAL_LCD_u8SendCommands>
}
    4e68:	0f 90       	pop	r0
    4e6a:	0f 90       	pop	r0
    4e6c:	0f 90       	pop	r0
    4e6e:	0f 90       	pop	r0
    4e70:	cf 91       	pop	r28
    4e72:	df 91       	pop	r29
    4e74:	08 95       	ret

00004e76 <HAL_LCD_voidData>:

 void  HAL_LCD_voidData(u8 Data)
{
    4e76:	df 93       	push	r29
    4e78:	cf 93       	push	r28
    4e7a:	0f 92       	push	r0
    4e7c:	cd b7       	in	r28, 0x3d	; 61
    4e7e:	de b7       	in	r29, 0x3e	; 62
    4e80:	89 83       	std	Y+1, r24	; 0x01

  if (GET_BIT(Data,0)==1)
    4e82:	89 81       	ldd	r24, Y+1	; 0x01
    4e84:	88 2f       	mov	r24, r24
    4e86:	90 e0       	ldi	r25, 0x00	; 0
    4e88:	81 70       	andi	r24, 0x01	; 1
    4e8a:	90 70       	andi	r25, 0x00	; 0
    4e8c:	88 23       	and	r24, r24
    4e8e:	31 f0       	breq	.+12     	; 0x4e9c <HAL_LCD_voidData+0x26>
  {
    MCAL_DIO_u8SetPinValue(LCD_D_PORT,LCD_D4_PIN,Pin_High);
    4e90:	80 e0       	ldi	r24, 0x00	; 0
    4e92:	64 e0       	ldi	r22, 0x04	; 4
    4e94:	41 e0       	ldi	r20, 0x01	; 1
    4e96:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
    4e9a:	05 c0       	rjmp	.+10     	; 0x4ea6 <HAL_LCD_voidData+0x30>
  }
  else
  {
	  MCAL_DIO_u8SetPinValue(LCD_D_PORT,LCD_D4_PIN,Pin_Low);
    4e9c:	80 e0       	ldi	r24, 0x00	; 0
    4e9e:	64 e0       	ldi	r22, 0x04	; 4
    4ea0:	40 e0       	ldi	r20, 0x00	; 0
    4ea2:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
  }
  if (GET_BIT(Data,1)==1)
    4ea6:	89 81       	ldd	r24, Y+1	; 0x01
    4ea8:	86 95       	lsr	r24
    4eaa:	88 2f       	mov	r24, r24
    4eac:	90 e0       	ldi	r25, 0x00	; 0
    4eae:	81 70       	andi	r24, 0x01	; 1
    4eb0:	90 70       	andi	r25, 0x00	; 0
    4eb2:	88 23       	and	r24, r24
    4eb4:	31 f0       	breq	.+12     	; 0x4ec2 <HAL_LCD_voidData+0x4c>
  {
	  MCAL_DIO_u8SetPinValue(LCD_D_PORT,LCD_D5_PIN,Pin_High);
    4eb6:	80 e0       	ldi	r24, 0x00	; 0
    4eb8:	65 e0       	ldi	r22, 0x05	; 5
    4eba:	41 e0       	ldi	r20, 0x01	; 1
    4ebc:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
    4ec0:	05 c0       	rjmp	.+10     	; 0x4ecc <HAL_LCD_voidData+0x56>
  }
  else
  {
	  MCAL_DIO_u8SetPinValue(LCD_D_PORT,LCD_D5_PIN,Pin_Low);
    4ec2:	80 e0       	ldi	r24, 0x00	; 0
    4ec4:	65 e0       	ldi	r22, 0x05	; 5
    4ec6:	40 e0       	ldi	r20, 0x00	; 0
    4ec8:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
  }

  if (GET_BIT(Data,2)==1)
    4ecc:	89 81       	ldd	r24, Y+1	; 0x01
    4ece:	86 95       	lsr	r24
    4ed0:	86 95       	lsr	r24
    4ed2:	88 2f       	mov	r24, r24
    4ed4:	90 e0       	ldi	r25, 0x00	; 0
    4ed6:	81 70       	andi	r24, 0x01	; 1
    4ed8:	90 70       	andi	r25, 0x00	; 0
    4eda:	88 23       	and	r24, r24
    4edc:	31 f0       	breq	.+12     	; 0x4eea <HAL_LCD_voidData+0x74>
  {
	  MCAL_DIO_u8SetPinValue(LCD_D_PORT,LCD_D6_PIN,Pin_High);
    4ede:	80 e0       	ldi	r24, 0x00	; 0
    4ee0:	66 e0       	ldi	r22, 0x06	; 6
    4ee2:	41 e0       	ldi	r20, 0x01	; 1
    4ee4:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
    4ee8:	05 c0       	rjmp	.+10     	; 0x4ef4 <HAL_LCD_voidData+0x7e>
  }
  else
  {
	  MCAL_DIO_u8SetPinValue(LCD_D_PORT,LCD_D6_PIN,Pin_Low);
    4eea:	80 e0       	ldi	r24, 0x00	; 0
    4eec:	66 e0       	ldi	r22, 0x06	; 6
    4eee:	40 e0       	ldi	r20, 0x00	; 0
    4ef0:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
  }

  if (GET_BIT(Data,3)==1)
    4ef4:	89 81       	ldd	r24, Y+1	; 0x01
    4ef6:	86 95       	lsr	r24
    4ef8:	86 95       	lsr	r24
    4efa:	86 95       	lsr	r24
    4efc:	88 2f       	mov	r24, r24
    4efe:	90 e0       	ldi	r25, 0x00	; 0
    4f00:	81 70       	andi	r24, 0x01	; 1
    4f02:	90 70       	andi	r25, 0x00	; 0
    4f04:	88 23       	and	r24, r24
    4f06:	31 f0       	breq	.+12     	; 0x4f14 <HAL_LCD_voidData+0x9e>
  {
	  MCAL_DIO_u8SetPinValue(LCD_D_PORT,LCD_D7_PIN,Pin_High);
    4f08:	80 e0       	ldi	r24, 0x00	; 0
    4f0a:	67 e0       	ldi	r22, 0x07	; 7
    4f0c:	41 e0       	ldi	r20, 0x01	; 1
    4f0e:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
    4f12:	05 c0       	rjmp	.+10     	; 0x4f1e <HAL_LCD_voidData+0xa8>
  }
  else
  {
	  MCAL_DIO_u8SetPinValue(LCD_D_PORT,LCD_D7_PIN,Pin_Low);
    4f14:	80 e0       	ldi	r24, 0x00	; 0
    4f16:	67 e0       	ldi	r22, 0x07	; 7
    4f18:	40 e0       	ldi	r20, 0x00	; 0
    4f1a:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
  }


}
    4f1e:	0f 90       	pop	r0
    4f20:	cf 91       	pop	r28
    4f22:	df 91       	pop	r29
    4f24:	08 95       	ret

00004f26 <HAL_void_H_BridgeInit>:
 *      Author: Mohamed
 */

#include "H_Bridge.h"

void HAL_void_H_BridgeInit() {
    4f26:	df 93       	push	r29
    4f28:	cf 93       	push	r28
    4f2a:	cd b7       	in	r28, 0x3d	; 61
    4f2c:	de b7       	in	r29, 0x3e	; 62
//	MCAL_DIO_u8SetPinDirection(PortD, Pin4, Pin_High);
//	MCAL_DIO_u8SetPinDirection(PortD, Pin5, Pin_High);
	MCAL_DIO_u8SetPinDirection(PortC, 3, Pin_High);
    4f2e:	82 e0       	ldi	r24, 0x02	; 2
    4f30:	63 e0       	ldi	r22, 0x03	; 3
    4f32:	41 e0       	ldi	r20, 0x01	; 1
    4f34:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(PortC, 4, Pin_High);
    4f38:	82 e0       	ldi	r24, 0x02	; 2
    4f3a:	64 e0       	ldi	r22, 0x04	; 4
    4f3c:	41 e0       	ldi	r20, 0x01	; 1
    4f3e:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(PortC, 5, Pin_High);
    4f42:	82 e0       	ldi	r24, 0x02	; 2
    4f44:	65 e0       	ldi	r22, 0x05	; 5
    4f46:	41 e0       	ldi	r20, 0x01	; 1
    4f48:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(PortC, 6, Pin_High);
    4f4c:	82 e0       	ldi	r24, 0x02	; 2
    4f4e:	66 e0       	ldi	r22, 0x06	; 6
    4f50:	41 e0       	ldi	r20, 0x01	; 1
    4f52:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <MCAL_DIO_u8SetPinDirection>
}
    4f56:	cf 91       	pop	r28
    4f58:	df 91       	pop	r29
    4f5a:	08 95       	ret

00004f5c <HAL_void_H_BridgeCW>:

void HAL_void_H_BridgeCW(u8 copy_u8_speed) {
    4f5c:	df 93       	push	r29
    4f5e:	cf 93       	push	r28
    4f60:	0f 92       	push	r0
    4f62:	cd b7       	in	r28, 0x3d	; 61
    4f64:	de b7       	in	r29, 0x3e	; 62
    4f66:	89 83       	std	Y+1, r24	; 0x01
	MCAL_T1_FPWM_10bitRES(CHENNEL_B, copy_u8_speed);
    4f68:	81 e0       	ldi	r24, 0x01	; 1
    4f6a:	69 81       	ldd	r22, Y+1	; 0x01
    4f6c:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <MCAL_T1_FPWM_10bitRES>
	MCAL_T1_FPWM_10bitRES(CHENNEL_A, copy_u8_speed);
    4f70:	80 e0       	ldi	r24, 0x00	; 0
    4f72:	69 81       	ldd	r22, Y+1	; 0x01
    4f74:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <MCAL_T1_FPWM_10bitRES>
	MCAL_DIO_u8SetPinValue(PortC, Pin3, Pin_Low);
    4f78:	82 e0       	ldi	r24, 0x02	; 2
    4f7a:	63 e0       	ldi	r22, 0x03	; 3
    4f7c:	40 e0       	ldi	r20, 0x00	; 0
    4f7e:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin4, Pin_Low);
    4f82:	82 e0       	ldi	r24, 0x02	; 2
    4f84:	64 e0       	ldi	r22, 0x04	; 4
    4f86:	40 e0       	ldi	r20, 0x00	; 0
    4f88:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin5, Pin_Low);
    4f8c:	82 e0       	ldi	r24, 0x02	; 2
    4f8e:	65 e0       	ldi	r22, 0x05	; 5
    4f90:	40 e0       	ldi	r20, 0x00	; 0
    4f92:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin6, Pin_High);
    4f96:	82 e0       	ldi	r24, 0x02	; 2
    4f98:	66 e0       	ldi	r22, 0x06	; 6
    4f9a:	41 e0       	ldi	r20, 0x01	; 1
    4f9c:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
}
    4fa0:	0f 90       	pop	r0
    4fa2:	cf 91       	pop	r28
    4fa4:	df 91       	pop	r29
    4fa6:	08 95       	ret

00004fa8 <HAL_void_H_BridgeFront>:
void HAL_void_H_BridgeFront(u8 copy_u8_speed) {
    4fa8:	df 93       	push	r29
    4faa:	cf 93       	push	r28
    4fac:	0f 92       	push	r0
    4fae:	cd b7       	in	r28, 0x3d	; 61
    4fb0:	de b7       	in	r29, 0x3e	; 62
    4fb2:	89 83       	std	Y+1, r24	; 0x01
	MCAL_T1_FPWM_10bitRES(CHENNEL_A, copy_u8_speed);
    4fb4:	80 e0       	ldi	r24, 0x00	; 0
    4fb6:	69 81       	ldd	r22, Y+1	; 0x01
    4fb8:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <MCAL_T1_FPWM_10bitRES>
	MCAL_T1_FPWM_10bitRES(CHENNEL_B, copy_u8_speed);
    4fbc:	81 e0       	ldi	r24, 0x01	; 1
    4fbe:	69 81       	ldd	r22, Y+1	; 0x01
    4fc0:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <MCAL_T1_FPWM_10bitRES>
	MCAL_DIO_u8SetPinValue(PortD, Pin4, Pin_High);
    4fc4:	83 e0       	ldi	r24, 0x03	; 3
    4fc6:	64 e0       	ldi	r22, 0x04	; 4
    4fc8:	41 e0       	ldi	r20, 0x01	; 1
    4fca:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortD, Pin5, Pin_High);
    4fce:	83 e0       	ldi	r24, 0x03	; 3
    4fd0:	65 e0       	ldi	r22, 0x05	; 5
    4fd2:	41 e0       	ldi	r20, 0x01	; 1
    4fd4:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin3, Pin_High);
    4fd8:	82 e0       	ldi	r24, 0x02	; 2
    4fda:	63 e0       	ldi	r22, 0x03	; 3
    4fdc:	41 e0       	ldi	r20, 0x01	; 1
    4fde:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin4, Pin_Low);
    4fe2:	82 e0       	ldi	r24, 0x02	; 2
    4fe4:	64 e0       	ldi	r22, 0x04	; 4
    4fe6:	40 e0       	ldi	r20, 0x00	; 0
    4fe8:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin5, Pin_Low);
    4fec:	82 e0       	ldi	r24, 0x02	; 2
    4fee:	65 e0       	ldi	r22, 0x05	; 5
    4ff0:	40 e0       	ldi	r20, 0x00	; 0
    4ff2:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin6, Pin_High);
    4ff6:	82 e0       	ldi	r24, 0x02	; 2
    4ff8:	66 e0       	ldi	r22, 0x06	; 6
    4ffa:	41 e0       	ldi	r20, 0x01	; 1
    4ffc:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
}
    5000:	0f 90       	pop	r0
    5002:	cf 91       	pop	r28
    5004:	df 91       	pop	r29
    5006:	08 95       	ret

00005008 <HAL_void_H_BridgeBack>:
void HAL_void_H_BridgeBack(u8 copy_u8_speed) {
    5008:	df 93       	push	r29
    500a:	cf 93       	push	r28
    500c:	0f 92       	push	r0
    500e:	cd b7       	in	r28, 0x3d	; 61
    5010:	de b7       	in	r29, 0x3e	; 62
    5012:	89 83       	std	Y+1, r24	; 0x01
	MCAL_T1_FPWM_10bitRES(CHENNEL_B, copy_u8_speed);
    5014:	81 e0       	ldi	r24, 0x01	; 1
    5016:	69 81       	ldd	r22, Y+1	; 0x01
    5018:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <MCAL_T1_FPWM_10bitRES>
	MCAL_T1_FPWM_10bitRES(CHENNEL_A, copy_u8_speed);
    501c:	80 e0       	ldi	r24, 0x00	; 0
    501e:	69 81       	ldd	r22, Y+1	; 0x01
    5020:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <MCAL_T1_FPWM_10bitRES>
	MCAL_DIO_u8SetPinValue(PortC, Pin3, Pin_Low);
    5024:	82 e0       	ldi	r24, 0x02	; 2
    5026:	63 e0       	ldi	r22, 0x03	; 3
    5028:	40 e0       	ldi	r20, 0x00	; 0
    502a:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin4, Pin_High);
    502e:	82 e0       	ldi	r24, 0x02	; 2
    5030:	64 e0       	ldi	r22, 0x04	; 4
    5032:	41 e0       	ldi	r20, 0x01	; 1
    5034:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin5, Pin_High);
    5038:	82 e0       	ldi	r24, 0x02	; 2
    503a:	65 e0       	ldi	r22, 0x05	; 5
    503c:	41 e0       	ldi	r20, 0x01	; 1
    503e:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin6, Pin_Low);
    5042:	82 e0       	ldi	r24, 0x02	; 2
    5044:	66 e0       	ldi	r22, 0x06	; 6
    5046:	40 e0       	ldi	r20, 0x00	; 0
    5048:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
}
    504c:	0f 90       	pop	r0
    504e:	cf 91       	pop	r28
    5050:	df 91       	pop	r29
    5052:	08 95       	ret

00005054 <HAL_void_H_BridgeCCW>:
void HAL_void_H_BridgeCCW(u8 copy_u8_speed) {
    5054:	df 93       	push	r29
    5056:	cf 93       	push	r28
    5058:	0f 92       	push	r0
    505a:	cd b7       	in	r28, 0x3d	; 61
    505c:	de b7       	in	r29, 0x3e	; 62
    505e:	89 83       	std	Y+1, r24	; 0x01
	MCAL_T1_FPWM_10bitRES(CHENNEL_B, copy_u8_speed);
    5060:	81 e0       	ldi	r24, 0x01	; 1
    5062:	69 81       	ldd	r22, Y+1	; 0x01
    5064:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <MCAL_T1_FPWM_10bitRES>
	MCAL_T1_FPWM_10bitRES(CHENNEL_A, copy_u8_speed);
    5068:	80 e0       	ldi	r24, 0x00	; 0
    506a:	69 81       	ldd	r22, Y+1	; 0x01
    506c:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <MCAL_T1_FPWM_10bitRES>
	MCAL_DIO_u8SetPinValue(PortC, Pin3, Pin_High);
    5070:	82 e0       	ldi	r24, 0x02	; 2
    5072:	63 e0       	ldi	r22, 0x03	; 3
    5074:	41 e0       	ldi	r20, 0x01	; 1
    5076:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin4, Pin_Low);
    507a:	82 e0       	ldi	r24, 0x02	; 2
    507c:	64 e0       	ldi	r22, 0x04	; 4
    507e:	40 e0       	ldi	r20, 0x00	; 0
    5080:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin5, Pin_Low);
    5084:	82 e0       	ldi	r24, 0x02	; 2
    5086:	65 e0       	ldi	r22, 0x05	; 5
    5088:	40 e0       	ldi	r20, 0x00	; 0
    508a:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin6, Pin_Low);
    508e:	82 e0       	ldi	r24, 0x02	; 2
    5090:	66 e0       	ldi	r22, 0x06	; 6
    5092:	40 e0       	ldi	r20, 0x00	; 0
    5094:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
}
    5098:	0f 90       	pop	r0
    509a:	cf 91       	pop	r28
    509c:	df 91       	pop	r29
    509e:	08 95       	ret

000050a0 <HAL_void_H_BridgeStop>:

void HAL_void_H_BridgeStop(u8 copy_u8_speed) {
    50a0:	df 93       	push	r29
    50a2:	cf 93       	push	r28
    50a4:	0f 92       	push	r0
    50a6:	cd b7       	in	r28, 0x3d	; 61
    50a8:	de b7       	in	r29, 0x3e	; 62
    50aa:	89 83       	std	Y+1, r24	; 0x01
	MCAL_T1_FPWM_10bitRES(CHENNEL_B, copy_u8_speed);
    50ac:	81 e0       	ldi	r24, 0x01	; 1
    50ae:	69 81       	ldd	r22, Y+1	; 0x01
    50b0:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <MCAL_T1_FPWM_10bitRES>
	MCAL_T1_FPWM_10bitRES(CHENNEL_A, copy_u8_speed);
    50b4:	80 e0       	ldi	r24, 0x00	; 0
    50b6:	69 81       	ldd	r22, Y+1	; 0x01
    50b8:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <MCAL_T1_FPWM_10bitRES>
	MCAL_DIO_u8SetPinValue(PortC, Pin3, Pin_Low);
    50bc:	82 e0       	ldi	r24, 0x02	; 2
    50be:	63 e0       	ldi	r22, 0x03	; 3
    50c0:	40 e0       	ldi	r20, 0x00	; 0
    50c2:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin4, Pin_Low);
    50c6:	82 e0       	ldi	r24, 0x02	; 2
    50c8:	64 e0       	ldi	r22, 0x04	; 4
    50ca:	40 e0       	ldi	r20, 0x00	; 0
    50cc:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin5, Pin_Low);
    50d0:	82 e0       	ldi	r24, 0x02	; 2
    50d2:	65 e0       	ldi	r22, 0x05	; 5
    50d4:	40 e0       	ldi	r20, 0x00	; 0
    50d6:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin6, Pin_Low);
    50da:	82 e0       	ldi	r24, 0x02	; 2
    50dc:	66 e0       	ldi	r22, 0x06	; 6
    50de:	40 e0       	ldi	r20, 0x00	; 0
    50e0:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
}
    50e4:	0f 90       	pop	r0
    50e6:	cf 91       	pop	r28
    50e8:	df 91       	pop	r29
    50ea:	08 95       	ret

000050ec <HAL_Buzzer_u8BuzzerInit>:
 *      Author: Mohamed
 */

#include "Buzzer.h"

STD_Type HAL_Buzzer_u8BuzzerInit(u8 Loc_u8BuzzerPortID, u8 Loc_u8BuzzerPinID) {
    50ec:	df 93       	push	r29
    50ee:	cf 93       	push	r28
    50f0:	00 d0       	rcall	.+0      	; 0x50f2 <HAL_Buzzer_u8BuzzerInit+0x6>
    50f2:	0f 92       	push	r0
    50f4:	cd b7       	in	r28, 0x3d	; 61
    50f6:	de b7       	in	r29, 0x3e	; 62
    50f8:	8a 83       	std	Y+2, r24	; 0x02
    50fa:	6b 83       	std	Y+3, r22	; 0x03
	u8 Loc_u8Return_Value = E_NOT_OK;
    50fc:	81 e0       	ldi	r24, 0x01	; 1
    50fe:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8BuzzerPortID <= PortD && Loc_u8BuzzerPinID <= Num_Of_Pins) {
    5100:	8a 81       	ldd	r24, Y+2	; 0x02
    5102:	84 30       	cpi	r24, 0x04	; 4
    5104:	48 f4       	brcc	.+18     	; 0x5118 <HAL_Buzzer_u8BuzzerInit+0x2c>
    5106:	8b 81       	ldd	r24, Y+3	; 0x03
    5108:	88 30       	cpi	r24, 0x08	; 8
    510a:	30 f4       	brcc	.+12     	; 0x5118 <HAL_Buzzer_u8BuzzerInit+0x2c>
		Loc_u8Return_Value=Loc_u8Return_Value = MCAL_DIO_u8SetPinDirection(Loc_u8BuzzerPortID,
    510c:	8a 81       	ldd	r24, Y+2	; 0x02
    510e:	6b 81       	ldd	r22, Y+3	; 0x03
    5110:	41 e0       	ldi	r20, 0x01	; 1
    5112:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <MCAL_DIO_u8SetPinDirection>
    5116:	89 83       	std	Y+1, r24	; 0x01
				Loc_u8BuzzerPinID, Pin_High);
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    5118:	89 81       	ldd	r24, Y+1	; 0x01
}
    511a:	0f 90       	pop	r0
    511c:	0f 90       	pop	r0
    511e:	0f 90       	pop	r0
    5120:	cf 91       	pop	r28
    5122:	df 91       	pop	r29
    5124:	08 95       	ret

00005126 <HAL_Buzzer_u8BuzzerMode>:

STD_Type HAL_Buzzer_u8BuzzerMode(u8 Loc_u8BuzzerPortID, u8 Loc_u8BuzzerPinID,
		u8 Loc_u8BuzzerMode) {
    5126:	df 93       	push	r29
    5128:	cf 93       	push	r28
    512a:	00 d0       	rcall	.+0      	; 0x512c <HAL_Buzzer_u8BuzzerMode+0x6>
    512c:	00 d0       	rcall	.+0      	; 0x512e <HAL_Buzzer_u8BuzzerMode+0x8>
    512e:	cd b7       	in	r28, 0x3d	; 61
    5130:	de b7       	in	r29, 0x3e	; 62
    5132:	8a 83       	std	Y+2, r24	; 0x02
    5134:	6b 83       	std	Y+3, r22	; 0x03
    5136:	4c 83       	std	Y+4, r20	; 0x04
	u8 Loc_u8Return_Value = E_NOT_OK;
    5138:	81 e0       	ldi	r24, 0x01	; 1
    513a:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8BuzzerPortID <= PortD && Loc_u8BuzzerPinID <= Num_Of_Pins
    513c:	8a 81       	ldd	r24, Y+2	; 0x02
    513e:	84 30       	cpi	r24, 0x04	; 4
    5140:	10 f5       	brcc	.+68     	; 0x5186 <HAL_Buzzer_u8BuzzerMode+0x60>
    5142:	8b 81       	ldd	r24, Y+3	; 0x03
    5144:	88 30       	cpi	r24, 0x08	; 8
    5146:	f8 f4       	brcc	.+62     	; 0x5186 <HAL_Buzzer_u8BuzzerMode+0x60>
    5148:	8c 81       	ldd	r24, Y+4	; 0x04
    514a:	83 30       	cpi	r24, 0x03	; 3
    514c:	e0 f4       	brcc	.+56     	; 0x5186 <HAL_Buzzer_u8BuzzerMode+0x60>
			&& Loc_u8BuzzerMode <= Buzzer_TOG) {
		if (Loc_u8BuzzerMode == Buzzer_ON) {
    514e:	8c 81       	ldd	r24, Y+4	; 0x04
    5150:	81 30       	cpi	r24, 0x01	; 1
    5152:	39 f4       	brne	.+14     	; 0x5162 <HAL_Buzzer_u8BuzzerMode+0x3c>
			Loc_u8Return_Value=MCAL_DIO_u8SetPinValue(Loc_u8BuzzerPortID, Loc_u8BuzzerPinID, Pin_High);
    5154:	8a 81       	ldd	r24, Y+2	; 0x02
    5156:	6b 81       	ldd	r22, Y+3	; 0x03
    5158:	41 e0       	ldi	r20, 0x01	; 1
    515a:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
    515e:	89 83       	std	Y+1, r24	; 0x01
    5160:	12 c0       	rjmp	.+36     	; 0x5186 <HAL_Buzzer_u8BuzzerMode+0x60>
		} else if (Loc_u8BuzzerMode == Buzzer_OFF) {
    5162:	8c 81       	ldd	r24, Y+4	; 0x04
    5164:	88 23       	and	r24, r24
    5166:	39 f4       	brne	.+14     	; 0x5176 <HAL_Buzzer_u8BuzzerMode+0x50>
			Loc_u8Return_Value=MCAL_DIO_u8SetPinValue(Loc_u8BuzzerPortID, Loc_u8BuzzerPinID, Pin_Low);
    5168:	8a 81       	ldd	r24, Y+2	; 0x02
    516a:	6b 81       	ldd	r22, Y+3	; 0x03
    516c:	40 e0       	ldi	r20, 0x00	; 0
    516e:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <MCAL_DIO_u8SetPinValue>
    5172:	89 83       	std	Y+1, r24	; 0x01
    5174:	08 c0       	rjmp	.+16     	; 0x5186 <HAL_Buzzer_u8BuzzerMode+0x60>
		} else if (Loc_u8BuzzerMode == Buzzer_TOG) {
    5176:	8c 81       	ldd	r24, Y+4	; 0x04
    5178:	82 30       	cpi	r24, 0x02	; 2
    517a:	29 f4       	brne	.+10     	; 0x5186 <HAL_Buzzer_u8BuzzerMode+0x60>
			Loc_u8Return_Value=MCAL_DIO_u8TogglePinValue(Loc_u8BuzzerPortID,Loc_u8BuzzerPinID);
    517c:	8a 81       	ldd	r24, Y+2	; 0x02
    517e:	6b 81       	ldd	r22, Y+3	; 0x03
    5180:	0e 94 52 19 	call	0x32a4	; 0x32a4 <MCAL_DIO_u8TogglePinValue>
    5184:	89 83       	std	Y+1, r24	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    5186:	89 81       	ldd	r24, Y+1	; 0x01
}
    5188:	0f 90       	pop	r0
    518a:	0f 90       	pop	r0
    518c:	0f 90       	pop	r0
    518e:	0f 90       	pop	r0
    5190:	cf 91       	pop	r28
    5192:	df 91       	pop	r29
    5194:	08 95       	ret

00005196 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    5196:	df 93       	push	r29
    5198:	cf 93       	push	r28
    519a:	cd b7       	in	r28, 0x3d	; 61
    519c:	de b7       	in	r29, 0x3e	; 62
    519e:	2e 97       	sbiw	r28, 0x0e	; 14
    51a0:	0f b6       	in	r0, 0x3f	; 63
    51a2:	f8 94       	cli
    51a4:	de bf       	out	0x3e, r29	; 62
    51a6:	0f be       	out	0x3f, r0	; 63
    51a8:	cd bf       	out	0x3d, r28	; 61
    51aa:	9e 87       	std	Y+14, r25	; 0x0e
    51ac:	8d 87       	std	Y+13, r24	; 0x0d
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    51ae:	1e 82       	std	Y+6, r1	; 0x06
    51b0:	1d 82       	std	Y+5, r1	; 0x05

	vTaskSuspendAll();
    51b2:	0e 94 8f 33 	call	0x671e	; 0x671e <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    51b6:	80 91 48 02 	lds	r24, 0x0248
    51ba:	88 23       	and	r24, r24
    51bc:	29 f4       	brne	.+10     	; 0x51c8 <pvPortMalloc+0x32>
		{
			prvHeapInit();
    51be:	0e 94 32 2a 	call	0x5464	; 0x5464 <prvHeapInit>
			xHeapHasBeenInitialised = pdTRUE;
    51c2:	81 e0       	ldi	r24, 0x01	; 1
    51c4:	80 93 48 02 	sts	0x0248, r24
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    51c8:	8d 85       	ldd	r24, Y+13	; 0x0d
    51ca:	9e 85       	ldd	r25, Y+14	; 0x0e
    51cc:	00 97       	sbiw	r24, 0x00	; 0
    51ce:	51 f0       	breq	.+20     	; 0x51e4 <pvPortMalloc+0x4e>
		{
			xWantedSize += heapSTRUCT_SIZE;
    51d0:	80 91 2b 02 	lds	r24, 0x022B
    51d4:	90 91 2c 02 	lds	r25, 0x022C
    51d8:	2d 85       	ldd	r18, Y+13	; 0x0d
    51da:	3e 85       	ldd	r19, Y+14	; 0x0e
    51dc:	82 0f       	add	r24, r18
    51de:	93 1f       	adc	r25, r19
    51e0:	9e 87       	std	Y+14, r25	; 0x0e
    51e2:	8d 87       	std	Y+13, r24	; 0x0d
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
    51e4:	8d 85       	ldd	r24, Y+13	; 0x0d
    51e6:	9e 85       	ldd	r25, Y+14	; 0x0e
    51e8:	00 97       	sbiw	r24, 0x00	; 0
    51ea:	09 f4       	brne	.+2      	; 0x51ee <pvPortMalloc+0x58>
    51ec:	af c0       	rjmp	.+350    	; 0x534c <pvPortMalloc+0x1b6>
    51ee:	8d 85       	ldd	r24, Y+13	; 0x0d
    51f0:	9e 85       	ldd	r25, Y+14	; 0x0e
    51f2:	23 e0       	ldi	r18, 0x03	; 3
    51f4:	87 3e       	cpi	r24, 0xE7	; 231
    51f6:	92 07       	cpc	r25, r18
    51f8:	08 f0       	brcs	.+2      	; 0x51fc <pvPortMalloc+0x66>
    51fa:	a8 c0       	rjmp	.+336    	; 0x534c <pvPortMalloc+0x1b6>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    51fc:	81 e3       	ldi	r24, 0x31	; 49
    51fe:	96 e0       	ldi	r25, 0x06	; 6
    5200:	9a 87       	std	Y+10, r25	; 0x0a
    5202:	89 87       	std	Y+9, r24	; 0x09
			pxBlock = xStart.pxNextFreeBlock;
    5204:	80 91 31 06 	lds	r24, 0x0631
    5208:	90 91 32 06 	lds	r25, 0x0632
    520c:	9c 87       	std	Y+12, r25	; 0x0c
    520e:	8b 87       	std	Y+11, r24	; 0x0b
    5210:	0a c0       	rjmp	.+20     	; 0x5226 <pvPortMalloc+0x90>
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
			{
				pxPreviousBlock = pxBlock;
    5212:	8b 85       	ldd	r24, Y+11	; 0x0b
    5214:	9c 85       	ldd	r25, Y+12	; 0x0c
    5216:	9a 87       	std	Y+10, r25	; 0x0a
    5218:	89 87       	std	Y+9, r24	; 0x09
				pxBlock = pxBlock->pxNextFreeBlock;
    521a:	eb 85       	ldd	r30, Y+11	; 0x0b
    521c:	fc 85       	ldd	r31, Y+12	; 0x0c
    521e:	80 81       	ld	r24, Z
    5220:	91 81       	ldd	r25, Z+1	; 0x01
    5222:	9c 87       	std	Y+12, r25	; 0x0c
    5224:	8b 87       	std	Y+11, r24	; 0x0b
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    5226:	eb 85       	ldd	r30, Y+11	; 0x0b
    5228:	fc 85       	ldd	r31, Y+12	; 0x0c
    522a:	22 81       	ldd	r18, Z+2	; 0x02
    522c:	33 81       	ldd	r19, Z+3	; 0x03
    522e:	8d 85       	ldd	r24, Y+13	; 0x0d
    5230:	9e 85       	ldd	r25, Y+14	; 0x0e
    5232:	28 17       	cp	r18, r24
    5234:	39 07       	cpc	r19, r25
    5236:	30 f4       	brcc	.+12     	; 0x5244 <pvPortMalloc+0xae>
    5238:	eb 85       	ldd	r30, Y+11	; 0x0b
    523a:	fc 85       	ldd	r31, Y+12	; 0x0c
    523c:	80 81       	ld	r24, Z
    523e:	91 81       	ldd	r25, Z+1	; 0x01
    5240:	00 97       	sbiw	r24, 0x00	; 0
    5242:	39 f7       	brne	.-50     	; 0x5212 <pvPortMalloc+0x7c>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    5244:	8b 85       	ldd	r24, Y+11	; 0x0b
    5246:	9c 85       	ldd	r25, Y+12	; 0x0c
    5248:	46 e0       	ldi	r20, 0x06	; 6
    524a:	85 33       	cpi	r24, 0x35	; 53
    524c:	94 07       	cpc	r25, r20
    524e:	09 f4       	brne	.+2      	; 0x5252 <pvPortMalloc+0xbc>
    5250:	7d c0       	rjmp	.+250    	; 0x534c <pvPortMalloc+0x1b6>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    5252:	e9 85       	ldd	r30, Y+9	; 0x09
    5254:	fa 85       	ldd	r31, Y+10	; 0x0a
    5256:	20 81       	ld	r18, Z
    5258:	31 81       	ldd	r19, Z+1	; 0x01
    525a:	80 91 2b 02 	lds	r24, 0x022B
    525e:	90 91 2c 02 	lds	r25, 0x022C
    5262:	82 0f       	add	r24, r18
    5264:	93 1f       	adc	r25, r19
    5266:	9e 83       	std	Y+6, r25	; 0x06
    5268:	8d 83       	std	Y+5, r24	; 0x05

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    526a:	eb 85       	ldd	r30, Y+11	; 0x0b
    526c:	fc 85       	ldd	r31, Y+12	; 0x0c
    526e:	80 81       	ld	r24, Z
    5270:	91 81       	ldd	r25, Z+1	; 0x01
    5272:	e9 85       	ldd	r30, Y+9	; 0x09
    5274:	fa 85       	ldd	r31, Y+10	; 0x0a
    5276:	91 83       	std	Z+1, r25	; 0x01
    5278:	80 83       	st	Z, r24

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    527a:	eb 85       	ldd	r30, Y+11	; 0x0b
    527c:	fc 85       	ldd	r31, Y+12	; 0x0c
    527e:	22 81       	ldd	r18, Z+2	; 0x02
    5280:	33 81       	ldd	r19, Z+3	; 0x03
    5282:	8d 85       	ldd	r24, Y+13	; 0x0d
    5284:	9e 85       	ldd	r25, Y+14	; 0x0e
    5286:	28 1b       	sub	r18, r24
    5288:	39 0b       	sbc	r19, r25
    528a:	80 91 2b 02 	lds	r24, 0x022B
    528e:	90 91 2c 02 	lds	r25, 0x022C
    5292:	88 0f       	add	r24, r24
    5294:	99 1f       	adc	r25, r25
    5296:	82 17       	cp	r24, r18
    5298:	93 07       	cpc	r25, r19
    529a:	08 f0       	brcs	.+2      	; 0x529e <pvPortMalloc+0x108>
    529c:	47 c0       	rjmp	.+142    	; 0x532c <pvPortMalloc+0x196>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    529e:	2b 85       	ldd	r18, Y+11	; 0x0b
    52a0:	3c 85       	ldd	r19, Y+12	; 0x0c
    52a2:	8d 85       	ldd	r24, Y+13	; 0x0d
    52a4:	9e 85       	ldd	r25, Y+14	; 0x0e
    52a6:	82 0f       	add	r24, r18
    52a8:	93 1f       	adc	r25, r19
    52aa:	98 87       	std	Y+8, r25	; 0x08
    52ac:	8f 83       	std	Y+7, r24	; 0x07

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    52ae:	eb 85       	ldd	r30, Y+11	; 0x0b
    52b0:	fc 85       	ldd	r31, Y+12	; 0x0c
    52b2:	22 81       	ldd	r18, Z+2	; 0x02
    52b4:	33 81       	ldd	r19, Z+3	; 0x03
    52b6:	8d 85       	ldd	r24, Y+13	; 0x0d
    52b8:	9e 85       	ldd	r25, Y+14	; 0x0e
    52ba:	a9 01       	movw	r20, r18
    52bc:	48 1b       	sub	r20, r24
    52be:	59 0b       	sbc	r21, r25
    52c0:	ca 01       	movw	r24, r20
    52c2:	ef 81       	ldd	r30, Y+7	; 0x07
    52c4:	f8 85       	ldd	r31, Y+8	; 0x08
    52c6:	93 83       	std	Z+3, r25	; 0x03
    52c8:	82 83       	std	Z+2, r24	; 0x02
					pxBlock->xBlockSize = xWantedSize;
    52ca:	eb 85       	ldd	r30, Y+11	; 0x0b
    52cc:	fc 85       	ldd	r31, Y+12	; 0x0c
    52ce:	8d 85       	ldd	r24, Y+13	; 0x0d
    52d0:	9e 85       	ldd	r25, Y+14	; 0x0e
    52d2:	93 83       	std	Z+3, r25	; 0x03
    52d4:	82 83       	std	Z+2, r24	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    52d6:	ef 81       	ldd	r30, Y+7	; 0x07
    52d8:	f8 85       	ldd	r31, Y+8	; 0x08
    52da:	82 81       	ldd	r24, Z+2	; 0x02
    52dc:	93 81       	ldd	r25, Z+3	; 0x03
    52de:	9a 83       	std	Y+2, r25	; 0x02
    52e0:	89 83       	std	Y+1, r24	; 0x01
    52e2:	81 e3       	ldi	r24, 0x31	; 49
    52e4:	96 e0       	ldi	r25, 0x06	; 6
    52e6:	9c 83       	std	Y+4, r25	; 0x04
    52e8:	8b 83       	std	Y+3, r24	; 0x03
    52ea:	06 c0       	rjmp	.+12     	; 0x52f8 <pvPortMalloc+0x162>
    52ec:	eb 81       	ldd	r30, Y+3	; 0x03
    52ee:	fc 81       	ldd	r31, Y+4	; 0x04
    52f0:	80 81       	ld	r24, Z
    52f2:	91 81       	ldd	r25, Z+1	; 0x01
    52f4:	9c 83       	std	Y+4, r25	; 0x04
    52f6:	8b 83       	std	Y+3, r24	; 0x03
    52f8:	eb 81       	ldd	r30, Y+3	; 0x03
    52fa:	fc 81       	ldd	r31, Y+4	; 0x04
    52fc:	01 90       	ld	r0, Z+
    52fe:	f0 81       	ld	r31, Z
    5300:	e0 2d       	mov	r30, r0
    5302:	22 81       	ldd	r18, Z+2	; 0x02
    5304:	33 81       	ldd	r19, Z+3	; 0x03
    5306:	89 81       	ldd	r24, Y+1	; 0x01
    5308:	9a 81       	ldd	r25, Y+2	; 0x02
    530a:	28 17       	cp	r18, r24
    530c:	39 07       	cpc	r19, r25
    530e:	70 f3       	brcs	.-36     	; 0x52ec <pvPortMalloc+0x156>
    5310:	eb 81       	ldd	r30, Y+3	; 0x03
    5312:	fc 81       	ldd	r31, Y+4	; 0x04
    5314:	80 81       	ld	r24, Z
    5316:	91 81       	ldd	r25, Z+1	; 0x01
    5318:	ef 81       	ldd	r30, Y+7	; 0x07
    531a:	f8 85       	ldd	r31, Y+8	; 0x08
    531c:	91 83       	std	Z+1, r25	; 0x01
    531e:	80 83       	st	Z, r24
    5320:	eb 81       	ldd	r30, Y+3	; 0x03
    5322:	fc 81       	ldd	r31, Y+4	; 0x04
    5324:	8f 81       	ldd	r24, Y+7	; 0x07
    5326:	98 85       	ldd	r25, Y+8	; 0x08
    5328:	91 83       	std	Z+1, r25	; 0x01
    532a:	80 83       	st	Z, r24
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
    532c:	20 91 28 02 	lds	r18, 0x0228
    5330:	30 91 29 02 	lds	r19, 0x0229
    5334:	eb 85       	ldd	r30, Y+11	; 0x0b
    5336:	fc 85       	ldd	r31, Y+12	; 0x0c
    5338:	82 81       	ldd	r24, Z+2	; 0x02
    533a:	93 81       	ldd	r25, Z+3	; 0x03
    533c:	a9 01       	movw	r20, r18
    533e:	48 1b       	sub	r20, r24
    5340:	59 0b       	sbc	r21, r25
    5342:	ca 01       	movw	r24, r20
    5344:	90 93 29 02 	sts	0x0229, r25
    5348:	80 93 28 02 	sts	0x0228, r24
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    534c:	0e 94 9b 33 	call	0x6736	; 0x6736 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    5350:	8d 81       	ldd	r24, Y+5	; 0x05
    5352:	9e 81       	ldd	r25, Y+6	; 0x06
}
    5354:	2e 96       	adiw	r28, 0x0e	; 14
    5356:	0f b6       	in	r0, 0x3f	; 63
    5358:	f8 94       	cli
    535a:	de bf       	out	0x3e, r29	; 62
    535c:	0f be       	out	0x3f, r0	; 63
    535e:	cd bf       	out	0x3d, r28	; 61
    5360:	cf 91       	pop	r28
    5362:	df 91       	pop	r29
    5364:	08 95       	ret

00005366 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    5366:	df 93       	push	r29
    5368:	cf 93       	push	r28
    536a:	cd b7       	in	r28, 0x3d	; 61
    536c:	de b7       	in	r29, 0x3e	; 62
    536e:	2a 97       	sbiw	r28, 0x0a	; 10
    5370:	0f b6       	in	r0, 0x3f	; 63
    5372:	f8 94       	cli
    5374:	de bf       	out	0x3e, r29	; 62
    5376:	0f be       	out	0x3f, r0	; 63
    5378:	cd bf       	out	0x3d, r28	; 61
    537a:	9a 87       	std	Y+10, r25	; 0x0a
    537c:	89 87       	std	Y+9, r24	; 0x09
uint8_t *puc = ( uint8_t * ) pv;
    537e:	89 85       	ldd	r24, Y+9	; 0x09
    5380:	9a 85       	ldd	r25, Y+10	; 0x0a
    5382:	98 87       	std	Y+8, r25	; 0x08
    5384:	8f 83       	std	Y+7, r24	; 0x07
BlockLink_t *pxLink;

	if( pv != NULL )
    5386:	89 85       	ldd	r24, Y+9	; 0x09
    5388:	9a 85       	ldd	r25, Y+10	; 0x0a
    538a:	00 97       	sbiw	r24, 0x00	; 0
    538c:	09 f4       	brne	.+2      	; 0x5390 <vPortFree+0x2a>
    538e:	4f c0       	rjmp	.+158    	; 0x542e <vPortFree+0xc8>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    5390:	80 91 2b 02 	lds	r24, 0x022B
    5394:	90 91 2c 02 	lds	r25, 0x022C
    5398:	22 27       	eor	r18, r18
    539a:	33 27       	eor	r19, r19
    539c:	28 1b       	sub	r18, r24
    539e:	39 0b       	sbc	r19, r25
    53a0:	8f 81       	ldd	r24, Y+7	; 0x07
    53a2:	98 85       	ldd	r25, Y+8	; 0x08
    53a4:	82 0f       	add	r24, r18
    53a6:	93 1f       	adc	r25, r19
    53a8:	98 87       	std	Y+8, r25	; 0x08
    53aa:	8f 83       	std	Y+7, r24	; 0x07

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;
    53ac:	8f 81       	ldd	r24, Y+7	; 0x07
    53ae:	98 85       	ldd	r25, Y+8	; 0x08
    53b0:	9e 83       	std	Y+6, r25	; 0x06
    53b2:	8d 83       	std	Y+5, r24	; 0x05

		vTaskSuspendAll();
    53b4:	0e 94 8f 33 	call	0x671e	; 0x671e <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    53b8:	ed 81       	ldd	r30, Y+5	; 0x05
    53ba:	fe 81       	ldd	r31, Y+6	; 0x06
    53bc:	82 81       	ldd	r24, Z+2	; 0x02
    53be:	93 81       	ldd	r25, Z+3	; 0x03
    53c0:	9a 83       	std	Y+2, r25	; 0x02
    53c2:	89 83       	std	Y+1, r24	; 0x01
    53c4:	81 e3       	ldi	r24, 0x31	; 49
    53c6:	96 e0       	ldi	r25, 0x06	; 6
    53c8:	9c 83       	std	Y+4, r25	; 0x04
    53ca:	8b 83       	std	Y+3, r24	; 0x03
    53cc:	06 c0       	rjmp	.+12     	; 0x53da <vPortFree+0x74>
    53ce:	eb 81       	ldd	r30, Y+3	; 0x03
    53d0:	fc 81       	ldd	r31, Y+4	; 0x04
    53d2:	80 81       	ld	r24, Z
    53d4:	91 81       	ldd	r25, Z+1	; 0x01
    53d6:	9c 83       	std	Y+4, r25	; 0x04
    53d8:	8b 83       	std	Y+3, r24	; 0x03
    53da:	eb 81       	ldd	r30, Y+3	; 0x03
    53dc:	fc 81       	ldd	r31, Y+4	; 0x04
    53de:	01 90       	ld	r0, Z+
    53e0:	f0 81       	ld	r31, Z
    53e2:	e0 2d       	mov	r30, r0
    53e4:	22 81       	ldd	r18, Z+2	; 0x02
    53e6:	33 81       	ldd	r19, Z+3	; 0x03
    53e8:	89 81       	ldd	r24, Y+1	; 0x01
    53ea:	9a 81       	ldd	r25, Y+2	; 0x02
    53ec:	28 17       	cp	r18, r24
    53ee:	39 07       	cpc	r19, r25
    53f0:	70 f3       	brcs	.-36     	; 0x53ce <vPortFree+0x68>
    53f2:	eb 81       	ldd	r30, Y+3	; 0x03
    53f4:	fc 81       	ldd	r31, Y+4	; 0x04
    53f6:	80 81       	ld	r24, Z
    53f8:	91 81       	ldd	r25, Z+1	; 0x01
    53fa:	ed 81       	ldd	r30, Y+5	; 0x05
    53fc:	fe 81       	ldd	r31, Y+6	; 0x06
    53fe:	91 83       	std	Z+1, r25	; 0x01
    5400:	80 83       	st	Z, r24
    5402:	eb 81       	ldd	r30, Y+3	; 0x03
    5404:	fc 81       	ldd	r31, Y+4	; 0x04
    5406:	8d 81       	ldd	r24, Y+5	; 0x05
    5408:	9e 81       	ldd	r25, Y+6	; 0x06
    540a:	91 83       	std	Z+1, r25	; 0x01
    540c:	80 83       	st	Z, r24
			xFreeBytesRemaining += pxLink->xBlockSize;
    540e:	ed 81       	ldd	r30, Y+5	; 0x05
    5410:	fe 81       	ldd	r31, Y+6	; 0x06
    5412:	22 81       	ldd	r18, Z+2	; 0x02
    5414:	33 81       	ldd	r19, Z+3	; 0x03
    5416:	80 91 28 02 	lds	r24, 0x0228
    541a:	90 91 29 02 	lds	r25, 0x0229
    541e:	82 0f       	add	r24, r18
    5420:	93 1f       	adc	r25, r19
    5422:	90 93 29 02 	sts	0x0229, r25
    5426:	80 93 28 02 	sts	0x0228, r24
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
    542a:	0e 94 9b 33 	call	0x6736	; 0x6736 <xTaskResumeAll>
	}
}
    542e:	2a 96       	adiw	r28, 0x0a	; 10
    5430:	0f b6       	in	r0, 0x3f	; 63
    5432:	f8 94       	cli
    5434:	de bf       	out	0x3e, r29	; 62
    5436:	0f be       	out	0x3f, r0	; 63
    5438:	cd bf       	out	0x3d, r28	; 61
    543a:	cf 91       	pop	r28
    543c:	df 91       	pop	r29
    543e:	08 95       	ret

00005440 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    5440:	df 93       	push	r29
    5442:	cf 93       	push	r28
    5444:	cd b7       	in	r28, 0x3d	; 61
    5446:	de b7       	in	r29, 0x3e	; 62
	return xFreeBytesRemaining;
    5448:	80 91 28 02 	lds	r24, 0x0228
    544c:	90 91 29 02 	lds	r25, 0x0229
}
    5450:	cf 91       	pop	r28
    5452:	df 91       	pop	r29
    5454:	08 95       	ret

00005456 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    5456:	df 93       	push	r29
    5458:	cf 93       	push	r28
    545a:	cd b7       	in	r28, 0x3d	; 61
    545c:	de b7       	in	r29, 0x3e	; 62
	/* This just exists to keep the linker quiet. */
}
    545e:	cf 91       	pop	r28
    5460:	df 91       	pop	r29
    5462:	08 95       	ret

00005464 <prvHeapInit>:
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
    5464:	df 93       	push	r29
    5466:	cf 93       	push	r28
    5468:	00 d0       	rcall	.+0      	; 0x546a <prvHeapInit+0x6>
    546a:	00 d0       	rcall	.+0      	; 0x546c <prvHeapInit+0x8>
    546c:	cd b7       	in	r28, 0x3d	; 61
    546e:	de b7       	in	r29, 0x3e	; 62
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    5470:	8a e4       	ldi	r24, 0x4A	; 74
    5472:	92 e0       	ldi	r25, 0x02	; 2
    5474:	9a 83       	std	Y+2, r25	; 0x02
    5476:	89 83       	std	Y+1, r24	; 0x01

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    5478:	89 81       	ldd	r24, Y+1	; 0x01
    547a:	9a 81       	ldd	r25, Y+2	; 0x02
    547c:	90 93 32 06 	sts	0x0632, r25
    5480:	80 93 31 06 	sts	0x0631, r24
	xStart.xBlockSize = ( size_t ) 0;
    5484:	10 92 34 06 	sts	0x0634, r1
    5488:	10 92 33 06 	sts	0x0633, r1

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
    548c:	87 ee       	ldi	r24, 0xE7	; 231
    548e:	93 e0       	ldi	r25, 0x03	; 3
    5490:	90 93 38 06 	sts	0x0638, r25
    5494:	80 93 37 06 	sts	0x0637, r24
	xEnd.pxNextFreeBlock = NULL;
    5498:	10 92 36 06 	sts	0x0636, r1
    549c:	10 92 35 06 	sts	0x0635, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
    54a0:	89 81       	ldd	r24, Y+1	; 0x01
    54a2:	9a 81       	ldd	r25, Y+2	; 0x02
    54a4:	9c 83       	std	Y+4, r25	; 0x04
    54a6:	8b 83       	std	Y+3, r24	; 0x03
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
    54a8:	eb 81       	ldd	r30, Y+3	; 0x03
    54aa:	fc 81       	ldd	r31, Y+4	; 0x04
    54ac:	87 ee       	ldi	r24, 0xE7	; 231
    54ae:	93 e0       	ldi	r25, 0x03	; 3
    54b0:	93 83       	std	Z+3, r25	; 0x03
    54b2:	82 83       	std	Z+2, r24	; 0x02
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
    54b4:	eb 81       	ldd	r30, Y+3	; 0x03
    54b6:	fc 81       	ldd	r31, Y+4	; 0x04
    54b8:	85 e3       	ldi	r24, 0x35	; 53
    54ba:	96 e0       	ldi	r25, 0x06	; 6
    54bc:	91 83       	std	Z+1, r25	; 0x01
    54be:	80 83       	st	Z, r24
}
    54c0:	0f 90       	pop	r0
    54c2:	0f 90       	pop	r0
    54c4:	0f 90       	pop	r0
    54c6:	0f 90       	pop	r0
    54c8:	cf 91       	pop	r28
    54ca:	df 91       	pop	r29
    54cc:	08 95       	ret

000054ce <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    54ce:	df 93       	push	r29
    54d0:	cf 93       	push	r28
    54d2:	00 d0       	rcall	.+0      	; 0x54d4 <vListInitialise+0x6>
    54d4:	cd b7       	in	r28, 0x3d	; 61
    54d6:	de b7       	in	r29, 0x3e	; 62
    54d8:	9a 83       	std	Y+2, r25	; 0x02
    54da:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    54dc:	89 81       	ldd	r24, Y+1	; 0x01
    54de:	9a 81       	ldd	r25, Y+2	; 0x02
    54e0:	03 96       	adiw	r24, 0x03	; 3
    54e2:	e9 81       	ldd	r30, Y+1	; 0x01
    54e4:	fa 81       	ldd	r31, Y+2	; 0x02
    54e6:	92 83       	std	Z+2, r25	; 0x02
    54e8:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    54ea:	e9 81       	ldd	r30, Y+1	; 0x01
    54ec:	fa 81       	ldd	r31, Y+2	; 0x02
    54ee:	8f ef       	ldi	r24, 0xFF	; 255
    54f0:	9f ef       	ldi	r25, 0xFF	; 255
    54f2:	94 83       	std	Z+4, r25	; 0x04
    54f4:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    54f6:	89 81       	ldd	r24, Y+1	; 0x01
    54f8:	9a 81       	ldd	r25, Y+2	; 0x02
    54fa:	03 96       	adiw	r24, 0x03	; 3
    54fc:	e9 81       	ldd	r30, Y+1	; 0x01
    54fe:	fa 81       	ldd	r31, Y+2	; 0x02
    5500:	96 83       	std	Z+6, r25	; 0x06
    5502:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    5504:	89 81       	ldd	r24, Y+1	; 0x01
    5506:	9a 81       	ldd	r25, Y+2	; 0x02
    5508:	03 96       	adiw	r24, 0x03	; 3
    550a:	e9 81       	ldd	r30, Y+1	; 0x01
    550c:	fa 81       	ldd	r31, Y+2	; 0x02
    550e:	90 87       	std	Z+8, r25	; 0x08
    5510:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    5512:	e9 81       	ldd	r30, Y+1	; 0x01
    5514:	fa 81       	ldd	r31, Y+2	; 0x02
    5516:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    5518:	0f 90       	pop	r0
    551a:	0f 90       	pop	r0
    551c:	cf 91       	pop	r28
    551e:	df 91       	pop	r29
    5520:	08 95       	ret

00005522 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    5522:	df 93       	push	r29
    5524:	cf 93       	push	r28
    5526:	00 d0       	rcall	.+0      	; 0x5528 <vListInitialiseItem+0x6>
    5528:	cd b7       	in	r28, 0x3d	; 61
    552a:	de b7       	in	r29, 0x3e	; 62
    552c:	9a 83       	std	Y+2, r25	; 0x02
    552e:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    5530:	e9 81       	ldd	r30, Y+1	; 0x01
    5532:	fa 81       	ldd	r31, Y+2	; 0x02
    5534:	11 86       	std	Z+9, r1	; 0x09
    5536:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    5538:	0f 90       	pop	r0
    553a:	0f 90       	pop	r0
    553c:	cf 91       	pop	r28
    553e:	df 91       	pop	r29
    5540:	08 95       	ret

00005542 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    5542:	df 93       	push	r29
    5544:	cf 93       	push	r28
    5546:	00 d0       	rcall	.+0      	; 0x5548 <vListInsertEnd+0x6>
    5548:	00 d0       	rcall	.+0      	; 0x554a <vListInsertEnd+0x8>
    554a:	00 d0       	rcall	.+0      	; 0x554c <vListInsertEnd+0xa>
    554c:	cd b7       	in	r28, 0x3d	; 61
    554e:	de b7       	in	r29, 0x3e	; 62
    5550:	9c 83       	std	Y+4, r25	; 0x04
    5552:	8b 83       	std	Y+3, r24	; 0x03
    5554:	7e 83       	std	Y+6, r23	; 0x06
    5556:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    5558:	eb 81       	ldd	r30, Y+3	; 0x03
    555a:	fc 81       	ldd	r31, Y+4	; 0x04
    555c:	81 81       	ldd	r24, Z+1	; 0x01
    555e:	92 81       	ldd	r25, Z+2	; 0x02
    5560:	9a 83       	std	Y+2, r25	; 0x02
    5562:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    5564:	ed 81       	ldd	r30, Y+5	; 0x05
    5566:	fe 81       	ldd	r31, Y+6	; 0x06
    5568:	89 81       	ldd	r24, Y+1	; 0x01
    556a:	9a 81       	ldd	r25, Y+2	; 0x02
    556c:	93 83       	std	Z+3, r25	; 0x03
    556e:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    5570:	e9 81       	ldd	r30, Y+1	; 0x01
    5572:	fa 81       	ldd	r31, Y+2	; 0x02
    5574:	84 81       	ldd	r24, Z+4	; 0x04
    5576:	95 81       	ldd	r25, Z+5	; 0x05
    5578:	ed 81       	ldd	r30, Y+5	; 0x05
    557a:	fe 81       	ldd	r31, Y+6	; 0x06
    557c:	95 83       	std	Z+5, r25	; 0x05
    557e:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    5580:	e9 81       	ldd	r30, Y+1	; 0x01
    5582:	fa 81       	ldd	r31, Y+2	; 0x02
    5584:	04 80       	ldd	r0, Z+4	; 0x04
    5586:	f5 81       	ldd	r31, Z+5	; 0x05
    5588:	e0 2d       	mov	r30, r0
    558a:	8d 81       	ldd	r24, Y+5	; 0x05
    558c:	9e 81       	ldd	r25, Y+6	; 0x06
    558e:	93 83       	std	Z+3, r25	; 0x03
    5590:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    5592:	e9 81       	ldd	r30, Y+1	; 0x01
    5594:	fa 81       	ldd	r31, Y+2	; 0x02
    5596:	8d 81       	ldd	r24, Y+5	; 0x05
    5598:	9e 81       	ldd	r25, Y+6	; 0x06
    559a:	95 83       	std	Z+5, r25	; 0x05
    559c:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    559e:	ed 81       	ldd	r30, Y+5	; 0x05
    55a0:	fe 81       	ldd	r31, Y+6	; 0x06
    55a2:	8b 81       	ldd	r24, Y+3	; 0x03
    55a4:	9c 81       	ldd	r25, Y+4	; 0x04
    55a6:	91 87       	std	Z+9, r25	; 0x09
    55a8:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    55aa:	eb 81       	ldd	r30, Y+3	; 0x03
    55ac:	fc 81       	ldd	r31, Y+4	; 0x04
    55ae:	80 81       	ld	r24, Z
    55b0:	8f 5f       	subi	r24, 0xFF	; 255
    55b2:	eb 81       	ldd	r30, Y+3	; 0x03
    55b4:	fc 81       	ldd	r31, Y+4	; 0x04
    55b6:	80 83       	st	Z, r24
}
    55b8:	26 96       	adiw	r28, 0x06	; 6
    55ba:	0f b6       	in	r0, 0x3f	; 63
    55bc:	f8 94       	cli
    55be:	de bf       	out	0x3e, r29	; 62
    55c0:	0f be       	out	0x3f, r0	; 63
    55c2:	cd bf       	out	0x3d, r28	; 61
    55c4:	cf 91       	pop	r28
    55c6:	df 91       	pop	r29
    55c8:	08 95       	ret

000055ca <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    55ca:	df 93       	push	r29
    55cc:	cf 93       	push	r28
    55ce:	cd b7       	in	r28, 0x3d	; 61
    55d0:	de b7       	in	r29, 0x3e	; 62
    55d2:	28 97       	sbiw	r28, 0x08	; 8
    55d4:	0f b6       	in	r0, 0x3f	; 63
    55d6:	f8 94       	cli
    55d8:	de bf       	out	0x3e, r29	; 62
    55da:	0f be       	out	0x3f, r0	; 63
    55dc:	cd bf       	out	0x3d, r28	; 61
    55de:	9e 83       	std	Y+6, r25	; 0x06
    55e0:	8d 83       	std	Y+5, r24	; 0x05
    55e2:	78 87       	std	Y+8, r23	; 0x08
    55e4:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    55e6:	ef 81       	ldd	r30, Y+7	; 0x07
    55e8:	f8 85       	ldd	r31, Y+8	; 0x08
    55ea:	80 81       	ld	r24, Z
    55ec:	91 81       	ldd	r25, Z+1	; 0x01
    55ee:	9a 83       	std	Y+2, r25	; 0x02
    55f0:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    55f2:	89 81       	ldd	r24, Y+1	; 0x01
    55f4:	9a 81       	ldd	r25, Y+2	; 0x02
    55f6:	2f ef       	ldi	r18, 0xFF	; 255
    55f8:	8f 3f       	cpi	r24, 0xFF	; 255
    55fa:	92 07       	cpc	r25, r18
    55fc:	39 f4       	brne	.+14     	; 0x560c <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    55fe:	ed 81       	ldd	r30, Y+5	; 0x05
    5600:	fe 81       	ldd	r31, Y+6	; 0x06
    5602:	87 81       	ldd	r24, Z+7	; 0x07
    5604:	90 85       	ldd	r25, Z+8	; 0x08
    5606:	9c 83       	std	Y+4, r25	; 0x04
    5608:	8b 83       	std	Y+3, r24	; 0x03
    560a:	18 c0       	rjmp	.+48     	; 0x563c <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    560c:	8d 81       	ldd	r24, Y+5	; 0x05
    560e:	9e 81       	ldd	r25, Y+6	; 0x06
    5610:	03 96       	adiw	r24, 0x03	; 3
    5612:	9c 83       	std	Y+4, r25	; 0x04
    5614:	8b 83       	std	Y+3, r24	; 0x03
    5616:	06 c0       	rjmp	.+12     	; 0x5624 <vListInsert+0x5a>
    5618:	eb 81       	ldd	r30, Y+3	; 0x03
    561a:	fc 81       	ldd	r31, Y+4	; 0x04
    561c:	82 81       	ldd	r24, Z+2	; 0x02
    561e:	93 81       	ldd	r25, Z+3	; 0x03
    5620:	9c 83       	std	Y+4, r25	; 0x04
    5622:	8b 83       	std	Y+3, r24	; 0x03
    5624:	eb 81       	ldd	r30, Y+3	; 0x03
    5626:	fc 81       	ldd	r31, Y+4	; 0x04
    5628:	02 80       	ldd	r0, Z+2	; 0x02
    562a:	f3 81       	ldd	r31, Z+3	; 0x03
    562c:	e0 2d       	mov	r30, r0
    562e:	20 81       	ld	r18, Z
    5630:	31 81       	ldd	r19, Z+1	; 0x01
    5632:	89 81       	ldd	r24, Y+1	; 0x01
    5634:	9a 81       	ldd	r25, Y+2	; 0x02
    5636:	82 17       	cp	r24, r18
    5638:	93 07       	cpc	r25, r19
    563a:	70 f7       	brcc	.-36     	; 0x5618 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    563c:	eb 81       	ldd	r30, Y+3	; 0x03
    563e:	fc 81       	ldd	r31, Y+4	; 0x04
    5640:	82 81       	ldd	r24, Z+2	; 0x02
    5642:	93 81       	ldd	r25, Z+3	; 0x03
    5644:	ef 81       	ldd	r30, Y+7	; 0x07
    5646:	f8 85       	ldd	r31, Y+8	; 0x08
    5648:	93 83       	std	Z+3, r25	; 0x03
    564a:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    564c:	ef 81       	ldd	r30, Y+7	; 0x07
    564e:	f8 85       	ldd	r31, Y+8	; 0x08
    5650:	02 80       	ldd	r0, Z+2	; 0x02
    5652:	f3 81       	ldd	r31, Z+3	; 0x03
    5654:	e0 2d       	mov	r30, r0
    5656:	8f 81       	ldd	r24, Y+7	; 0x07
    5658:	98 85       	ldd	r25, Y+8	; 0x08
    565a:	95 83       	std	Z+5, r25	; 0x05
    565c:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    565e:	ef 81       	ldd	r30, Y+7	; 0x07
    5660:	f8 85       	ldd	r31, Y+8	; 0x08
    5662:	8b 81       	ldd	r24, Y+3	; 0x03
    5664:	9c 81       	ldd	r25, Y+4	; 0x04
    5666:	95 83       	std	Z+5, r25	; 0x05
    5668:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    566a:	eb 81       	ldd	r30, Y+3	; 0x03
    566c:	fc 81       	ldd	r31, Y+4	; 0x04
    566e:	8f 81       	ldd	r24, Y+7	; 0x07
    5670:	98 85       	ldd	r25, Y+8	; 0x08
    5672:	93 83       	std	Z+3, r25	; 0x03
    5674:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    5676:	ef 81       	ldd	r30, Y+7	; 0x07
    5678:	f8 85       	ldd	r31, Y+8	; 0x08
    567a:	8d 81       	ldd	r24, Y+5	; 0x05
    567c:	9e 81       	ldd	r25, Y+6	; 0x06
    567e:	91 87       	std	Z+9, r25	; 0x09
    5680:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    5682:	ed 81       	ldd	r30, Y+5	; 0x05
    5684:	fe 81       	ldd	r31, Y+6	; 0x06
    5686:	80 81       	ld	r24, Z
    5688:	8f 5f       	subi	r24, 0xFF	; 255
    568a:	ed 81       	ldd	r30, Y+5	; 0x05
    568c:	fe 81       	ldd	r31, Y+6	; 0x06
    568e:	80 83       	st	Z, r24
}
    5690:	28 96       	adiw	r28, 0x08	; 8
    5692:	0f b6       	in	r0, 0x3f	; 63
    5694:	f8 94       	cli
    5696:	de bf       	out	0x3e, r29	; 62
    5698:	0f be       	out	0x3f, r0	; 63
    569a:	cd bf       	out	0x3d, r28	; 61
    569c:	cf 91       	pop	r28
    569e:	df 91       	pop	r29
    56a0:	08 95       	ret

000056a2 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    56a2:	df 93       	push	r29
    56a4:	cf 93       	push	r28
    56a6:	00 d0       	rcall	.+0      	; 0x56a8 <uxListRemove+0x6>
    56a8:	00 d0       	rcall	.+0      	; 0x56aa <uxListRemove+0x8>
    56aa:	cd b7       	in	r28, 0x3d	; 61
    56ac:	de b7       	in	r29, 0x3e	; 62
    56ae:	9c 83       	std	Y+4, r25	; 0x04
    56b0:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    56b2:	eb 81       	ldd	r30, Y+3	; 0x03
    56b4:	fc 81       	ldd	r31, Y+4	; 0x04
    56b6:	80 85       	ldd	r24, Z+8	; 0x08
    56b8:	91 85       	ldd	r25, Z+9	; 0x09
    56ba:	9a 83       	std	Y+2, r25	; 0x02
    56bc:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    56be:	eb 81       	ldd	r30, Y+3	; 0x03
    56c0:	fc 81       	ldd	r31, Y+4	; 0x04
    56c2:	a2 81       	ldd	r26, Z+2	; 0x02
    56c4:	b3 81       	ldd	r27, Z+3	; 0x03
    56c6:	eb 81       	ldd	r30, Y+3	; 0x03
    56c8:	fc 81       	ldd	r31, Y+4	; 0x04
    56ca:	84 81       	ldd	r24, Z+4	; 0x04
    56cc:	95 81       	ldd	r25, Z+5	; 0x05
    56ce:	15 96       	adiw	r26, 0x05	; 5
    56d0:	9c 93       	st	X, r25
    56d2:	8e 93       	st	-X, r24
    56d4:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    56d6:	eb 81       	ldd	r30, Y+3	; 0x03
    56d8:	fc 81       	ldd	r31, Y+4	; 0x04
    56da:	a4 81       	ldd	r26, Z+4	; 0x04
    56dc:	b5 81       	ldd	r27, Z+5	; 0x05
    56de:	eb 81       	ldd	r30, Y+3	; 0x03
    56e0:	fc 81       	ldd	r31, Y+4	; 0x04
    56e2:	82 81       	ldd	r24, Z+2	; 0x02
    56e4:	93 81       	ldd	r25, Z+3	; 0x03
    56e6:	13 96       	adiw	r26, 0x03	; 3
    56e8:	9c 93       	st	X, r25
    56ea:	8e 93       	st	-X, r24
    56ec:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    56ee:	e9 81       	ldd	r30, Y+1	; 0x01
    56f0:	fa 81       	ldd	r31, Y+2	; 0x02
    56f2:	21 81       	ldd	r18, Z+1	; 0x01
    56f4:	32 81       	ldd	r19, Z+2	; 0x02
    56f6:	8b 81       	ldd	r24, Y+3	; 0x03
    56f8:	9c 81       	ldd	r25, Y+4	; 0x04
    56fa:	28 17       	cp	r18, r24
    56fc:	39 07       	cpc	r19, r25
    56fe:	41 f4       	brne	.+16     	; 0x5710 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    5700:	eb 81       	ldd	r30, Y+3	; 0x03
    5702:	fc 81       	ldd	r31, Y+4	; 0x04
    5704:	84 81       	ldd	r24, Z+4	; 0x04
    5706:	95 81       	ldd	r25, Z+5	; 0x05
    5708:	e9 81       	ldd	r30, Y+1	; 0x01
    570a:	fa 81       	ldd	r31, Y+2	; 0x02
    570c:	92 83       	std	Z+2, r25	; 0x02
    570e:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    5710:	eb 81       	ldd	r30, Y+3	; 0x03
    5712:	fc 81       	ldd	r31, Y+4	; 0x04
    5714:	11 86       	std	Z+9, r1	; 0x09
    5716:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    5718:	e9 81       	ldd	r30, Y+1	; 0x01
    571a:	fa 81       	ldd	r31, Y+2	; 0x02
    571c:	80 81       	ld	r24, Z
    571e:	81 50       	subi	r24, 0x01	; 1
    5720:	e9 81       	ldd	r30, Y+1	; 0x01
    5722:	fa 81       	ldd	r31, Y+2	; 0x02
    5724:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    5726:	e9 81       	ldd	r30, Y+1	; 0x01
    5728:	fa 81       	ldd	r31, Y+2	; 0x02
    572a:	80 81       	ld	r24, Z
}
    572c:	0f 90       	pop	r0
    572e:	0f 90       	pop	r0
    5730:	0f 90       	pop	r0
    5732:	0f 90       	pop	r0
    5734:	cf 91       	pop	r28
    5736:	df 91       	pop	r29
    5738:	08 95       	ret

0000573a <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    573a:	df 93       	push	r29
    573c:	cf 93       	push	r28
    573e:	cd b7       	in	r28, 0x3d	; 61
    5740:	de b7       	in	r29, 0x3e	; 62
    5742:	28 97       	sbiw	r28, 0x08	; 8
    5744:	0f b6       	in	r0, 0x3f	; 63
    5746:	f8 94       	cli
    5748:	de bf       	out	0x3e, r29	; 62
    574a:	0f be       	out	0x3f, r0	; 63
    574c:	cd bf       	out	0x3d, r28	; 61
    574e:	9c 83       	std	Y+4, r25	; 0x04
    5750:	8b 83       	std	Y+3, r24	; 0x03
    5752:	7e 83       	std	Y+6, r23	; 0x06
    5754:	6d 83       	std	Y+5, r22	; 0x05
    5756:	58 87       	std	Y+8, r21	; 0x08
    5758:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    575a:	eb 81       	ldd	r30, Y+3	; 0x03
    575c:	fc 81       	ldd	r31, Y+4	; 0x04
    575e:	81 e1       	ldi	r24, 0x11	; 17
    5760:	80 83       	st	Z, r24
	pxTopOfStack--;
    5762:	8b 81       	ldd	r24, Y+3	; 0x03
    5764:	9c 81       	ldd	r25, Y+4	; 0x04
    5766:	01 97       	sbiw	r24, 0x01	; 1
    5768:	9c 83       	std	Y+4, r25	; 0x04
    576a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    576c:	eb 81       	ldd	r30, Y+3	; 0x03
    576e:	fc 81       	ldd	r31, Y+4	; 0x04
    5770:	82 e2       	ldi	r24, 0x22	; 34
    5772:	80 83       	st	Z, r24
	pxTopOfStack--;
    5774:	8b 81       	ldd	r24, Y+3	; 0x03
    5776:	9c 81       	ldd	r25, Y+4	; 0x04
    5778:	01 97       	sbiw	r24, 0x01	; 1
    577a:	9c 83       	std	Y+4, r25	; 0x04
    577c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    577e:	eb 81       	ldd	r30, Y+3	; 0x03
    5780:	fc 81       	ldd	r31, Y+4	; 0x04
    5782:	83 e3       	ldi	r24, 0x33	; 51
    5784:	80 83       	st	Z, r24
	pxTopOfStack--;
    5786:	8b 81       	ldd	r24, Y+3	; 0x03
    5788:	9c 81       	ldd	r25, Y+4	; 0x04
    578a:	01 97       	sbiw	r24, 0x01	; 1
    578c:	9c 83       	std	Y+4, r25	; 0x04
    578e:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    5790:	8d 81       	ldd	r24, Y+5	; 0x05
    5792:	9e 81       	ldd	r25, Y+6	; 0x06
    5794:	9a 83       	std	Y+2, r25	; 0x02
    5796:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    5798:	89 81       	ldd	r24, Y+1	; 0x01
    579a:	eb 81       	ldd	r30, Y+3	; 0x03
    579c:	fc 81       	ldd	r31, Y+4	; 0x04
    579e:	80 83       	st	Z, r24
	pxTopOfStack--;
    57a0:	8b 81       	ldd	r24, Y+3	; 0x03
    57a2:	9c 81       	ldd	r25, Y+4	; 0x04
    57a4:	01 97       	sbiw	r24, 0x01	; 1
    57a6:	9c 83       	std	Y+4, r25	; 0x04
    57a8:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    57aa:	89 81       	ldd	r24, Y+1	; 0x01
    57ac:	9a 81       	ldd	r25, Y+2	; 0x02
    57ae:	89 2f       	mov	r24, r25
    57b0:	99 27       	eor	r25, r25
    57b2:	9a 83       	std	Y+2, r25	; 0x02
    57b4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    57b6:	89 81       	ldd	r24, Y+1	; 0x01
    57b8:	eb 81       	ldd	r30, Y+3	; 0x03
    57ba:	fc 81       	ldd	r31, Y+4	; 0x04
    57bc:	80 83       	st	Z, r24
	pxTopOfStack--;
    57be:	8b 81       	ldd	r24, Y+3	; 0x03
    57c0:	9c 81       	ldd	r25, Y+4	; 0x04
    57c2:	01 97       	sbiw	r24, 0x01	; 1
    57c4:	9c 83       	std	Y+4, r25	; 0x04
    57c6:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    57c8:	eb 81       	ldd	r30, Y+3	; 0x03
    57ca:	fc 81       	ldd	r31, Y+4	; 0x04
    57cc:	10 82       	st	Z, r1
	pxTopOfStack--;
    57ce:	8b 81       	ldd	r24, Y+3	; 0x03
    57d0:	9c 81       	ldd	r25, Y+4	; 0x04
    57d2:	01 97       	sbiw	r24, 0x01	; 1
    57d4:	9c 83       	std	Y+4, r25	; 0x04
    57d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    57d8:	eb 81       	ldd	r30, Y+3	; 0x03
    57da:	fc 81       	ldd	r31, Y+4	; 0x04
    57dc:	80 e8       	ldi	r24, 0x80	; 128
    57de:	80 83       	st	Z, r24
	pxTopOfStack--;
    57e0:	8b 81       	ldd	r24, Y+3	; 0x03
    57e2:	9c 81       	ldd	r25, Y+4	; 0x04
    57e4:	01 97       	sbiw	r24, 0x01	; 1
    57e6:	9c 83       	std	Y+4, r25	; 0x04
    57e8:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    57ea:	eb 81       	ldd	r30, Y+3	; 0x03
    57ec:	fc 81       	ldd	r31, Y+4	; 0x04
    57ee:	10 82       	st	Z, r1
	pxTopOfStack--;
    57f0:	8b 81       	ldd	r24, Y+3	; 0x03
    57f2:	9c 81       	ldd	r25, Y+4	; 0x04
    57f4:	01 97       	sbiw	r24, 0x01	; 1
    57f6:	9c 83       	std	Y+4, r25	; 0x04
    57f8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    57fa:	eb 81       	ldd	r30, Y+3	; 0x03
    57fc:	fc 81       	ldd	r31, Y+4	; 0x04
    57fe:	82 e0       	ldi	r24, 0x02	; 2
    5800:	80 83       	st	Z, r24
	pxTopOfStack--;
    5802:	8b 81       	ldd	r24, Y+3	; 0x03
    5804:	9c 81       	ldd	r25, Y+4	; 0x04
    5806:	01 97       	sbiw	r24, 0x01	; 1
    5808:	9c 83       	std	Y+4, r25	; 0x04
    580a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    580c:	eb 81       	ldd	r30, Y+3	; 0x03
    580e:	fc 81       	ldd	r31, Y+4	; 0x04
    5810:	83 e0       	ldi	r24, 0x03	; 3
    5812:	80 83       	st	Z, r24
	pxTopOfStack--;
    5814:	8b 81       	ldd	r24, Y+3	; 0x03
    5816:	9c 81       	ldd	r25, Y+4	; 0x04
    5818:	01 97       	sbiw	r24, 0x01	; 1
    581a:	9c 83       	std	Y+4, r25	; 0x04
    581c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    581e:	eb 81       	ldd	r30, Y+3	; 0x03
    5820:	fc 81       	ldd	r31, Y+4	; 0x04
    5822:	84 e0       	ldi	r24, 0x04	; 4
    5824:	80 83       	st	Z, r24
	pxTopOfStack--;
    5826:	8b 81       	ldd	r24, Y+3	; 0x03
    5828:	9c 81       	ldd	r25, Y+4	; 0x04
    582a:	01 97       	sbiw	r24, 0x01	; 1
    582c:	9c 83       	std	Y+4, r25	; 0x04
    582e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    5830:	eb 81       	ldd	r30, Y+3	; 0x03
    5832:	fc 81       	ldd	r31, Y+4	; 0x04
    5834:	85 e0       	ldi	r24, 0x05	; 5
    5836:	80 83       	st	Z, r24
	pxTopOfStack--;
    5838:	8b 81       	ldd	r24, Y+3	; 0x03
    583a:	9c 81       	ldd	r25, Y+4	; 0x04
    583c:	01 97       	sbiw	r24, 0x01	; 1
    583e:	9c 83       	std	Y+4, r25	; 0x04
    5840:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    5842:	eb 81       	ldd	r30, Y+3	; 0x03
    5844:	fc 81       	ldd	r31, Y+4	; 0x04
    5846:	86 e0       	ldi	r24, 0x06	; 6
    5848:	80 83       	st	Z, r24
	pxTopOfStack--;
    584a:	8b 81       	ldd	r24, Y+3	; 0x03
    584c:	9c 81       	ldd	r25, Y+4	; 0x04
    584e:	01 97       	sbiw	r24, 0x01	; 1
    5850:	9c 83       	std	Y+4, r25	; 0x04
    5852:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    5854:	eb 81       	ldd	r30, Y+3	; 0x03
    5856:	fc 81       	ldd	r31, Y+4	; 0x04
    5858:	87 e0       	ldi	r24, 0x07	; 7
    585a:	80 83       	st	Z, r24
	pxTopOfStack--;
    585c:	8b 81       	ldd	r24, Y+3	; 0x03
    585e:	9c 81       	ldd	r25, Y+4	; 0x04
    5860:	01 97       	sbiw	r24, 0x01	; 1
    5862:	9c 83       	std	Y+4, r25	; 0x04
    5864:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    5866:	eb 81       	ldd	r30, Y+3	; 0x03
    5868:	fc 81       	ldd	r31, Y+4	; 0x04
    586a:	88 e0       	ldi	r24, 0x08	; 8
    586c:	80 83       	st	Z, r24
	pxTopOfStack--;
    586e:	8b 81       	ldd	r24, Y+3	; 0x03
    5870:	9c 81       	ldd	r25, Y+4	; 0x04
    5872:	01 97       	sbiw	r24, 0x01	; 1
    5874:	9c 83       	std	Y+4, r25	; 0x04
    5876:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    5878:	eb 81       	ldd	r30, Y+3	; 0x03
    587a:	fc 81       	ldd	r31, Y+4	; 0x04
    587c:	89 e0       	ldi	r24, 0x09	; 9
    587e:	80 83       	st	Z, r24
	pxTopOfStack--;
    5880:	8b 81       	ldd	r24, Y+3	; 0x03
    5882:	9c 81       	ldd	r25, Y+4	; 0x04
    5884:	01 97       	sbiw	r24, 0x01	; 1
    5886:	9c 83       	std	Y+4, r25	; 0x04
    5888:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    588a:	eb 81       	ldd	r30, Y+3	; 0x03
    588c:	fc 81       	ldd	r31, Y+4	; 0x04
    588e:	80 e1       	ldi	r24, 0x10	; 16
    5890:	80 83       	st	Z, r24
	pxTopOfStack--;
    5892:	8b 81       	ldd	r24, Y+3	; 0x03
    5894:	9c 81       	ldd	r25, Y+4	; 0x04
    5896:	01 97       	sbiw	r24, 0x01	; 1
    5898:	9c 83       	std	Y+4, r25	; 0x04
    589a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    589c:	eb 81       	ldd	r30, Y+3	; 0x03
    589e:	fc 81       	ldd	r31, Y+4	; 0x04
    58a0:	81 e1       	ldi	r24, 0x11	; 17
    58a2:	80 83       	st	Z, r24
	pxTopOfStack--;
    58a4:	8b 81       	ldd	r24, Y+3	; 0x03
    58a6:	9c 81       	ldd	r25, Y+4	; 0x04
    58a8:	01 97       	sbiw	r24, 0x01	; 1
    58aa:	9c 83       	std	Y+4, r25	; 0x04
    58ac:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    58ae:	eb 81       	ldd	r30, Y+3	; 0x03
    58b0:	fc 81       	ldd	r31, Y+4	; 0x04
    58b2:	82 e1       	ldi	r24, 0x12	; 18
    58b4:	80 83       	st	Z, r24
	pxTopOfStack--;
    58b6:	8b 81       	ldd	r24, Y+3	; 0x03
    58b8:	9c 81       	ldd	r25, Y+4	; 0x04
    58ba:	01 97       	sbiw	r24, 0x01	; 1
    58bc:	9c 83       	std	Y+4, r25	; 0x04
    58be:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    58c0:	eb 81       	ldd	r30, Y+3	; 0x03
    58c2:	fc 81       	ldd	r31, Y+4	; 0x04
    58c4:	83 e1       	ldi	r24, 0x13	; 19
    58c6:	80 83       	st	Z, r24
	pxTopOfStack--;
    58c8:	8b 81       	ldd	r24, Y+3	; 0x03
    58ca:	9c 81       	ldd	r25, Y+4	; 0x04
    58cc:	01 97       	sbiw	r24, 0x01	; 1
    58ce:	9c 83       	std	Y+4, r25	; 0x04
    58d0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    58d2:	eb 81       	ldd	r30, Y+3	; 0x03
    58d4:	fc 81       	ldd	r31, Y+4	; 0x04
    58d6:	84 e1       	ldi	r24, 0x14	; 20
    58d8:	80 83       	st	Z, r24
	pxTopOfStack--;
    58da:	8b 81       	ldd	r24, Y+3	; 0x03
    58dc:	9c 81       	ldd	r25, Y+4	; 0x04
    58de:	01 97       	sbiw	r24, 0x01	; 1
    58e0:	9c 83       	std	Y+4, r25	; 0x04
    58e2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    58e4:	eb 81       	ldd	r30, Y+3	; 0x03
    58e6:	fc 81       	ldd	r31, Y+4	; 0x04
    58e8:	85 e1       	ldi	r24, 0x15	; 21
    58ea:	80 83       	st	Z, r24
	pxTopOfStack--;
    58ec:	8b 81       	ldd	r24, Y+3	; 0x03
    58ee:	9c 81       	ldd	r25, Y+4	; 0x04
    58f0:	01 97       	sbiw	r24, 0x01	; 1
    58f2:	9c 83       	std	Y+4, r25	; 0x04
    58f4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    58f6:	eb 81       	ldd	r30, Y+3	; 0x03
    58f8:	fc 81       	ldd	r31, Y+4	; 0x04
    58fa:	86 e1       	ldi	r24, 0x16	; 22
    58fc:	80 83       	st	Z, r24
	pxTopOfStack--;
    58fe:	8b 81       	ldd	r24, Y+3	; 0x03
    5900:	9c 81       	ldd	r25, Y+4	; 0x04
    5902:	01 97       	sbiw	r24, 0x01	; 1
    5904:	9c 83       	std	Y+4, r25	; 0x04
    5906:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    5908:	eb 81       	ldd	r30, Y+3	; 0x03
    590a:	fc 81       	ldd	r31, Y+4	; 0x04
    590c:	87 e1       	ldi	r24, 0x17	; 23
    590e:	80 83       	st	Z, r24
	pxTopOfStack--;
    5910:	8b 81       	ldd	r24, Y+3	; 0x03
    5912:	9c 81       	ldd	r25, Y+4	; 0x04
    5914:	01 97       	sbiw	r24, 0x01	; 1
    5916:	9c 83       	std	Y+4, r25	; 0x04
    5918:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    591a:	eb 81       	ldd	r30, Y+3	; 0x03
    591c:	fc 81       	ldd	r31, Y+4	; 0x04
    591e:	88 e1       	ldi	r24, 0x18	; 24
    5920:	80 83       	st	Z, r24
	pxTopOfStack--;
    5922:	8b 81       	ldd	r24, Y+3	; 0x03
    5924:	9c 81       	ldd	r25, Y+4	; 0x04
    5926:	01 97       	sbiw	r24, 0x01	; 1
    5928:	9c 83       	std	Y+4, r25	; 0x04
    592a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    592c:	eb 81       	ldd	r30, Y+3	; 0x03
    592e:	fc 81       	ldd	r31, Y+4	; 0x04
    5930:	89 e1       	ldi	r24, 0x19	; 25
    5932:	80 83       	st	Z, r24
	pxTopOfStack--;
    5934:	8b 81       	ldd	r24, Y+3	; 0x03
    5936:	9c 81       	ldd	r25, Y+4	; 0x04
    5938:	01 97       	sbiw	r24, 0x01	; 1
    593a:	9c 83       	std	Y+4, r25	; 0x04
    593c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    593e:	eb 81       	ldd	r30, Y+3	; 0x03
    5940:	fc 81       	ldd	r31, Y+4	; 0x04
    5942:	80 e2       	ldi	r24, 0x20	; 32
    5944:	80 83       	st	Z, r24
	pxTopOfStack--;
    5946:	8b 81       	ldd	r24, Y+3	; 0x03
    5948:	9c 81       	ldd	r25, Y+4	; 0x04
    594a:	01 97       	sbiw	r24, 0x01	; 1
    594c:	9c 83       	std	Y+4, r25	; 0x04
    594e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    5950:	eb 81       	ldd	r30, Y+3	; 0x03
    5952:	fc 81       	ldd	r31, Y+4	; 0x04
    5954:	81 e2       	ldi	r24, 0x21	; 33
    5956:	80 83       	st	Z, r24
	pxTopOfStack--;
    5958:	8b 81       	ldd	r24, Y+3	; 0x03
    595a:	9c 81       	ldd	r25, Y+4	; 0x04
    595c:	01 97       	sbiw	r24, 0x01	; 1
    595e:	9c 83       	std	Y+4, r25	; 0x04
    5960:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    5962:	eb 81       	ldd	r30, Y+3	; 0x03
    5964:	fc 81       	ldd	r31, Y+4	; 0x04
    5966:	82 e2       	ldi	r24, 0x22	; 34
    5968:	80 83       	st	Z, r24
	pxTopOfStack--;
    596a:	8b 81       	ldd	r24, Y+3	; 0x03
    596c:	9c 81       	ldd	r25, Y+4	; 0x04
    596e:	01 97       	sbiw	r24, 0x01	; 1
    5970:	9c 83       	std	Y+4, r25	; 0x04
    5972:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    5974:	eb 81       	ldd	r30, Y+3	; 0x03
    5976:	fc 81       	ldd	r31, Y+4	; 0x04
    5978:	83 e2       	ldi	r24, 0x23	; 35
    597a:	80 83       	st	Z, r24
	pxTopOfStack--;
    597c:	8b 81       	ldd	r24, Y+3	; 0x03
    597e:	9c 81       	ldd	r25, Y+4	; 0x04
    5980:	01 97       	sbiw	r24, 0x01	; 1
    5982:	9c 83       	std	Y+4, r25	; 0x04
    5984:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    5986:	8f 81       	ldd	r24, Y+7	; 0x07
    5988:	98 85       	ldd	r25, Y+8	; 0x08
    598a:	9a 83       	std	Y+2, r25	; 0x02
    598c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    598e:	89 81       	ldd	r24, Y+1	; 0x01
    5990:	eb 81       	ldd	r30, Y+3	; 0x03
    5992:	fc 81       	ldd	r31, Y+4	; 0x04
    5994:	80 83       	st	Z, r24
	pxTopOfStack--;
    5996:	8b 81       	ldd	r24, Y+3	; 0x03
    5998:	9c 81       	ldd	r25, Y+4	; 0x04
    599a:	01 97       	sbiw	r24, 0x01	; 1
    599c:	9c 83       	std	Y+4, r25	; 0x04
    599e:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    59a0:	89 81       	ldd	r24, Y+1	; 0x01
    59a2:	9a 81       	ldd	r25, Y+2	; 0x02
    59a4:	89 2f       	mov	r24, r25
    59a6:	99 27       	eor	r25, r25
    59a8:	9a 83       	std	Y+2, r25	; 0x02
    59aa:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    59ac:	89 81       	ldd	r24, Y+1	; 0x01
    59ae:	eb 81       	ldd	r30, Y+3	; 0x03
    59b0:	fc 81       	ldd	r31, Y+4	; 0x04
    59b2:	80 83       	st	Z, r24
	pxTopOfStack--;
    59b4:	8b 81       	ldd	r24, Y+3	; 0x03
    59b6:	9c 81       	ldd	r25, Y+4	; 0x04
    59b8:	01 97       	sbiw	r24, 0x01	; 1
    59ba:	9c 83       	std	Y+4, r25	; 0x04
    59bc:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    59be:	eb 81       	ldd	r30, Y+3	; 0x03
    59c0:	fc 81       	ldd	r31, Y+4	; 0x04
    59c2:	86 e2       	ldi	r24, 0x26	; 38
    59c4:	80 83       	st	Z, r24
	pxTopOfStack--;
    59c6:	8b 81       	ldd	r24, Y+3	; 0x03
    59c8:	9c 81       	ldd	r25, Y+4	; 0x04
    59ca:	01 97       	sbiw	r24, 0x01	; 1
    59cc:	9c 83       	std	Y+4, r25	; 0x04
    59ce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    59d0:	eb 81       	ldd	r30, Y+3	; 0x03
    59d2:	fc 81       	ldd	r31, Y+4	; 0x04
    59d4:	87 e2       	ldi	r24, 0x27	; 39
    59d6:	80 83       	st	Z, r24
	pxTopOfStack--;
    59d8:	8b 81       	ldd	r24, Y+3	; 0x03
    59da:	9c 81       	ldd	r25, Y+4	; 0x04
    59dc:	01 97       	sbiw	r24, 0x01	; 1
    59de:	9c 83       	std	Y+4, r25	; 0x04
    59e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    59e2:	eb 81       	ldd	r30, Y+3	; 0x03
    59e4:	fc 81       	ldd	r31, Y+4	; 0x04
    59e6:	88 e2       	ldi	r24, 0x28	; 40
    59e8:	80 83       	st	Z, r24
	pxTopOfStack--;
    59ea:	8b 81       	ldd	r24, Y+3	; 0x03
    59ec:	9c 81       	ldd	r25, Y+4	; 0x04
    59ee:	01 97       	sbiw	r24, 0x01	; 1
    59f0:	9c 83       	std	Y+4, r25	; 0x04
    59f2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    59f4:	eb 81       	ldd	r30, Y+3	; 0x03
    59f6:	fc 81       	ldd	r31, Y+4	; 0x04
    59f8:	89 e2       	ldi	r24, 0x29	; 41
    59fa:	80 83       	st	Z, r24
	pxTopOfStack--;
    59fc:	8b 81       	ldd	r24, Y+3	; 0x03
    59fe:	9c 81       	ldd	r25, Y+4	; 0x04
    5a00:	01 97       	sbiw	r24, 0x01	; 1
    5a02:	9c 83       	std	Y+4, r25	; 0x04
    5a04:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    5a06:	eb 81       	ldd	r30, Y+3	; 0x03
    5a08:	fc 81       	ldd	r31, Y+4	; 0x04
    5a0a:	80 e3       	ldi	r24, 0x30	; 48
    5a0c:	80 83       	st	Z, r24
	pxTopOfStack--;
    5a0e:	8b 81       	ldd	r24, Y+3	; 0x03
    5a10:	9c 81       	ldd	r25, Y+4	; 0x04
    5a12:	01 97       	sbiw	r24, 0x01	; 1
    5a14:	9c 83       	std	Y+4, r25	; 0x04
    5a16:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    5a18:	eb 81       	ldd	r30, Y+3	; 0x03
    5a1a:	fc 81       	ldd	r31, Y+4	; 0x04
    5a1c:	81 e3       	ldi	r24, 0x31	; 49
    5a1e:	80 83       	st	Z, r24
	pxTopOfStack--;
    5a20:	8b 81       	ldd	r24, Y+3	; 0x03
    5a22:	9c 81       	ldd	r25, Y+4	; 0x04
    5a24:	01 97       	sbiw	r24, 0x01	; 1
    5a26:	9c 83       	std	Y+4, r25	; 0x04
    5a28:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    5a2a:	8b 81       	ldd	r24, Y+3	; 0x03
    5a2c:	9c 81       	ldd	r25, Y+4	; 0x04
}
    5a2e:	28 96       	adiw	r28, 0x08	; 8
    5a30:	0f b6       	in	r0, 0x3f	; 63
    5a32:	f8 94       	cli
    5a34:	de bf       	out	0x3e, r29	; 62
    5a36:	0f be       	out	0x3f, r0	; 63
    5a38:	cd bf       	out	0x3d, r28	; 61
    5a3a:	cf 91       	pop	r28
    5a3c:	df 91       	pop	r29
    5a3e:	08 95       	ret

00005a40 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    5a40:	df 93       	push	r29
    5a42:	cf 93       	push	r28
    5a44:	cd b7       	in	r28, 0x3d	; 61
    5a46:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    5a48:	0e 94 12 2e 	call	0x5c24	; 0x5c24 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    5a4c:	a0 91 39 06 	lds	r26, 0x0639
    5a50:	b0 91 3a 06 	lds	r27, 0x063A
    5a54:	cd 91       	ld	r28, X+
    5a56:	cd bf       	out	0x3d, r28	; 61
    5a58:	dd 91       	ld	r29, X+
    5a5a:	de bf       	out	0x3e, r29	; 62
    5a5c:	ff 91       	pop	r31
    5a5e:	ef 91       	pop	r30
    5a60:	df 91       	pop	r29
    5a62:	cf 91       	pop	r28
    5a64:	bf 91       	pop	r27
    5a66:	af 91       	pop	r26
    5a68:	9f 91       	pop	r25
    5a6a:	8f 91       	pop	r24
    5a6c:	7f 91       	pop	r23
    5a6e:	6f 91       	pop	r22
    5a70:	5f 91       	pop	r21
    5a72:	4f 91       	pop	r20
    5a74:	3f 91       	pop	r19
    5a76:	2f 91       	pop	r18
    5a78:	1f 91       	pop	r17
    5a7a:	0f 91       	pop	r16
    5a7c:	ff 90       	pop	r15
    5a7e:	ef 90       	pop	r14
    5a80:	df 90       	pop	r13
    5a82:	cf 90       	pop	r12
    5a84:	bf 90       	pop	r11
    5a86:	af 90       	pop	r10
    5a88:	9f 90       	pop	r9
    5a8a:	8f 90       	pop	r8
    5a8c:	7f 90       	pop	r7
    5a8e:	6f 90       	pop	r6
    5a90:	5f 90       	pop	r5
    5a92:	4f 90       	pop	r4
    5a94:	3f 90       	pop	r3
    5a96:	2f 90       	pop	r2
    5a98:	1f 90       	pop	r1
    5a9a:	0f 90       	pop	r0
    5a9c:	0f be       	out	0x3f, r0	; 63
    5a9e:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    5aa0:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    5aa2:	81 e0       	ldi	r24, 0x01	; 1
}
    5aa4:	cf 91       	pop	r28
    5aa6:	df 91       	pop	r29
    5aa8:	08 95       	ret

00005aaa <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    5aaa:	df 93       	push	r29
    5aac:	cf 93       	push	r28
    5aae:	cd b7       	in	r28, 0x3d	; 61
    5ab0:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    5ab2:	cf 91       	pop	r28
    5ab4:	df 91       	pop	r29
    5ab6:	08 95       	ret

00005ab8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    5ab8:	0f 92       	push	r0
    5aba:	0f b6       	in	r0, 0x3f	; 63
    5abc:	f8 94       	cli
    5abe:	0f 92       	push	r0
    5ac0:	1f 92       	push	r1
    5ac2:	11 24       	eor	r1, r1
    5ac4:	2f 92       	push	r2
    5ac6:	3f 92       	push	r3
    5ac8:	4f 92       	push	r4
    5aca:	5f 92       	push	r5
    5acc:	6f 92       	push	r6
    5ace:	7f 92       	push	r7
    5ad0:	8f 92       	push	r8
    5ad2:	9f 92       	push	r9
    5ad4:	af 92       	push	r10
    5ad6:	bf 92       	push	r11
    5ad8:	cf 92       	push	r12
    5ada:	df 92       	push	r13
    5adc:	ef 92       	push	r14
    5ade:	ff 92       	push	r15
    5ae0:	0f 93       	push	r16
    5ae2:	1f 93       	push	r17
    5ae4:	2f 93       	push	r18
    5ae6:	3f 93       	push	r19
    5ae8:	4f 93       	push	r20
    5aea:	5f 93       	push	r21
    5aec:	6f 93       	push	r22
    5aee:	7f 93       	push	r23
    5af0:	8f 93       	push	r24
    5af2:	9f 93       	push	r25
    5af4:	af 93       	push	r26
    5af6:	bf 93       	push	r27
    5af8:	cf 93       	push	r28
    5afa:	df 93       	push	r29
    5afc:	ef 93       	push	r30
    5afe:	ff 93       	push	r31
    5b00:	a0 91 39 06 	lds	r26, 0x0639
    5b04:	b0 91 3a 06 	lds	r27, 0x063A
    5b08:	0d b6       	in	r0, 0x3d	; 61
    5b0a:	0d 92       	st	X+, r0
    5b0c:	0e b6       	in	r0, 0x3e	; 62
    5b0e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    5b10:	0e 94 57 35 	call	0x6aae	; 0x6aae <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    5b14:	a0 91 39 06 	lds	r26, 0x0639
    5b18:	b0 91 3a 06 	lds	r27, 0x063A
    5b1c:	cd 91       	ld	r28, X+
    5b1e:	cd bf       	out	0x3d, r28	; 61
    5b20:	dd 91       	ld	r29, X+
    5b22:	de bf       	out	0x3e, r29	; 62
    5b24:	ff 91       	pop	r31
    5b26:	ef 91       	pop	r30
    5b28:	df 91       	pop	r29
    5b2a:	cf 91       	pop	r28
    5b2c:	bf 91       	pop	r27
    5b2e:	af 91       	pop	r26
    5b30:	9f 91       	pop	r25
    5b32:	8f 91       	pop	r24
    5b34:	7f 91       	pop	r23
    5b36:	6f 91       	pop	r22
    5b38:	5f 91       	pop	r21
    5b3a:	4f 91       	pop	r20
    5b3c:	3f 91       	pop	r19
    5b3e:	2f 91       	pop	r18
    5b40:	1f 91       	pop	r17
    5b42:	0f 91       	pop	r16
    5b44:	ff 90       	pop	r15
    5b46:	ef 90       	pop	r14
    5b48:	df 90       	pop	r13
    5b4a:	cf 90       	pop	r12
    5b4c:	bf 90       	pop	r11
    5b4e:	af 90       	pop	r10
    5b50:	9f 90       	pop	r9
    5b52:	8f 90       	pop	r8
    5b54:	7f 90       	pop	r7
    5b56:	6f 90       	pop	r6
    5b58:	5f 90       	pop	r5
    5b5a:	4f 90       	pop	r4
    5b5c:	3f 90       	pop	r3
    5b5e:	2f 90       	pop	r2
    5b60:	1f 90       	pop	r1
    5b62:	0f 90       	pop	r0
    5b64:	0f be       	out	0x3f, r0	; 63
    5b66:	0f 90       	pop	r0

	asm volatile ( "ret" );
    5b68:	08 95       	ret

00005b6a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    5b6a:	0f 92       	push	r0
    5b6c:	0f b6       	in	r0, 0x3f	; 63
    5b6e:	f8 94       	cli
    5b70:	0f 92       	push	r0
    5b72:	1f 92       	push	r1
    5b74:	11 24       	eor	r1, r1
    5b76:	2f 92       	push	r2
    5b78:	3f 92       	push	r3
    5b7a:	4f 92       	push	r4
    5b7c:	5f 92       	push	r5
    5b7e:	6f 92       	push	r6
    5b80:	7f 92       	push	r7
    5b82:	8f 92       	push	r8
    5b84:	9f 92       	push	r9
    5b86:	af 92       	push	r10
    5b88:	bf 92       	push	r11
    5b8a:	cf 92       	push	r12
    5b8c:	df 92       	push	r13
    5b8e:	ef 92       	push	r14
    5b90:	ff 92       	push	r15
    5b92:	0f 93       	push	r16
    5b94:	1f 93       	push	r17
    5b96:	2f 93       	push	r18
    5b98:	3f 93       	push	r19
    5b9a:	4f 93       	push	r20
    5b9c:	5f 93       	push	r21
    5b9e:	6f 93       	push	r22
    5ba0:	7f 93       	push	r23
    5ba2:	8f 93       	push	r24
    5ba4:	9f 93       	push	r25
    5ba6:	af 93       	push	r26
    5ba8:	bf 93       	push	r27
    5baa:	cf 93       	push	r28
    5bac:	df 93       	push	r29
    5bae:	ef 93       	push	r30
    5bb0:	ff 93       	push	r31
    5bb2:	a0 91 39 06 	lds	r26, 0x0639
    5bb6:	b0 91 3a 06 	lds	r27, 0x063A
    5bba:	0d b6       	in	r0, 0x3d	; 61
    5bbc:	0d 92       	st	X+, r0
    5bbe:	0e b6       	in	r0, 0x3e	; 62
    5bc0:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    5bc2:	0e 94 8b 34 	call	0x6916	; 0x6916 <xTaskIncrementTick>
    5bc6:	88 23       	and	r24, r24
    5bc8:	11 f0       	breq	.+4      	; 0x5bce <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    5bca:	0e 94 57 35 	call	0x6aae	; 0x6aae <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    5bce:	a0 91 39 06 	lds	r26, 0x0639
    5bd2:	b0 91 3a 06 	lds	r27, 0x063A
    5bd6:	cd 91       	ld	r28, X+
    5bd8:	cd bf       	out	0x3d, r28	; 61
    5bda:	dd 91       	ld	r29, X+
    5bdc:	de bf       	out	0x3e, r29	; 62
    5bde:	ff 91       	pop	r31
    5be0:	ef 91       	pop	r30
    5be2:	df 91       	pop	r29
    5be4:	cf 91       	pop	r28
    5be6:	bf 91       	pop	r27
    5be8:	af 91       	pop	r26
    5bea:	9f 91       	pop	r25
    5bec:	8f 91       	pop	r24
    5bee:	7f 91       	pop	r23
    5bf0:	6f 91       	pop	r22
    5bf2:	5f 91       	pop	r21
    5bf4:	4f 91       	pop	r20
    5bf6:	3f 91       	pop	r19
    5bf8:	2f 91       	pop	r18
    5bfa:	1f 91       	pop	r17
    5bfc:	0f 91       	pop	r16
    5bfe:	ff 90       	pop	r15
    5c00:	ef 90       	pop	r14
    5c02:	df 90       	pop	r13
    5c04:	cf 90       	pop	r12
    5c06:	bf 90       	pop	r11
    5c08:	af 90       	pop	r10
    5c0a:	9f 90       	pop	r9
    5c0c:	8f 90       	pop	r8
    5c0e:	7f 90       	pop	r7
    5c10:	6f 90       	pop	r6
    5c12:	5f 90       	pop	r5
    5c14:	4f 90       	pop	r4
    5c16:	3f 90       	pop	r3
    5c18:	2f 90       	pop	r2
    5c1a:	1f 90       	pop	r1
    5c1c:	0f 90       	pop	r0
    5c1e:	0f be       	out	0x3f, r0	; 63
    5c20:	0f 90       	pop	r0

	asm volatile ( "ret" );
    5c22:	08 95       	ret

00005c24 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    5c24:	df 93       	push	r29
    5c26:	cf 93       	push	r28
    5c28:	00 d0       	rcall	.+0      	; 0x5c2a <prvSetupTimerInterrupt+0x6>
    5c2a:	00 d0       	rcall	.+0      	; 0x5c2c <prvSetupTimerInterrupt+0x8>
    5c2c:	00 d0       	rcall	.+0      	; 0x5c2e <prvSetupTimerInterrupt+0xa>
    5c2e:	cd b7       	in	r28, 0x3d	; 61
    5c30:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    5c32:	80 e8       	ldi	r24, 0x80	; 128
    5c34:	9e e3       	ldi	r25, 0x3E	; 62
    5c36:	a0 e0       	ldi	r26, 0x00	; 0
    5c38:	b0 e0       	ldi	r27, 0x00	; 0
    5c3a:	8b 83       	std	Y+3, r24	; 0x03
    5c3c:	9c 83       	std	Y+4, r25	; 0x04
    5c3e:	ad 83       	std	Y+5, r26	; 0x05
    5c40:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    5c42:	8b 81       	ldd	r24, Y+3	; 0x03
    5c44:	9c 81       	ldd	r25, Y+4	; 0x04
    5c46:	ad 81       	ldd	r26, Y+5	; 0x05
    5c48:	be 81       	ldd	r27, Y+6	; 0x06
    5c4a:	68 94       	set
    5c4c:	15 f8       	bld	r1, 5
    5c4e:	b6 95       	lsr	r27
    5c50:	a7 95       	ror	r26
    5c52:	97 95       	ror	r25
    5c54:	87 95       	ror	r24
    5c56:	16 94       	lsr	r1
    5c58:	d1 f7       	brne	.-12     	; 0x5c4e <prvSetupTimerInterrupt+0x2a>
    5c5a:	8b 83       	std	Y+3, r24	; 0x03
    5c5c:	9c 83       	std	Y+4, r25	; 0x04
    5c5e:	ad 83       	std	Y+5, r26	; 0x05
    5c60:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    5c62:	8b 81       	ldd	r24, Y+3	; 0x03
    5c64:	9c 81       	ldd	r25, Y+4	; 0x04
    5c66:	ad 81       	ldd	r26, Y+5	; 0x05
    5c68:	be 81       	ldd	r27, Y+6	; 0x06
    5c6a:	01 97       	sbiw	r24, 0x01	; 1
    5c6c:	a1 09       	sbc	r26, r1
    5c6e:	b1 09       	sbc	r27, r1
    5c70:	8b 83       	std	Y+3, r24	; 0x03
    5c72:	9c 83       	std	Y+4, r25	; 0x04
    5c74:	ad 83       	std	Y+5, r26	; 0x05
    5c76:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    5c78:	8b 81       	ldd	r24, Y+3	; 0x03
    5c7a:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    5c7c:	8b 81       	ldd	r24, Y+3	; 0x03
    5c7e:	9c 81       	ldd	r25, Y+4	; 0x04
    5c80:	ad 81       	ldd	r26, Y+5	; 0x05
    5c82:	be 81       	ldd	r27, Y+6	; 0x06
    5c84:	89 2f       	mov	r24, r25
    5c86:	9a 2f       	mov	r25, r26
    5c88:	ab 2f       	mov	r26, r27
    5c8a:	bb 27       	eor	r27, r27
    5c8c:	8b 83       	std	Y+3, r24	; 0x03
    5c8e:	9c 83       	std	Y+4, r25	; 0x04
    5c90:	ad 83       	std	Y+5, r26	; 0x05
    5c92:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    5c94:	8b 81       	ldd	r24, Y+3	; 0x03
    5c96:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    5c98:	eb e4       	ldi	r30, 0x4B	; 75
    5c9a:	f0 e0       	ldi	r31, 0x00	; 0
    5c9c:	8a 81       	ldd	r24, Y+2	; 0x02
    5c9e:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    5ca0:	ea e4       	ldi	r30, 0x4A	; 74
    5ca2:	f0 e0       	ldi	r31, 0x00	; 0
    5ca4:	89 81       	ldd	r24, Y+1	; 0x01
    5ca6:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    5ca8:	8b e0       	ldi	r24, 0x0B	; 11
    5caa:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    5cac:	ee e4       	ldi	r30, 0x4E	; 78
    5cae:	f0 e0       	ldi	r31, 0x00	; 0
    5cb0:	89 81       	ldd	r24, Y+1	; 0x01
    5cb2:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    5cb4:	e9 e5       	ldi	r30, 0x59	; 89
    5cb6:	f0 e0       	ldi	r31, 0x00	; 0
    5cb8:	80 81       	ld	r24, Z
    5cba:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    5cbc:	89 81       	ldd	r24, Y+1	; 0x01
    5cbe:	80 61       	ori	r24, 0x10	; 16
    5cc0:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    5cc2:	e9 e5       	ldi	r30, 0x59	; 89
    5cc4:	f0 e0       	ldi	r31, 0x00	; 0
    5cc6:	89 81       	ldd	r24, Y+1	; 0x01
    5cc8:	80 83       	st	Z, r24
}
    5cca:	26 96       	adiw	r28, 0x06	; 6
    5ccc:	0f b6       	in	r0, 0x3f	; 63
    5cce:	f8 94       	cli
    5cd0:	de bf       	out	0x3e, r29	; 62
    5cd2:	0f be       	out	0x3f, r0	; 63
    5cd4:	cd bf       	out	0x3d, r28	; 61
    5cd6:	cf 91       	pop	r28
    5cd8:	df 91       	pop	r29
    5cda:	08 95       	ret

00005cdc <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    5cdc:	0e 94 b5 2d 	call	0x5b6a	; 0x5b6a <vPortYieldFromTick>
		asm volatile ( "reti" );
    5ce0:	18 95       	reti

00005ce2 <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    5ce2:	8f 92       	push	r8
    5ce4:	9f 92       	push	r9
    5ce6:	af 92       	push	r10
    5ce8:	bf 92       	push	r11
    5cea:	cf 92       	push	r12
    5cec:	df 92       	push	r13
    5cee:	ef 92       	push	r14
    5cf0:	ff 92       	push	r15
    5cf2:	0f 93       	push	r16
    5cf4:	1f 93       	push	r17
    5cf6:	df 93       	push	r29
    5cf8:	cf 93       	push	r28
    5cfa:	cd b7       	in	r28, 0x3d	; 61
    5cfc:	de b7       	in	r29, 0x3e	; 62
    5cfe:	60 97       	sbiw	r28, 0x10	; 16
    5d00:	0f b6       	in	r0, 0x3f	; 63
    5d02:	f8 94       	cli
    5d04:	de bf       	out	0x3e, r29	; 62
    5d06:	0f be       	out	0x3f, r0	; 63
    5d08:	cd bf       	out	0x3d, r28	; 61
    5d0a:	9f 83       	std	Y+7, r25	; 0x07
    5d0c:	8e 83       	std	Y+6, r24	; 0x06
    5d0e:	79 87       	std	Y+9, r23	; 0x09
    5d10:	68 87       	std	Y+8, r22	; 0x08
    5d12:	5b 87       	std	Y+11, r21	; 0x0b
    5d14:	4a 87       	std	Y+10, r20	; 0x0a
    5d16:	3d 87       	std	Y+13, r19	; 0x0d
    5d18:	2c 87       	std	Y+12, r18	; 0x0c
    5d1a:	0e 87       	std	Y+14, r16	; 0x0e
    5d1c:	f8 8a       	std	Y+16, r15	; 0x10
    5d1e:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5d20:	8a 85       	ldd	r24, Y+10	; 0x0a
    5d22:	9b 85       	ldd	r25, Y+11	; 0x0b
    5d24:	0e 94 cb 28 	call	0x5196	; 0x5196 <pvPortMalloc>
    5d28:	9a 83       	std	Y+2, r25	; 0x02
    5d2a:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    5d2c:	89 81       	ldd	r24, Y+1	; 0x01
    5d2e:	9a 81       	ldd	r25, Y+2	; 0x02
    5d30:	00 97       	sbiw	r24, 0x00	; 0
    5d32:	b1 f0       	breq	.+44     	; 0x5d60 <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    5d34:	88 e2       	ldi	r24, 0x28	; 40
    5d36:	90 e0       	ldi	r25, 0x00	; 0
    5d38:	0e 94 cb 28 	call	0x5196	; 0x5196 <pvPortMalloc>
    5d3c:	9d 83       	std	Y+5, r25	; 0x05
    5d3e:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    5d40:	8c 81       	ldd	r24, Y+4	; 0x04
    5d42:	9d 81       	ldd	r25, Y+5	; 0x05
    5d44:	00 97       	sbiw	r24, 0x00	; 0
    5d46:	39 f0       	breq	.+14     	; 0x5d56 <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    5d48:	ec 81       	ldd	r30, Y+4	; 0x04
    5d4a:	fd 81       	ldd	r31, Y+5	; 0x05
    5d4c:	89 81       	ldd	r24, Y+1	; 0x01
    5d4e:	9a 81       	ldd	r25, Y+2	; 0x02
    5d50:	90 8f       	std	Z+24, r25	; 0x18
    5d52:	87 8b       	std	Z+23, r24	; 0x17
    5d54:	07 c0       	rjmp	.+14     	; 0x5d64 <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    5d56:	89 81       	ldd	r24, Y+1	; 0x01
    5d58:	9a 81       	ldd	r25, Y+2	; 0x02
    5d5a:	0e 94 b3 29 	call	0x5366	; 0x5366 <vPortFree>
    5d5e:	02 c0       	rjmp	.+4      	; 0x5d64 <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    5d60:	1d 82       	std	Y+5, r1	; 0x05
    5d62:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    5d64:	8c 81       	ldd	r24, Y+4	; 0x04
    5d66:	9d 81       	ldd	r25, Y+5	; 0x05
    5d68:	00 97       	sbiw	r24, 0x00	; 0
    5d6a:	e9 f0       	breq	.+58     	; 0x5da6 <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    5d6c:	8a 85       	ldd	r24, Y+10	; 0x0a
    5d6e:	9b 85       	ldd	r25, Y+11	; 0x0b
    5d70:	9c 01       	movw	r18, r24
    5d72:	40 e0       	ldi	r20, 0x00	; 0
    5d74:	50 e0       	ldi	r21, 0x00	; 0
    5d76:	8e 81       	ldd	r24, Y+6	; 0x06
    5d78:	9f 81       	ldd	r25, Y+7	; 0x07
    5d7a:	68 85       	ldd	r22, Y+8	; 0x08
    5d7c:	79 85       	ldd	r23, Y+9	; 0x09
    5d7e:	ec 85       	ldd	r30, Y+12	; 0x0c
    5d80:	fd 85       	ldd	r31, Y+13	; 0x0d
    5d82:	af 85       	ldd	r26, Y+15	; 0x0f
    5d84:	b8 89       	ldd	r27, Y+16	; 0x10
    5d86:	ac 80       	ldd	r10, Y+4	; 0x04
    5d88:	bd 80       	ldd	r11, Y+5	; 0x05
    5d8a:	8f 01       	movw	r16, r30
    5d8c:	ee 84       	ldd	r14, Y+14	; 0x0e
    5d8e:	6d 01       	movw	r12, r26
    5d90:	88 24       	eor	r8, r8
    5d92:	99 24       	eor	r9, r9
    5d94:	0e 94 e9 2e 	call	0x5dd2	; 0x5dd2 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    5d98:	8c 81       	ldd	r24, Y+4	; 0x04
    5d9a:	9d 81       	ldd	r25, Y+5	; 0x05
    5d9c:	0e 94 a4 2f 	call	0x5f48	; 0x5f48 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    5da0:	81 e0       	ldi	r24, 0x01	; 1
    5da2:	8b 83       	std	Y+3, r24	; 0x03
    5da4:	02 c0       	rjmp	.+4      	; 0x5daa <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    5da6:	8f ef       	ldi	r24, 0xFF	; 255
    5da8:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    5daa:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    5dac:	60 96       	adiw	r28, 0x10	; 16
    5dae:	0f b6       	in	r0, 0x3f	; 63
    5db0:	f8 94       	cli
    5db2:	de bf       	out	0x3e, r29	; 62
    5db4:	0f be       	out	0x3f, r0	; 63
    5db6:	cd bf       	out	0x3d, r28	; 61
    5db8:	cf 91       	pop	r28
    5dba:	df 91       	pop	r29
    5dbc:	1f 91       	pop	r17
    5dbe:	0f 91       	pop	r16
    5dc0:	ff 90       	pop	r15
    5dc2:	ef 90       	pop	r14
    5dc4:	df 90       	pop	r13
    5dc6:	cf 90       	pop	r12
    5dc8:	bf 90       	pop	r11
    5dca:	af 90       	pop	r10
    5dcc:	9f 90       	pop	r9
    5dce:	8f 90       	pop	r8
    5dd0:	08 95       	ret

00005dd2 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    5dd2:	8f 92       	push	r8
    5dd4:	9f 92       	push	r9
    5dd6:	af 92       	push	r10
    5dd8:	bf 92       	push	r11
    5dda:	cf 92       	push	r12
    5ddc:	df 92       	push	r13
    5dde:	ef 92       	push	r14
    5de0:	0f 93       	push	r16
    5de2:	1f 93       	push	r17
    5de4:	df 93       	push	r29
    5de6:	cf 93       	push	r28
    5de8:	cd b7       	in	r28, 0x3d	; 61
    5dea:	de b7       	in	r29, 0x3e	; 62
    5dec:	64 97       	sbiw	r28, 0x14	; 20
    5dee:	0f b6       	in	r0, 0x3f	; 63
    5df0:	f8 94       	cli
    5df2:	de bf       	out	0x3e, r29	; 62
    5df4:	0f be       	out	0x3f, r0	; 63
    5df6:	cd bf       	out	0x3d, r28	; 61
    5df8:	9d 83       	std	Y+5, r25	; 0x05
    5dfa:	8c 83       	std	Y+4, r24	; 0x04
    5dfc:	7f 83       	std	Y+7, r23	; 0x07
    5dfe:	6e 83       	std	Y+6, r22	; 0x06
    5e00:	28 87       	std	Y+8, r18	; 0x08
    5e02:	39 87       	std	Y+9, r19	; 0x09
    5e04:	4a 87       	std	Y+10, r20	; 0x0a
    5e06:	5b 87       	std	Y+11, r21	; 0x0b
    5e08:	1d 87       	std	Y+13, r17	; 0x0d
    5e0a:	0c 87       	std	Y+12, r16	; 0x0c
    5e0c:	ee 86       	std	Y+14, r14	; 0x0e
    5e0e:	d8 8a       	std	Y+16, r13	; 0x10
    5e10:	cf 86       	std	Y+15, r12	; 0x0f
    5e12:	ba 8a       	std	Y+18, r11	; 0x12
    5e14:	a9 8a       	std	Y+17, r10	; 0x11
    5e16:	9c 8a       	std	Y+20, r9	; 0x14
    5e18:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    5e1a:	e9 89       	ldd	r30, Y+17	; 0x11
    5e1c:	fa 89       	ldd	r31, Y+18	; 0x12
    5e1e:	27 89       	ldd	r18, Z+23	; 0x17
    5e20:	30 8d       	ldd	r19, Z+24	; 0x18
    5e22:	88 85       	ldd	r24, Y+8	; 0x08
    5e24:	99 85       	ldd	r25, Y+9	; 0x09
    5e26:	01 97       	sbiw	r24, 0x01	; 1
    5e28:	82 0f       	add	r24, r18
    5e2a:	93 1f       	adc	r25, r19
    5e2c:	9b 83       	std	Y+3, r25	; 0x03
    5e2e:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    5e30:	19 82       	std	Y+1, r1	; 0x01
    5e32:	21 c0       	rjmp	.+66     	; 0x5e76 <prvInitialiseNewTask+0xa4>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    5e34:	89 81       	ldd	r24, Y+1	; 0x01
    5e36:	48 2f       	mov	r20, r24
    5e38:	50 e0       	ldi	r21, 0x00	; 0
    5e3a:	89 81       	ldd	r24, Y+1	; 0x01
    5e3c:	28 2f       	mov	r18, r24
    5e3e:	30 e0       	ldi	r19, 0x00	; 0
    5e40:	8e 81       	ldd	r24, Y+6	; 0x06
    5e42:	9f 81       	ldd	r25, Y+7	; 0x07
    5e44:	fc 01       	movw	r30, r24
    5e46:	e2 0f       	add	r30, r18
    5e48:	f3 1f       	adc	r31, r19
    5e4a:	20 81       	ld	r18, Z
    5e4c:	89 89       	ldd	r24, Y+17	; 0x11
    5e4e:	9a 89       	ldd	r25, Y+18	; 0x12
    5e50:	84 0f       	add	r24, r20
    5e52:	95 1f       	adc	r25, r21
    5e54:	fc 01       	movw	r30, r24
    5e56:	79 96       	adiw	r30, 0x19	; 25
    5e58:	20 83       	st	Z, r18

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    5e5a:	89 81       	ldd	r24, Y+1	; 0x01
    5e5c:	28 2f       	mov	r18, r24
    5e5e:	30 e0       	ldi	r19, 0x00	; 0
    5e60:	8e 81       	ldd	r24, Y+6	; 0x06
    5e62:	9f 81       	ldd	r25, Y+7	; 0x07
    5e64:	fc 01       	movw	r30, r24
    5e66:	e2 0f       	add	r30, r18
    5e68:	f3 1f       	adc	r31, r19
    5e6a:	80 81       	ld	r24, Z
    5e6c:	88 23       	and	r24, r24
    5e6e:	31 f0       	breq	.+12     	; 0x5e7c <prvInitialiseNewTask+0xaa>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    5e70:	89 81       	ldd	r24, Y+1	; 0x01
    5e72:	8f 5f       	subi	r24, 0xFF	; 255
    5e74:	89 83       	std	Y+1, r24	; 0x01
    5e76:	89 81       	ldd	r24, Y+1	; 0x01
    5e78:	88 30       	cpi	r24, 0x08	; 8
    5e7a:	e0 f2       	brcs	.-72     	; 0x5e34 <prvInitialiseNewTask+0x62>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    5e7c:	e9 89       	ldd	r30, Y+17	; 0x11
    5e7e:	fa 89       	ldd	r31, Y+18	; 0x12
    5e80:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    5e82:	8e 85       	ldd	r24, Y+14	; 0x0e
    5e84:	89 30       	cpi	r24, 0x09	; 9
    5e86:	10 f0       	brcs	.+4      	; 0x5e8c <prvInitialiseNewTask+0xba>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    5e88:	88 e0       	ldi	r24, 0x08	; 8
    5e8a:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    5e8c:	e9 89       	ldd	r30, Y+17	; 0x11
    5e8e:	fa 89       	ldd	r31, Y+18	; 0x12
    5e90:	8e 85       	ldd	r24, Y+14	; 0x0e
    5e92:	86 8b       	std	Z+22, r24	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    5e94:	e9 89       	ldd	r30, Y+17	; 0x11
    5e96:	fa 89       	ldd	r31, Y+18	; 0x12
    5e98:	8e 85       	ldd	r24, Y+14	; 0x0e
    5e9a:	81 a3       	std	Z+33, r24	; 0x21
		pxNewTCB->uxMutexesHeld = 0;
    5e9c:	e9 89       	ldd	r30, Y+17	; 0x11
    5e9e:	fa 89       	ldd	r31, Y+18	; 0x12
    5ea0:	12 a2       	std	Z+34, r1	; 0x22
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    5ea2:	89 89       	ldd	r24, Y+17	; 0x11
    5ea4:	9a 89       	ldd	r25, Y+18	; 0x12
    5ea6:	02 96       	adiw	r24, 0x02	; 2
    5ea8:	0e 94 91 2a 	call	0x5522	; 0x5522 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    5eac:	89 89       	ldd	r24, Y+17	; 0x11
    5eae:	9a 89       	ldd	r25, Y+18	; 0x12
    5eb0:	0c 96       	adiw	r24, 0x0c	; 12
    5eb2:	0e 94 91 2a 	call	0x5522	; 0x5522 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    5eb6:	e9 89       	ldd	r30, Y+17	; 0x11
    5eb8:	fa 89       	ldd	r31, Y+18	; 0x12
    5eba:	89 89       	ldd	r24, Y+17	; 0x11
    5ebc:	9a 89       	ldd	r25, Y+18	; 0x12
    5ebe:	91 87       	std	Z+9, r25	; 0x09
    5ec0:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5ec2:	8e 85       	ldd	r24, Y+14	; 0x0e
    5ec4:	28 2f       	mov	r18, r24
    5ec6:	30 e0       	ldi	r19, 0x00	; 0
    5ec8:	89 e0       	ldi	r24, 0x09	; 9
    5eca:	90 e0       	ldi	r25, 0x00	; 0
    5ecc:	82 1b       	sub	r24, r18
    5ece:	93 0b       	sbc	r25, r19
    5ed0:	e9 89       	ldd	r30, Y+17	; 0x11
    5ed2:	fa 89       	ldd	r31, Y+18	; 0x12
    5ed4:	95 87       	std	Z+13, r25	; 0x0d
    5ed6:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    5ed8:	e9 89       	ldd	r30, Y+17	; 0x11
    5eda:	fa 89       	ldd	r31, Y+18	; 0x12
    5edc:	89 89       	ldd	r24, Y+17	; 0x11
    5ede:	9a 89       	ldd	r25, Y+18	; 0x12
    5ee0:	93 8b       	std	Z+19, r25	; 0x13
    5ee2:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    5ee4:	e9 89       	ldd	r30, Y+17	; 0x11
    5ee6:	fa 89       	ldd	r31, Y+18	; 0x12
    5ee8:	13 a2       	std	Z+35, r1	; 0x23
    5eea:	14 a2       	std	Z+36, r1	; 0x24
    5eec:	15 a2       	std	Z+37, r1	; 0x25
    5eee:	16 a2       	std	Z+38, r1	; 0x26
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5ef0:	e9 89       	ldd	r30, Y+17	; 0x11
    5ef2:	fa 89       	ldd	r31, Y+18	; 0x12
    5ef4:	17 a2       	std	Z+39, r1	; 0x27
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    5ef6:	8a 81       	ldd	r24, Y+2	; 0x02
    5ef8:	9b 81       	ldd	r25, Y+3	; 0x03
    5efa:	2c 81       	ldd	r18, Y+4	; 0x04
    5efc:	3d 81       	ldd	r19, Y+5	; 0x05
    5efe:	4c 85       	ldd	r20, Y+12	; 0x0c
    5f00:	5d 85       	ldd	r21, Y+13	; 0x0d
    5f02:	b9 01       	movw	r22, r18
    5f04:	0e 94 9d 2b 	call	0x573a	; 0x573a <pxPortInitialiseStack>
    5f08:	e9 89       	ldd	r30, Y+17	; 0x11
    5f0a:	fa 89       	ldd	r31, Y+18	; 0x12
    5f0c:	91 83       	std	Z+1, r25	; 0x01
    5f0e:	80 83       	st	Z, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
    5f10:	8f 85       	ldd	r24, Y+15	; 0x0f
    5f12:	98 89       	ldd	r25, Y+16	; 0x10
    5f14:	00 97       	sbiw	r24, 0x00	; 0
    5f16:	31 f0       	breq	.+12     	; 0x5f24 <prvInitialiseNewTask+0x152>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    5f18:	ef 85       	ldd	r30, Y+15	; 0x0f
    5f1a:	f8 89       	ldd	r31, Y+16	; 0x10
    5f1c:	89 89       	ldd	r24, Y+17	; 0x11
    5f1e:	9a 89       	ldd	r25, Y+18	; 0x12
    5f20:	91 83       	std	Z+1, r25	; 0x01
    5f22:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    5f24:	64 96       	adiw	r28, 0x14	; 20
    5f26:	0f b6       	in	r0, 0x3f	; 63
    5f28:	f8 94       	cli
    5f2a:	de bf       	out	0x3e, r29	; 62
    5f2c:	0f be       	out	0x3f, r0	; 63
    5f2e:	cd bf       	out	0x3d, r28	; 61
    5f30:	cf 91       	pop	r28
    5f32:	df 91       	pop	r29
    5f34:	1f 91       	pop	r17
    5f36:	0f 91       	pop	r16
    5f38:	ef 90       	pop	r14
    5f3a:	df 90       	pop	r13
    5f3c:	cf 90       	pop	r12
    5f3e:	bf 90       	pop	r11
    5f40:	af 90       	pop	r10
    5f42:	9f 90       	pop	r9
    5f44:	8f 90       	pop	r8
    5f46:	08 95       	ret

00005f48 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    5f48:	df 93       	push	r29
    5f4a:	cf 93       	push	r28
    5f4c:	00 d0       	rcall	.+0      	; 0x5f4e <prvAddNewTaskToReadyList+0x6>
    5f4e:	cd b7       	in	r28, 0x3d	; 61
    5f50:	de b7       	in	r29, 0x3e	; 62
    5f52:	9a 83       	std	Y+2, r25	; 0x02
    5f54:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    5f56:	0f b6       	in	r0, 0x3f	; 63
    5f58:	f8 94       	cli
    5f5a:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    5f5c:	80 91 3c 06 	lds	r24, 0x063C
    5f60:	8f 5f       	subi	r24, 0xFF	; 255
    5f62:	80 93 3c 06 	sts	0x063C, r24
		if( pxCurrentTCB == NULL )
    5f66:	80 91 39 06 	lds	r24, 0x0639
    5f6a:	90 91 3a 06 	lds	r25, 0x063A
    5f6e:	00 97       	sbiw	r24, 0x00	; 0
    5f70:	69 f4       	brne	.+26     	; 0x5f8c <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    5f72:	89 81       	ldd	r24, Y+1	; 0x01
    5f74:	9a 81       	ldd	r25, Y+2	; 0x02
    5f76:	90 93 3a 06 	sts	0x063A, r25
    5f7a:	80 93 39 06 	sts	0x0639, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    5f7e:	80 91 3c 06 	lds	r24, 0x063C
    5f82:	81 30       	cpi	r24, 0x01	; 1
    5f84:	b9 f4       	brne	.+46     	; 0x5fb4 <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    5f86:	0e 94 80 37 	call	0x6f00	; 0x6f00 <prvInitialiseTaskLists>
    5f8a:	14 c0       	rjmp	.+40     	; 0x5fb4 <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    5f8c:	80 91 40 06 	lds	r24, 0x0640
    5f90:	88 23       	and	r24, r24
    5f92:	81 f4       	brne	.+32     	; 0x5fb4 <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    5f94:	e0 91 39 06 	lds	r30, 0x0639
    5f98:	f0 91 3a 06 	lds	r31, 0x063A
    5f9c:	96 89       	ldd	r25, Z+22	; 0x16
    5f9e:	e9 81       	ldd	r30, Y+1	; 0x01
    5fa0:	fa 81       	ldd	r31, Y+2	; 0x02
    5fa2:	86 89       	ldd	r24, Z+22	; 0x16
    5fa4:	89 17       	cp	r24, r25
    5fa6:	30 f0       	brcs	.+12     	; 0x5fb4 <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    5fa8:	89 81       	ldd	r24, Y+1	; 0x01
    5faa:	9a 81       	ldd	r25, Y+2	; 0x02
    5fac:	90 93 3a 06 	sts	0x063A, r25
    5fb0:	80 93 39 06 	sts	0x0639, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    5fb4:	80 91 44 06 	lds	r24, 0x0644
    5fb8:	8f 5f       	subi	r24, 0xFF	; 255
    5fba:	80 93 44 06 	sts	0x0644, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    5fbe:	e9 81       	ldd	r30, Y+1	; 0x01
    5fc0:	fa 81       	ldd	r31, Y+2	; 0x02
    5fc2:	96 89       	ldd	r25, Z+22	; 0x16
    5fc4:	80 91 3f 06 	lds	r24, 0x063F
    5fc8:	89 17       	cp	r24, r25
    5fca:	28 f4       	brcc	.+10     	; 0x5fd6 <prvAddNewTaskToReadyList+0x8e>
    5fcc:	e9 81       	ldd	r30, Y+1	; 0x01
    5fce:	fa 81       	ldd	r31, Y+2	; 0x02
    5fd0:	86 89       	ldd	r24, Z+22	; 0x16
    5fd2:	80 93 3f 06 	sts	0x063F, r24
    5fd6:	e9 81       	ldd	r30, Y+1	; 0x01
    5fd8:	fa 81       	ldd	r31, Y+2	; 0x02
    5fda:	86 89       	ldd	r24, Z+22	; 0x16
    5fdc:	28 2f       	mov	r18, r24
    5fde:	30 e0       	ldi	r19, 0x00	; 0
    5fe0:	c9 01       	movw	r24, r18
    5fe2:	88 0f       	add	r24, r24
    5fe4:	99 1f       	adc	r25, r25
    5fe6:	88 0f       	add	r24, r24
    5fe8:	99 1f       	adc	r25, r25
    5fea:	88 0f       	add	r24, r24
    5fec:	99 1f       	adc	r25, r25
    5fee:	82 0f       	add	r24, r18
    5ff0:	93 1f       	adc	r25, r19
    5ff2:	ac 01       	movw	r20, r24
    5ff4:	46 5b       	subi	r20, 0xB6	; 182
    5ff6:	59 4f       	sbci	r21, 0xF9	; 249
    5ff8:	89 81       	ldd	r24, Y+1	; 0x01
    5ffa:	9a 81       	ldd	r25, Y+2	; 0x02
    5ffc:	9c 01       	movw	r18, r24
    5ffe:	2e 5f       	subi	r18, 0xFE	; 254
    6000:	3f 4f       	sbci	r19, 0xFF	; 255
    6002:	ca 01       	movw	r24, r20
    6004:	b9 01       	movw	r22, r18
    6006:	0e 94 a1 2a 	call	0x5542	; 0x5542 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    600a:	0f 90       	pop	r0
    600c:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    600e:	80 91 40 06 	lds	r24, 0x0640
    6012:	88 23       	and	r24, r24
    6014:	61 f0       	breq	.+24     	; 0x602e <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    6016:	e0 91 39 06 	lds	r30, 0x0639
    601a:	f0 91 3a 06 	lds	r31, 0x063A
    601e:	96 89       	ldd	r25, Z+22	; 0x16
    6020:	e9 81       	ldd	r30, Y+1	; 0x01
    6022:	fa 81       	ldd	r31, Y+2	; 0x02
    6024:	86 89       	ldd	r24, Z+22	; 0x16
    6026:	98 17       	cp	r25, r24
    6028:	10 f4       	brcc	.+4      	; 0x602e <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    602a:	0e 94 5c 2d 	call	0x5ab8	; 0x5ab8 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    602e:	0f 90       	pop	r0
    6030:	0f 90       	pop	r0
    6032:	cf 91       	pop	r28
    6034:	df 91       	pop	r29
    6036:	08 95       	ret

00006038 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    6038:	df 93       	push	r29
    603a:	cf 93       	push	r28
    603c:	00 d0       	rcall	.+0      	; 0x603e <vTaskDelete+0x6>
    603e:	00 d0       	rcall	.+0      	; 0x6040 <vTaskDelete+0x8>
    6040:	00 d0       	rcall	.+0      	; 0x6042 <vTaskDelete+0xa>
    6042:	cd b7       	in	r28, 0x3d	; 61
    6044:	de b7       	in	r29, 0x3e	; 62
    6046:	9c 83       	std	Y+4, r25	; 0x04
    6048:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    604a:	0f b6       	in	r0, 0x3f	; 63
    604c:	f8 94       	cli
    604e:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    6050:	8b 81       	ldd	r24, Y+3	; 0x03
    6052:	9c 81       	ldd	r25, Y+4	; 0x04
    6054:	00 97       	sbiw	r24, 0x00	; 0
    6056:	39 f4       	brne	.+14     	; 0x6066 <vTaskDelete+0x2e>
    6058:	80 91 39 06 	lds	r24, 0x0639
    605c:	90 91 3a 06 	lds	r25, 0x063A
    6060:	9e 83       	std	Y+6, r25	; 0x06
    6062:	8d 83       	std	Y+5, r24	; 0x05
    6064:	04 c0       	rjmp	.+8      	; 0x606e <vTaskDelete+0x36>
    6066:	8b 81       	ldd	r24, Y+3	; 0x03
    6068:	9c 81       	ldd	r25, Y+4	; 0x04
    606a:	9e 83       	std	Y+6, r25	; 0x06
    606c:	8d 83       	std	Y+5, r24	; 0x05
    606e:	8d 81       	ldd	r24, Y+5	; 0x05
    6070:	9e 81       	ldd	r25, Y+6	; 0x06
    6072:	9a 83       	std	Y+2, r25	; 0x02
    6074:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    6076:	89 81       	ldd	r24, Y+1	; 0x01
    6078:	9a 81       	ldd	r25, Y+2	; 0x02
    607a:	02 96       	adiw	r24, 0x02	; 2
    607c:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    6080:	e9 81       	ldd	r30, Y+1	; 0x01
    6082:	fa 81       	ldd	r31, Y+2	; 0x02
    6084:	84 89       	ldd	r24, Z+20	; 0x14
    6086:	95 89       	ldd	r25, Z+21	; 0x15
    6088:	00 97       	sbiw	r24, 0x00	; 0
    608a:	29 f0       	breq	.+10     	; 0x6096 <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    608c:	89 81       	ldd	r24, Y+1	; 0x01
    608e:	9a 81       	ldd	r25, Y+2	; 0x02
    6090:	0c 96       	adiw	r24, 0x0c	; 12
    6092:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    6096:	80 91 44 06 	lds	r24, 0x0644
    609a:	8f 5f       	subi	r24, 0xFF	; 255
    609c:	80 93 44 06 	sts	0x0644, r24

			if( pxTCB == pxCurrentTCB )
    60a0:	20 91 39 06 	lds	r18, 0x0639
    60a4:	30 91 3a 06 	lds	r19, 0x063A
    60a8:	89 81       	ldd	r24, Y+1	; 0x01
    60aa:	9a 81       	ldd	r25, Y+2	; 0x02
    60ac:	82 17       	cp	r24, r18
    60ae:	93 07       	cpc	r25, r19
    60b0:	81 f4       	brne	.+32     	; 0x60d2 <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    60b2:	89 81       	ldd	r24, Y+1	; 0x01
    60b4:	9a 81       	ldd	r25, Y+2	; 0x02
    60b6:	9c 01       	movw	r18, r24
    60b8:	2e 5f       	subi	r18, 0xFE	; 254
    60ba:	3f 4f       	sbci	r19, 0xFF	; 255
    60bc:	8a eb       	ldi	r24, 0xBA	; 186
    60be:	96 e0       	ldi	r25, 0x06	; 6
    60c0:	b9 01       	movw	r22, r18
    60c2:	0e 94 a1 2a 	call	0x5542	; 0x5542 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    60c6:	80 91 3b 06 	lds	r24, 0x063B
    60ca:	8f 5f       	subi	r24, 0xFF	; 255
    60cc:	80 93 3b 06 	sts	0x063B, r24
    60d0:	0b c0       	rjmp	.+22     	; 0x60e8 <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    60d2:	80 91 3c 06 	lds	r24, 0x063C
    60d6:	81 50       	subi	r24, 0x01	; 1
    60d8:	80 93 3c 06 	sts	0x063C, r24
				prvDeleteTCB( pxTCB );
    60dc:	89 81       	ldd	r24, Y+1	; 0x01
    60de:	9a 81       	ldd	r25, Y+2	; 0x02
    60e0:	0e 94 00 38 	call	0x7000	; 0x7000 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    60e4:	0e 94 16 38 	call	0x702c	; 0x702c <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    60e8:	0f 90       	pop	r0
    60ea:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    60ec:	80 91 40 06 	lds	r24, 0x0640
    60f0:	88 23       	and	r24, r24
    60f2:	59 f0       	breq	.+22     	; 0x610a <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    60f4:	20 91 39 06 	lds	r18, 0x0639
    60f8:	30 91 3a 06 	lds	r19, 0x063A
    60fc:	89 81       	ldd	r24, Y+1	; 0x01
    60fe:	9a 81       	ldd	r25, Y+2	; 0x02
    6100:	82 17       	cp	r24, r18
    6102:	93 07       	cpc	r25, r19
    6104:	11 f4       	brne	.+4      	; 0x610a <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    6106:	0e 94 5c 2d 	call	0x5ab8	; 0x5ab8 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    610a:	26 96       	adiw	r28, 0x06	; 6
    610c:	0f b6       	in	r0, 0x3f	; 63
    610e:	f8 94       	cli
    6110:	de bf       	out	0x3e, r29	; 62
    6112:	0f be       	out	0x3f, r0	; 63
    6114:	cd bf       	out	0x3d, r28	; 61
    6116:	cf 91       	pop	r28
    6118:	df 91       	pop	r29
    611a:	08 95       	ret

0000611c <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    611c:	df 93       	push	r29
    611e:	cf 93       	push	r28
    6120:	cd b7       	in	r28, 0x3d	; 61
    6122:	de b7       	in	r29, 0x3e	; 62
    6124:	2a 97       	sbiw	r28, 0x0a	; 10
    6126:	0f b6       	in	r0, 0x3f	; 63
    6128:	f8 94       	cli
    612a:	de bf       	out	0x3e, r29	; 62
    612c:	0f be       	out	0x3f, r0	; 63
    612e:	cd bf       	out	0x3d, r28	; 61
    6130:	98 87       	std	Y+8, r25	; 0x08
    6132:	8f 83       	std	Y+7, r24	; 0x07
    6134:	7a 87       	std	Y+10, r23	; 0x0a
    6136:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    6138:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    613a:	0e 94 8f 33 	call	0x671e	; 0x671e <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    613e:	80 91 3d 06 	lds	r24, 0x063D
    6142:	90 91 3e 06 	lds	r25, 0x063E
    6146:	9a 83       	std	Y+2, r25	; 0x02
    6148:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    614a:	ef 81       	ldd	r30, Y+7	; 0x07
    614c:	f8 85       	ldd	r31, Y+8	; 0x08
    614e:	20 81       	ld	r18, Z
    6150:	31 81       	ldd	r19, Z+1	; 0x01
    6152:	89 85       	ldd	r24, Y+9	; 0x09
    6154:	9a 85       	ldd	r25, Y+10	; 0x0a
    6156:	82 0f       	add	r24, r18
    6158:	93 1f       	adc	r25, r19
    615a:	9e 83       	std	Y+6, r25	; 0x06
    615c:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    615e:	ef 81       	ldd	r30, Y+7	; 0x07
    6160:	f8 85       	ldd	r31, Y+8	; 0x08
    6162:	20 81       	ld	r18, Z
    6164:	31 81       	ldd	r19, Z+1	; 0x01
    6166:	89 81       	ldd	r24, Y+1	; 0x01
    6168:	9a 81       	ldd	r25, Y+2	; 0x02
    616a:	82 17       	cp	r24, r18
    616c:	93 07       	cpc	r25, r19
    616e:	98 f4       	brcc	.+38     	; 0x6196 <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    6170:	ef 81       	ldd	r30, Y+7	; 0x07
    6172:	f8 85       	ldd	r31, Y+8	; 0x08
    6174:	20 81       	ld	r18, Z
    6176:	31 81       	ldd	r19, Z+1	; 0x01
    6178:	8d 81       	ldd	r24, Y+5	; 0x05
    617a:	9e 81       	ldd	r25, Y+6	; 0x06
    617c:	82 17       	cp	r24, r18
    617e:	93 07       	cpc	r25, r19
    6180:	e0 f4       	brcc	.+56     	; 0x61ba <vTaskDelayUntil+0x9e>
    6182:	2d 81       	ldd	r18, Y+5	; 0x05
    6184:	3e 81       	ldd	r19, Y+6	; 0x06
    6186:	89 81       	ldd	r24, Y+1	; 0x01
    6188:	9a 81       	ldd	r25, Y+2	; 0x02
    618a:	82 17       	cp	r24, r18
    618c:	93 07       	cpc	r25, r19
    618e:	a8 f4       	brcc	.+42     	; 0x61ba <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    6190:	81 e0       	ldi	r24, 0x01	; 1
    6192:	8b 83       	std	Y+3, r24	; 0x03
    6194:	12 c0       	rjmp	.+36     	; 0x61ba <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    6196:	ef 81       	ldd	r30, Y+7	; 0x07
    6198:	f8 85       	ldd	r31, Y+8	; 0x08
    619a:	20 81       	ld	r18, Z
    619c:	31 81       	ldd	r19, Z+1	; 0x01
    619e:	8d 81       	ldd	r24, Y+5	; 0x05
    61a0:	9e 81       	ldd	r25, Y+6	; 0x06
    61a2:	82 17       	cp	r24, r18
    61a4:	93 07       	cpc	r25, r19
    61a6:	38 f0       	brcs	.+14     	; 0x61b6 <vTaskDelayUntil+0x9a>
    61a8:	2d 81       	ldd	r18, Y+5	; 0x05
    61aa:	3e 81       	ldd	r19, Y+6	; 0x06
    61ac:	89 81       	ldd	r24, Y+1	; 0x01
    61ae:	9a 81       	ldd	r25, Y+2	; 0x02
    61b0:	82 17       	cp	r24, r18
    61b2:	93 07       	cpc	r25, r19
    61b4:	10 f4       	brcc	.+4      	; 0x61ba <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    61b6:	81 e0       	ldi	r24, 0x01	; 1
    61b8:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    61ba:	ef 81       	ldd	r30, Y+7	; 0x07
    61bc:	f8 85       	ldd	r31, Y+8	; 0x08
    61be:	8d 81       	ldd	r24, Y+5	; 0x05
    61c0:	9e 81       	ldd	r25, Y+6	; 0x06
    61c2:	91 83       	std	Z+1, r25	; 0x01
    61c4:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    61c6:	8b 81       	ldd	r24, Y+3	; 0x03
    61c8:	88 23       	and	r24, r24
    61ca:	49 f0       	breq	.+18     	; 0x61de <vTaskDelayUntil+0xc2>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    61cc:	8d 81       	ldd	r24, Y+5	; 0x05
    61ce:	9e 81       	ldd	r25, Y+6	; 0x06
    61d0:	29 81       	ldd	r18, Y+1	; 0x01
    61d2:	3a 81       	ldd	r19, Y+2	; 0x02
    61d4:	82 1b       	sub	r24, r18
    61d6:	93 0b       	sbc	r25, r19
    61d8:	60 e0       	ldi	r22, 0x00	; 0
    61da:	0e 94 39 3d 	call	0x7a72	; 0x7a72 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    61de:	0e 94 9b 33 	call	0x6736	; 0x6736 <xTaskResumeAll>
    61e2:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    61e4:	8c 81       	ldd	r24, Y+4	; 0x04
    61e6:	88 23       	and	r24, r24
    61e8:	11 f4       	brne	.+4      	; 0x61ee <vTaskDelayUntil+0xd2>
		{
			portYIELD_WITHIN_API();
    61ea:	0e 94 5c 2d 	call	0x5ab8	; 0x5ab8 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    61ee:	2a 96       	adiw	r28, 0x0a	; 10
    61f0:	0f b6       	in	r0, 0x3f	; 63
    61f2:	f8 94       	cli
    61f4:	de bf       	out	0x3e, r29	; 62
    61f6:	0f be       	out	0x3f, r0	; 63
    61f8:	cd bf       	out	0x3d, r28	; 61
    61fa:	cf 91       	pop	r28
    61fc:	df 91       	pop	r29
    61fe:	08 95       	ret

00006200 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    6200:	df 93       	push	r29
    6202:	cf 93       	push	r28
    6204:	00 d0       	rcall	.+0      	; 0x6206 <vTaskDelay+0x6>
    6206:	0f 92       	push	r0
    6208:	cd b7       	in	r28, 0x3d	; 61
    620a:	de b7       	in	r29, 0x3e	; 62
    620c:	9b 83       	std	Y+3, r25	; 0x03
    620e:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    6210:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    6212:	8a 81       	ldd	r24, Y+2	; 0x02
    6214:	9b 81       	ldd	r25, Y+3	; 0x03
    6216:	00 97       	sbiw	r24, 0x00	; 0
    6218:	51 f0       	breq	.+20     	; 0x622e <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    621a:	0e 94 8f 33 	call	0x671e	; 0x671e <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    621e:	8a 81       	ldd	r24, Y+2	; 0x02
    6220:	9b 81       	ldd	r25, Y+3	; 0x03
    6222:	60 e0       	ldi	r22, 0x00	; 0
    6224:	0e 94 39 3d 	call	0x7a72	; 0x7a72 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    6228:	0e 94 9b 33 	call	0x6736	; 0x6736 <xTaskResumeAll>
    622c:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    622e:	89 81       	ldd	r24, Y+1	; 0x01
    6230:	88 23       	and	r24, r24
    6232:	11 f4       	brne	.+4      	; 0x6238 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    6234:	0e 94 5c 2d 	call	0x5ab8	; 0x5ab8 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    6238:	0f 90       	pop	r0
    623a:	0f 90       	pop	r0
    623c:	0f 90       	pop	r0
    623e:	cf 91       	pop	r28
    6240:	df 91       	pop	r29
    6242:	08 95       	ret

00006244 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    6244:	df 93       	push	r29
    6246:	cf 93       	push	r28
    6248:	cd b7       	in	r28, 0x3d	; 61
    624a:	de b7       	in	r29, 0x3e	; 62
    624c:	2a 97       	sbiw	r28, 0x0a	; 10
    624e:	0f b6       	in	r0, 0x3f	; 63
    6250:	f8 94       	cli
    6252:	de bf       	out	0x3e, r29	; 62
    6254:	0f be       	out	0x3f, r0	; 63
    6256:	cd bf       	out	0x3d, r28	; 61
    6258:	9f 83       	std	Y+7, r25	; 0x07
    625a:	8e 83       	std	Y+6, r24	; 0x06
    625c:	68 87       	std	Y+8, r22	; 0x08
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    625e:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    6260:	88 85       	ldd	r24, Y+8	; 0x08
    6262:	89 30       	cpi	r24, 0x09	; 9
    6264:	10 f0       	brcs	.+4      	; 0x626a <vTaskPrioritySet+0x26>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    6266:	88 e0       	ldi	r24, 0x08	; 8
    6268:	88 87       	std	Y+8, r24	; 0x08
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    626a:	0f b6       	in	r0, 0x3f	; 63
    626c:	f8 94       	cli
    626e:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    6270:	8e 81       	ldd	r24, Y+6	; 0x06
    6272:	9f 81       	ldd	r25, Y+7	; 0x07
    6274:	00 97       	sbiw	r24, 0x00	; 0
    6276:	39 f4       	brne	.+14     	; 0x6286 <vTaskPrioritySet+0x42>
    6278:	80 91 39 06 	lds	r24, 0x0639
    627c:	90 91 3a 06 	lds	r25, 0x063A
    6280:	9a 87       	std	Y+10, r25	; 0x0a
    6282:	89 87       	std	Y+9, r24	; 0x09
    6284:	04 c0       	rjmp	.+8      	; 0x628e <vTaskPrioritySet+0x4a>
    6286:	8e 81       	ldd	r24, Y+6	; 0x06
    6288:	9f 81       	ldd	r25, Y+7	; 0x07
    628a:	9a 87       	std	Y+10, r25	; 0x0a
    628c:	89 87       	std	Y+9, r24	; 0x09
    628e:	89 85       	ldd	r24, Y+9	; 0x09
    6290:	9a 85       	ldd	r25, Y+10	; 0x0a
    6292:	9d 83       	std	Y+5, r25	; 0x05
    6294:	8c 83       	std	Y+4, r24	; 0x04

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
    6296:	ec 81       	ldd	r30, Y+4	; 0x04
    6298:	fd 81       	ldd	r31, Y+5	; 0x05
    629a:	81 a1       	ldd	r24, Z+33	; 0x21
    629c:	8b 83       	std	Y+3, r24	; 0x03
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    629e:	9b 81       	ldd	r25, Y+3	; 0x03
    62a0:	88 85       	ldd	r24, Y+8	; 0x08
    62a2:	98 17       	cp	r25, r24
    62a4:	09 f4       	brne	.+2      	; 0x62a8 <vTaskPrioritySet+0x64>
    62a6:	8d c0       	rjmp	.+282    	; 0x63c2 <vTaskPrioritySet+0x17e>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    62a8:	98 85       	ldd	r25, Y+8	; 0x08
    62aa:	8b 81       	ldd	r24, Y+3	; 0x03
    62ac:	89 17       	cp	r24, r25
    62ae:	a0 f4       	brcc	.+40     	; 0x62d8 <vTaskPrioritySet+0x94>
				{
					if( pxTCB != pxCurrentTCB )
    62b0:	20 91 39 06 	lds	r18, 0x0639
    62b4:	30 91 3a 06 	lds	r19, 0x063A
    62b8:	8c 81       	ldd	r24, Y+4	; 0x04
    62ba:	9d 81       	ldd	r25, Y+5	; 0x05
    62bc:	82 17       	cp	r24, r18
    62be:	93 07       	cpc	r25, r19
    62c0:	b1 f0       	breq	.+44     	; 0x62ee <vTaskPrioritySet+0xaa>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    62c2:	e0 91 39 06 	lds	r30, 0x0639
    62c6:	f0 91 3a 06 	lds	r31, 0x063A
    62ca:	96 89       	ldd	r25, Z+22	; 0x16
    62cc:	88 85       	ldd	r24, Y+8	; 0x08
    62ce:	89 17       	cp	r24, r25
    62d0:	70 f0       	brcs	.+28     	; 0x62ee <vTaskPrioritySet+0xaa>
						{
							xYieldRequired = pdTRUE;
    62d2:	81 e0       	ldi	r24, 0x01	; 1
    62d4:	89 83       	std	Y+1, r24	; 0x01
    62d6:	0b c0       	rjmp	.+22     	; 0x62ee <vTaskPrioritySet+0xaa>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    62d8:	20 91 39 06 	lds	r18, 0x0639
    62dc:	30 91 3a 06 	lds	r19, 0x063A
    62e0:	8c 81       	ldd	r24, Y+4	; 0x04
    62e2:	9d 81       	ldd	r25, Y+5	; 0x05
    62e4:	82 17       	cp	r24, r18
    62e6:	93 07       	cpc	r25, r19
    62e8:	11 f4       	brne	.+4      	; 0x62ee <vTaskPrioritySet+0xaa>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
    62ea:	81 e0       	ldi	r24, 0x01	; 1
    62ec:	89 83       	std	Y+1, r24	; 0x01
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    62ee:	ec 81       	ldd	r30, Y+4	; 0x04
    62f0:	fd 81       	ldd	r31, Y+5	; 0x05
    62f2:	86 89       	ldd	r24, Z+22	; 0x16
    62f4:	8a 83       	std	Y+2, r24	; 0x02

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    62f6:	ec 81       	ldd	r30, Y+4	; 0x04
    62f8:	fd 81       	ldd	r31, Y+5	; 0x05
    62fa:	91 a1       	ldd	r25, Z+33	; 0x21
    62fc:	ec 81       	ldd	r30, Y+4	; 0x04
    62fe:	fd 81       	ldd	r31, Y+5	; 0x05
    6300:	86 89       	ldd	r24, Z+22	; 0x16
    6302:	98 17       	cp	r25, r24
    6304:	21 f4       	brne	.+8      	; 0x630e <vTaskPrioritySet+0xca>
					{
						pxTCB->uxPriority = uxNewPriority;
    6306:	ec 81       	ldd	r30, Y+4	; 0x04
    6308:	fd 81       	ldd	r31, Y+5	; 0x05
    630a:	88 85       	ldd	r24, Y+8	; 0x08
    630c:	86 8b       	std	Z+22, r24	; 0x16
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
    630e:	ec 81       	ldd	r30, Y+4	; 0x04
    6310:	fd 81       	ldd	r31, Y+5	; 0x05
    6312:	88 85       	ldd	r24, Y+8	; 0x08
    6314:	81 a3       	std	Z+33, r24	; 0x21
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    6316:	ec 81       	ldd	r30, Y+4	; 0x04
    6318:	fd 81       	ldd	r31, Y+5	; 0x05
    631a:	84 85       	ldd	r24, Z+12	; 0x0c
    631c:	95 85       	ldd	r25, Z+13	; 0x0d
    631e:	99 23       	and	r25, r25
    6320:	5c f0       	brlt	.+22     	; 0x6338 <vTaskPrioritySet+0xf4>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    6322:	88 85       	ldd	r24, Y+8	; 0x08
    6324:	28 2f       	mov	r18, r24
    6326:	30 e0       	ldi	r19, 0x00	; 0
    6328:	89 e0       	ldi	r24, 0x09	; 9
    632a:	90 e0       	ldi	r25, 0x00	; 0
    632c:	82 1b       	sub	r24, r18
    632e:	93 0b       	sbc	r25, r19
    6330:	ec 81       	ldd	r30, Y+4	; 0x04
    6332:	fd 81       	ldd	r31, Y+5	; 0x05
    6334:	95 87       	std	Z+13, r25	; 0x0d
    6336:	84 87       	std	Z+12, r24	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    6338:	ec 81       	ldd	r30, Y+4	; 0x04
    633a:	fd 81       	ldd	r31, Y+5	; 0x05
    633c:	42 85       	ldd	r20, Z+10	; 0x0a
    633e:	53 85       	ldd	r21, Z+11	; 0x0b
    6340:	8a 81       	ldd	r24, Y+2	; 0x02
    6342:	28 2f       	mov	r18, r24
    6344:	30 e0       	ldi	r19, 0x00	; 0
    6346:	c9 01       	movw	r24, r18
    6348:	88 0f       	add	r24, r24
    634a:	99 1f       	adc	r25, r25
    634c:	88 0f       	add	r24, r24
    634e:	99 1f       	adc	r25, r25
    6350:	88 0f       	add	r24, r24
    6352:	99 1f       	adc	r25, r25
    6354:	82 0f       	add	r24, r18
    6356:	93 1f       	adc	r25, r19
    6358:	86 5b       	subi	r24, 0xB6	; 182
    635a:	99 4f       	sbci	r25, 0xF9	; 249
    635c:	48 17       	cp	r20, r24
    635e:	59 07       	cpc	r21, r25
    6360:	59 f5       	brne	.+86     	; 0x63b8 <vTaskPrioritySet+0x174>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    6362:	8c 81       	ldd	r24, Y+4	; 0x04
    6364:	9d 81       	ldd	r25, Y+5	; 0x05
    6366:	02 96       	adiw	r24, 0x02	; 2
    6368:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    636c:	ec 81       	ldd	r30, Y+4	; 0x04
    636e:	fd 81       	ldd	r31, Y+5	; 0x05
    6370:	96 89       	ldd	r25, Z+22	; 0x16
    6372:	80 91 3f 06 	lds	r24, 0x063F
    6376:	89 17       	cp	r24, r25
    6378:	28 f4       	brcc	.+10     	; 0x6384 <vTaskPrioritySet+0x140>
    637a:	ec 81       	ldd	r30, Y+4	; 0x04
    637c:	fd 81       	ldd	r31, Y+5	; 0x05
    637e:	86 89       	ldd	r24, Z+22	; 0x16
    6380:	80 93 3f 06 	sts	0x063F, r24
    6384:	ec 81       	ldd	r30, Y+4	; 0x04
    6386:	fd 81       	ldd	r31, Y+5	; 0x05
    6388:	86 89       	ldd	r24, Z+22	; 0x16
    638a:	28 2f       	mov	r18, r24
    638c:	30 e0       	ldi	r19, 0x00	; 0
    638e:	c9 01       	movw	r24, r18
    6390:	88 0f       	add	r24, r24
    6392:	99 1f       	adc	r25, r25
    6394:	88 0f       	add	r24, r24
    6396:	99 1f       	adc	r25, r25
    6398:	88 0f       	add	r24, r24
    639a:	99 1f       	adc	r25, r25
    639c:	82 0f       	add	r24, r18
    639e:	93 1f       	adc	r25, r19
    63a0:	ac 01       	movw	r20, r24
    63a2:	46 5b       	subi	r20, 0xB6	; 182
    63a4:	59 4f       	sbci	r21, 0xF9	; 249
    63a6:	8c 81       	ldd	r24, Y+4	; 0x04
    63a8:	9d 81       	ldd	r25, Y+5	; 0x05
    63aa:	9c 01       	movw	r18, r24
    63ac:	2e 5f       	subi	r18, 0xFE	; 254
    63ae:	3f 4f       	sbci	r19, 0xFF	; 255
    63b0:	ca 01       	movw	r24, r20
    63b2:	b9 01       	movw	r22, r18
    63b4:	0e 94 a1 2a 	call	0x5542	; 0x5542 <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
    63b8:	89 81       	ldd	r24, Y+1	; 0x01
    63ba:	88 23       	and	r24, r24
    63bc:	11 f0       	breq	.+4      	; 0x63c2 <vTaskPrioritySet+0x17e>
				{
					taskYIELD_IF_USING_PREEMPTION();
    63be:	0e 94 5c 2d 	call	0x5ab8	; 0x5ab8 <vPortYield>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    63c2:	0f 90       	pop	r0
    63c4:	0f be       	out	0x3f, r0	; 63
	}
    63c6:	2a 96       	adiw	r28, 0x0a	; 10
    63c8:	0f b6       	in	r0, 0x3f	; 63
    63ca:	f8 94       	cli
    63cc:	de bf       	out	0x3e, r29	; 62
    63ce:	0f be       	out	0x3f, r0	; 63
    63d0:	cd bf       	out	0x3d, r28	; 61
    63d2:	cf 91       	pop	r28
    63d4:	df 91       	pop	r29
    63d6:	08 95       	ret

000063d8 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    63d8:	df 93       	push	r29
    63da:	cf 93       	push	r28
    63dc:	00 d0       	rcall	.+0      	; 0x63de <vTaskSuspend+0x6>
    63de:	00 d0       	rcall	.+0      	; 0x63e0 <vTaskSuspend+0x8>
    63e0:	00 d0       	rcall	.+0      	; 0x63e2 <vTaskSuspend+0xa>
    63e2:	cd b7       	in	r28, 0x3d	; 61
    63e4:	de b7       	in	r29, 0x3e	; 62
    63e6:	9c 83       	std	Y+4, r25	; 0x04
    63e8:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    63ea:	0f b6       	in	r0, 0x3f	; 63
    63ec:	f8 94       	cli
    63ee:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    63f0:	8b 81       	ldd	r24, Y+3	; 0x03
    63f2:	9c 81       	ldd	r25, Y+4	; 0x04
    63f4:	00 97       	sbiw	r24, 0x00	; 0
    63f6:	39 f4       	brne	.+14     	; 0x6406 <vTaskSuspend+0x2e>
    63f8:	80 91 39 06 	lds	r24, 0x0639
    63fc:	90 91 3a 06 	lds	r25, 0x063A
    6400:	9e 83       	std	Y+6, r25	; 0x06
    6402:	8d 83       	std	Y+5, r24	; 0x05
    6404:	04 c0       	rjmp	.+8      	; 0x640e <vTaskSuspend+0x36>
    6406:	8b 81       	ldd	r24, Y+3	; 0x03
    6408:	9c 81       	ldd	r25, Y+4	; 0x04
    640a:	9e 83       	std	Y+6, r25	; 0x06
    640c:	8d 83       	std	Y+5, r24	; 0x05
    640e:	8d 81       	ldd	r24, Y+5	; 0x05
    6410:	9e 81       	ldd	r25, Y+6	; 0x06
    6412:	9a 83       	std	Y+2, r25	; 0x02
    6414:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    6416:	89 81       	ldd	r24, Y+1	; 0x01
    6418:	9a 81       	ldd	r25, Y+2	; 0x02
    641a:	02 96       	adiw	r24, 0x02	; 2
    641c:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    6420:	e9 81       	ldd	r30, Y+1	; 0x01
    6422:	fa 81       	ldd	r31, Y+2	; 0x02
    6424:	84 89       	ldd	r24, Z+20	; 0x14
    6426:	95 89       	ldd	r25, Z+21	; 0x15
    6428:	00 97       	sbiw	r24, 0x00	; 0
    642a:	29 f0       	breq	.+10     	; 0x6436 <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    642c:	89 81       	ldd	r24, Y+1	; 0x01
    642e:	9a 81       	ldd	r25, Y+2	; 0x02
    6430:	0c 96       	adiw	r24, 0x0c	; 12
    6432:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    6436:	89 81       	ldd	r24, Y+1	; 0x01
    6438:	9a 81       	ldd	r25, Y+2	; 0x02
    643a:	9c 01       	movw	r18, r24
    643c:	2e 5f       	subi	r18, 0xFE	; 254
    643e:	3f 4f       	sbci	r19, 0xFF	; 255
    6440:	83 ec       	ldi	r24, 0xC3	; 195
    6442:	96 e0       	ldi	r25, 0x06	; 6
    6444:	b9 01       	movw	r22, r18
    6446:	0e 94 a1 2a 	call	0x5542	; 0x5542 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    644a:	0f 90       	pop	r0
    644c:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    644e:	80 91 40 06 	lds	r24, 0x0640
    6452:	88 23       	and	r24, r24
    6454:	39 f0       	breq	.+14     	; 0x6464 <vTaskSuspend+0x8c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    6456:	0f b6       	in	r0, 0x3f	; 63
    6458:	f8 94       	cli
    645a:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    645c:	0e 94 16 38 	call	0x702c	; 0x702c <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    6460:	0f 90       	pop	r0
    6462:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    6464:	20 91 39 06 	lds	r18, 0x0639
    6468:	30 91 3a 06 	lds	r19, 0x063A
    646c:	89 81       	ldd	r24, Y+1	; 0x01
    646e:	9a 81       	ldd	r25, Y+2	; 0x02
    6470:	82 17       	cp	r24, r18
    6472:	93 07       	cpc	r25, r19
    6474:	a1 f4       	brne	.+40     	; 0x649e <vTaskSuspend+0xc6>
		{
			if( xSchedulerRunning != pdFALSE )
    6476:	80 91 40 06 	lds	r24, 0x0640
    647a:	88 23       	and	r24, r24
    647c:	19 f0       	breq	.+6      	; 0x6484 <vTaskSuspend+0xac>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    647e:	0e 94 5c 2d 	call	0x5ab8	; 0x5ab8 <vPortYield>
    6482:	0d c0       	rjmp	.+26     	; 0x649e <vTaskSuspend+0xc6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    6484:	90 91 c3 06 	lds	r25, 0x06C3
    6488:	80 91 3c 06 	lds	r24, 0x063C
    648c:	98 17       	cp	r25, r24
    648e:	29 f4       	brne	.+10     	; 0x649a <vTaskSuspend+0xc2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    6490:	10 92 3a 06 	sts	0x063A, r1
    6494:	10 92 39 06 	sts	0x0639, r1
    6498:	02 c0       	rjmp	.+4      	; 0x649e <vTaskSuspend+0xc6>
				}
				else
				{
					vTaskSwitchContext();
    649a:	0e 94 57 35 	call	0x6aae	; 0x6aae <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    649e:	26 96       	adiw	r28, 0x06	; 6
    64a0:	0f b6       	in	r0, 0x3f	; 63
    64a2:	f8 94       	cli
    64a4:	de bf       	out	0x3e, r29	; 62
    64a6:	0f be       	out	0x3f, r0	; 63
    64a8:	cd bf       	out	0x3d, r28	; 61
    64aa:	cf 91       	pop	r28
    64ac:	df 91       	pop	r29
    64ae:	08 95       	ret

000064b0 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    64b0:	df 93       	push	r29
    64b2:	cf 93       	push	r28
    64b4:	00 d0       	rcall	.+0      	; 0x64b6 <prvTaskIsTaskSuspended+0x6>
    64b6:	00 d0       	rcall	.+0      	; 0x64b8 <prvTaskIsTaskSuspended+0x8>
    64b8:	0f 92       	push	r0
    64ba:	cd b7       	in	r28, 0x3d	; 61
    64bc:	de b7       	in	r29, 0x3e	; 62
    64be:	9d 83       	std	Y+5, r25	; 0x05
    64c0:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    64c2:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
    64c4:	8c 81       	ldd	r24, Y+4	; 0x04
    64c6:	9d 81       	ldd	r25, Y+5	; 0x05
    64c8:	9a 83       	std	Y+2, r25	; 0x02
    64ca:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    64cc:	e9 81       	ldd	r30, Y+1	; 0x01
    64ce:	fa 81       	ldd	r31, Y+2	; 0x02
    64d0:	82 85       	ldd	r24, Z+10	; 0x0a
    64d2:	93 85       	ldd	r25, Z+11	; 0x0b
    64d4:	26 e0       	ldi	r18, 0x06	; 6
    64d6:	83 3c       	cpi	r24, 0xC3	; 195
    64d8:	92 07       	cpc	r25, r18
    64da:	81 f4       	brne	.+32     	; 0x64fc <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    64dc:	e9 81       	ldd	r30, Y+1	; 0x01
    64de:	fa 81       	ldd	r31, Y+2	; 0x02
    64e0:	84 89       	ldd	r24, Z+20	; 0x14
    64e2:	95 89       	ldd	r25, Z+21	; 0x15
    64e4:	26 e0       	ldi	r18, 0x06	; 6
    64e6:	81 3b       	cpi	r24, 0xB1	; 177
    64e8:	92 07       	cpc	r25, r18
    64ea:	41 f0       	breq	.+16     	; 0x64fc <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
    64ec:	e9 81       	ldd	r30, Y+1	; 0x01
    64ee:	fa 81       	ldd	r31, Y+2	; 0x02
    64f0:	84 89       	ldd	r24, Z+20	; 0x14
    64f2:	95 89       	ldd	r25, Z+21	; 0x15
    64f4:	00 97       	sbiw	r24, 0x00	; 0
    64f6:	11 f4       	brne	.+4      	; 0x64fc <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    64f8:	81 e0       	ldi	r24, 0x01	; 1
    64fa:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    64fc:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    64fe:	0f 90       	pop	r0
    6500:	0f 90       	pop	r0
    6502:	0f 90       	pop	r0
    6504:	0f 90       	pop	r0
    6506:	0f 90       	pop	r0
    6508:	cf 91       	pop	r28
    650a:	df 91       	pop	r29
    650c:	08 95       	ret

0000650e <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    650e:	df 93       	push	r29
    6510:	cf 93       	push	r28
    6512:	00 d0       	rcall	.+0      	; 0x6514 <vTaskResume+0x6>
    6514:	00 d0       	rcall	.+0      	; 0x6516 <vTaskResume+0x8>
    6516:	cd b7       	in	r28, 0x3d	; 61
    6518:	de b7       	in	r29, 0x3e	; 62
    651a:	9c 83       	std	Y+4, r25	; 0x04
    651c:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
    651e:	8b 81       	ldd	r24, Y+3	; 0x03
    6520:	9c 81       	ldd	r25, Y+4	; 0x04
    6522:	9a 83       	std	Y+2, r25	; 0x02
    6524:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    6526:	89 81       	ldd	r24, Y+1	; 0x01
    6528:	9a 81       	ldd	r25, Y+2	; 0x02
    652a:	00 97       	sbiw	r24, 0x00	; 0
    652c:	09 f4       	brne	.+2      	; 0x6530 <vTaskResume+0x22>
    652e:	4c c0       	rjmp	.+152    	; 0x65c8 <vTaskResume+0xba>
    6530:	20 91 39 06 	lds	r18, 0x0639
    6534:	30 91 3a 06 	lds	r19, 0x063A
    6538:	89 81       	ldd	r24, Y+1	; 0x01
    653a:	9a 81       	ldd	r25, Y+2	; 0x02
    653c:	82 17       	cp	r24, r18
    653e:	93 07       	cpc	r25, r19
    6540:	09 f4       	brne	.+2      	; 0x6544 <vTaskResume+0x36>
    6542:	42 c0       	rjmp	.+132    	; 0x65c8 <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    6544:	0f b6       	in	r0, 0x3f	; 63
    6546:	f8 94       	cli
    6548:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    654a:	89 81       	ldd	r24, Y+1	; 0x01
    654c:	9a 81       	ldd	r25, Y+2	; 0x02
    654e:	0e 94 58 32 	call	0x64b0	; 0x64b0 <prvTaskIsTaskSuspended>
    6552:	88 23       	and	r24, r24
    6554:	b9 f1       	breq	.+110    	; 0x65c4 <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    6556:	89 81       	ldd	r24, Y+1	; 0x01
    6558:	9a 81       	ldd	r25, Y+2	; 0x02
    655a:	02 96       	adiw	r24, 0x02	; 2
    655c:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    6560:	e9 81       	ldd	r30, Y+1	; 0x01
    6562:	fa 81       	ldd	r31, Y+2	; 0x02
    6564:	96 89       	ldd	r25, Z+22	; 0x16
    6566:	80 91 3f 06 	lds	r24, 0x063F
    656a:	89 17       	cp	r24, r25
    656c:	28 f4       	brcc	.+10     	; 0x6578 <vTaskResume+0x6a>
    656e:	e9 81       	ldd	r30, Y+1	; 0x01
    6570:	fa 81       	ldd	r31, Y+2	; 0x02
    6572:	86 89       	ldd	r24, Z+22	; 0x16
    6574:	80 93 3f 06 	sts	0x063F, r24
    6578:	e9 81       	ldd	r30, Y+1	; 0x01
    657a:	fa 81       	ldd	r31, Y+2	; 0x02
    657c:	86 89       	ldd	r24, Z+22	; 0x16
    657e:	28 2f       	mov	r18, r24
    6580:	30 e0       	ldi	r19, 0x00	; 0
    6582:	c9 01       	movw	r24, r18
    6584:	88 0f       	add	r24, r24
    6586:	99 1f       	adc	r25, r25
    6588:	88 0f       	add	r24, r24
    658a:	99 1f       	adc	r25, r25
    658c:	88 0f       	add	r24, r24
    658e:	99 1f       	adc	r25, r25
    6590:	82 0f       	add	r24, r18
    6592:	93 1f       	adc	r25, r19
    6594:	ac 01       	movw	r20, r24
    6596:	46 5b       	subi	r20, 0xB6	; 182
    6598:	59 4f       	sbci	r21, 0xF9	; 249
    659a:	89 81       	ldd	r24, Y+1	; 0x01
    659c:	9a 81       	ldd	r25, Y+2	; 0x02
    659e:	9c 01       	movw	r18, r24
    65a0:	2e 5f       	subi	r18, 0xFE	; 254
    65a2:	3f 4f       	sbci	r19, 0xFF	; 255
    65a4:	ca 01       	movw	r24, r20
    65a6:	b9 01       	movw	r22, r18
    65a8:	0e 94 a1 2a 	call	0x5542	; 0x5542 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    65ac:	e9 81       	ldd	r30, Y+1	; 0x01
    65ae:	fa 81       	ldd	r31, Y+2	; 0x02
    65b0:	96 89       	ldd	r25, Z+22	; 0x16
    65b2:	e0 91 39 06 	lds	r30, 0x0639
    65b6:	f0 91 3a 06 	lds	r31, 0x063A
    65ba:	86 89       	ldd	r24, Z+22	; 0x16
    65bc:	98 17       	cp	r25, r24
    65be:	10 f0       	brcs	.+4      	; 0x65c4 <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    65c0:	0e 94 5c 2d 	call	0x5ab8	; 0x5ab8 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    65c4:	0f 90       	pop	r0
    65c6:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    65c8:	0f 90       	pop	r0
    65ca:	0f 90       	pop	r0
    65cc:	0f 90       	pop	r0
    65ce:	0f 90       	pop	r0
    65d0:	cf 91       	pop	r28
    65d2:	df 91       	pop	r29
    65d4:	08 95       	ret

000065d6 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    65d6:	df 93       	push	r29
    65d8:	cf 93       	push	r28
    65da:	00 d0       	rcall	.+0      	; 0x65dc <xTaskResumeFromISR+0x6>
    65dc:	00 d0       	rcall	.+0      	; 0x65de <xTaskResumeFromISR+0x8>
    65de:	00 d0       	rcall	.+0      	; 0x65e0 <xTaskResumeFromISR+0xa>
    65e0:	cd b7       	in	r28, 0x3d	; 61
    65e2:	de b7       	in	r29, 0x3e	; 62
    65e4:	9e 83       	std	Y+6, r25	; 0x06
    65e6:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    65e8:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
    65ea:	8d 81       	ldd	r24, Y+5	; 0x05
    65ec:	9e 81       	ldd	r25, Y+6	; 0x06
    65ee:	9b 83       	std	Y+3, r25	; 0x03
    65f0:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    65f2:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    65f4:	8a 81       	ldd	r24, Y+2	; 0x02
    65f6:	9b 81       	ldd	r25, Y+3	; 0x03
    65f8:	0e 94 58 32 	call	0x64b0	; 0x64b0 <prvTaskIsTaskSuspended>
    65fc:	88 23       	and	r24, r24
    65fe:	09 f4       	brne	.+2      	; 0x6602 <xTaskResumeFromISR+0x2c>
    6600:	46 c0       	rjmp	.+140    	; 0x668e <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    6602:	80 91 49 06 	lds	r24, 0x0649
    6606:	88 23       	and	r24, r24
    6608:	c1 f5       	brne	.+112    	; 0x667a <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    660a:	ea 81       	ldd	r30, Y+2	; 0x02
    660c:	fb 81       	ldd	r31, Y+3	; 0x03
    660e:	96 89       	ldd	r25, Z+22	; 0x16
    6610:	e0 91 39 06 	lds	r30, 0x0639
    6614:	f0 91 3a 06 	lds	r31, 0x063A
    6618:	86 89       	ldd	r24, Z+22	; 0x16
    661a:	98 17       	cp	r25, r24
    661c:	10 f0       	brcs	.+4      	; 0x6622 <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    661e:	81 e0       	ldi	r24, 0x01	; 1
    6620:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    6622:	8a 81       	ldd	r24, Y+2	; 0x02
    6624:	9b 81       	ldd	r25, Y+3	; 0x03
    6626:	02 96       	adiw	r24, 0x02	; 2
    6628:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    662c:	ea 81       	ldd	r30, Y+2	; 0x02
    662e:	fb 81       	ldd	r31, Y+3	; 0x03
    6630:	96 89       	ldd	r25, Z+22	; 0x16
    6632:	80 91 3f 06 	lds	r24, 0x063F
    6636:	89 17       	cp	r24, r25
    6638:	28 f4       	brcc	.+10     	; 0x6644 <xTaskResumeFromISR+0x6e>
    663a:	ea 81       	ldd	r30, Y+2	; 0x02
    663c:	fb 81       	ldd	r31, Y+3	; 0x03
    663e:	86 89       	ldd	r24, Z+22	; 0x16
    6640:	80 93 3f 06 	sts	0x063F, r24
    6644:	ea 81       	ldd	r30, Y+2	; 0x02
    6646:	fb 81       	ldd	r31, Y+3	; 0x03
    6648:	86 89       	ldd	r24, Z+22	; 0x16
    664a:	28 2f       	mov	r18, r24
    664c:	30 e0       	ldi	r19, 0x00	; 0
    664e:	c9 01       	movw	r24, r18
    6650:	88 0f       	add	r24, r24
    6652:	99 1f       	adc	r25, r25
    6654:	88 0f       	add	r24, r24
    6656:	99 1f       	adc	r25, r25
    6658:	88 0f       	add	r24, r24
    665a:	99 1f       	adc	r25, r25
    665c:	82 0f       	add	r24, r18
    665e:	93 1f       	adc	r25, r19
    6660:	ac 01       	movw	r20, r24
    6662:	46 5b       	subi	r20, 0xB6	; 182
    6664:	59 4f       	sbci	r21, 0xF9	; 249
    6666:	8a 81       	ldd	r24, Y+2	; 0x02
    6668:	9b 81       	ldd	r25, Y+3	; 0x03
    666a:	9c 01       	movw	r18, r24
    666c:	2e 5f       	subi	r18, 0xFE	; 254
    666e:	3f 4f       	sbci	r19, 0xFF	; 255
    6670:	ca 01       	movw	r24, r20
    6672:	b9 01       	movw	r22, r18
    6674:	0e 94 a1 2a 	call	0x5542	; 0x5542 <vListInsertEnd>
    6678:	0a c0       	rjmp	.+20     	; 0x668e <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    667a:	8a 81       	ldd	r24, Y+2	; 0x02
    667c:	9b 81       	ldd	r25, Y+3	; 0x03
    667e:	9c 01       	movw	r18, r24
    6680:	24 5f       	subi	r18, 0xF4	; 244
    6682:	3f 4f       	sbci	r19, 0xFF	; 255
    6684:	81 eb       	ldi	r24, 0xB1	; 177
    6686:	96 e0       	ldi	r25, 0x06	; 6
    6688:	b9 01       	movw	r22, r18
    668a:	0e 94 a1 2a 	call	0x5542	; 0x5542 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    668e:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    6690:	26 96       	adiw	r28, 0x06	; 6
    6692:	0f b6       	in	r0, 0x3f	; 63
    6694:	f8 94       	cli
    6696:	de bf       	out	0x3e, r29	; 62
    6698:	0f be       	out	0x3f, r0	; 63
    669a:	cd bf       	out	0x3d, r28	; 61
    669c:	cf 91       	pop	r28
    669e:	df 91       	pop	r29
    66a0:	08 95       	ret

000066a2 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    66a2:	ef 92       	push	r14
    66a4:	ff 92       	push	r15
    66a6:	0f 93       	push	r16
    66a8:	df 93       	push	r29
    66aa:	cf 93       	push	r28
    66ac:	0f 92       	push	r0
    66ae:	cd b7       	in	r28, 0x3d	; 61
    66b0:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    66b2:	86 e7       	ldi	r24, 0x76	; 118
    66b4:	97 e3       	ldi	r25, 0x37	; 55
    66b6:	20 e6       	ldi	r18, 0x60	; 96
    66b8:	30 e0       	ldi	r19, 0x00	; 0
    66ba:	e7 e4       	ldi	r30, 0x47	; 71
    66bc:	f6 e0       	ldi	r31, 0x06	; 6
    66be:	b9 01       	movw	r22, r18
    66c0:	40 e5       	ldi	r20, 0x50	; 80
    66c2:	50 e0       	ldi	r21, 0x00	; 0
    66c4:	20 e0       	ldi	r18, 0x00	; 0
    66c6:	30 e0       	ldi	r19, 0x00	; 0
    66c8:	00 e0       	ldi	r16, 0x00	; 0
    66ca:	7f 01       	movw	r14, r30
    66cc:	0e 94 71 2e 	call	0x5ce2	; 0x5ce2 <xTaskCreate>
    66d0:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    66d2:	89 81       	ldd	r24, Y+1	; 0x01
    66d4:	81 30       	cpi	r24, 0x01	; 1
    66d6:	81 f4       	brne	.+32     	; 0x66f8 <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    66d8:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    66da:	8f ef       	ldi	r24, 0xFF	; 255
    66dc:	9f ef       	ldi	r25, 0xFF	; 255
    66de:	90 93 46 06 	sts	0x0646, r25
    66e2:	80 93 45 06 	sts	0x0645, r24
		xSchedulerRunning = pdTRUE;
    66e6:	81 e0       	ldi	r24, 0x01	; 1
    66e8:	80 93 40 06 	sts	0x0640, r24
		xTickCount = ( TickType_t ) 0U;
    66ec:	10 92 3e 06 	sts	0x063E, r1
    66f0:	10 92 3d 06 	sts	0x063D, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    66f4:	0e 94 20 2d 	call	0x5a40	; 0x5a40 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    66f8:	0f 90       	pop	r0
    66fa:	cf 91       	pop	r28
    66fc:	df 91       	pop	r29
    66fe:	0f 91       	pop	r16
    6700:	ff 90       	pop	r15
    6702:	ef 90       	pop	r14
    6704:	08 95       	ret

00006706 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    6706:	df 93       	push	r29
    6708:	cf 93       	push	r28
    670a:	cd b7       	in	r28, 0x3d	; 61
    670c:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    670e:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    6710:	10 92 40 06 	sts	0x0640, r1
	vPortEndScheduler();
    6714:	0e 94 55 2d 	call	0x5aaa	; 0x5aaa <vPortEndScheduler>
}
    6718:	cf 91       	pop	r28
    671a:	df 91       	pop	r29
    671c:	08 95       	ret

0000671e <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    671e:	df 93       	push	r29
    6720:	cf 93       	push	r28
    6722:	cd b7       	in	r28, 0x3d	; 61
    6724:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    6726:	80 91 49 06 	lds	r24, 0x0649
    672a:	8f 5f       	subi	r24, 0xFF	; 255
    672c:	80 93 49 06 	sts	0x0649, r24
}
    6730:	cf 91       	pop	r28
    6732:	df 91       	pop	r29
    6734:	08 95       	ret

00006736 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    6736:	df 93       	push	r29
    6738:	cf 93       	push	r28
    673a:	00 d0       	rcall	.+0      	; 0x673c <xTaskResumeAll+0x6>
    673c:	00 d0       	rcall	.+0      	; 0x673e <xTaskResumeAll+0x8>
    673e:	cd b7       	in	r28, 0x3d	; 61
    6740:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    6742:	1c 82       	std	Y+4, r1	; 0x04
    6744:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    6746:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    6748:	0f b6       	in	r0, 0x3f	; 63
    674a:	f8 94       	cli
    674c:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    674e:	80 91 49 06 	lds	r24, 0x0649
    6752:	81 50       	subi	r24, 0x01	; 1
    6754:	80 93 49 06 	sts	0x0649, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    6758:	80 91 49 06 	lds	r24, 0x0649
    675c:	88 23       	and	r24, r24
    675e:	09 f0       	breq	.+2      	; 0x6762 <xTaskResumeAll+0x2c>
    6760:	73 c0       	rjmp	.+230    	; 0x6848 <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    6762:	80 91 3c 06 	lds	r24, 0x063C
    6766:	88 23       	and	r24, r24
    6768:	09 f4       	brne	.+2      	; 0x676c <xTaskResumeAll+0x36>
    676a:	6e c0       	rjmp	.+220    	; 0x6848 <xTaskResumeAll+0x112>
    676c:	45 c0       	rjmp	.+138    	; 0x67f8 <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    676e:	e0 91 b6 06 	lds	r30, 0x06B6
    6772:	f0 91 b7 06 	lds	r31, 0x06B7
    6776:	86 81       	ldd	r24, Z+6	; 0x06
    6778:	97 81       	ldd	r25, Z+7	; 0x07
    677a:	9c 83       	std	Y+4, r25	; 0x04
    677c:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    677e:	8b 81       	ldd	r24, Y+3	; 0x03
    6780:	9c 81       	ldd	r25, Y+4	; 0x04
    6782:	0c 96       	adiw	r24, 0x0c	; 12
    6784:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    6788:	8b 81       	ldd	r24, Y+3	; 0x03
    678a:	9c 81       	ldd	r25, Y+4	; 0x04
    678c:	02 96       	adiw	r24, 0x02	; 2
    678e:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    6792:	eb 81       	ldd	r30, Y+3	; 0x03
    6794:	fc 81       	ldd	r31, Y+4	; 0x04
    6796:	96 89       	ldd	r25, Z+22	; 0x16
    6798:	80 91 3f 06 	lds	r24, 0x063F
    679c:	89 17       	cp	r24, r25
    679e:	28 f4       	brcc	.+10     	; 0x67aa <xTaskResumeAll+0x74>
    67a0:	eb 81       	ldd	r30, Y+3	; 0x03
    67a2:	fc 81       	ldd	r31, Y+4	; 0x04
    67a4:	86 89       	ldd	r24, Z+22	; 0x16
    67a6:	80 93 3f 06 	sts	0x063F, r24
    67aa:	eb 81       	ldd	r30, Y+3	; 0x03
    67ac:	fc 81       	ldd	r31, Y+4	; 0x04
    67ae:	86 89       	ldd	r24, Z+22	; 0x16
    67b0:	28 2f       	mov	r18, r24
    67b2:	30 e0       	ldi	r19, 0x00	; 0
    67b4:	c9 01       	movw	r24, r18
    67b6:	88 0f       	add	r24, r24
    67b8:	99 1f       	adc	r25, r25
    67ba:	88 0f       	add	r24, r24
    67bc:	99 1f       	adc	r25, r25
    67be:	88 0f       	add	r24, r24
    67c0:	99 1f       	adc	r25, r25
    67c2:	82 0f       	add	r24, r18
    67c4:	93 1f       	adc	r25, r19
    67c6:	ac 01       	movw	r20, r24
    67c8:	46 5b       	subi	r20, 0xB6	; 182
    67ca:	59 4f       	sbci	r21, 0xF9	; 249
    67cc:	8b 81       	ldd	r24, Y+3	; 0x03
    67ce:	9c 81       	ldd	r25, Y+4	; 0x04
    67d0:	9c 01       	movw	r18, r24
    67d2:	2e 5f       	subi	r18, 0xFE	; 254
    67d4:	3f 4f       	sbci	r19, 0xFF	; 255
    67d6:	ca 01       	movw	r24, r20
    67d8:	b9 01       	movw	r22, r18
    67da:	0e 94 a1 2a 	call	0x5542	; 0x5542 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    67de:	eb 81       	ldd	r30, Y+3	; 0x03
    67e0:	fc 81       	ldd	r31, Y+4	; 0x04
    67e2:	96 89       	ldd	r25, Z+22	; 0x16
    67e4:	e0 91 39 06 	lds	r30, 0x0639
    67e8:	f0 91 3a 06 	lds	r31, 0x063A
    67ec:	86 89       	ldd	r24, Z+22	; 0x16
    67ee:	98 17       	cp	r25, r24
    67f0:	18 f0       	brcs	.+6      	; 0x67f8 <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    67f2:	81 e0       	ldi	r24, 0x01	; 1
    67f4:	80 93 42 06 	sts	0x0642, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    67f8:	80 91 b1 06 	lds	r24, 0x06B1
    67fc:	88 23       	and	r24, r24
    67fe:	09 f0       	breq	.+2      	; 0x6802 <xTaskResumeAll+0xcc>
    6800:	b6 cf       	rjmp	.-148    	; 0x676e <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    6802:	8b 81       	ldd	r24, Y+3	; 0x03
    6804:	9c 81       	ldd	r25, Y+4	; 0x04
    6806:	00 97       	sbiw	r24, 0x00	; 0
    6808:	11 f0       	breq	.+4      	; 0x680e <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    680a:	0e 94 16 38 	call	0x702c	; 0x702c <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    680e:	80 91 41 06 	lds	r24, 0x0641
    6812:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    6814:	89 81       	ldd	r24, Y+1	; 0x01
    6816:	88 23       	and	r24, r24
    6818:	79 f0       	breq	.+30     	; 0x6838 <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    681a:	0e 94 8b 34 	call	0x6916	; 0x6916 <xTaskIncrementTick>
    681e:	88 23       	and	r24, r24
    6820:	19 f0       	breq	.+6      	; 0x6828 <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    6822:	81 e0       	ldi	r24, 0x01	; 1
    6824:	80 93 42 06 	sts	0x0642, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    6828:	89 81       	ldd	r24, Y+1	; 0x01
    682a:	81 50       	subi	r24, 0x01	; 1
    682c:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    682e:	89 81       	ldd	r24, Y+1	; 0x01
    6830:	88 23       	and	r24, r24
    6832:	99 f7       	brne	.-26     	; 0x681a <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    6834:	10 92 41 06 	sts	0x0641, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    6838:	80 91 42 06 	lds	r24, 0x0642
    683c:	88 23       	and	r24, r24
    683e:	21 f0       	breq	.+8      	; 0x6848 <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    6840:	81 e0       	ldi	r24, 0x01	; 1
    6842:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    6844:	0e 94 5c 2d 	call	0x5ab8	; 0x5ab8 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    6848:	0f 90       	pop	r0
    684a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    684c:	8a 81       	ldd	r24, Y+2	; 0x02
}
    684e:	0f 90       	pop	r0
    6850:	0f 90       	pop	r0
    6852:	0f 90       	pop	r0
    6854:	0f 90       	pop	r0
    6856:	cf 91       	pop	r28
    6858:	df 91       	pop	r29
    685a:	08 95       	ret

0000685c <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    685c:	df 93       	push	r29
    685e:	cf 93       	push	r28
    6860:	00 d0       	rcall	.+0      	; 0x6862 <xTaskGetTickCount+0x6>
    6862:	cd b7       	in	r28, 0x3d	; 61
    6864:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    6866:	0f b6       	in	r0, 0x3f	; 63
    6868:	f8 94       	cli
    686a:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    686c:	80 91 3d 06 	lds	r24, 0x063D
    6870:	90 91 3e 06 	lds	r25, 0x063E
    6874:	9a 83       	std	Y+2, r25	; 0x02
    6876:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    6878:	0f 90       	pop	r0
    687a:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    687c:	89 81       	ldd	r24, Y+1	; 0x01
    687e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    6880:	0f 90       	pop	r0
    6882:	0f 90       	pop	r0
    6884:	cf 91       	pop	r28
    6886:	df 91       	pop	r29
    6888:	08 95       	ret

0000688a <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    688a:	df 93       	push	r29
    688c:	cf 93       	push	r28
    688e:	00 d0       	rcall	.+0      	; 0x6890 <xTaskGetTickCountFromISR+0x6>
    6890:	0f 92       	push	r0
    6892:	cd b7       	in	r28, 0x3d	; 61
    6894:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    6896:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    6898:	80 91 3d 06 	lds	r24, 0x063D
    689c:	90 91 3e 06 	lds	r25, 0x063E
    68a0:	9b 83       	std	Y+3, r25	; 0x03
    68a2:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    68a4:	8a 81       	ldd	r24, Y+2	; 0x02
    68a6:	9b 81       	ldd	r25, Y+3	; 0x03
}
    68a8:	0f 90       	pop	r0
    68aa:	0f 90       	pop	r0
    68ac:	0f 90       	pop	r0
    68ae:	cf 91       	pop	r28
    68b0:	df 91       	pop	r29
    68b2:	08 95       	ret

000068b4 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    68b4:	df 93       	push	r29
    68b6:	cf 93       	push	r28
    68b8:	cd b7       	in	r28, 0x3d	; 61
    68ba:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    68bc:	80 91 3c 06 	lds	r24, 0x063C
}
    68c0:	cf 91       	pop	r28
    68c2:	df 91       	pop	r29
    68c4:	08 95       	ret

000068c6 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    68c6:	df 93       	push	r29
    68c8:	cf 93       	push	r28
    68ca:	00 d0       	rcall	.+0      	; 0x68cc <pcTaskGetName+0x6>
    68cc:	00 d0       	rcall	.+0      	; 0x68ce <pcTaskGetName+0x8>
    68ce:	00 d0       	rcall	.+0      	; 0x68d0 <pcTaskGetName+0xa>
    68d0:	cd b7       	in	r28, 0x3d	; 61
    68d2:	de b7       	in	r29, 0x3e	; 62
    68d4:	9c 83       	std	Y+4, r25	; 0x04
    68d6:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    68d8:	8b 81       	ldd	r24, Y+3	; 0x03
    68da:	9c 81       	ldd	r25, Y+4	; 0x04
    68dc:	00 97       	sbiw	r24, 0x00	; 0
    68de:	39 f4       	brne	.+14     	; 0x68ee <pcTaskGetName+0x28>
    68e0:	80 91 39 06 	lds	r24, 0x0639
    68e4:	90 91 3a 06 	lds	r25, 0x063A
    68e8:	9e 83       	std	Y+6, r25	; 0x06
    68ea:	8d 83       	std	Y+5, r24	; 0x05
    68ec:	04 c0       	rjmp	.+8      	; 0x68f6 <pcTaskGetName+0x30>
    68ee:	8b 81       	ldd	r24, Y+3	; 0x03
    68f0:	9c 81       	ldd	r25, Y+4	; 0x04
    68f2:	9e 83       	std	Y+6, r25	; 0x06
    68f4:	8d 83       	std	Y+5, r24	; 0x05
    68f6:	8d 81       	ldd	r24, Y+5	; 0x05
    68f8:	9e 81       	ldd	r25, Y+6	; 0x06
    68fa:	9a 83       	std	Y+2, r25	; 0x02
    68fc:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    68fe:	89 81       	ldd	r24, Y+1	; 0x01
    6900:	9a 81       	ldd	r25, Y+2	; 0x02
    6902:	49 96       	adiw	r24, 0x19	; 25
}
    6904:	26 96       	adiw	r28, 0x06	; 6
    6906:	0f b6       	in	r0, 0x3f	; 63
    6908:	f8 94       	cli
    690a:	de bf       	out	0x3e, r29	; 62
    690c:	0f be       	out	0x3f, r0	; 63
    690e:	cd bf       	out	0x3d, r28	; 61
    6910:	cf 91       	pop	r28
    6912:	df 91       	pop	r29
    6914:	08 95       	ret

00006916 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    6916:	df 93       	push	r29
    6918:	cf 93       	push	r28
    691a:	cd b7       	in	r28, 0x3d	; 61
    691c:	de b7       	in	r29, 0x3e	; 62
    691e:	29 97       	sbiw	r28, 0x09	; 9
    6920:	0f b6       	in	r0, 0x3f	; 63
    6922:	f8 94       	cli
    6924:	de bf       	out	0x3e, r29	; 62
    6926:	0f be       	out	0x3f, r0	; 63
    6928:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    692a:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    692c:	80 91 49 06 	lds	r24, 0x0649
    6930:	88 23       	and	r24, r24
    6932:	09 f0       	breq	.+2      	; 0x6936 <xTaskIncrementTick+0x20>
    6934:	a7 c0       	rjmp	.+334    	; 0x6a84 <xTaskIncrementTick+0x16e>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
    6936:	80 91 3d 06 	lds	r24, 0x063D
    693a:	90 91 3e 06 	lds	r25, 0x063E
    693e:	01 96       	adiw	r24, 0x01	; 1
    6940:	9c 83       	std	Y+4, r25	; 0x04
    6942:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    6944:	8b 81       	ldd	r24, Y+3	; 0x03
    6946:	9c 81       	ldd	r25, Y+4	; 0x04
    6948:	90 93 3e 06 	sts	0x063E, r25
    694c:	80 93 3d 06 	sts	0x063D, r24

		if( xConstTickCount == ( TickType_t ) 0U )
    6950:	8b 81       	ldd	r24, Y+3	; 0x03
    6952:	9c 81       	ldd	r25, Y+4	; 0x04
    6954:	00 97       	sbiw	r24, 0x00	; 0
    6956:	d9 f4       	brne	.+54     	; 0x698e <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    6958:	80 91 ad 06 	lds	r24, 0x06AD
    695c:	90 91 ae 06 	lds	r25, 0x06AE
    6960:	9a 83       	std	Y+2, r25	; 0x02
    6962:	89 83       	std	Y+1, r24	; 0x01
    6964:	80 91 af 06 	lds	r24, 0x06AF
    6968:	90 91 b0 06 	lds	r25, 0x06B0
    696c:	90 93 ae 06 	sts	0x06AE, r25
    6970:	80 93 ad 06 	sts	0x06AD, r24
    6974:	89 81       	ldd	r24, Y+1	; 0x01
    6976:	9a 81       	ldd	r25, Y+2	; 0x02
    6978:	90 93 b0 06 	sts	0x06B0, r25
    697c:	80 93 af 06 	sts	0x06AF, r24
    6980:	80 91 43 06 	lds	r24, 0x0643
    6984:	8f 5f       	subi	r24, 0xFF	; 255
    6986:	80 93 43 06 	sts	0x0643, r24
    698a:	0e 94 16 38 	call	0x702c	; 0x702c <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    698e:	20 91 45 06 	lds	r18, 0x0645
    6992:	30 91 46 06 	lds	r19, 0x0646
    6996:	8b 81       	ldd	r24, Y+3	; 0x03
    6998:	9c 81       	ldd	r25, Y+4	; 0x04
    699a:	82 17       	cp	r24, r18
    699c:	93 07       	cpc	r25, r19
    699e:	08 f4       	brcc	.+2      	; 0x69a2 <xTaskIncrementTick+0x8c>
    69a0:	76 c0       	rjmp	.+236    	; 0x6a8e <xTaskIncrementTick+0x178>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    69a2:	e0 91 ad 06 	lds	r30, 0x06AD
    69a6:	f0 91 ae 06 	lds	r31, 0x06AE
    69aa:	80 81       	ld	r24, Z
    69ac:	88 23       	and	r24, r24
    69ae:	39 f4       	brne	.+14     	; 0x69be <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    69b0:	8f ef       	ldi	r24, 0xFF	; 255
    69b2:	9f ef       	ldi	r25, 0xFF	; 255
    69b4:	90 93 46 06 	sts	0x0646, r25
    69b8:	80 93 45 06 	sts	0x0645, r24
    69bc:	68 c0       	rjmp	.+208    	; 0x6a8e <xTaskIncrementTick+0x178>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    69be:	e0 91 ad 06 	lds	r30, 0x06AD
    69c2:	f0 91 ae 06 	lds	r31, 0x06AE
    69c6:	05 80       	ldd	r0, Z+5	; 0x05
    69c8:	f6 81       	ldd	r31, Z+6	; 0x06
    69ca:	e0 2d       	mov	r30, r0
    69cc:	86 81       	ldd	r24, Z+6	; 0x06
    69ce:	97 81       	ldd	r25, Z+7	; 0x07
    69d0:	99 87       	std	Y+9, r25	; 0x09
    69d2:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    69d4:	e8 85       	ldd	r30, Y+8	; 0x08
    69d6:	f9 85       	ldd	r31, Y+9	; 0x09
    69d8:	82 81       	ldd	r24, Z+2	; 0x02
    69da:	93 81       	ldd	r25, Z+3	; 0x03
    69dc:	9f 83       	std	Y+7, r25	; 0x07
    69de:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    69e0:	2b 81       	ldd	r18, Y+3	; 0x03
    69e2:	3c 81       	ldd	r19, Y+4	; 0x04
    69e4:	8e 81       	ldd	r24, Y+6	; 0x06
    69e6:	9f 81       	ldd	r25, Y+7	; 0x07
    69e8:	28 17       	cp	r18, r24
    69ea:	39 07       	cpc	r19, r25
    69ec:	38 f4       	brcc	.+14     	; 0x69fc <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    69ee:	8e 81       	ldd	r24, Y+6	; 0x06
    69f0:	9f 81       	ldd	r25, Y+7	; 0x07
    69f2:	90 93 46 06 	sts	0x0646, r25
    69f6:	80 93 45 06 	sts	0x0645, r24
    69fa:	49 c0       	rjmp	.+146    	; 0x6a8e <xTaskIncrementTick+0x178>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    69fc:	88 85       	ldd	r24, Y+8	; 0x08
    69fe:	99 85       	ldd	r25, Y+9	; 0x09
    6a00:	02 96       	adiw	r24, 0x02	; 2
    6a02:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    6a06:	e8 85       	ldd	r30, Y+8	; 0x08
    6a08:	f9 85       	ldd	r31, Y+9	; 0x09
    6a0a:	84 89       	ldd	r24, Z+20	; 0x14
    6a0c:	95 89       	ldd	r25, Z+21	; 0x15
    6a0e:	00 97       	sbiw	r24, 0x00	; 0
    6a10:	29 f0       	breq	.+10     	; 0x6a1c <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    6a12:	88 85       	ldd	r24, Y+8	; 0x08
    6a14:	99 85       	ldd	r25, Y+9	; 0x09
    6a16:	0c 96       	adiw	r24, 0x0c	; 12
    6a18:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    6a1c:	e8 85       	ldd	r30, Y+8	; 0x08
    6a1e:	f9 85       	ldd	r31, Y+9	; 0x09
    6a20:	96 89       	ldd	r25, Z+22	; 0x16
    6a22:	80 91 3f 06 	lds	r24, 0x063F
    6a26:	89 17       	cp	r24, r25
    6a28:	28 f4       	brcc	.+10     	; 0x6a34 <xTaskIncrementTick+0x11e>
    6a2a:	e8 85       	ldd	r30, Y+8	; 0x08
    6a2c:	f9 85       	ldd	r31, Y+9	; 0x09
    6a2e:	86 89       	ldd	r24, Z+22	; 0x16
    6a30:	80 93 3f 06 	sts	0x063F, r24
    6a34:	e8 85       	ldd	r30, Y+8	; 0x08
    6a36:	f9 85       	ldd	r31, Y+9	; 0x09
    6a38:	86 89       	ldd	r24, Z+22	; 0x16
    6a3a:	28 2f       	mov	r18, r24
    6a3c:	30 e0       	ldi	r19, 0x00	; 0
    6a3e:	c9 01       	movw	r24, r18
    6a40:	88 0f       	add	r24, r24
    6a42:	99 1f       	adc	r25, r25
    6a44:	88 0f       	add	r24, r24
    6a46:	99 1f       	adc	r25, r25
    6a48:	88 0f       	add	r24, r24
    6a4a:	99 1f       	adc	r25, r25
    6a4c:	82 0f       	add	r24, r18
    6a4e:	93 1f       	adc	r25, r19
    6a50:	ac 01       	movw	r20, r24
    6a52:	46 5b       	subi	r20, 0xB6	; 182
    6a54:	59 4f       	sbci	r21, 0xF9	; 249
    6a56:	88 85       	ldd	r24, Y+8	; 0x08
    6a58:	99 85       	ldd	r25, Y+9	; 0x09
    6a5a:	9c 01       	movw	r18, r24
    6a5c:	2e 5f       	subi	r18, 0xFE	; 254
    6a5e:	3f 4f       	sbci	r19, 0xFF	; 255
    6a60:	ca 01       	movw	r24, r20
    6a62:	b9 01       	movw	r22, r18
    6a64:	0e 94 a1 2a 	call	0x5542	; 0x5542 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    6a68:	e8 85       	ldd	r30, Y+8	; 0x08
    6a6a:	f9 85       	ldd	r31, Y+9	; 0x09
    6a6c:	96 89       	ldd	r25, Z+22	; 0x16
    6a6e:	e0 91 39 06 	lds	r30, 0x0639
    6a72:	f0 91 3a 06 	lds	r31, 0x063A
    6a76:	86 89       	ldd	r24, Z+22	; 0x16
    6a78:	98 17       	cp	r25, r24
    6a7a:	08 f4       	brcc	.+2      	; 0x6a7e <xTaskIncrementTick+0x168>
    6a7c:	92 cf       	rjmp	.-220    	; 0x69a2 <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    6a7e:	81 e0       	ldi	r24, 0x01	; 1
    6a80:	8d 83       	std	Y+5, r24	; 0x05
    6a82:	8f cf       	rjmp	.-226    	; 0x69a2 <xTaskIncrementTick+0x8c>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    6a84:	80 91 41 06 	lds	r24, 0x0641
    6a88:	8f 5f       	subi	r24, 0xFF	; 255
    6a8a:	80 93 41 06 	sts	0x0641, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    6a8e:	80 91 42 06 	lds	r24, 0x0642
    6a92:	88 23       	and	r24, r24
    6a94:	11 f0       	breq	.+4      	; 0x6a9a <xTaskIncrementTick+0x184>
		{
			xSwitchRequired = pdTRUE;
    6a96:	81 e0       	ldi	r24, 0x01	; 1
    6a98:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    6a9a:	8d 81       	ldd	r24, Y+5	; 0x05
}
    6a9c:	29 96       	adiw	r28, 0x09	; 9
    6a9e:	0f b6       	in	r0, 0x3f	; 63
    6aa0:	f8 94       	cli
    6aa2:	de bf       	out	0x3e, r29	; 62
    6aa4:	0f be       	out	0x3f, r0	; 63
    6aa6:	cd bf       	out	0x3d, r28	; 61
    6aa8:	cf 91       	pop	r28
    6aaa:	df 91       	pop	r29
    6aac:	08 95       	ret

00006aae <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    6aae:	df 93       	push	r29
    6ab0:	cf 93       	push	r28
    6ab2:	00 d0       	rcall	.+0      	; 0x6ab4 <vTaskSwitchContext+0x6>
    6ab4:	0f 92       	push	r0
    6ab6:	cd b7       	in	r28, 0x3d	; 61
    6ab8:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    6aba:	80 91 49 06 	lds	r24, 0x0649
    6abe:	88 23       	and	r24, r24
    6ac0:	21 f0       	breq	.+8      	; 0x6aca <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    6ac2:	81 e0       	ldi	r24, 0x01	; 1
    6ac4:	80 93 42 06 	sts	0x0642, r24
    6ac8:	59 c0       	rjmp	.+178    	; 0x6b7c <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    6aca:	10 92 42 06 	sts	0x0642, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    6ace:	80 91 3f 06 	lds	r24, 0x063F
    6ad2:	8b 83       	std	Y+3, r24	; 0x03
    6ad4:	03 c0       	rjmp	.+6      	; 0x6adc <vTaskSwitchContext+0x2e>
    6ad6:	8b 81       	ldd	r24, Y+3	; 0x03
    6ad8:	81 50       	subi	r24, 0x01	; 1
    6ada:	8b 83       	std	Y+3, r24	; 0x03
    6adc:	8b 81       	ldd	r24, Y+3	; 0x03
    6ade:	28 2f       	mov	r18, r24
    6ae0:	30 e0       	ldi	r19, 0x00	; 0
    6ae2:	c9 01       	movw	r24, r18
    6ae4:	88 0f       	add	r24, r24
    6ae6:	99 1f       	adc	r25, r25
    6ae8:	88 0f       	add	r24, r24
    6aea:	99 1f       	adc	r25, r25
    6aec:	88 0f       	add	r24, r24
    6aee:	99 1f       	adc	r25, r25
    6af0:	82 0f       	add	r24, r18
    6af2:	93 1f       	adc	r25, r19
    6af4:	fc 01       	movw	r30, r24
    6af6:	e6 5b       	subi	r30, 0xB6	; 182
    6af8:	f9 4f       	sbci	r31, 0xF9	; 249
    6afa:	80 81       	ld	r24, Z
    6afc:	88 23       	and	r24, r24
    6afe:	59 f3       	breq	.-42     	; 0x6ad6 <vTaskSwitchContext+0x28>
    6b00:	8b 81       	ldd	r24, Y+3	; 0x03
    6b02:	28 2f       	mov	r18, r24
    6b04:	30 e0       	ldi	r19, 0x00	; 0
    6b06:	c9 01       	movw	r24, r18
    6b08:	88 0f       	add	r24, r24
    6b0a:	99 1f       	adc	r25, r25
    6b0c:	88 0f       	add	r24, r24
    6b0e:	99 1f       	adc	r25, r25
    6b10:	88 0f       	add	r24, r24
    6b12:	99 1f       	adc	r25, r25
    6b14:	82 0f       	add	r24, r18
    6b16:	93 1f       	adc	r25, r19
    6b18:	86 5b       	subi	r24, 0xB6	; 182
    6b1a:	99 4f       	sbci	r25, 0xF9	; 249
    6b1c:	9a 83       	std	Y+2, r25	; 0x02
    6b1e:	89 83       	std	Y+1, r24	; 0x01
    6b20:	e9 81       	ldd	r30, Y+1	; 0x01
    6b22:	fa 81       	ldd	r31, Y+2	; 0x02
    6b24:	01 80       	ldd	r0, Z+1	; 0x01
    6b26:	f2 81       	ldd	r31, Z+2	; 0x02
    6b28:	e0 2d       	mov	r30, r0
    6b2a:	82 81       	ldd	r24, Z+2	; 0x02
    6b2c:	93 81       	ldd	r25, Z+3	; 0x03
    6b2e:	e9 81       	ldd	r30, Y+1	; 0x01
    6b30:	fa 81       	ldd	r31, Y+2	; 0x02
    6b32:	92 83       	std	Z+2, r25	; 0x02
    6b34:	81 83       	std	Z+1, r24	; 0x01
    6b36:	e9 81       	ldd	r30, Y+1	; 0x01
    6b38:	fa 81       	ldd	r31, Y+2	; 0x02
    6b3a:	21 81       	ldd	r18, Z+1	; 0x01
    6b3c:	32 81       	ldd	r19, Z+2	; 0x02
    6b3e:	89 81       	ldd	r24, Y+1	; 0x01
    6b40:	9a 81       	ldd	r25, Y+2	; 0x02
    6b42:	03 96       	adiw	r24, 0x03	; 3
    6b44:	28 17       	cp	r18, r24
    6b46:	39 07       	cpc	r19, r25
    6b48:	59 f4       	brne	.+22     	; 0x6b60 <vTaskSwitchContext+0xb2>
    6b4a:	e9 81       	ldd	r30, Y+1	; 0x01
    6b4c:	fa 81       	ldd	r31, Y+2	; 0x02
    6b4e:	01 80       	ldd	r0, Z+1	; 0x01
    6b50:	f2 81       	ldd	r31, Z+2	; 0x02
    6b52:	e0 2d       	mov	r30, r0
    6b54:	82 81       	ldd	r24, Z+2	; 0x02
    6b56:	93 81       	ldd	r25, Z+3	; 0x03
    6b58:	e9 81       	ldd	r30, Y+1	; 0x01
    6b5a:	fa 81       	ldd	r31, Y+2	; 0x02
    6b5c:	92 83       	std	Z+2, r25	; 0x02
    6b5e:	81 83       	std	Z+1, r24	; 0x01
    6b60:	e9 81       	ldd	r30, Y+1	; 0x01
    6b62:	fa 81       	ldd	r31, Y+2	; 0x02
    6b64:	01 80       	ldd	r0, Z+1	; 0x01
    6b66:	f2 81       	ldd	r31, Z+2	; 0x02
    6b68:	e0 2d       	mov	r30, r0
    6b6a:	86 81       	ldd	r24, Z+6	; 0x06
    6b6c:	97 81       	ldd	r25, Z+7	; 0x07
    6b6e:	90 93 3a 06 	sts	0x063A, r25
    6b72:	80 93 39 06 	sts	0x0639, r24
    6b76:	8b 81       	ldd	r24, Y+3	; 0x03
    6b78:	80 93 3f 06 	sts	0x063F, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    6b7c:	0f 90       	pop	r0
    6b7e:	0f 90       	pop	r0
    6b80:	0f 90       	pop	r0
    6b82:	cf 91       	pop	r28
    6b84:	df 91       	pop	r29
    6b86:	08 95       	ret

00006b88 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    6b88:	df 93       	push	r29
    6b8a:	cf 93       	push	r28
    6b8c:	00 d0       	rcall	.+0      	; 0x6b8e <vTaskPlaceOnEventList+0x6>
    6b8e:	00 d0       	rcall	.+0      	; 0x6b90 <vTaskPlaceOnEventList+0x8>
    6b90:	cd b7       	in	r28, 0x3d	; 61
    6b92:	de b7       	in	r29, 0x3e	; 62
    6b94:	9a 83       	std	Y+2, r25	; 0x02
    6b96:	89 83       	std	Y+1, r24	; 0x01
    6b98:	7c 83       	std	Y+4, r23	; 0x04
    6b9a:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    6b9c:	80 91 39 06 	lds	r24, 0x0639
    6ba0:	90 91 3a 06 	lds	r25, 0x063A
    6ba4:	9c 01       	movw	r18, r24
    6ba6:	24 5f       	subi	r18, 0xF4	; 244
    6ba8:	3f 4f       	sbci	r19, 0xFF	; 255
    6baa:	89 81       	ldd	r24, Y+1	; 0x01
    6bac:	9a 81       	ldd	r25, Y+2	; 0x02
    6bae:	b9 01       	movw	r22, r18
    6bb0:	0e 94 e5 2a 	call	0x55ca	; 0x55ca <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    6bb4:	8b 81       	ldd	r24, Y+3	; 0x03
    6bb6:	9c 81       	ldd	r25, Y+4	; 0x04
    6bb8:	61 e0       	ldi	r22, 0x01	; 1
    6bba:	0e 94 39 3d 	call	0x7a72	; 0x7a72 <prvAddCurrentTaskToDelayedList>
}
    6bbe:	0f 90       	pop	r0
    6bc0:	0f 90       	pop	r0
    6bc2:	0f 90       	pop	r0
    6bc4:	0f 90       	pop	r0
    6bc6:	cf 91       	pop	r28
    6bc8:	df 91       	pop	r29
    6bca:	08 95       	ret

00006bcc <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    6bcc:	df 93       	push	r29
    6bce:	cf 93       	push	r28
    6bd0:	00 d0       	rcall	.+0      	; 0x6bd2 <vTaskPlaceOnUnorderedEventList+0x6>
    6bd2:	00 d0       	rcall	.+0      	; 0x6bd4 <vTaskPlaceOnUnorderedEventList+0x8>
    6bd4:	00 d0       	rcall	.+0      	; 0x6bd6 <vTaskPlaceOnUnorderedEventList+0xa>
    6bd6:	cd b7       	in	r28, 0x3d	; 61
    6bd8:	de b7       	in	r29, 0x3e	; 62
    6bda:	9a 83       	std	Y+2, r25	; 0x02
    6bdc:	89 83       	std	Y+1, r24	; 0x01
    6bde:	7c 83       	std	Y+4, r23	; 0x04
    6be0:	6b 83       	std	Y+3, r22	; 0x03
    6be2:	5e 83       	std	Y+6, r21	; 0x06
    6be4:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    6be6:	e0 91 39 06 	lds	r30, 0x0639
    6bea:	f0 91 3a 06 	lds	r31, 0x063A
    6bee:	8b 81       	ldd	r24, Y+3	; 0x03
    6bf0:	9c 81       	ldd	r25, Y+4	; 0x04
    6bf2:	90 68       	ori	r25, 0x80	; 128
    6bf4:	95 87       	std	Z+13, r25	; 0x0d
    6bf6:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    6bf8:	80 91 39 06 	lds	r24, 0x0639
    6bfc:	90 91 3a 06 	lds	r25, 0x063A
    6c00:	9c 01       	movw	r18, r24
    6c02:	24 5f       	subi	r18, 0xF4	; 244
    6c04:	3f 4f       	sbci	r19, 0xFF	; 255
    6c06:	89 81       	ldd	r24, Y+1	; 0x01
    6c08:	9a 81       	ldd	r25, Y+2	; 0x02
    6c0a:	b9 01       	movw	r22, r18
    6c0c:	0e 94 a1 2a 	call	0x5542	; 0x5542 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    6c10:	8d 81       	ldd	r24, Y+5	; 0x05
    6c12:	9e 81       	ldd	r25, Y+6	; 0x06
    6c14:	61 e0       	ldi	r22, 0x01	; 1
    6c16:	0e 94 39 3d 	call	0x7a72	; 0x7a72 <prvAddCurrentTaskToDelayedList>
}
    6c1a:	26 96       	adiw	r28, 0x06	; 6
    6c1c:	0f b6       	in	r0, 0x3f	; 63
    6c1e:	f8 94       	cli
    6c20:	de bf       	out	0x3e, r29	; 62
    6c22:	0f be       	out	0x3f, r0	; 63
    6c24:	cd bf       	out	0x3d, r28	; 61
    6c26:	cf 91       	pop	r28
    6c28:	df 91       	pop	r29
    6c2a:	08 95       	ret

00006c2c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    6c2c:	df 93       	push	r29
    6c2e:	cf 93       	push	r28
    6c30:	00 d0       	rcall	.+0      	; 0x6c32 <xTaskRemoveFromEventList+0x6>
    6c32:	00 d0       	rcall	.+0      	; 0x6c34 <xTaskRemoveFromEventList+0x8>
    6c34:	0f 92       	push	r0
    6c36:	cd b7       	in	r28, 0x3d	; 61
    6c38:	de b7       	in	r29, 0x3e	; 62
    6c3a:	9d 83       	std	Y+5, r25	; 0x05
    6c3c:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    6c3e:	ec 81       	ldd	r30, Y+4	; 0x04
    6c40:	fd 81       	ldd	r31, Y+5	; 0x05
    6c42:	05 80       	ldd	r0, Z+5	; 0x05
    6c44:	f6 81       	ldd	r31, Z+6	; 0x06
    6c46:	e0 2d       	mov	r30, r0
    6c48:	86 81       	ldd	r24, Z+6	; 0x06
    6c4a:	97 81       	ldd	r25, Z+7	; 0x07
    6c4c:	9b 83       	std	Y+3, r25	; 0x03
    6c4e:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    6c50:	8a 81       	ldd	r24, Y+2	; 0x02
    6c52:	9b 81       	ldd	r25, Y+3	; 0x03
    6c54:	0c 96       	adiw	r24, 0x0c	; 12
    6c56:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    6c5a:	80 91 49 06 	lds	r24, 0x0649
    6c5e:	88 23       	and	r24, r24
    6c60:	61 f5       	brne	.+88     	; 0x6cba <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    6c62:	8a 81       	ldd	r24, Y+2	; 0x02
    6c64:	9b 81       	ldd	r25, Y+3	; 0x03
    6c66:	02 96       	adiw	r24, 0x02	; 2
    6c68:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    6c6c:	ea 81       	ldd	r30, Y+2	; 0x02
    6c6e:	fb 81       	ldd	r31, Y+3	; 0x03
    6c70:	96 89       	ldd	r25, Z+22	; 0x16
    6c72:	80 91 3f 06 	lds	r24, 0x063F
    6c76:	89 17       	cp	r24, r25
    6c78:	28 f4       	brcc	.+10     	; 0x6c84 <xTaskRemoveFromEventList+0x58>
    6c7a:	ea 81       	ldd	r30, Y+2	; 0x02
    6c7c:	fb 81       	ldd	r31, Y+3	; 0x03
    6c7e:	86 89       	ldd	r24, Z+22	; 0x16
    6c80:	80 93 3f 06 	sts	0x063F, r24
    6c84:	ea 81       	ldd	r30, Y+2	; 0x02
    6c86:	fb 81       	ldd	r31, Y+3	; 0x03
    6c88:	86 89       	ldd	r24, Z+22	; 0x16
    6c8a:	28 2f       	mov	r18, r24
    6c8c:	30 e0       	ldi	r19, 0x00	; 0
    6c8e:	c9 01       	movw	r24, r18
    6c90:	88 0f       	add	r24, r24
    6c92:	99 1f       	adc	r25, r25
    6c94:	88 0f       	add	r24, r24
    6c96:	99 1f       	adc	r25, r25
    6c98:	88 0f       	add	r24, r24
    6c9a:	99 1f       	adc	r25, r25
    6c9c:	82 0f       	add	r24, r18
    6c9e:	93 1f       	adc	r25, r19
    6ca0:	ac 01       	movw	r20, r24
    6ca2:	46 5b       	subi	r20, 0xB6	; 182
    6ca4:	59 4f       	sbci	r21, 0xF9	; 249
    6ca6:	8a 81       	ldd	r24, Y+2	; 0x02
    6ca8:	9b 81       	ldd	r25, Y+3	; 0x03
    6caa:	9c 01       	movw	r18, r24
    6cac:	2e 5f       	subi	r18, 0xFE	; 254
    6cae:	3f 4f       	sbci	r19, 0xFF	; 255
    6cb0:	ca 01       	movw	r24, r20
    6cb2:	b9 01       	movw	r22, r18
    6cb4:	0e 94 a1 2a 	call	0x5542	; 0x5542 <vListInsertEnd>
    6cb8:	0a c0       	rjmp	.+20     	; 0x6cce <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    6cba:	8a 81       	ldd	r24, Y+2	; 0x02
    6cbc:	9b 81       	ldd	r25, Y+3	; 0x03
    6cbe:	9c 01       	movw	r18, r24
    6cc0:	24 5f       	subi	r18, 0xF4	; 244
    6cc2:	3f 4f       	sbci	r19, 0xFF	; 255
    6cc4:	81 eb       	ldi	r24, 0xB1	; 177
    6cc6:	96 e0       	ldi	r25, 0x06	; 6
    6cc8:	b9 01       	movw	r22, r18
    6cca:	0e 94 a1 2a 	call	0x5542	; 0x5542 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    6cce:	ea 81       	ldd	r30, Y+2	; 0x02
    6cd0:	fb 81       	ldd	r31, Y+3	; 0x03
    6cd2:	96 89       	ldd	r25, Z+22	; 0x16
    6cd4:	e0 91 39 06 	lds	r30, 0x0639
    6cd8:	f0 91 3a 06 	lds	r31, 0x063A
    6cdc:	86 89       	ldd	r24, Z+22	; 0x16
    6cde:	89 17       	cp	r24, r25
    6ce0:	30 f4       	brcc	.+12     	; 0x6cee <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    6ce2:	81 e0       	ldi	r24, 0x01	; 1
    6ce4:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    6ce6:	81 e0       	ldi	r24, 0x01	; 1
    6ce8:	80 93 42 06 	sts	0x0642, r24
    6cec:	01 c0       	rjmp	.+2      	; 0x6cf0 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    6cee:	19 82       	std	Y+1, r1	; 0x01
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
    6cf0:	89 81       	ldd	r24, Y+1	; 0x01
}
    6cf2:	0f 90       	pop	r0
    6cf4:	0f 90       	pop	r0
    6cf6:	0f 90       	pop	r0
    6cf8:	0f 90       	pop	r0
    6cfa:	0f 90       	pop	r0
    6cfc:	cf 91       	pop	r28
    6cfe:	df 91       	pop	r29
    6d00:	08 95       	ret

00006d02 <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    6d02:	df 93       	push	r29
    6d04:	cf 93       	push	r28
    6d06:	cd b7       	in	r28, 0x3d	; 61
    6d08:	de b7       	in	r29, 0x3e	; 62
    6d0a:	27 97       	sbiw	r28, 0x07	; 7
    6d0c:	0f b6       	in	r0, 0x3f	; 63
    6d0e:	f8 94       	cli
    6d10:	de bf       	out	0x3e, r29	; 62
    6d12:	0f be       	out	0x3f, r0	; 63
    6d14:	cd bf       	out	0x3d, r28	; 61
    6d16:	9d 83       	std	Y+5, r25	; 0x05
    6d18:	8c 83       	std	Y+4, r24	; 0x04
    6d1a:	7f 83       	std	Y+7, r23	; 0x07
    6d1c:	6e 83       	std	Y+6, r22	; 0x06
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    6d1e:	8e 81       	ldd	r24, Y+6	; 0x06
    6d20:	9f 81       	ldd	r25, Y+7	; 0x07
    6d22:	90 68       	ori	r25, 0x80	; 128
    6d24:	ec 81       	ldd	r30, Y+4	; 0x04
    6d26:	fd 81       	ldd	r31, Y+5	; 0x05
    6d28:	91 83       	std	Z+1, r25	; 0x01
    6d2a:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    6d2c:	ec 81       	ldd	r30, Y+4	; 0x04
    6d2e:	fd 81       	ldd	r31, Y+5	; 0x05
    6d30:	86 81       	ldd	r24, Z+6	; 0x06
    6d32:	97 81       	ldd	r25, Z+7	; 0x07
    6d34:	9b 83       	std	Y+3, r25	; 0x03
    6d36:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    6d38:	8c 81       	ldd	r24, Y+4	; 0x04
    6d3a:	9d 81       	ldd	r25, Y+5	; 0x05
    6d3c:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    6d40:	8a 81       	ldd	r24, Y+2	; 0x02
    6d42:	9b 81       	ldd	r25, Y+3	; 0x03
    6d44:	02 96       	adiw	r24, 0x02	; 2
    6d46:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    6d4a:	ea 81       	ldd	r30, Y+2	; 0x02
    6d4c:	fb 81       	ldd	r31, Y+3	; 0x03
    6d4e:	96 89       	ldd	r25, Z+22	; 0x16
    6d50:	80 91 3f 06 	lds	r24, 0x063F
    6d54:	89 17       	cp	r24, r25
    6d56:	28 f4       	brcc	.+10     	; 0x6d62 <xTaskRemoveFromUnorderedEventList+0x60>
    6d58:	ea 81       	ldd	r30, Y+2	; 0x02
    6d5a:	fb 81       	ldd	r31, Y+3	; 0x03
    6d5c:	86 89       	ldd	r24, Z+22	; 0x16
    6d5e:	80 93 3f 06 	sts	0x063F, r24
    6d62:	ea 81       	ldd	r30, Y+2	; 0x02
    6d64:	fb 81       	ldd	r31, Y+3	; 0x03
    6d66:	86 89       	ldd	r24, Z+22	; 0x16
    6d68:	28 2f       	mov	r18, r24
    6d6a:	30 e0       	ldi	r19, 0x00	; 0
    6d6c:	c9 01       	movw	r24, r18
    6d6e:	88 0f       	add	r24, r24
    6d70:	99 1f       	adc	r25, r25
    6d72:	88 0f       	add	r24, r24
    6d74:	99 1f       	adc	r25, r25
    6d76:	88 0f       	add	r24, r24
    6d78:	99 1f       	adc	r25, r25
    6d7a:	82 0f       	add	r24, r18
    6d7c:	93 1f       	adc	r25, r19
    6d7e:	ac 01       	movw	r20, r24
    6d80:	46 5b       	subi	r20, 0xB6	; 182
    6d82:	59 4f       	sbci	r21, 0xF9	; 249
    6d84:	8a 81       	ldd	r24, Y+2	; 0x02
    6d86:	9b 81       	ldd	r25, Y+3	; 0x03
    6d88:	9c 01       	movw	r18, r24
    6d8a:	2e 5f       	subi	r18, 0xFE	; 254
    6d8c:	3f 4f       	sbci	r19, 0xFF	; 255
    6d8e:	ca 01       	movw	r24, r20
    6d90:	b9 01       	movw	r22, r18
    6d92:	0e 94 a1 2a 	call	0x5542	; 0x5542 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    6d96:	ea 81       	ldd	r30, Y+2	; 0x02
    6d98:	fb 81       	ldd	r31, Y+3	; 0x03
    6d9a:	96 89       	ldd	r25, Z+22	; 0x16
    6d9c:	e0 91 39 06 	lds	r30, 0x0639
    6da0:	f0 91 3a 06 	lds	r31, 0x063A
    6da4:	86 89       	ldd	r24, Z+22	; 0x16
    6da6:	89 17       	cp	r24, r25
    6da8:	30 f4       	brcc	.+12     	; 0x6db6 <xTaskRemoveFromUnorderedEventList+0xb4>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    6daa:	81 e0       	ldi	r24, 0x01	; 1
    6dac:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    6dae:	81 e0       	ldi	r24, 0x01	; 1
    6db0:	80 93 42 06 	sts	0x0642, r24
    6db4:	01 c0       	rjmp	.+2      	; 0x6db8 <xTaskRemoveFromUnorderedEventList+0xb6>
	}
	else
	{
		xReturn = pdFALSE;
    6db6:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    6db8:	89 81       	ldd	r24, Y+1	; 0x01
}
    6dba:	27 96       	adiw	r28, 0x07	; 7
    6dbc:	0f b6       	in	r0, 0x3f	; 63
    6dbe:	f8 94       	cli
    6dc0:	de bf       	out	0x3e, r29	; 62
    6dc2:	0f be       	out	0x3f, r0	; 63
    6dc4:	cd bf       	out	0x3d, r28	; 61
    6dc6:	cf 91       	pop	r28
    6dc8:	df 91       	pop	r29
    6dca:	08 95       	ret

00006dcc <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    6dcc:	df 93       	push	r29
    6dce:	cf 93       	push	r28
    6dd0:	00 d0       	rcall	.+0      	; 0x6dd2 <vTaskSetTimeOutState+0x6>
    6dd2:	cd b7       	in	r28, 0x3d	; 61
    6dd4:	de b7       	in	r29, 0x3e	; 62
    6dd6:	9a 83       	std	Y+2, r25	; 0x02
    6dd8:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    6dda:	80 91 43 06 	lds	r24, 0x0643
    6dde:	e9 81       	ldd	r30, Y+1	; 0x01
    6de0:	fa 81       	ldd	r31, Y+2	; 0x02
    6de2:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    6de4:	80 91 3d 06 	lds	r24, 0x063D
    6de8:	90 91 3e 06 	lds	r25, 0x063E
    6dec:	e9 81       	ldd	r30, Y+1	; 0x01
    6dee:	fa 81       	ldd	r31, Y+2	; 0x02
    6df0:	92 83       	std	Z+2, r25	; 0x02
    6df2:	81 83       	std	Z+1, r24	; 0x01
}
    6df4:	0f 90       	pop	r0
    6df6:	0f 90       	pop	r0
    6df8:	cf 91       	pop	r28
    6dfa:	df 91       	pop	r29
    6dfc:	08 95       	ret

00006dfe <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    6dfe:	df 93       	push	r29
    6e00:	cf 93       	push	r28
    6e02:	cd b7       	in	r28, 0x3d	; 61
    6e04:	de b7       	in	r29, 0x3e	; 62
    6e06:	27 97       	sbiw	r28, 0x07	; 7
    6e08:	0f b6       	in	r0, 0x3f	; 63
    6e0a:	f8 94       	cli
    6e0c:	de bf       	out	0x3e, r29	; 62
    6e0e:	0f be       	out	0x3f, r0	; 63
    6e10:	cd bf       	out	0x3d, r28	; 61
    6e12:	9d 83       	std	Y+5, r25	; 0x05
    6e14:	8c 83       	std	Y+4, r24	; 0x04
    6e16:	7f 83       	std	Y+7, r23	; 0x07
    6e18:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    6e1a:	0f b6       	in	r0, 0x3f	; 63
    6e1c:	f8 94       	cli
    6e1e:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    6e20:	80 91 3d 06 	lds	r24, 0x063D
    6e24:	90 91 3e 06 	lds	r25, 0x063E
    6e28:	9a 83       	std	Y+2, r25	; 0x02
    6e2a:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    6e2c:	ee 81       	ldd	r30, Y+6	; 0x06
    6e2e:	ff 81       	ldd	r31, Y+7	; 0x07
    6e30:	80 81       	ld	r24, Z
    6e32:	91 81       	ldd	r25, Z+1	; 0x01
    6e34:	2f ef       	ldi	r18, 0xFF	; 255
    6e36:	8f 3f       	cpi	r24, 0xFF	; 255
    6e38:	92 07       	cpc	r25, r18
    6e3a:	11 f4       	brne	.+4      	; 0x6e40 <xTaskCheckForTimeOut+0x42>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    6e3c:	1b 82       	std	Y+3, r1	; 0x03
    6e3e:	40 c0       	rjmp	.+128    	; 0x6ec0 <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    6e40:	ec 81       	ldd	r30, Y+4	; 0x04
    6e42:	fd 81       	ldd	r31, Y+5	; 0x05
    6e44:	90 81       	ld	r25, Z
    6e46:	80 91 43 06 	lds	r24, 0x0643
    6e4a:	98 17       	cp	r25, r24
    6e4c:	61 f0       	breq	.+24     	; 0x6e66 <xTaskCheckForTimeOut+0x68>
    6e4e:	ec 81       	ldd	r30, Y+4	; 0x04
    6e50:	fd 81       	ldd	r31, Y+5	; 0x05
    6e52:	21 81       	ldd	r18, Z+1	; 0x01
    6e54:	32 81       	ldd	r19, Z+2	; 0x02
    6e56:	89 81       	ldd	r24, Y+1	; 0x01
    6e58:	9a 81       	ldd	r25, Y+2	; 0x02
    6e5a:	82 17       	cp	r24, r18
    6e5c:	93 07       	cpc	r25, r19
    6e5e:	18 f0       	brcs	.+6      	; 0x6e66 <xTaskCheckForTimeOut+0x68>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    6e60:	81 e0       	ldi	r24, 0x01	; 1
    6e62:	8b 83       	std	Y+3, r24	; 0x03
    6e64:	2d c0       	rjmp	.+90     	; 0x6ec0 <xTaskCheckForTimeOut+0xc2>
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    6e66:	ec 81       	ldd	r30, Y+4	; 0x04
    6e68:	fd 81       	ldd	r31, Y+5	; 0x05
    6e6a:	21 81       	ldd	r18, Z+1	; 0x01
    6e6c:	32 81       	ldd	r19, Z+2	; 0x02
    6e6e:	89 81       	ldd	r24, Y+1	; 0x01
    6e70:	9a 81       	ldd	r25, Y+2	; 0x02
    6e72:	ac 01       	movw	r20, r24
    6e74:	42 1b       	sub	r20, r18
    6e76:	53 0b       	sbc	r21, r19
    6e78:	9a 01       	movw	r18, r20
    6e7a:	ee 81       	ldd	r30, Y+6	; 0x06
    6e7c:	ff 81       	ldd	r31, Y+7	; 0x07
    6e7e:	80 81       	ld	r24, Z
    6e80:	91 81       	ldd	r25, Z+1	; 0x01
    6e82:	28 17       	cp	r18, r24
    6e84:	39 07       	cpc	r19, r25
    6e86:	d0 f4       	brcc	.+52     	; 0x6ebc <xTaskCheckForTimeOut+0xbe>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    6e88:	ee 81       	ldd	r30, Y+6	; 0x06
    6e8a:	ff 81       	ldd	r31, Y+7	; 0x07
    6e8c:	40 81       	ld	r20, Z
    6e8e:	51 81       	ldd	r21, Z+1	; 0x01
    6e90:	ec 81       	ldd	r30, Y+4	; 0x04
    6e92:	fd 81       	ldd	r31, Y+5	; 0x05
    6e94:	21 81       	ldd	r18, Z+1	; 0x01
    6e96:	32 81       	ldd	r19, Z+2	; 0x02
    6e98:	89 81       	ldd	r24, Y+1	; 0x01
    6e9a:	9a 81       	ldd	r25, Y+2	; 0x02
    6e9c:	b9 01       	movw	r22, r18
    6e9e:	68 1b       	sub	r22, r24
    6ea0:	79 0b       	sbc	r23, r25
    6ea2:	cb 01       	movw	r24, r22
    6ea4:	84 0f       	add	r24, r20
    6ea6:	95 1f       	adc	r25, r21
    6ea8:	ee 81       	ldd	r30, Y+6	; 0x06
    6eaa:	ff 81       	ldd	r31, Y+7	; 0x07
    6eac:	91 83       	std	Z+1, r25	; 0x01
    6eae:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    6eb0:	8c 81       	ldd	r24, Y+4	; 0x04
    6eb2:	9d 81       	ldd	r25, Y+5	; 0x05
    6eb4:	0e 94 e6 36 	call	0x6dcc	; 0x6dcc <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    6eb8:	1b 82       	std	Y+3, r1	; 0x03
    6eba:	02 c0       	rjmp	.+4      	; 0x6ec0 <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			xReturn = pdTRUE;
    6ebc:	81 e0       	ldi	r24, 0x01	; 1
    6ebe:	8b 83       	std	Y+3, r24	; 0x03
		}
	}
	taskEXIT_CRITICAL();
    6ec0:	0f 90       	pop	r0
    6ec2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    6ec4:	8b 81       	ldd	r24, Y+3	; 0x03
}
    6ec6:	27 96       	adiw	r28, 0x07	; 7
    6ec8:	0f b6       	in	r0, 0x3f	; 63
    6eca:	f8 94       	cli
    6ecc:	de bf       	out	0x3e, r29	; 62
    6ece:	0f be       	out	0x3f, r0	; 63
    6ed0:	cd bf       	out	0x3d, r28	; 61
    6ed2:	cf 91       	pop	r28
    6ed4:	df 91       	pop	r29
    6ed6:	08 95       	ret

00006ed8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    6ed8:	df 93       	push	r29
    6eda:	cf 93       	push	r28
    6edc:	cd b7       	in	r28, 0x3d	; 61
    6ede:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    6ee0:	81 e0       	ldi	r24, 0x01	; 1
    6ee2:	80 93 42 06 	sts	0x0642, r24
}
    6ee6:	cf 91       	pop	r28
    6ee8:	df 91       	pop	r29
    6eea:	08 95       	ret

00006eec <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    6eec:	df 93       	push	r29
    6eee:	cf 93       	push	r28
    6ef0:	00 d0       	rcall	.+0      	; 0x6ef2 <prvIdleTask+0x6>
    6ef2:	cd b7       	in	r28, 0x3d	; 61
    6ef4:	de b7       	in	r29, 0x3e	; 62
    6ef6:	9a 83       	std	Y+2, r25	; 0x02
    6ef8:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    6efa:	0e 94 c1 37 	call	0x6f82	; 0x6f82 <prvCheckTasksWaitingTermination>
    6efe:	fd cf       	rjmp	.-6      	; 0x6efa <prvIdleTask+0xe>

00006f00 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    6f00:	df 93       	push	r29
    6f02:	cf 93       	push	r28
    6f04:	0f 92       	push	r0
    6f06:	cd b7       	in	r28, 0x3d	; 61
    6f08:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    6f0a:	19 82       	std	Y+1, r1	; 0x01
    6f0c:	13 c0       	rjmp	.+38     	; 0x6f34 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    6f0e:	89 81       	ldd	r24, Y+1	; 0x01
    6f10:	28 2f       	mov	r18, r24
    6f12:	30 e0       	ldi	r19, 0x00	; 0
    6f14:	c9 01       	movw	r24, r18
    6f16:	88 0f       	add	r24, r24
    6f18:	99 1f       	adc	r25, r25
    6f1a:	88 0f       	add	r24, r24
    6f1c:	99 1f       	adc	r25, r25
    6f1e:	88 0f       	add	r24, r24
    6f20:	99 1f       	adc	r25, r25
    6f22:	82 0f       	add	r24, r18
    6f24:	93 1f       	adc	r25, r19
    6f26:	86 5b       	subi	r24, 0xB6	; 182
    6f28:	99 4f       	sbci	r25, 0xF9	; 249
    6f2a:	0e 94 67 2a 	call	0x54ce	; 0x54ce <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    6f2e:	89 81       	ldd	r24, Y+1	; 0x01
    6f30:	8f 5f       	subi	r24, 0xFF	; 255
    6f32:	89 83       	std	Y+1, r24	; 0x01
    6f34:	89 81       	ldd	r24, Y+1	; 0x01
    6f36:	89 30       	cpi	r24, 0x09	; 9
    6f38:	50 f3       	brcs	.-44     	; 0x6f0e <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    6f3a:	8b e9       	ldi	r24, 0x9B	; 155
    6f3c:	96 e0       	ldi	r25, 0x06	; 6
    6f3e:	0e 94 67 2a 	call	0x54ce	; 0x54ce <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    6f42:	84 ea       	ldi	r24, 0xA4	; 164
    6f44:	96 e0       	ldi	r25, 0x06	; 6
    6f46:	0e 94 67 2a 	call	0x54ce	; 0x54ce <vListInitialise>
	vListInitialise( &xPendingReadyList );
    6f4a:	81 eb       	ldi	r24, 0xB1	; 177
    6f4c:	96 e0       	ldi	r25, 0x06	; 6
    6f4e:	0e 94 67 2a 	call	0x54ce	; 0x54ce <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    6f52:	8a eb       	ldi	r24, 0xBA	; 186
    6f54:	96 e0       	ldi	r25, 0x06	; 6
    6f56:	0e 94 67 2a 	call	0x54ce	; 0x54ce <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    6f5a:	83 ec       	ldi	r24, 0xC3	; 195
    6f5c:	96 e0       	ldi	r25, 0x06	; 6
    6f5e:	0e 94 67 2a 	call	0x54ce	; 0x54ce <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    6f62:	8b e9       	ldi	r24, 0x9B	; 155
    6f64:	96 e0       	ldi	r25, 0x06	; 6
    6f66:	90 93 ae 06 	sts	0x06AE, r25
    6f6a:	80 93 ad 06 	sts	0x06AD, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    6f6e:	84 ea       	ldi	r24, 0xA4	; 164
    6f70:	96 e0       	ldi	r25, 0x06	; 6
    6f72:	90 93 b0 06 	sts	0x06B0, r25
    6f76:	80 93 af 06 	sts	0x06AF, r24
}
    6f7a:	0f 90       	pop	r0
    6f7c:	cf 91       	pop	r28
    6f7e:	df 91       	pop	r29
    6f80:	08 95       	ret

00006f82 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    6f82:	df 93       	push	r29
    6f84:	cf 93       	push	r28
    6f86:	00 d0       	rcall	.+0      	; 0x6f88 <prvCheckTasksWaitingTermination+0x6>
    6f88:	0f 92       	push	r0
    6f8a:	cd b7       	in	r28, 0x3d	; 61
    6f8c:	de b7       	in	r29, 0x3e	; 62
    6f8e:	2e c0       	rjmp	.+92     	; 0x6fec <prvCheckTasksWaitingTermination+0x6a>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    6f90:	0e 94 8f 33 	call	0x671e	; 0x671e <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    6f94:	80 91 ba 06 	lds	r24, 0x06BA
    6f98:	1b 82       	std	Y+3, r1	; 0x03
    6f9a:	88 23       	and	r24, r24
    6f9c:	11 f4       	brne	.+4      	; 0x6fa2 <prvCheckTasksWaitingTermination+0x20>
    6f9e:	81 e0       	ldi	r24, 0x01	; 1
    6fa0:	8b 83       	std	Y+3, r24	; 0x03
			}
			( void ) xTaskResumeAll();
    6fa2:	0e 94 9b 33 	call	0x6736	; 0x6736 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    6fa6:	8b 81       	ldd	r24, Y+3	; 0x03
    6fa8:	88 23       	and	r24, r24
    6faa:	01 f5       	brne	.+64     	; 0x6fec <prvCheckTasksWaitingTermination+0x6a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    6fac:	0f b6       	in	r0, 0x3f	; 63
    6fae:	f8 94       	cli
    6fb0:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    6fb2:	e0 91 bf 06 	lds	r30, 0x06BF
    6fb6:	f0 91 c0 06 	lds	r31, 0x06C0
    6fba:	86 81       	ldd	r24, Z+6	; 0x06
    6fbc:	97 81       	ldd	r25, Z+7	; 0x07
    6fbe:	9a 83       	std	Y+2, r25	; 0x02
    6fc0:	89 83       	std	Y+1, r24	; 0x01
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    6fc2:	89 81       	ldd	r24, Y+1	; 0x01
    6fc4:	9a 81       	ldd	r25, Y+2	; 0x02
    6fc6:	02 96       	adiw	r24, 0x02	; 2
    6fc8:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <uxListRemove>
					--uxCurrentNumberOfTasks;
    6fcc:	80 91 3c 06 	lds	r24, 0x063C
    6fd0:	81 50       	subi	r24, 0x01	; 1
    6fd2:	80 93 3c 06 	sts	0x063C, r24
					--uxDeletedTasksWaitingCleanUp;
    6fd6:	80 91 3b 06 	lds	r24, 0x063B
    6fda:	81 50       	subi	r24, 0x01	; 1
    6fdc:	80 93 3b 06 	sts	0x063B, r24
				}
				taskEXIT_CRITICAL();
    6fe0:	0f 90       	pop	r0
    6fe2:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    6fe4:	89 81       	ldd	r24, Y+1	; 0x01
    6fe6:	9a 81       	ldd	r25, Y+2	; 0x02
    6fe8:	0e 94 00 38 	call	0x7000	; 0x7000 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    6fec:	80 91 3b 06 	lds	r24, 0x063B
    6ff0:	88 23       	and	r24, r24
    6ff2:	71 f6       	brne	.-100    	; 0x6f90 <prvCheckTasksWaitingTermination+0xe>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    6ff4:	0f 90       	pop	r0
    6ff6:	0f 90       	pop	r0
    6ff8:	0f 90       	pop	r0
    6ffa:	cf 91       	pop	r28
    6ffc:	df 91       	pop	r29
    6ffe:	08 95       	ret

00007000 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    7000:	df 93       	push	r29
    7002:	cf 93       	push	r28
    7004:	00 d0       	rcall	.+0      	; 0x7006 <prvDeleteTCB+0x6>
    7006:	cd b7       	in	r28, 0x3d	; 61
    7008:	de b7       	in	r29, 0x3e	; 62
    700a:	9a 83       	std	Y+2, r25	; 0x02
    700c:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    700e:	e9 81       	ldd	r30, Y+1	; 0x01
    7010:	fa 81       	ldd	r31, Y+2	; 0x02
    7012:	87 89       	ldd	r24, Z+23	; 0x17
    7014:	90 8d       	ldd	r25, Z+24	; 0x18
    7016:	0e 94 b3 29 	call	0x5366	; 0x5366 <vPortFree>
			vPortFree( pxTCB );
    701a:	89 81       	ldd	r24, Y+1	; 0x01
    701c:	9a 81       	ldd	r25, Y+2	; 0x02
    701e:	0e 94 b3 29 	call	0x5366	; 0x5366 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    7022:	0f 90       	pop	r0
    7024:	0f 90       	pop	r0
    7026:	cf 91       	pop	r28
    7028:	df 91       	pop	r29
    702a:	08 95       	ret

0000702c <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    702c:	df 93       	push	r29
    702e:	cf 93       	push	r28
    7030:	00 d0       	rcall	.+0      	; 0x7032 <prvResetNextTaskUnblockTime+0x6>
    7032:	cd b7       	in	r28, 0x3d	; 61
    7034:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    7036:	e0 91 ad 06 	lds	r30, 0x06AD
    703a:	f0 91 ae 06 	lds	r31, 0x06AE
    703e:	80 81       	ld	r24, Z
    7040:	88 23       	and	r24, r24
    7042:	39 f4       	brne	.+14     	; 0x7052 <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    7044:	8f ef       	ldi	r24, 0xFF	; 255
    7046:	9f ef       	ldi	r25, 0xFF	; 255
    7048:	90 93 46 06 	sts	0x0646, r25
    704c:	80 93 45 06 	sts	0x0645, r24
    7050:	13 c0       	rjmp	.+38     	; 0x7078 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    7052:	e0 91 ad 06 	lds	r30, 0x06AD
    7056:	f0 91 ae 06 	lds	r31, 0x06AE
    705a:	05 80       	ldd	r0, Z+5	; 0x05
    705c:	f6 81       	ldd	r31, Z+6	; 0x06
    705e:	e0 2d       	mov	r30, r0
    7060:	86 81       	ldd	r24, Z+6	; 0x06
    7062:	97 81       	ldd	r25, Z+7	; 0x07
    7064:	9a 83       	std	Y+2, r25	; 0x02
    7066:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    7068:	e9 81       	ldd	r30, Y+1	; 0x01
    706a:	fa 81       	ldd	r31, Y+2	; 0x02
    706c:	82 81       	ldd	r24, Z+2	; 0x02
    706e:	93 81       	ldd	r25, Z+3	; 0x03
    7070:	90 93 46 06 	sts	0x0646, r25
    7074:	80 93 45 06 	sts	0x0645, r24
	}
}
    7078:	0f 90       	pop	r0
    707a:	0f 90       	pop	r0
    707c:	cf 91       	pop	r28
    707e:	df 91       	pop	r29
    7080:	08 95       	ret

00007082 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    7082:	df 93       	push	r29
    7084:	cf 93       	push	r28
    7086:	00 d0       	rcall	.+0      	; 0x7088 <xTaskGetCurrentTaskHandle+0x6>
    7088:	cd b7       	in	r28, 0x3d	; 61
    708a:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    708c:	80 91 39 06 	lds	r24, 0x0639
    7090:	90 91 3a 06 	lds	r25, 0x063A
    7094:	9a 83       	std	Y+2, r25	; 0x02
    7096:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    7098:	89 81       	ldd	r24, Y+1	; 0x01
    709a:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    709c:	0f 90       	pop	r0
    709e:	0f 90       	pop	r0
    70a0:	cf 91       	pop	r28
    70a2:	df 91       	pop	r29
    70a4:	08 95       	ret

000070a6 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    70a6:	df 93       	push	r29
    70a8:	cf 93       	push	r28
    70aa:	00 d0       	rcall	.+0      	; 0x70ac <vTaskPriorityInherit+0x6>
    70ac:	00 d0       	rcall	.+0      	; 0x70ae <vTaskPriorityInherit+0x8>
    70ae:	cd b7       	in	r28, 0x3d	; 61
    70b0:	de b7       	in	r29, 0x3e	; 62
    70b2:	9c 83       	std	Y+4, r25	; 0x04
    70b4:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    70b6:	8b 81       	ldd	r24, Y+3	; 0x03
    70b8:	9c 81       	ldd	r25, Y+4	; 0x04
    70ba:	9a 83       	std	Y+2, r25	; 0x02
    70bc:	89 83       	std	Y+1, r24	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    70be:	8b 81       	ldd	r24, Y+3	; 0x03
    70c0:	9c 81       	ldd	r25, Y+4	; 0x04
    70c2:	00 97       	sbiw	r24, 0x00	; 0
    70c4:	09 f4       	brne	.+2      	; 0x70c8 <vTaskPriorityInherit+0x22>
    70c6:	73 c0       	rjmp	.+230    	; 0x71ae <vTaskPriorityInherit+0x108>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    70c8:	e9 81       	ldd	r30, Y+1	; 0x01
    70ca:	fa 81       	ldd	r31, Y+2	; 0x02
    70cc:	96 89       	ldd	r25, Z+22	; 0x16
    70ce:	e0 91 39 06 	lds	r30, 0x0639
    70d2:	f0 91 3a 06 	lds	r31, 0x063A
    70d6:	86 89       	ldd	r24, Z+22	; 0x16
    70d8:	98 17       	cp	r25, r24
    70da:	08 f0       	brcs	.+2      	; 0x70de <vTaskPriorityInherit+0x38>
    70dc:	68 c0       	rjmp	.+208    	; 0x71ae <vTaskPriorityInherit+0x108>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    70de:	e9 81       	ldd	r30, Y+1	; 0x01
    70e0:	fa 81       	ldd	r31, Y+2	; 0x02
    70e2:	84 85       	ldd	r24, Z+12	; 0x0c
    70e4:	95 85       	ldd	r25, Z+13	; 0x0d
    70e6:	99 23       	and	r25, r25
    70e8:	7c f0       	brlt	.+30     	; 0x7108 <vTaskPriorityInherit+0x62>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    70ea:	e0 91 39 06 	lds	r30, 0x0639
    70ee:	f0 91 3a 06 	lds	r31, 0x063A
    70f2:	86 89       	ldd	r24, Z+22	; 0x16
    70f4:	28 2f       	mov	r18, r24
    70f6:	30 e0       	ldi	r19, 0x00	; 0
    70f8:	89 e0       	ldi	r24, 0x09	; 9
    70fa:	90 e0       	ldi	r25, 0x00	; 0
    70fc:	82 1b       	sub	r24, r18
    70fe:	93 0b       	sbc	r25, r19
    7100:	e9 81       	ldd	r30, Y+1	; 0x01
    7102:	fa 81       	ldd	r31, Y+2	; 0x02
    7104:	95 87       	std	Z+13, r25	; 0x0d
    7106:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    7108:	e9 81       	ldd	r30, Y+1	; 0x01
    710a:	fa 81       	ldd	r31, Y+2	; 0x02
    710c:	42 85       	ldd	r20, Z+10	; 0x0a
    710e:	53 85       	ldd	r21, Z+11	; 0x0b
    7110:	e9 81       	ldd	r30, Y+1	; 0x01
    7112:	fa 81       	ldd	r31, Y+2	; 0x02
    7114:	86 89       	ldd	r24, Z+22	; 0x16
    7116:	28 2f       	mov	r18, r24
    7118:	30 e0       	ldi	r19, 0x00	; 0
    711a:	c9 01       	movw	r24, r18
    711c:	88 0f       	add	r24, r24
    711e:	99 1f       	adc	r25, r25
    7120:	88 0f       	add	r24, r24
    7122:	99 1f       	adc	r25, r25
    7124:	88 0f       	add	r24, r24
    7126:	99 1f       	adc	r25, r25
    7128:	82 0f       	add	r24, r18
    712a:	93 1f       	adc	r25, r19
    712c:	86 5b       	subi	r24, 0xB6	; 182
    712e:	99 4f       	sbci	r25, 0xF9	; 249
    7130:	48 17       	cp	r20, r24
    7132:	59 07       	cpc	r21, r25
    7134:	a1 f5       	brne	.+104    	; 0x719e <vTaskPriorityInherit+0xf8>
				{
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    7136:	89 81       	ldd	r24, Y+1	; 0x01
    7138:	9a 81       	ldd	r25, Y+2	; 0x02
    713a:	02 96       	adiw	r24, 0x02	; 2
    713c:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    7140:	e0 91 39 06 	lds	r30, 0x0639
    7144:	f0 91 3a 06 	lds	r31, 0x063A
    7148:	86 89       	ldd	r24, Z+22	; 0x16
    714a:	e9 81       	ldd	r30, Y+1	; 0x01
    714c:	fa 81       	ldd	r31, Y+2	; 0x02
    714e:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    7150:	e9 81       	ldd	r30, Y+1	; 0x01
    7152:	fa 81       	ldd	r31, Y+2	; 0x02
    7154:	96 89       	ldd	r25, Z+22	; 0x16
    7156:	80 91 3f 06 	lds	r24, 0x063F
    715a:	89 17       	cp	r24, r25
    715c:	28 f4       	brcc	.+10     	; 0x7168 <vTaskPriorityInherit+0xc2>
    715e:	e9 81       	ldd	r30, Y+1	; 0x01
    7160:	fa 81       	ldd	r31, Y+2	; 0x02
    7162:	86 89       	ldd	r24, Z+22	; 0x16
    7164:	80 93 3f 06 	sts	0x063F, r24
    7168:	e9 81       	ldd	r30, Y+1	; 0x01
    716a:	fa 81       	ldd	r31, Y+2	; 0x02
    716c:	86 89       	ldd	r24, Z+22	; 0x16
    716e:	28 2f       	mov	r18, r24
    7170:	30 e0       	ldi	r19, 0x00	; 0
    7172:	c9 01       	movw	r24, r18
    7174:	88 0f       	add	r24, r24
    7176:	99 1f       	adc	r25, r25
    7178:	88 0f       	add	r24, r24
    717a:	99 1f       	adc	r25, r25
    717c:	88 0f       	add	r24, r24
    717e:	99 1f       	adc	r25, r25
    7180:	82 0f       	add	r24, r18
    7182:	93 1f       	adc	r25, r19
    7184:	ac 01       	movw	r20, r24
    7186:	46 5b       	subi	r20, 0xB6	; 182
    7188:	59 4f       	sbci	r21, 0xF9	; 249
    718a:	89 81       	ldd	r24, Y+1	; 0x01
    718c:	9a 81       	ldd	r25, Y+2	; 0x02
    718e:	9c 01       	movw	r18, r24
    7190:	2e 5f       	subi	r18, 0xFE	; 254
    7192:	3f 4f       	sbci	r19, 0xFF	; 255
    7194:	ca 01       	movw	r24, r20
    7196:	b9 01       	movw	r22, r18
    7198:	0e 94 a1 2a 	call	0x5542	; 0x5542 <vListInsertEnd>
    719c:	08 c0       	rjmp	.+16     	; 0x71ae <vTaskPriorityInherit+0x108>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    719e:	e0 91 39 06 	lds	r30, 0x0639
    71a2:	f0 91 3a 06 	lds	r31, 0x063A
    71a6:	86 89       	ldd	r24, Z+22	; 0x16
    71a8:	e9 81       	ldd	r30, Y+1	; 0x01
    71aa:	fa 81       	ldd	r31, Y+2	; 0x02
    71ac:	86 8b       	std	Z+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    71ae:	0f 90       	pop	r0
    71b0:	0f 90       	pop	r0
    71b2:	0f 90       	pop	r0
    71b4:	0f 90       	pop	r0
    71b6:	cf 91       	pop	r28
    71b8:	df 91       	pop	r29
    71ba:	08 95       	ret

000071bc <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    71bc:	df 93       	push	r29
    71be:	cf 93       	push	r28
    71c0:	00 d0       	rcall	.+0      	; 0x71c2 <xTaskPriorityDisinherit+0x6>
    71c2:	00 d0       	rcall	.+0      	; 0x71c4 <xTaskPriorityDisinherit+0x8>
    71c4:	0f 92       	push	r0
    71c6:	cd b7       	in	r28, 0x3d	; 61
    71c8:	de b7       	in	r29, 0x3e	; 62
    71ca:	9d 83       	std	Y+5, r25	; 0x05
    71cc:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    71ce:	8c 81       	ldd	r24, Y+4	; 0x04
    71d0:	9d 81       	ldd	r25, Y+5	; 0x05
    71d2:	9b 83       	std	Y+3, r25	; 0x03
    71d4:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    71d6:	19 82       	std	Y+1, r1	; 0x01

		if( pxMutexHolder != NULL )
    71d8:	8c 81       	ldd	r24, Y+4	; 0x04
    71da:	9d 81       	ldd	r25, Y+5	; 0x05
    71dc:	00 97       	sbiw	r24, 0x00	; 0
    71de:	09 f4       	brne	.+2      	; 0x71e2 <xTaskPriorityDisinherit+0x26>
    71e0:	56 c0       	rjmp	.+172    	; 0x728e <xTaskPriorityDisinherit+0xd2>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    71e2:	ea 81       	ldd	r30, Y+2	; 0x02
    71e4:	fb 81       	ldd	r31, Y+3	; 0x03
    71e6:	82 a1       	ldd	r24, Z+34	; 0x22
    71e8:	81 50       	subi	r24, 0x01	; 1
    71ea:	ea 81       	ldd	r30, Y+2	; 0x02
    71ec:	fb 81       	ldd	r31, Y+3	; 0x03
    71ee:	82 a3       	std	Z+34, r24	; 0x22

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    71f0:	ea 81       	ldd	r30, Y+2	; 0x02
    71f2:	fb 81       	ldd	r31, Y+3	; 0x03
    71f4:	96 89       	ldd	r25, Z+22	; 0x16
    71f6:	ea 81       	ldd	r30, Y+2	; 0x02
    71f8:	fb 81       	ldd	r31, Y+3	; 0x03
    71fa:	81 a1       	ldd	r24, Z+33	; 0x21
    71fc:	98 17       	cp	r25, r24
    71fe:	09 f4       	brne	.+2      	; 0x7202 <xTaskPriorityDisinherit+0x46>
    7200:	46 c0       	rjmp	.+140    	; 0x728e <xTaskPriorityDisinherit+0xd2>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    7202:	ea 81       	ldd	r30, Y+2	; 0x02
    7204:	fb 81       	ldd	r31, Y+3	; 0x03
    7206:	82 a1       	ldd	r24, Z+34	; 0x22
    7208:	88 23       	and	r24, r24
    720a:	09 f0       	breq	.+2      	; 0x720e <xTaskPriorityDisinherit+0x52>
    720c:	40 c0       	rjmp	.+128    	; 0x728e <xTaskPriorityDisinherit+0xd2>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    720e:	8a 81       	ldd	r24, Y+2	; 0x02
    7210:	9b 81       	ldd	r25, Y+3	; 0x03
    7212:	02 96       	adiw	r24, 0x02	; 2
    7214:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    7218:	ea 81       	ldd	r30, Y+2	; 0x02
    721a:	fb 81       	ldd	r31, Y+3	; 0x03
    721c:	81 a1       	ldd	r24, Z+33	; 0x21
    721e:	ea 81       	ldd	r30, Y+2	; 0x02
    7220:	fb 81       	ldd	r31, Y+3	; 0x03
    7222:	86 8b       	std	Z+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    7224:	ea 81       	ldd	r30, Y+2	; 0x02
    7226:	fb 81       	ldd	r31, Y+3	; 0x03
    7228:	86 89       	ldd	r24, Z+22	; 0x16
    722a:	28 2f       	mov	r18, r24
    722c:	30 e0       	ldi	r19, 0x00	; 0
    722e:	89 e0       	ldi	r24, 0x09	; 9
    7230:	90 e0       	ldi	r25, 0x00	; 0
    7232:	82 1b       	sub	r24, r18
    7234:	93 0b       	sbc	r25, r19
    7236:	ea 81       	ldd	r30, Y+2	; 0x02
    7238:	fb 81       	ldd	r31, Y+3	; 0x03
    723a:	95 87       	std	Z+13, r25	; 0x0d
    723c:	84 87       	std	Z+12, r24	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    723e:	ea 81       	ldd	r30, Y+2	; 0x02
    7240:	fb 81       	ldd	r31, Y+3	; 0x03
    7242:	96 89       	ldd	r25, Z+22	; 0x16
    7244:	80 91 3f 06 	lds	r24, 0x063F
    7248:	89 17       	cp	r24, r25
    724a:	28 f4       	brcc	.+10     	; 0x7256 <xTaskPriorityDisinherit+0x9a>
    724c:	ea 81       	ldd	r30, Y+2	; 0x02
    724e:	fb 81       	ldd	r31, Y+3	; 0x03
    7250:	86 89       	ldd	r24, Z+22	; 0x16
    7252:	80 93 3f 06 	sts	0x063F, r24
    7256:	ea 81       	ldd	r30, Y+2	; 0x02
    7258:	fb 81       	ldd	r31, Y+3	; 0x03
    725a:	86 89       	ldd	r24, Z+22	; 0x16
    725c:	28 2f       	mov	r18, r24
    725e:	30 e0       	ldi	r19, 0x00	; 0
    7260:	c9 01       	movw	r24, r18
    7262:	88 0f       	add	r24, r24
    7264:	99 1f       	adc	r25, r25
    7266:	88 0f       	add	r24, r24
    7268:	99 1f       	adc	r25, r25
    726a:	88 0f       	add	r24, r24
    726c:	99 1f       	adc	r25, r25
    726e:	82 0f       	add	r24, r18
    7270:	93 1f       	adc	r25, r19
    7272:	ac 01       	movw	r20, r24
    7274:	46 5b       	subi	r20, 0xB6	; 182
    7276:	59 4f       	sbci	r21, 0xF9	; 249
    7278:	8a 81       	ldd	r24, Y+2	; 0x02
    727a:	9b 81       	ldd	r25, Y+3	; 0x03
    727c:	9c 01       	movw	r18, r24
    727e:	2e 5f       	subi	r18, 0xFE	; 254
    7280:	3f 4f       	sbci	r19, 0xFF	; 255
    7282:	ca 01       	movw	r24, r20
    7284:	b9 01       	movw	r22, r18
    7286:	0e 94 a1 2a 	call	0x5542	; 0x5542 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    728a:	81 e0       	ldi	r24, 0x01	; 1
    728c:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    728e:	89 81       	ldd	r24, Y+1	; 0x01
	}
    7290:	0f 90       	pop	r0
    7292:	0f 90       	pop	r0
    7294:	0f 90       	pop	r0
    7296:	0f 90       	pop	r0
    7298:	0f 90       	pop	r0
    729a:	cf 91       	pop	r28
    729c:	df 91       	pop	r29
    729e:	08 95       	ret

000072a0 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    72a0:	df 93       	push	r29
    72a2:	cf 93       	push	r28
    72a4:	00 d0       	rcall	.+0      	; 0x72a6 <uxTaskResetEventItemValue+0x6>
    72a6:	cd b7       	in	r28, 0x3d	; 61
    72a8:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    72aa:	e0 91 39 06 	lds	r30, 0x0639
    72ae:	f0 91 3a 06 	lds	r31, 0x063A
    72b2:	84 85       	ldd	r24, Z+12	; 0x0c
    72b4:	95 85       	ldd	r25, Z+13	; 0x0d
    72b6:	9a 83       	std	Y+2, r25	; 0x02
    72b8:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    72ba:	a0 91 39 06 	lds	r26, 0x0639
    72be:	b0 91 3a 06 	lds	r27, 0x063A
    72c2:	e0 91 39 06 	lds	r30, 0x0639
    72c6:	f0 91 3a 06 	lds	r31, 0x063A
    72ca:	86 89       	ldd	r24, Z+22	; 0x16
    72cc:	28 2f       	mov	r18, r24
    72ce:	30 e0       	ldi	r19, 0x00	; 0
    72d0:	89 e0       	ldi	r24, 0x09	; 9
    72d2:	90 e0       	ldi	r25, 0x00	; 0
    72d4:	82 1b       	sub	r24, r18
    72d6:	93 0b       	sbc	r25, r19
    72d8:	1d 96       	adiw	r26, 0x0d	; 13
    72da:	9c 93       	st	X, r25
    72dc:	8e 93       	st	-X, r24
    72de:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    72e0:	89 81       	ldd	r24, Y+1	; 0x01
    72e2:	9a 81       	ldd	r25, Y+2	; 0x02
}
    72e4:	0f 90       	pop	r0
    72e6:	0f 90       	pop	r0
    72e8:	cf 91       	pop	r28
    72ea:	df 91       	pop	r29
    72ec:	08 95       	ret

000072ee <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void *pvTaskIncrementMutexHeldCount( void )
	{
    72ee:	df 93       	push	r29
    72f0:	cf 93       	push	r28
    72f2:	cd b7       	in	r28, 0x3d	; 61
    72f4:	de b7       	in	r29, 0x3e	; 62
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    72f6:	80 91 39 06 	lds	r24, 0x0639
    72fa:	90 91 3a 06 	lds	r25, 0x063A
    72fe:	00 97       	sbiw	r24, 0x00	; 0
    7300:	39 f0       	breq	.+14     	; 0x7310 <pvTaskIncrementMutexHeldCount+0x22>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    7302:	e0 91 39 06 	lds	r30, 0x0639
    7306:	f0 91 3a 06 	lds	r31, 0x063A
    730a:	82 a1       	ldd	r24, Z+34	; 0x22
    730c:	8f 5f       	subi	r24, 0xFF	; 255
    730e:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    7310:	80 91 39 06 	lds	r24, 0x0639
    7314:	90 91 3a 06 	lds	r25, 0x063A
	}
    7318:	cf 91       	pop	r28
    731a:	df 91       	pop	r29
    731c:	08 95       	ret

0000731e <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    731e:	df 93       	push	r29
    7320:	cf 93       	push	r28
    7322:	cd b7       	in	r28, 0x3d	; 61
    7324:	de b7       	in	r29, 0x3e	; 62
    7326:	27 97       	sbiw	r28, 0x07	; 7
    7328:	0f b6       	in	r0, 0x3f	; 63
    732a:	f8 94       	cli
    732c:	de bf       	out	0x3e, r29	; 62
    732e:	0f be       	out	0x3f, r0	; 63
    7330:	cd bf       	out	0x3d, r28	; 61
    7332:	8d 83       	std	Y+5, r24	; 0x05
    7334:	7f 83       	std	Y+7, r23	; 0x07
    7336:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    7338:	0f b6       	in	r0, 0x3f	; 63
    733a:	f8 94       	cli
    733c:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    733e:	e0 91 39 06 	lds	r30, 0x0639
    7342:	f0 91 3a 06 	lds	r31, 0x063A
    7346:	83 a1       	ldd	r24, Z+35	; 0x23
    7348:	94 a1       	ldd	r25, Z+36	; 0x24
    734a:	a5 a1       	ldd	r26, Z+37	; 0x25
    734c:	b6 a1       	ldd	r27, Z+38	; 0x26
    734e:	00 97       	sbiw	r24, 0x00	; 0
    7350:	a1 05       	cpc	r26, r1
    7352:	b1 05       	cpc	r27, r1
    7354:	89 f4       	brne	.+34     	; 0x7378 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    7356:	e0 91 39 06 	lds	r30, 0x0639
    735a:	f0 91 3a 06 	lds	r31, 0x063A
    735e:	81 e0       	ldi	r24, 0x01	; 1
    7360:	87 a3       	std	Z+39, r24	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    7362:	8e 81       	ldd	r24, Y+6	; 0x06
    7364:	9f 81       	ldd	r25, Y+7	; 0x07
    7366:	00 97       	sbiw	r24, 0x00	; 0
    7368:	39 f0       	breq	.+14     	; 0x7378 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    736a:	8e 81       	ldd	r24, Y+6	; 0x06
    736c:	9f 81       	ldd	r25, Y+7	; 0x07
    736e:	61 e0       	ldi	r22, 0x01	; 1
    7370:	0e 94 39 3d 	call	0x7a72	; 0x7a72 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    7374:	0e 94 5c 2d 	call	0x5ab8	; 0x5ab8 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    7378:	0f 90       	pop	r0
    737a:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    737c:	0f b6       	in	r0, 0x3f	; 63
    737e:	f8 94       	cli
    7380:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    7382:	e0 91 39 06 	lds	r30, 0x0639
    7386:	f0 91 3a 06 	lds	r31, 0x063A
    738a:	83 a1       	ldd	r24, Z+35	; 0x23
    738c:	94 a1       	ldd	r25, Z+36	; 0x24
    738e:	a5 a1       	ldd	r26, Z+37	; 0x25
    7390:	b6 a1       	ldd	r27, Z+38	; 0x26
    7392:	89 83       	std	Y+1, r24	; 0x01
    7394:	9a 83       	std	Y+2, r25	; 0x02
    7396:	ab 83       	std	Y+3, r26	; 0x03
    7398:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    739a:	89 81       	ldd	r24, Y+1	; 0x01
    739c:	9a 81       	ldd	r25, Y+2	; 0x02
    739e:	ab 81       	ldd	r26, Y+3	; 0x03
    73a0:	bc 81       	ldd	r27, Y+4	; 0x04
    73a2:	00 97       	sbiw	r24, 0x00	; 0
    73a4:	a1 05       	cpc	r26, r1
    73a6:	b1 05       	cpc	r27, r1
    73a8:	d9 f0       	breq	.+54     	; 0x73e0 <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    73aa:	8d 81       	ldd	r24, Y+5	; 0x05
    73ac:	88 23       	and	r24, r24
    73ae:	49 f0       	breq	.+18     	; 0x73c2 <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    73b0:	e0 91 39 06 	lds	r30, 0x0639
    73b4:	f0 91 3a 06 	lds	r31, 0x063A
    73b8:	13 a2       	std	Z+35, r1	; 0x23
    73ba:	14 a2       	std	Z+36, r1	; 0x24
    73bc:	15 a2       	std	Z+37, r1	; 0x25
    73be:	16 a2       	std	Z+38, r1	; 0x26
    73c0:	0f c0       	rjmp	.+30     	; 0x73e0 <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
    73c2:	e0 91 39 06 	lds	r30, 0x0639
    73c6:	f0 91 3a 06 	lds	r31, 0x063A
    73ca:	89 81       	ldd	r24, Y+1	; 0x01
    73cc:	9a 81       	ldd	r25, Y+2	; 0x02
    73ce:	ab 81       	ldd	r26, Y+3	; 0x03
    73d0:	bc 81       	ldd	r27, Y+4	; 0x04
    73d2:	01 97       	sbiw	r24, 0x01	; 1
    73d4:	a1 09       	sbc	r26, r1
    73d6:	b1 09       	sbc	r27, r1
    73d8:	83 a3       	std	Z+35, r24	; 0x23
    73da:	94 a3       	std	Z+36, r25	; 0x24
    73dc:	a5 a3       	std	Z+37, r26	; 0x25
    73de:	b6 a3       	std	Z+38, r27	; 0x26
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    73e0:	e0 91 39 06 	lds	r30, 0x0639
    73e4:	f0 91 3a 06 	lds	r31, 0x063A
    73e8:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    73ea:	0f 90       	pop	r0
    73ec:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    73ee:	89 81       	ldd	r24, Y+1	; 0x01
    73f0:	9a 81       	ldd	r25, Y+2	; 0x02
    73f2:	ab 81       	ldd	r26, Y+3	; 0x03
    73f4:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    73f6:	bc 01       	movw	r22, r24
    73f8:	cd 01       	movw	r24, r26
    73fa:	27 96       	adiw	r28, 0x07	; 7
    73fc:	0f b6       	in	r0, 0x3f	; 63
    73fe:	f8 94       	cli
    7400:	de bf       	out	0x3e, r29	; 62
    7402:	0f be       	out	0x3f, r0	; 63
    7404:	cd bf       	out	0x3d, r28	; 61
    7406:	cf 91       	pop	r28
    7408:	df 91       	pop	r29
    740a:	08 95       	ret

0000740c <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    740c:	ef 92       	push	r14
    740e:	ff 92       	push	r15
    7410:	0f 93       	push	r16
    7412:	1f 93       	push	r17
    7414:	df 93       	push	r29
    7416:	cf 93       	push	r28
    7418:	cd b7       	in	r28, 0x3d	; 61
    741a:	de b7       	in	r29, 0x3e	; 62
    741c:	2d 97       	sbiw	r28, 0x0d	; 13
    741e:	0f b6       	in	r0, 0x3f	; 63
    7420:	f8 94       	cli
    7422:	de bf       	out	0x3e, r29	; 62
    7424:	0f be       	out	0x3f, r0	; 63
    7426:	cd bf       	out	0x3d, r28	; 61
    7428:	6a 83       	std	Y+2, r22	; 0x02
    742a:	7b 83       	std	Y+3, r23	; 0x03
    742c:	8c 83       	std	Y+4, r24	; 0x04
    742e:	9d 83       	std	Y+5, r25	; 0x05
    7430:	2e 83       	std	Y+6, r18	; 0x06
    7432:	3f 83       	std	Y+7, r19	; 0x07
    7434:	48 87       	std	Y+8, r20	; 0x08
    7436:	59 87       	std	Y+9, r21	; 0x09
    7438:	1b 87       	std	Y+11, r17	; 0x0b
    743a:	0a 87       	std	Y+10, r16	; 0x0a
    743c:	fd 86       	std	Y+13, r15	; 0x0d
    743e:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    7440:	0f b6       	in	r0, 0x3f	; 63
    7442:	f8 94       	cli
    7444:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    7446:	e0 91 39 06 	lds	r30, 0x0639
    744a:	f0 91 3a 06 	lds	r31, 0x063A
    744e:	87 a1       	ldd	r24, Z+39	; 0x27
    7450:	82 30       	cpi	r24, 0x02	; 2
    7452:	49 f1       	breq	.+82     	; 0x74a6 <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    7454:	e0 91 39 06 	lds	r30, 0x0639
    7458:	f0 91 3a 06 	lds	r31, 0x063A
    745c:	23 a1       	ldd	r18, Z+35	; 0x23
    745e:	34 a1       	ldd	r19, Z+36	; 0x24
    7460:	45 a1       	ldd	r20, Z+37	; 0x25
    7462:	56 a1       	ldd	r21, Z+38	; 0x26
    7464:	8a 81       	ldd	r24, Y+2	; 0x02
    7466:	9b 81       	ldd	r25, Y+3	; 0x03
    7468:	ac 81       	ldd	r26, Y+4	; 0x04
    746a:	bd 81       	ldd	r27, Y+5	; 0x05
    746c:	80 95       	com	r24
    746e:	90 95       	com	r25
    7470:	a0 95       	com	r26
    7472:	b0 95       	com	r27
    7474:	82 23       	and	r24, r18
    7476:	93 23       	and	r25, r19
    7478:	a4 23       	and	r26, r20
    747a:	b5 23       	and	r27, r21
    747c:	83 a3       	std	Z+35, r24	; 0x23
    747e:	94 a3       	std	Z+36, r25	; 0x24
    7480:	a5 a3       	std	Z+37, r26	; 0x25
    7482:	b6 a3       	std	Z+38, r27	; 0x26

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    7484:	e0 91 39 06 	lds	r30, 0x0639
    7488:	f0 91 3a 06 	lds	r31, 0x063A
    748c:	81 e0       	ldi	r24, 0x01	; 1
    748e:	87 a3       	std	Z+39, r24	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    7490:	8c 85       	ldd	r24, Y+12	; 0x0c
    7492:	9d 85       	ldd	r25, Y+13	; 0x0d
    7494:	00 97       	sbiw	r24, 0x00	; 0
    7496:	39 f0       	breq	.+14     	; 0x74a6 <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    7498:	8c 85       	ldd	r24, Y+12	; 0x0c
    749a:	9d 85       	ldd	r25, Y+13	; 0x0d
    749c:	61 e0       	ldi	r22, 0x01	; 1
    749e:	0e 94 39 3d 	call	0x7a72	; 0x7a72 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    74a2:	0e 94 5c 2d 	call	0x5ab8	; 0x5ab8 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    74a6:	0f 90       	pop	r0
    74a8:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    74aa:	0f b6       	in	r0, 0x3f	; 63
    74ac:	f8 94       	cli
    74ae:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    74b0:	8a 85       	ldd	r24, Y+10	; 0x0a
    74b2:	9b 85       	ldd	r25, Y+11	; 0x0b
    74b4:	00 97       	sbiw	r24, 0x00	; 0
    74b6:	71 f0       	breq	.+28     	; 0x74d4 <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    74b8:	e0 91 39 06 	lds	r30, 0x0639
    74bc:	f0 91 3a 06 	lds	r31, 0x063A
    74c0:	83 a1       	ldd	r24, Z+35	; 0x23
    74c2:	94 a1       	ldd	r25, Z+36	; 0x24
    74c4:	a5 a1       	ldd	r26, Z+37	; 0x25
    74c6:	b6 a1       	ldd	r27, Z+38	; 0x26
    74c8:	ea 85       	ldd	r30, Y+10	; 0x0a
    74ca:	fb 85       	ldd	r31, Y+11	; 0x0b
    74cc:	80 83       	st	Z, r24
    74ce:	91 83       	std	Z+1, r25	; 0x01
    74d0:	a2 83       	std	Z+2, r26	; 0x02
    74d2:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    74d4:	e0 91 39 06 	lds	r30, 0x0639
    74d8:	f0 91 3a 06 	lds	r31, 0x063A
    74dc:	87 a1       	ldd	r24, Z+39	; 0x27
    74de:	81 30       	cpi	r24, 0x01	; 1
    74e0:	11 f4       	brne	.+4      	; 0x74e6 <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    74e2:	19 82       	std	Y+1, r1	; 0x01
    74e4:	1a c0       	rjmp	.+52     	; 0x751a <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    74e6:	e0 91 39 06 	lds	r30, 0x0639
    74ea:	f0 91 3a 06 	lds	r31, 0x063A
    74ee:	23 a1       	ldd	r18, Z+35	; 0x23
    74f0:	34 a1       	ldd	r19, Z+36	; 0x24
    74f2:	45 a1       	ldd	r20, Z+37	; 0x25
    74f4:	56 a1       	ldd	r21, Z+38	; 0x26
    74f6:	8e 81       	ldd	r24, Y+6	; 0x06
    74f8:	9f 81       	ldd	r25, Y+7	; 0x07
    74fa:	a8 85       	ldd	r26, Y+8	; 0x08
    74fc:	b9 85       	ldd	r27, Y+9	; 0x09
    74fe:	80 95       	com	r24
    7500:	90 95       	com	r25
    7502:	a0 95       	com	r26
    7504:	b0 95       	com	r27
    7506:	82 23       	and	r24, r18
    7508:	93 23       	and	r25, r19
    750a:	a4 23       	and	r26, r20
    750c:	b5 23       	and	r27, r21
    750e:	83 a3       	std	Z+35, r24	; 0x23
    7510:	94 a3       	std	Z+36, r25	; 0x24
    7512:	a5 a3       	std	Z+37, r26	; 0x25
    7514:	b6 a3       	std	Z+38, r27	; 0x26
				xReturn = pdTRUE;
    7516:	81 e0       	ldi	r24, 0x01	; 1
    7518:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    751a:	e0 91 39 06 	lds	r30, 0x0639
    751e:	f0 91 3a 06 	lds	r31, 0x063A
    7522:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    7524:	0f 90       	pop	r0
    7526:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    7528:	89 81       	ldd	r24, Y+1	; 0x01
	}
    752a:	2d 96       	adiw	r28, 0x0d	; 13
    752c:	0f b6       	in	r0, 0x3f	; 63
    752e:	f8 94       	cli
    7530:	de bf       	out	0x3e, r29	; 62
    7532:	0f be       	out	0x3f, r0	; 63
    7534:	cd bf       	out	0x3d, r28	; 61
    7536:	cf 91       	pop	r28
    7538:	df 91       	pop	r29
    753a:	1f 91       	pop	r17
    753c:	0f 91       	pop	r16
    753e:	ff 90       	pop	r15
    7540:	ef 90       	pop	r14
    7542:	08 95       	ret

00007544 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    7544:	0f 93       	push	r16
    7546:	1f 93       	push	r17
    7548:	df 93       	push	r29
    754a:	cf 93       	push	r28
    754c:	cd b7       	in	r28, 0x3d	; 61
    754e:	de b7       	in	r29, 0x3e	; 62
    7550:	2f 97       	sbiw	r28, 0x0f	; 15
    7552:	0f b6       	in	r0, 0x3f	; 63
    7554:	f8 94       	cli
    7556:	de bf       	out	0x3e, r29	; 62
    7558:	0f be       	out	0x3f, r0	; 63
    755a:	cd bf       	out	0x3d, r28	; 61
    755c:	9e 83       	std	Y+6, r25	; 0x06
    755e:	8d 83       	std	Y+5, r24	; 0x05
    7560:	4f 83       	std	Y+7, r20	; 0x07
    7562:	58 87       	std	Y+8, r21	; 0x08
    7564:	69 87       	std	Y+9, r22	; 0x09
    7566:	7a 87       	std	Y+10, r23	; 0x0a
    7568:	2b 87       	std	Y+11, r18	; 0x0b
    756a:	1d 87       	std	Y+13, r17	; 0x0d
    756c:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    756e:	81 e0       	ldi	r24, 0x01	; 1
    7570:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;
    7572:	8d 81       	ldd	r24, Y+5	; 0x05
    7574:	9e 81       	ldd	r25, Y+6	; 0x06
    7576:	9c 83       	std	Y+4, r25	; 0x04
    7578:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    757a:	0f b6       	in	r0, 0x3f	; 63
    757c:	f8 94       	cli
    757e:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    7580:	8c 85       	ldd	r24, Y+12	; 0x0c
    7582:	9d 85       	ldd	r25, Y+13	; 0x0d
    7584:	00 97       	sbiw	r24, 0x00	; 0
    7586:	61 f0       	breq	.+24     	; 0x75a0 <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    7588:	eb 81       	ldd	r30, Y+3	; 0x03
    758a:	fc 81       	ldd	r31, Y+4	; 0x04
    758c:	83 a1       	ldd	r24, Z+35	; 0x23
    758e:	94 a1       	ldd	r25, Z+36	; 0x24
    7590:	a5 a1       	ldd	r26, Z+37	; 0x25
    7592:	b6 a1       	ldd	r27, Z+38	; 0x26
    7594:	ec 85       	ldd	r30, Y+12	; 0x0c
    7596:	fd 85       	ldd	r31, Y+13	; 0x0d
    7598:	80 83       	st	Z, r24
    759a:	91 83       	std	Z+1, r25	; 0x01
    759c:	a2 83       	std	Z+2, r26	; 0x02
    759e:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    75a0:	eb 81       	ldd	r30, Y+3	; 0x03
    75a2:	fc 81       	ldd	r31, Y+4	; 0x04
    75a4:	87 a1       	ldd	r24, Z+39	; 0x27
    75a6:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    75a8:	eb 81       	ldd	r30, Y+3	; 0x03
    75aa:	fc 81       	ldd	r31, Y+4	; 0x04
    75ac:	82 e0       	ldi	r24, 0x02	; 2
    75ae:	87 a3       	std	Z+39, r24	; 0x27

			switch( eAction )
    75b0:	8b 85       	ldd	r24, Y+11	; 0x0b
    75b2:	28 2f       	mov	r18, r24
    75b4:	30 e0       	ldi	r19, 0x00	; 0
    75b6:	3f 87       	std	Y+15, r19	; 0x0f
    75b8:	2e 87       	std	Y+14, r18	; 0x0e
    75ba:	8e 85       	ldd	r24, Y+14	; 0x0e
    75bc:	9f 85       	ldd	r25, Y+15	; 0x0f
    75be:	82 30       	cpi	r24, 0x02	; 2
    75c0:	91 05       	cpc	r25, r1
    75c2:	59 f1       	breq	.+86     	; 0x761a <xTaskGenericNotify+0xd6>
    75c4:	2e 85       	ldd	r18, Y+14	; 0x0e
    75c6:	3f 85       	ldd	r19, Y+15	; 0x0f
    75c8:	23 30       	cpi	r18, 0x03	; 3
    75ca:	31 05       	cpc	r19, r1
    75cc:	34 f4       	brge	.+12     	; 0x75da <xTaskGenericNotify+0x96>
    75ce:	8e 85       	ldd	r24, Y+14	; 0x0e
    75d0:	9f 85       	ldd	r25, Y+15	; 0x0f
    75d2:	81 30       	cpi	r24, 0x01	; 1
    75d4:	91 05       	cpc	r25, r1
    75d6:	61 f0       	breq	.+24     	; 0x75f0 <xTaskGenericNotify+0xac>
    75d8:	4a c0       	rjmp	.+148    	; 0x766e <xTaskGenericNotify+0x12a>
    75da:	2e 85       	ldd	r18, Y+14	; 0x0e
    75dc:	3f 85       	ldd	r19, Y+15	; 0x0f
    75de:	23 30       	cpi	r18, 0x03	; 3
    75e0:	31 05       	cpc	r19, r1
    75e2:	59 f1       	breq	.+86     	; 0x763a <xTaskGenericNotify+0xf6>
    75e4:	8e 85       	ldd	r24, Y+14	; 0x0e
    75e6:	9f 85       	ldd	r25, Y+15	; 0x0f
    75e8:	84 30       	cpi	r24, 0x04	; 4
    75ea:	91 05       	cpc	r25, r1
    75ec:	89 f1       	breq	.+98     	; 0x7650 <xTaskGenericNotify+0x10c>
    75ee:	3f c0       	rjmp	.+126    	; 0x766e <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    75f0:	eb 81       	ldd	r30, Y+3	; 0x03
    75f2:	fc 81       	ldd	r31, Y+4	; 0x04
    75f4:	23 a1       	ldd	r18, Z+35	; 0x23
    75f6:	34 a1       	ldd	r19, Z+36	; 0x24
    75f8:	45 a1       	ldd	r20, Z+37	; 0x25
    75fa:	56 a1       	ldd	r21, Z+38	; 0x26
    75fc:	8f 81       	ldd	r24, Y+7	; 0x07
    75fe:	98 85       	ldd	r25, Y+8	; 0x08
    7600:	a9 85       	ldd	r26, Y+9	; 0x09
    7602:	ba 85       	ldd	r27, Y+10	; 0x0a
    7604:	82 2b       	or	r24, r18
    7606:	93 2b       	or	r25, r19
    7608:	a4 2b       	or	r26, r20
    760a:	b5 2b       	or	r27, r21
    760c:	eb 81       	ldd	r30, Y+3	; 0x03
    760e:	fc 81       	ldd	r31, Y+4	; 0x04
    7610:	83 a3       	std	Z+35, r24	; 0x23
    7612:	94 a3       	std	Z+36, r25	; 0x24
    7614:	a5 a3       	std	Z+37, r26	; 0x25
    7616:	b6 a3       	std	Z+38, r27	; 0x26
    7618:	2a c0       	rjmp	.+84     	; 0x766e <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    761a:	eb 81       	ldd	r30, Y+3	; 0x03
    761c:	fc 81       	ldd	r31, Y+4	; 0x04
    761e:	83 a1       	ldd	r24, Z+35	; 0x23
    7620:	94 a1       	ldd	r25, Z+36	; 0x24
    7622:	a5 a1       	ldd	r26, Z+37	; 0x25
    7624:	b6 a1       	ldd	r27, Z+38	; 0x26
    7626:	01 96       	adiw	r24, 0x01	; 1
    7628:	a1 1d       	adc	r26, r1
    762a:	b1 1d       	adc	r27, r1
    762c:	eb 81       	ldd	r30, Y+3	; 0x03
    762e:	fc 81       	ldd	r31, Y+4	; 0x04
    7630:	83 a3       	std	Z+35, r24	; 0x23
    7632:	94 a3       	std	Z+36, r25	; 0x24
    7634:	a5 a3       	std	Z+37, r26	; 0x25
    7636:	b6 a3       	std	Z+38, r27	; 0x26
    7638:	1a c0       	rjmp	.+52     	; 0x766e <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    763a:	eb 81       	ldd	r30, Y+3	; 0x03
    763c:	fc 81       	ldd	r31, Y+4	; 0x04
    763e:	8f 81       	ldd	r24, Y+7	; 0x07
    7640:	98 85       	ldd	r25, Y+8	; 0x08
    7642:	a9 85       	ldd	r26, Y+9	; 0x09
    7644:	ba 85       	ldd	r27, Y+10	; 0x0a
    7646:	83 a3       	std	Z+35, r24	; 0x23
    7648:	94 a3       	std	Z+36, r25	; 0x24
    764a:	a5 a3       	std	Z+37, r26	; 0x25
    764c:	b6 a3       	std	Z+38, r27	; 0x26
    764e:	0f c0       	rjmp	.+30     	; 0x766e <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    7650:	89 81       	ldd	r24, Y+1	; 0x01
    7652:	82 30       	cpi	r24, 0x02	; 2
    7654:	59 f0       	breq	.+22     	; 0x766c <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    7656:	eb 81       	ldd	r30, Y+3	; 0x03
    7658:	fc 81       	ldd	r31, Y+4	; 0x04
    765a:	8f 81       	ldd	r24, Y+7	; 0x07
    765c:	98 85       	ldd	r25, Y+8	; 0x08
    765e:	a9 85       	ldd	r26, Y+9	; 0x09
    7660:	ba 85       	ldd	r27, Y+10	; 0x0a
    7662:	83 a3       	std	Z+35, r24	; 0x23
    7664:	94 a3       	std	Z+36, r25	; 0x24
    7666:	a5 a3       	std	Z+37, r26	; 0x25
    7668:	b6 a3       	std	Z+38, r27	; 0x26
    766a:	01 c0       	rjmp	.+2      	; 0x766e <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    766c:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    766e:	89 81       	ldd	r24, Y+1	; 0x01
    7670:	81 30       	cpi	r24, 0x01	; 1
    7672:	b9 f5       	brne	.+110    	; 0x76e2 <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    7674:	8b 81       	ldd	r24, Y+3	; 0x03
    7676:	9c 81       	ldd	r25, Y+4	; 0x04
    7678:	02 96       	adiw	r24, 0x02	; 2
    767a:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    767e:	eb 81       	ldd	r30, Y+3	; 0x03
    7680:	fc 81       	ldd	r31, Y+4	; 0x04
    7682:	96 89       	ldd	r25, Z+22	; 0x16
    7684:	80 91 3f 06 	lds	r24, 0x063F
    7688:	89 17       	cp	r24, r25
    768a:	28 f4       	brcc	.+10     	; 0x7696 <xTaskGenericNotify+0x152>
    768c:	eb 81       	ldd	r30, Y+3	; 0x03
    768e:	fc 81       	ldd	r31, Y+4	; 0x04
    7690:	86 89       	ldd	r24, Z+22	; 0x16
    7692:	80 93 3f 06 	sts	0x063F, r24
    7696:	eb 81       	ldd	r30, Y+3	; 0x03
    7698:	fc 81       	ldd	r31, Y+4	; 0x04
    769a:	86 89       	ldd	r24, Z+22	; 0x16
    769c:	28 2f       	mov	r18, r24
    769e:	30 e0       	ldi	r19, 0x00	; 0
    76a0:	c9 01       	movw	r24, r18
    76a2:	88 0f       	add	r24, r24
    76a4:	99 1f       	adc	r25, r25
    76a6:	88 0f       	add	r24, r24
    76a8:	99 1f       	adc	r25, r25
    76aa:	88 0f       	add	r24, r24
    76ac:	99 1f       	adc	r25, r25
    76ae:	82 0f       	add	r24, r18
    76b0:	93 1f       	adc	r25, r19
    76b2:	ac 01       	movw	r20, r24
    76b4:	46 5b       	subi	r20, 0xB6	; 182
    76b6:	59 4f       	sbci	r21, 0xF9	; 249
    76b8:	8b 81       	ldd	r24, Y+3	; 0x03
    76ba:	9c 81       	ldd	r25, Y+4	; 0x04
    76bc:	9c 01       	movw	r18, r24
    76be:	2e 5f       	subi	r18, 0xFE	; 254
    76c0:	3f 4f       	sbci	r19, 0xFF	; 255
    76c2:	ca 01       	movw	r24, r20
    76c4:	b9 01       	movw	r22, r18
    76c6:	0e 94 a1 2a 	call	0x5542	; 0x5542 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    76ca:	eb 81       	ldd	r30, Y+3	; 0x03
    76cc:	fc 81       	ldd	r31, Y+4	; 0x04
    76ce:	96 89       	ldd	r25, Z+22	; 0x16
    76d0:	e0 91 39 06 	lds	r30, 0x0639
    76d4:	f0 91 3a 06 	lds	r31, 0x063A
    76d8:	86 89       	ldd	r24, Z+22	; 0x16
    76da:	89 17       	cp	r24, r25
    76dc:	10 f4       	brcc	.+4      	; 0x76e2 <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    76de:	0e 94 5c 2d 	call	0x5ab8	; 0x5ab8 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    76e2:	0f 90       	pop	r0
    76e4:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    76e6:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    76e8:	2f 96       	adiw	r28, 0x0f	; 15
    76ea:	0f b6       	in	r0, 0x3f	; 63
    76ec:	f8 94       	cli
    76ee:	de bf       	out	0x3e, r29	; 62
    76f0:	0f be       	out	0x3f, r0	; 63
    76f2:	cd bf       	out	0x3d, r28	; 61
    76f4:	cf 91       	pop	r28
    76f6:	df 91       	pop	r29
    76f8:	1f 91       	pop	r17
    76fa:	0f 91       	pop	r16
    76fc:	08 95       	ret

000076fe <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    76fe:	ef 92       	push	r14
    7700:	ff 92       	push	r15
    7702:	0f 93       	push	r16
    7704:	1f 93       	push	r17
    7706:	df 93       	push	r29
    7708:	cf 93       	push	r28
    770a:	cd b7       	in	r28, 0x3d	; 61
    770c:	de b7       	in	r29, 0x3e	; 62
    770e:	62 97       	sbiw	r28, 0x12	; 18
    7710:	0f b6       	in	r0, 0x3f	; 63
    7712:	f8 94       	cli
    7714:	de bf       	out	0x3e, r29	; 62
    7716:	0f be       	out	0x3f, r0	; 63
    7718:	cd bf       	out	0x3d, r28	; 61
    771a:	9f 83       	std	Y+7, r25	; 0x07
    771c:	8e 83       	std	Y+6, r24	; 0x06
    771e:	48 87       	std	Y+8, r20	; 0x08
    7720:	59 87       	std	Y+9, r21	; 0x09
    7722:	6a 87       	std	Y+10, r22	; 0x0a
    7724:	7b 87       	std	Y+11, r23	; 0x0b
    7726:	2c 87       	std	Y+12, r18	; 0x0c
    7728:	1e 87       	std	Y+14, r17	; 0x0e
    772a:	0d 87       	std	Y+13, r16	; 0x0d
    772c:	f8 8a       	std	Y+16, r15	; 0x10
    772e:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    7730:	81 e0       	ldi	r24, 0x01	; 1
    7732:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    7734:	8e 81       	ldd	r24, Y+6	; 0x06
    7736:	9f 81       	ldd	r25, Y+7	; 0x07
    7738:	9d 83       	std	Y+5, r25	; 0x05
    773a:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    773c:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    773e:	8d 85       	ldd	r24, Y+13	; 0x0d
    7740:	9e 85       	ldd	r25, Y+14	; 0x0e
    7742:	00 97       	sbiw	r24, 0x00	; 0
    7744:	61 f0       	breq	.+24     	; 0x775e <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    7746:	ec 81       	ldd	r30, Y+4	; 0x04
    7748:	fd 81       	ldd	r31, Y+5	; 0x05
    774a:	83 a1       	ldd	r24, Z+35	; 0x23
    774c:	94 a1       	ldd	r25, Z+36	; 0x24
    774e:	a5 a1       	ldd	r26, Z+37	; 0x25
    7750:	b6 a1       	ldd	r27, Z+38	; 0x26
    7752:	ed 85       	ldd	r30, Y+13	; 0x0d
    7754:	fe 85       	ldd	r31, Y+14	; 0x0e
    7756:	80 83       	st	Z, r24
    7758:	91 83       	std	Z+1, r25	; 0x01
    775a:	a2 83       	std	Z+2, r26	; 0x02
    775c:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    775e:	ec 81       	ldd	r30, Y+4	; 0x04
    7760:	fd 81       	ldd	r31, Y+5	; 0x05
    7762:	87 a1       	ldd	r24, Z+39	; 0x27
    7764:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    7766:	ec 81       	ldd	r30, Y+4	; 0x04
    7768:	fd 81       	ldd	r31, Y+5	; 0x05
    776a:	82 e0       	ldi	r24, 0x02	; 2
    776c:	87 a3       	std	Z+39, r24	; 0x27

			switch( eAction )
    776e:	8c 85       	ldd	r24, Y+12	; 0x0c
    7770:	28 2f       	mov	r18, r24
    7772:	30 e0       	ldi	r19, 0x00	; 0
    7774:	3a 8b       	std	Y+18, r19	; 0x12
    7776:	29 8b       	std	Y+17, r18	; 0x11
    7778:	89 89       	ldd	r24, Y+17	; 0x11
    777a:	9a 89       	ldd	r25, Y+18	; 0x12
    777c:	82 30       	cpi	r24, 0x02	; 2
    777e:	91 05       	cpc	r25, r1
    7780:	59 f1       	breq	.+86     	; 0x77d8 <xTaskGenericNotifyFromISR+0xda>
    7782:	29 89       	ldd	r18, Y+17	; 0x11
    7784:	3a 89       	ldd	r19, Y+18	; 0x12
    7786:	23 30       	cpi	r18, 0x03	; 3
    7788:	31 05       	cpc	r19, r1
    778a:	34 f4       	brge	.+12     	; 0x7798 <xTaskGenericNotifyFromISR+0x9a>
    778c:	89 89       	ldd	r24, Y+17	; 0x11
    778e:	9a 89       	ldd	r25, Y+18	; 0x12
    7790:	81 30       	cpi	r24, 0x01	; 1
    7792:	91 05       	cpc	r25, r1
    7794:	61 f0       	breq	.+24     	; 0x77ae <xTaskGenericNotifyFromISR+0xb0>
    7796:	4a c0       	rjmp	.+148    	; 0x782c <xTaskGenericNotifyFromISR+0x12e>
    7798:	29 89       	ldd	r18, Y+17	; 0x11
    779a:	3a 89       	ldd	r19, Y+18	; 0x12
    779c:	23 30       	cpi	r18, 0x03	; 3
    779e:	31 05       	cpc	r19, r1
    77a0:	59 f1       	breq	.+86     	; 0x77f8 <xTaskGenericNotifyFromISR+0xfa>
    77a2:	89 89       	ldd	r24, Y+17	; 0x11
    77a4:	9a 89       	ldd	r25, Y+18	; 0x12
    77a6:	84 30       	cpi	r24, 0x04	; 4
    77a8:	91 05       	cpc	r25, r1
    77aa:	89 f1       	breq	.+98     	; 0x780e <xTaskGenericNotifyFromISR+0x110>
    77ac:	3f c0       	rjmp	.+126    	; 0x782c <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    77ae:	ec 81       	ldd	r30, Y+4	; 0x04
    77b0:	fd 81       	ldd	r31, Y+5	; 0x05
    77b2:	23 a1       	ldd	r18, Z+35	; 0x23
    77b4:	34 a1       	ldd	r19, Z+36	; 0x24
    77b6:	45 a1       	ldd	r20, Z+37	; 0x25
    77b8:	56 a1       	ldd	r21, Z+38	; 0x26
    77ba:	88 85       	ldd	r24, Y+8	; 0x08
    77bc:	99 85       	ldd	r25, Y+9	; 0x09
    77be:	aa 85       	ldd	r26, Y+10	; 0x0a
    77c0:	bb 85       	ldd	r27, Y+11	; 0x0b
    77c2:	82 2b       	or	r24, r18
    77c4:	93 2b       	or	r25, r19
    77c6:	a4 2b       	or	r26, r20
    77c8:	b5 2b       	or	r27, r21
    77ca:	ec 81       	ldd	r30, Y+4	; 0x04
    77cc:	fd 81       	ldd	r31, Y+5	; 0x05
    77ce:	83 a3       	std	Z+35, r24	; 0x23
    77d0:	94 a3       	std	Z+36, r25	; 0x24
    77d2:	a5 a3       	std	Z+37, r26	; 0x25
    77d4:	b6 a3       	std	Z+38, r27	; 0x26
    77d6:	2a c0       	rjmp	.+84     	; 0x782c <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    77d8:	ec 81       	ldd	r30, Y+4	; 0x04
    77da:	fd 81       	ldd	r31, Y+5	; 0x05
    77dc:	83 a1       	ldd	r24, Z+35	; 0x23
    77de:	94 a1       	ldd	r25, Z+36	; 0x24
    77e0:	a5 a1       	ldd	r26, Z+37	; 0x25
    77e2:	b6 a1       	ldd	r27, Z+38	; 0x26
    77e4:	01 96       	adiw	r24, 0x01	; 1
    77e6:	a1 1d       	adc	r26, r1
    77e8:	b1 1d       	adc	r27, r1
    77ea:	ec 81       	ldd	r30, Y+4	; 0x04
    77ec:	fd 81       	ldd	r31, Y+5	; 0x05
    77ee:	83 a3       	std	Z+35, r24	; 0x23
    77f0:	94 a3       	std	Z+36, r25	; 0x24
    77f2:	a5 a3       	std	Z+37, r26	; 0x25
    77f4:	b6 a3       	std	Z+38, r27	; 0x26
    77f6:	1a c0       	rjmp	.+52     	; 0x782c <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    77f8:	ec 81       	ldd	r30, Y+4	; 0x04
    77fa:	fd 81       	ldd	r31, Y+5	; 0x05
    77fc:	88 85       	ldd	r24, Y+8	; 0x08
    77fe:	99 85       	ldd	r25, Y+9	; 0x09
    7800:	aa 85       	ldd	r26, Y+10	; 0x0a
    7802:	bb 85       	ldd	r27, Y+11	; 0x0b
    7804:	83 a3       	std	Z+35, r24	; 0x23
    7806:	94 a3       	std	Z+36, r25	; 0x24
    7808:	a5 a3       	std	Z+37, r26	; 0x25
    780a:	b6 a3       	std	Z+38, r27	; 0x26
    780c:	0f c0       	rjmp	.+30     	; 0x782c <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    780e:	8b 81       	ldd	r24, Y+3	; 0x03
    7810:	82 30       	cpi	r24, 0x02	; 2
    7812:	59 f0       	breq	.+22     	; 0x782a <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    7814:	ec 81       	ldd	r30, Y+4	; 0x04
    7816:	fd 81       	ldd	r31, Y+5	; 0x05
    7818:	88 85       	ldd	r24, Y+8	; 0x08
    781a:	99 85       	ldd	r25, Y+9	; 0x09
    781c:	aa 85       	ldd	r26, Y+10	; 0x0a
    781e:	bb 85       	ldd	r27, Y+11	; 0x0b
    7820:	83 a3       	std	Z+35, r24	; 0x23
    7822:	94 a3       	std	Z+36, r25	; 0x24
    7824:	a5 a3       	std	Z+37, r26	; 0x25
    7826:	b6 a3       	std	Z+38, r27	; 0x26
    7828:	01 c0       	rjmp	.+2      	; 0x782c <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    782a:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    782c:	8b 81       	ldd	r24, Y+3	; 0x03
    782e:	81 30       	cpi	r24, 0x01	; 1
    7830:	09 f0       	breq	.+2      	; 0x7834 <xTaskGenericNotifyFromISR+0x136>
    7832:	50 c0       	rjmp	.+160    	; 0x78d4 <xTaskGenericNotifyFromISR+0x1d6>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    7834:	80 91 49 06 	lds	r24, 0x0649
    7838:	88 23       	and	r24, r24
    783a:	61 f5       	brne	.+88     	; 0x7894 <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    783c:	8c 81       	ldd	r24, Y+4	; 0x04
    783e:	9d 81       	ldd	r25, Y+5	; 0x05
    7840:	02 96       	adiw	r24, 0x02	; 2
    7842:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    7846:	ec 81       	ldd	r30, Y+4	; 0x04
    7848:	fd 81       	ldd	r31, Y+5	; 0x05
    784a:	96 89       	ldd	r25, Z+22	; 0x16
    784c:	80 91 3f 06 	lds	r24, 0x063F
    7850:	89 17       	cp	r24, r25
    7852:	28 f4       	brcc	.+10     	; 0x785e <xTaskGenericNotifyFromISR+0x160>
    7854:	ec 81       	ldd	r30, Y+4	; 0x04
    7856:	fd 81       	ldd	r31, Y+5	; 0x05
    7858:	86 89       	ldd	r24, Z+22	; 0x16
    785a:	80 93 3f 06 	sts	0x063F, r24
    785e:	ec 81       	ldd	r30, Y+4	; 0x04
    7860:	fd 81       	ldd	r31, Y+5	; 0x05
    7862:	86 89       	ldd	r24, Z+22	; 0x16
    7864:	28 2f       	mov	r18, r24
    7866:	30 e0       	ldi	r19, 0x00	; 0
    7868:	c9 01       	movw	r24, r18
    786a:	88 0f       	add	r24, r24
    786c:	99 1f       	adc	r25, r25
    786e:	88 0f       	add	r24, r24
    7870:	99 1f       	adc	r25, r25
    7872:	88 0f       	add	r24, r24
    7874:	99 1f       	adc	r25, r25
    7876:	82 0f       	add	r24, r18
    7878:	93 1f       	adc	r25, r19
    787a:	ac 01       	movw	r20, r24
    787c:	46 5b       	subi	r20, 0xB6	; 182
    787e:	59 4f       	sbci	r21, 0xF9	; 249
    7880:	8c 81       	ldd	r24, Y+4	; 0x04
    7882:	9d 81       	ldd	r25, Y+5	; 0x05
    7884:	9c 01       	movw	r18, r24
    7886:	2e 5f       	subi	r18, 0xFE	; 254
    7888:	3f 4f       	sbci	r19, 0xFF	; 255
    788a:	ca 01       	movw	r24, r20
    788c:	b9 01       	movw	r22, r18
    788e:	0e 94 a1 2a 	call	0x5542	; 0x5542 <vListInsertEnd>
    7892:	0a c0       	rjmp	.+20     	; 0x78a8 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    7894:	8c 81       	ldd	r24, Y+4	; 0x04
    7896:	9d 81       	ldd	r25, Y+5	; 0x05
    7898:	9c 01       	movw	r18, r24
    789a:	24 5f       	subi	r18, 0xF4	; 244
    789c:	3f 4f       	sbci	r19, 0xFF	; 255
    789e:	81 eb       	ldi	r24, 0xB1	; 177
    78a0:	96 e0       	ldi	r25, 0x06	; 6
    78a2:	b9 01       	movw	r22, r18
    78a4:	0e 94 a1 2a 	call	0x5542	; 0x5542 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    78a8:	ec 81       	ldd	r30, Y+4	; 0x04
    78aa:	fd 81       	ldd	r31, Y+5	; 0x05
    78ac:	96 89       	ldd	r25, Z+22	; 0x16
    78ae:	e0 91 39 06 	lds	r30, 0x0639
    78b2:	f0 91 3a 06 	lds	r31, 0x063A
    78b6:	86 89       	ldd	r24, Z+22	; 0x16
    78b8:	89 17       	cp	r24, r25
    78ba:	60 f4       	brcc	.+24     	; 0x78d4 <xTaskGenericNotifyFromISR+0x1d6>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    78bc:	8f 85       	ldd	r24, Y+15	; 0x0f
    78be:	98 89       	ldd	r25, Y+16	; 0x10
    78c0:	00 97       	sbiw	r24, 0x00	; 0
    78c2:	29 f0       	breq	.+10     	; 0x78ce <xTaskGenericNotifyFromISR+0x1d0>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    78c4:	ef 85       	ldd	r30, Y+15	; 0x0f
    78c6:	f8 89       	ldd	r31, Y+16	; 0x10
    78c8:	81 e0       	ldi	r24, 0x01	; 1
    78ca:	80 83       	st	Z, r24
    78cc:	03 c0       	rjmp	.+6      	; 0x78d4 <xTaskGenericNotifyFromISR+0x1d6>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    78ce:	81 e0       	ldi	r24, 0x01	; 1
    78d0:	80 93 42 06 	sts	0x0642, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    78d4:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    78d6:	62 96       	adiw	r28, 0x12	; 18
    78d8:	0f b6       	in	r0, 0x3f	; 63
    78da:	f8 94       	cli
    78dc:	de bf       	out	0x3e, r29	; 62
    78de:	0f be       	out	0x3f, r0	; 63
    78e0:	cd bf       	out	0x3d, r28	; 61
    78e2:	cf 91       	pop	r28
    78e4:	df 91       	pop	r29
    78e6:	1f 91       	pop	r17
    78e8:	0f 91       	pop	r16
    78ea:	ff 90       	pop	r15
    78ec:	ef 90       	pop	r14
    78ee:	08 95       	ret

000078f0 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    78f0:	df 93       	push	r29
    78f2:	cf 93       	push	r28
    78f4:	cd b7       	in	r28, 0x3d	; 61
    78f6:	de b7       	in	r29, 0x3e	; 62
    78f8:	28 97       	sbiw	r28, 0x08	; 8
    78fa:	0f b6       	in	r0, 0x3f	; 63
    78fc:	f8 94       	cli
    78fe:	de bf       	out	0x3e, r29	; 62
    7900:	0f be       	out	0x3f, r0	; 63
    7902:	cd bf       	out	0x3d, r28	; 61
    7904:	9e 83       	std	Y+6, r25	; 0x06
    7906:	8d 83       	std	Y+5, r24	; 0x05
    7908:	78 87       	std	Y+8, r23	; 0x08
    790a:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    790c:	8d 81       	ldd	r24, Y+5	; 0x05
    790e:	9e 81       	ldd	r25, Y+6	; 0x06
    7910:	9c 83       	std	Y+4, r25	; 0x04
    7912:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    7914:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    7916:	eb 81       	ldd	r30, Y+3	; 0x03
    7918:	fc 81       	ldd	r31, Y+4	; 0x04
    791a:	87 a1       	ldd	r24, Z+39	; 0x27
    791c:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    791e:	eb 81       	ldd	r30, Y+3	; 0x03
    7920:	fc 81       	ldd	r31, Y+4	; 0x04
    7922:	82 e0       	ldi	r24, 0x02	; 2
    7924:	87 a3       	std	Z+39, r24	; 0x27

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    7926:	eb 81       	ldd	r30, Y+3	; 0x03
    7928:	fc 81       	ldd	r31, Y+4	; 0x04
    792a:	83 a1       	ldd	r24, Z+35	; 0x23
    792c:	94 a1       	ldd	r25, Z+36	; 0x24
    792e:	a5 a1       	ldd	r26, Z+37	; 0x25
    7930:	b6 a1       	ldd	r27, Z+38	; 0x26
    7932:	01 96       	adiw	r24, 0x01	; 1
    7934:	a1 1d       	adc	r26, r1
    7936:	b1 1d       	adc	r27, r1
    7938:	eb 81       	ldd	r30, Y+3	; 0x03
    793a:	fc 81       	ldd	r31, Y+4	; 0x04
    793c:	83 a3       	std	Z+35, r24	; 0x23
    793e:	94 a3       	std	Z+36, r25	; 0x24
    7940:	a5 a3       	std	Z+37, r26	; 0x25
    7942:	b6 a3       	std	Z+38, r27	; 0x26

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    7944:	8a 81       	ldd	r24, Y+2	; 0x02
    7946:	81 30       	cpi	r24, 0x01	; 1
    7948:	09 f0       	breq	.+2      	; 0x794c <vTaskNotifyGiveFromISR+0x5c>
    794a:	50 c0       	rjmp	.+160    	; 0x79ec <vTaskNotifyGiveFromISR+0xfc>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    794c:	80 91 49 06 	lds	r24, 0x0649
    7950:	88 23       	and	r24, r24
    7952:	61 f5       	brne	.+88     	; 0x79ac <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    7954:	8b 81       	ldd	r24, Y+3	; 0x03
    7956:	9c 81       	ldd	r25, Y+4	; 0x04
    7958:	02 96       	adiw	r24, 0x02	; 2
    795a:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    795e:	eb 81       	ldd	r30, Y+3	; 0x03
    7960:	fc 81       	ldd	r31, Y+4	; 0x04
    7962:	96 89       	ldd	r25, Z+22	; 0x16
    7964:	80 91 3f 06 	lds	r24, 0x063F
    7968:	89 17       	cp	r24, r25
    796a:	28 f4       	brcc	.+10     	; 0x7976 <vTaskNotifyGiveFromISR+0x86>
    796c:	eb 81       	ldd	r30, Y+3	; 0x03
    796e:	fc 81       	ldd	r31, Y+4	; 0x04
    7970:	86 89       	ldd	r24, Z+22	; 0x16
    7972:	80 93 3f 06 	sts	0x063F, r24
    7976:	eb 81       	ldd	r30, Y+3	; 0x03
    7978:	fc 81       	ldd	r31, Y+4	; 0x04
    797a:	86 89       	ldd	r24, Z+22	; 0x16
    797c:	28 2f       	mov	r18, r24
    797e:	30 e0       	ldi	r19, 0x00	; 0
    7980:	c9 01       	movw	r24, r18
    7982:	88 0f       	add	r24, r24
    7984:	99 1f       	adc	r25, r25
    7986:	88 0f       	add	r24, r24
    7988:	99 1f       	adc	r25, r25
    798a:	88 0f       	add	r24, r24
    798c:	99 1f       	adc	r25, r25
    798e:	82 0f       	add	r24, r18
    7990:	93 1f       	adc	r25, r19
    7992:	ac 01       	movw	r20, r24
    7994:	46 5b       	subi	r20, 0xB6	; 182
    7996:	59 4f       	sbci	r21, 0xF9	; 249
    7998:	8b 81       	ldd	r24, Y+3	; 0x03
    799a:	9c 81       	ldd	r25, Y+4	; 0x04
    799c:	9c 01       	movw	r18, r24
    799e:	2e 5f       	subi	r18, 0xFE	; 254
    79a0:	3f 4f       	sbci	r19, 0xFF	; 255
    79a2:	ca 01       	movw	r24, r20
    79a4:	b9 01       	movw	r22, r18
    79a6:	0e 94 a1 2a 	call	0x5542	; 0x5542 <vListInsertEnd>
    79aa:	0a c0       	rjmp	.+20     	; 0x79c0 <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    79ac:	8b 81       	ldd	r24, Y+3	; 0x03
    79ae:	9c 81       	ldd	r25, Y+4	; 0x04
    79b0:	9c 01       	movw	r18, r24
    79b2:	24 5f       	subi	r18, 0xF4	; 244
    79b4:	3f 4f       	sbci	r19, 0xFF	; 255
    79b6:	81 eb       	ldi	r24, 0xB1	; 177
    79b8:	96 e0       	ldi	r25, 0x06	; 6
    79ba:	b9 01       	movw	r22, r18
    79bc:	0e 94 a1 2a 	call	0x5542	; 0x5542 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    79c0:	eb 81       	ldd	r30, Y+3	; 0x03
    79c2:	fc 81       	ldd	r31, Y+4	; 0x04
    79c4:	96 89       	ldd	r25, Z+22	; 0x16
    79c6:	e0 91 39 06 	lds	r30, 0x0639
    79ca:	f0 91 3a 06 	lds	r31, 0x063A
    79ce:	86 89       	ldd	r24, Z+22	; 0x16
    79d0:	89 17       	cp	r24, r25
    79d2:	60 f4       	brcc	.+24     	; 0x79ec <vTaskNotifyGiveFromISR+0xfc>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    79d4:	8f 81       	ldd	r24, Y+7	; 0x07
    79d6:	98 85       	ldd	r25, Y+8	; 0x08
    79d8:	00 97       	sbiw	r24, 0x00	; 0
    79da:	29 f0       	breq	.+10     	; 0x79e6 <vTaskNotifyGiveFromISR+0xf6>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    79dc:	ef 81       	ldd	r30, Y+7	; 0x07
    79de:	f8 85       	ldd	r31, Y+8	; 0x08
    79e0:	81 e0       	ldi	r24, 0x01	; 1
    79e2:	80 83       	st	Z, r24
    79e4:	03 c0       	rjmp	.+6      	; 0x79ec <vTaskNotifyGiveFromISR+0xfc>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    79e6:	81 e0       	ldi	r24, 0x01	; 1
    79e8:	80 93 42 06 	sts	0x0642, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    79ec:	28 96       	adiw	r28, 0x08	; 8
    79ee:	0f b6       	in	r0, 0x3f	; 63
    79f0:	f8 94       	cli
    79f2:	de bf       	out	0x3e, r29	; 62
    79f4:	0f be       	out	0x3f, r0	; 63
    79f6:	cd bf       	out	0x3d, r28	; 61
    79f8:	cf 91       	pop	r28
    79fa:	df 91       	pop	r29
    79fc:	08 95       	ret

000079fe <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    79fe:	df 93       	push	r29
    7a00:	cf 93       	push	r28
    7a02:	cd b7       	in	r28, 0x3d	; 61
    7a04:	de b7       	in	r29, 0x3e	; 62
    7a06:	27 97       	sbiw	r28, 0x07	; 7
    7a08:	0f b6       	in	r0, 0x3f	; 63
    7a0a:	f8 94       	cli
    7a0c:	de bf       	out	0x3e, r29	; 62
    7a0e:	0f be       	out	0x3f, r0	; 63
    7a10:	cd bf       	out	0x3d, r28	; 61
    7a12:	9d 83       	std	Y+5, r25	; 0x05
    7a14:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    7a16:	8c 81       	ldd	r24, Y+4	; 0x04
    7a18:	9d 81       	ldd	r25, Y+5	; 0x05
    7a1a:	00 97       	sbiw	r24, 0x00	; 0
    7a1c:	39 f4       	brne	.+14     	; 0x7a2c <xTaskNotifyStateClear+0x2e>
    7a1e:	80 91 39 06 	lds	r24, 0x0639
    7a22:	90 91 3a 06 	lds	r25, 0x063A
    7a26:	9f 83       	std	Y+7, r25	; 0x07
    7a28:	8e 83       	std	Y+6, r24	; 0x06
    7a2a:	04 c0       	rjmp	.+8      	; 0x7a34 <xTaskNotifyStateClear+0x36>
    7a2c:	8c 81       	ldd	r24, Y+4	; 0x04
    7a2e:	9d 81       	ldd	r25, Y+5	; 0x05
    7a30:	9f 83       	std	Y+7, r25	; 0x07
    7a32:	8e 83       	std	Y+6, r24	; 0x06
    7a34:	8e 81       	ldd	r24, Y+6	; 0x06
    7a36:	9f 81       	ldd	r25, Y+7	; 0x07
    7a38:	9b 83       	std	Y+3, r25	; 0x03
    7a3a:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    7a3c:	0f b6       	in	r0, 0x3f	; 63
    7a3e:	f8 94       	cli
    7a40:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    7a42:	ea 81       	ldd	r30, Y+2	; 0x02
    7a44:	fb 81       	ldd	r31, Y+3	; 0x03
    7a46:	87 a1       	ldd	r24, Z+39	; 0x27
    7a48:	82 30       	cpi	r24, 0x02	; 2
    7a4a:	31 f4       	brne	.+12     	; 0x7a58 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    7a4c:	ea 81       	ldd	r30, Y+2	; 0x02
    7a4e:	fb 81       	ldd	r31, Y+3	; 0x03
    7a50:	17 a2       	std	Z+39, r1	; 0x27
				xReturn = pdPASS;
    7a52:	81 e0       	ldi	r24, 0x01	; 1
    7a54:	89 83       	std	Y+1, r24	; 0x01
    7a56:	01 c0       	rjmp	.+2      	; 0x7a5a <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    7a58:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    7a5a:	0f 90       	pop	r0
    7a5c:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    7a5e:	89 81       	ldd	r24, Y+1	; 0x01
	}
    7a60:	27 96       	adiw	r28, 0x07	; 7
    7a62:	0f b6       	in	r0, 0x3f	; 63
    7a64:	f8 94       	cli
    7a66:	de bf       	out	0x3e, r29	; 62
    7a68:	0f be       	out	0x3f, r0	; 63
    7a6a:	cd bf       	out	0x3d, r28	; 61
    7a6c:	cf 91       	pop	r28
    7a6e:	df 91       	pop	r29
    7a70:	08 95       	ret

00007a72 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    7a72:	df 93       	push	r29
    7a74:	cf 93       	push	r28
    7a76:	cd b7       	in	r28, 0x3d	; 61
    7a78:	de b7       	in	r29, 0x3e	; 62
    7a7a:	27 97       	sbiw	r28, 0x07	; 7
    7a7c:	0f b6       	in	r0, 0x3f	; 63
    7a7e:	f8 94       	cli
    7a80:	de bf       	out	0x3e, r29	; 62
    7a82:	0f be       	out	0x3f, r0	; 63
    7a84:	cd bf       	out	0x3d, r28	; 61
    7a86:	9e 83       	std	Y+6, r25	; 0x06
    7a88:	8d 83       	std	Y+5, r24	; 0x05
    7a8a:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    7a8c:	80 91 3d 06 	lds	r24, 0x063D
    7a90:	90 91 3e 06 	lds	r25, 0x063E
    7a94:	9a 83       	std	Y+2, r25	; 0x02
    7a96:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    7a98:	80 91 39 06 	lds	r24, 0x0639
    7a9c:	90 91 3a 06 	lds	r25, 0x063A
    7aa0:	02 96       	adiw	r24, 0x02	; 2
    7aa2:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    7aa6:	8d 81       	ldd	r24, Y+5	; 0x05
    7aa8:	9e 81       	ldd	r25, Y+6	; 0x06
    7aaa:	2f ef       	ldi	r18, 0xFF	; 255
    7aac:	8f 3f       	cpi	r24, 0xFF	; 255
    7aae:	92 07       	cpc	r25, r18
    7ab0:	81 f4       	brne	.+32     	; 0x7ad2 <prvAddCurrentTaskToDelayedList+0x60>
    7ab2:	8f 81       	ldd	r24, Y+7	; 0x07
    7ab4:	88 23       	and	r24, r24
    7ab6:	69 f0       	breq	.+26     	; 0x7ad2 <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    7ab8:	80 91 39 06 	lds	r24, 0x0639
    7abc:	90 91 3a 06 	lds	r25, 0x063A
    7ac0:	9c 01       	movw	r18, r24
    7ac2:	2e 5f       	subi	r18, 0xFE	; 254
    7ac4:	3f 4f       	sbci	r19, 0xFF	; 255
    7ac6:	83 ec       	ldi	r24, 0xC3	; 195
    7ac8:	96 e0       	ldi	r25, 0x06	; 6
    7aca:	b9 01       	movw	r22, r18
    7acc:	0e 94 a1 2a 	call	0x5542	; 0x5542 <vListInsertEnd>
    7ad0:	43 c0       	rjmp	.+134    	; 0x7b58 <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    7ad2:	29 81       	ldd	r18, Y+1	; 0x01
    7ad4:	3a 81       	ldd	r19, Y+2	; 0x02
    7ad6:	8d 81       	ldd	r24, Y+5	; 0x05
    7ad8:	9e 81       	ldd	r25, Y+6	; 0x06
    7ada:	82 0f       	add	r24, r18
    7adc:	93 1f       	adc	r25, r19
    7ade:	9c 83       	std	Y+4, r25	; 0x04
    7ae0:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    7ae2:	e0 91 39 06 	lds	r30, 0x0639
    7ae6:	f0 91 3a 06 	lds	r31, 0x063A
    7aea:	8b 81       	ldd	r24, Y+3	; 0x03
    7aec:	9c 81       	ldd	r25, Y+4	; 0x04
    7aee:	93 83       	std	Z+3, r25	; 0x03
    7af0:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    7af2:	2b 81       	ldd	r18, Y+3	; 0x03
    7af4:	3c 81       	ldd	r19, Y+4	; 0x04
    7af6:	89 81       	ldd	r24, Y+1	; 0x01
    7af8:	9a 81       	ldd	r25, Y+2	; 0x02
    7afa:	28 17       	cp	r18, r24
    7afc:	39 07       	cpc	r19, r25
    7afe:	70 f4       	brcc	.+28     	; 0x7b1c <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    7b00:	80 91 af 06 	lds	r24, 0x06AF
    7b04:	90 91 b0 06 	lds	r25, 0x06B0
    7b08:	20 91 39 06 	lds	r18, 0x0639
    7b0c:	30 91 3a 06 	lds	r19, 0x063A
    7b10:	2e 5f       	subi	r18, 0xFE	; 254
    7b12:	3f 4f       	sbci	r19, 0xFF	; 255
    7b14:	b9 01       	movw	r22, r18
    7b16:	0e 94 e5 2a 	call	0x55ca	; 0x55ca <vListInsert>
    7b1a:	1e c0       	rjmp	.+60     	; 0x7b58 <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    7b1c:	40 91 ad 06 	lds	r20, 0x06AD
    7b20:	50 91 ae 06 	lds	r21, 0x06AE
    7b24:	80 91 39 06 	lds	r24, 0x0639
    7b28:	90 91 3a 06 	lds	r25, 0x063A
    7b2c:	9c 01       	movw	r18, r24
    7b2e:	2e 5f       	subi	r18, 0xFE	; 254
    7b30:	3f 4f       	sbci	r19, 0xFF	; 255
    7b32:	ca 01       	movw	r24, r20
    7b34:	b9 01       	movw	r22, r18
    7b36:	0e 94 e5 2a 	call	0x55ca	; 0x55ca <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    7b3a:	20 91 45 06 	lds	r18, 0x0645
    7b3e:	30 91 46 06 	lds	r19, 0x0646
    7b42:	8b 81       	ldd	r24, Y+3	; 0x03
    7b44:	9c 81       	ldd	r25, Y+4	; 0x04
    7b46:	82 17       	cp	r24, r18
    7b48:	93 07       	cpc	r25, r19
    7b4a:	30 f4       	brcc	.+12     	; 0x7b58 <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    7b4c:	8b 81       	ldd	r24, Y+3	; 0x03
    7b4e:	9c 81       	ldd	r25, Y+4	; 0x04
    7b50:	90 93 46 06 	sts	0x0646, r25
    7b54:	80 93 45 06 	sts	0x0645, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    7b58:	27 96       	adiw	r28, 0x07	; 7
    7b5a:	0f b6       	in	r0, 0x3f	; 63
    7b5c:	f8 94       	cli
    7b5e:	de bf       	out	0x3e, r29	; 62
    7b60:	0f be       	out	0x3f, r0	; 63
    7b62:	cd bf       	out	0x3d, r28	; 61
    7b64:	cf 91       	pop	r28
    7b66:	df 91       	pop	r29
    7b68:	08 95       	ret

00007b6a <APP_Control_Car_Init>:
#include "Control_Car.h"
f32 Glob_f32distance = 0;
u8 Glob_u8Event = 'S';
void sensor(void *pt) ;
void lcd_display(void *ptr) ;
void APP_Control_Car_Init(void) {
    7b6a:	ef 92       	push	r14
    7b6c:	ff 92       	push	r15
    7b6e:	0f 93       	push	r16
    7b70:	df 93       	push	r29
    7b72:	cf 93       	push	r28
    7b74:	cd b7       	in	r28, 0x3d	; 61
    7b76:	de b7       	in	r29, 0x3e	; 62
	//Init Buzzer
	HAL_Buzzer_u8BuzzerInit(PortA, Pin3);
    7b78:	80 e0       	ldi	r24, 0x00	; 0
    7b7a:	63 e0       	ldi	r22, 0x03	; 3
    7b7c:	0e 94 76 28 	call	0x50ec	; 0x50ec <HAL_Buzzer_u8BuzzerInit>
	//Init LCD
	HAL_LCD_u8LCDInit();
    7b80:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <HAL_LCD_u8LCDInit>
	//Init Servo Motor
	HAL_SM_voidSMInit();
    7b84:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <HAL_SM_voidSMInit>
	//Init UltraSonic Sensor
	HAL_Ultrasonic_Sensor_voidInit();
    7b88:	0e 94 ca 19 	call	0x3394	; 0x3394 <HAL_Ultrasonic_Sensor_voidInit>
	//Init H_Bridge
	HAL_void_H_BridgeInit();
    7b8c:	0e 94 93 27 	call	0x4f26	; 0x4f26 <HAL_void_H_BridgeInit>
	//Leds
	HAL_LED_u8LedInit(PortA, Pin0);
    7b90:	80 e0       	ldi	r24, 0x00	; 0
    7b92:	60 e0       	ldi	r22, 0x00	; 0
    7b94:	0e 94 ea 1d 	call	0x3bd4	; 0x3bd4 <HAL_LED_u8LedInit>
	HAL_LED_u8LedInit(PortA, Pin1);
    7b98:	80 e0       	ldi	r24, 0x00	; 0
    7b9a:	61 e0       	ldi	r22, 0x01	; 1
    7b9c:	0e 94 ea 1d 	call	0x3bd4	; 0x3bd4 <HAL_LED_u8LedInit>
	//UART
	MCAL_UART_UARTInit();
    7ba0:	0e 94 a5 07 	call	0xf4a	; 0xf4a <MCAL_UART_UARTInit>
	//Free Rtos
	xTaskCreate(lcd_display, "lcd_display", 80, 0, 1, 0);
    7ba4:	87 e9       	ldi	r24, 0x97	; 151
    7ba6:	9e e3       	ldi	r25, 0x3E	; 62
    7ba8:	25 e6       	ldi	r18, 0x65	; 101
    7baa:	30 e0       	ldi	r19, 0x00	; 0
    7bac:	b9 01       	movw	r22, r18
    7bae:	40 e5       	ldi	r20, 0x50	; 80
    7bb0:	50 e0       	ldi	r21, 0x00	; 0
    7bb2:	20 e0       	ldi	r18, 0x00	; 0
    7bb4:	30 e0       	ldi	r19, 0x00	; 0
    7bb6:	01 e0       	ldi	r16, 0x01	; 1
    7bb8:	ee 24       	eor	r14, r14
    7bba:	ff 24       	eor	r15, r15
    7bbc:	0e 94 71 2e 	call	0x5ce2	; 0x5ce2 <xTaskCreate>
	xTaskCreate(sensor, "sensor", 80, 0, 1, 0);
    7bc0:	8f e1       	ldi	r24, 0x1F	; 31
    7bc2:	92 e4       	ldi	r25, 0x42	; 66
    7bc4:	21 e7       	ldi	r18, 0x71	; 113
    7bc6:	30 e0       	ldi	r19, 0x00	; 0
    7bc8:	b9 01       	movw	r22, r18
    7bca:	40 e5       	ldi	r20, 0x50	; 80
    7bcc:	50 e0       	ldi	r21, 0x00	; 0
    7bce:	20 e0       	ldi	r18, 0x00	; 0
    7bd0:	30 e0       	ldi	r19, 0x00	; 0
    7bd2:	01 e0       	ldi	r16, 0x01	; 1
    7bd4:	ee 24       	eor	r14, r14
    7bd6:	ff 24       	eor	r15, r15
    7bd8:	0e 94 71 2e 	call	0x5ce2	; 0x5ce2 <xTaskCreate>
	vTaskStartScheduler();
    7bdc:	0e 94 51 33 	call	0x66a2	; 0x66a2 <vTaskStartScheduler>
}
    7be0:	cf 91       	pop	r28
    7be2:	df 91       	pop	r29
    7be4:	0f 91       	pop	r16
    7be6:	ff 90       	pop	r15
    7be8:	ef 90       	pop	r14
    7bea:	08 95       	ret

00007bec <APP_Control_Car_App>:
void APP_Control_Car_App(void) {
    7bec:	df 93       	push	r29
    7bee:	cf 93       	push	r28
    7bf0:	cd b7       	in	r28, 0x3d	; 61
    7bf2:	de b7       	in	r29, 0x3e	; 62

	//	Initially Set Servo Angle 90
	HAL_SM_voidSMSetAngle(START_ANGLE);
    7bf4:	8a e5       	ldi	r24, 0x5A	; 90
    7bf6:	0e 94 f1 1b 	call	0x37e2	; 0x37e2 <HAL_SM_voidSMSetAngle>
	//Light Front LEDS
	HAL_LED_u8LedMode(PortA, Pin0, LED_ON);
    7bfa:	80 e0       	ldi	r24, 0x00	; 0
    7bfc:	60 e0       	ldi	r22, 0x00	; 0
    7bfe:	41 e0       	ldi	r20, 0x01	; 1
    7c00:	0e 94 07 1e 	call	0x3c0e	; 0x3c0e <HAL_LED_u8LedMode>
	while (1) {
		MCAL_UART_UARTReceive(&Glob_u8Event);
    7c04:	8a e2       	ldi	r24, 0x2A	; 42
    7c06:	92 e0       	ldi	r25, 0x02	; 2
    7c08:	0e 94 f3 07 	call	0xfe6	; 0xfe6 <MCAL_UART_UARTReceive>
		if (Glob_u8Event == 'F') {
    7c0c:	80 91 2a 02 	lds	r24, 0x022A
    7c10:	86 34       	cpi	r24, 0x46	; 70
    7c12:	21 f5       	brne	.+72     	; 0x7c5c <APP_Control_Car_App+0x70>
			if(Glob_f32distance>30){
    7c14:	80 91 cc 06 	lds	r24, 0x06CC
    7c18:	90 91 cd 06 	lds	r25, 0x06CD
    7c1c:	a0 91 ce 06 	lds	r26, 0x06CE
    7c20:	b0 91 cf 06 	lds	r27, 0x06CF
    7c24:	bc 01       	movw	r22, r24
    7c26:	cd 01       	movw	r24, r26
    7c28:	20 e0       	ldi	r18, 0x00	; 0
    7c2a:	30 e0       	ldi	r19, 0x00	; 0
    7c2c:	40 ef       	ldi	r20, 0xF0	; 240
    7c2e:	51 e4       	ldi	r21, 0x41	; 65
    7c30:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    7c34:	18 16       	cp	r1, r24
    7c36:	74 f4       	brge	.+28     	; 0x7c54 <APP_Control_Car_App+0x68>
			HAL_LED_u8LedMode(PortA, Pin0, LED_ON);
    7c38:	80 e0       	ldi	r24, 0x00	; 0
    7c3a:	60 e0       	ldi	r22, 0x00	; 0
    7c3c:	41 e0       	ldi	r20, 0x01	; 1
    7c3e:	0e 94 07 1e 	call	0x3c0e	; 0x3c0e <HAL_LED_u8LedMode>
			HAL_LED_u8LedMode(PortA, Pin1, LED_OFF);
    7c42:	80 e0       	ldi	r24, 0x00	; 0
    7c44:	61 e0       	ldi	r22, 0x01	; 1
    7c46:	40 e0       	ldi	r20, 0x00	; 0
    7c48:	0e 94 07 1e 	call	0x3c0e	; 0x3c0e <HAL_LED_u8LedMode>
			HAL_void_H_BridgeFront(MAX_SPEED);
    7c4c:	83 e6       	ldi	r24, 0x63	; 99
    7c4e:	0e 94 d4 27 	call	0x4fa8	; 0x4fa8 <HAL_void_H_BridgeFront>
    7c52:	d8 cf       	rjmp	.-80     	; 0x7c04 <APP_Control_Car_App+0x18>
			}else{
				HAL_void_H_BridgeStop(NUM0);
    7c54:	80 e0       	ldi	r24, 0x00	; 0
    7c56:	0e 94 50 28 	call	0x50a0	; 0x50a0 <HAL_void_H_BridgeStop>
    7c5a:	d4 cf       	rjmp	.-88     	; 0x7c04 <APP_Control_Car_App+0x18>
			}
		} else if (Glob_u8Event == 'B') {
    7c5c:	80 91 2a 02 	lds	r24, 0x022A
    7c60:	82 34       	cpi	r24, 0x42	; 66
    7c62:	49 f4       	brne	.+18     	; 0x7c76 <APP_Control_Car_App+0x8a>
			HAL_void_H_BridgeBack(MAX_SPEED);
    7c64:	83 e6       	ldi	r24, 0x63	; 99
    7c66:	0e 94 04 28 	call	0x5008	; 0x5008 <HAL_void_H_BridgeBack>
			HAL_LED_u8LedMode(PortA, Pin1, LED_ON);
    7c6a:	80 e0       	ldi	r24, 0x00	; 0
    7c6c:	61 e0       	ldi	r22, 0x01	; 1
    7c6e:	41 e0       	ldi	r20, 0x01	; 1
    7c70:	0e 94 07 1e 	call	0x3c0e	; 0x3c0e <HAL_LED_u8LedMode>
    7c74:	c7 cf       	rjmp	.-114    	; 0x7c04 <APP_Control_Car_App+0x18>
		} else if (Glob_u8Event == 'L') {
    7c76:	80 91 2a 02 	lds	r24, 0x022A
    7c7a:	8c 34       	cpi	r24, 0x4C	; 76
    7c7c:	21 f4       	brne	.+8      	; 0x7c86 <APP_Control_Car_App+0x9a>
			HAL_void_H_BridgeCCW(MAX_SPEED);
    7c7e:	83 e6       	ldi	r24, 0x63	; 99
    7c80:	0e 94 2a 28 	call	0x5054	; 0x5054 <HAL_void_H_BridgeCCW>
    7c84:	bf cf       	rjmp	.-130    	; 0x7c04 <APP_Control_Car_App+0x18>
		} else if (Glob_u8Event == 'R') {
    7c86:	80 91 2a 02 	lds	r24, 0x022A
    7c8a:	82 35       	cpi	r24, 0x52	; 82
    7c8c:	21 f4       	brne	.+8      	; 0x7c96 <APP_Control_Car_App+0xaa>
			HAL_void_H_BridgeCW(MAX_SPEED);
    7c8e:	83 e6       	ldi	r24, 0x63	; 99
    7c90:	0e 94 ae 27 	call	0x4f5c	; 0x4f5c <HAL_void_H_BridgeCW>
    7c94:	b7 cf       	rjmp	.-146    	; 0x7c04 <APP_Control_Car_App+0x18>
		} else if (Glob_u8Event == 'S') {
    7c96:	80 91 2a 02 	lds	r24, 0x022A
    7c9a:	83 35       	cpi	r24, 0x53	; 83
    7c9c:	21 f4       	brne	.+8      	; 0x7ca6 <APP_Control_Car_App+0xba>
			HAL_void_H_BridgeStop(NUM0);
    7c9e:	80 e0       	ldi	r24, 0x00	; 0
    7ca0:	0e 94 50 28 	call	0x50a0	; 0x50a0 <HAL_void_H_BridgeStop>
    7ca4:	af cf       	rjmp	.-162    	; 0x7c04 <APP_Control_Car_App+0x18>
		} else if (Glob_u8Event == 'W') {
    7ca6:	80 91 2a 02 	lds	r24, 0x022A
    7caa:	87 35       	cpi	r24, 0x57	; 87
    7cac:	31 f4       	brne	.+12     	; 0x7cba <APP_Control_Car_App+0xce>
			HAL_LED_u8LedMode(PortA, PIN0, LED_ON);
    7cae:	80 e0       	ldi	r24, 0x00	; 0
    7cb0:	60 e0       	ldi	r22, 0x00	; 0
    7cb2:	41 e0       	ldi	r20, 0x01	; 1
    7cb4:	0e 94 07 1e 	call	0x3c0e	; 0x3c0e <HAL_LED_u8LedMode>
    7cb8:	a5 cf       	rjmp	.-182    	; 0x7c04 <APP_Control_Car_App+0x18>
		} else if (Glob_u8Event == 'w') {
    7cba:	80 91 2a 02 	lds	r24, 0x022A
    7cbe:	87 37       	cpi	r24, 0x77	; 119
    7cc0:	31 f4       	brne	.+12     	; 0x7cce <APP_Control_Car_App+0xe2>
			HAL_LED_u8LedMode(PortA, PIN0, LED_OFF);
    7cc2:	80 e0       	ldi	r24, 0x00	; 0
    7cc4:	60 e0       	ldi	r22, 0x00	; 0
    7cc6:	40 e0       	ldi	r20, 0x00	; 0
    7cc8:	0e 94 07 1e 	call	0x3c0e	; 0x3c0e <HAL_LED_u8LedMode>
    7ccc:	9b cf       	rjmp	.-202    	; 0x7c04 <APP_Control_Car_App+0x18>
		} else if (Glob_u8Event == 'U') {
    7cce:	80 91 2a 02 	lds	r24, 0x022A
    7cd2:	85 35       	cpi	r24, 0x55	; 85
    7cd4:	31 f4       	brne	.+12     	; 0x7ce2 <APP_Control_Car_App+0xf6>
			HAL_LED_u8LedMode(PortA, PIN1, LED_ON);
    7cd6:	80 e0       	ldi	r24, 0x00	; 0
    7cd8:	61 e0       	ldi	r22, 0x01	; 1
    7cda:	41 e0       	ldi	r20, 0x01	; 1
    7cdc:	0e 94 07 1e 	call	0x3c0e	; 0x3c0e <HAL_LED_u8LedMode>
    7ce0:	91 cf       	rjmp	.-222    	; 0x7c04 <APP_Control_Car_App+0x18>
		} else if (Glob_u8Event == 'u') {
    7ce2:	80 91 2a 02 	lds	r24, 0x022A
    7ce6:	85 37       	cpi	r24, 0x75	; 117
    7ce8:	31 f4       	brne	.+12     	; 0x7cf6 <APP_Control_Car_App+0x10a>
			HAL_LED_u8LedMode(PortA, PIN1, LED_OFF);
    7cea:	80 e0       	ldi	r24, 0x00	; 0
    7cec:	61 e0       	ldi	r22, 0x01	; 1
    7cee:	40 e0       	ldi	r20, 0x00	; 0
    7cf0:	0e 94 07 1e 	call	0x3c0e	; 0x3c0e <HAL_LED_u8LedMode>
    7cf4:	87 cf       	rjmp	.-242    	; 0x7c04 <APP_Control_Car_App+0x18>
		} else if (Glob_u8Event == 'V') {
    7cf6:	80 91 2a 02 	lds	r24, 0x022A
    7cfa:	86 35       	cpi	r24, 0x56	; 86
    7cfc:	31 f4       	brne	.+12     	; 0x7d0a <APP_Control_Car_App+0x11e>
			HAL_Buzzer_u8BuzzerMode(PortA, Pin3, Buzzer_ON);
    7cfe:	80 e0       	ldi	r24, 0x00	; 0
    7d00:	63 e0       	ldi	r22, 0x03	; 3
    7d02:	41 e0       	ldi	r20, 0x01	; 1
    7d04:	0e 94 93 28 	call	0x5126	; 0x5126 <HAL_Buzzer_u8BuzzerMode>
    7d08:	7d cf       	rjmp	.-262    	; 0x7c04 <APP_Control_Car_App+0x18>
		} else if (Glob_u8Event == 'v') {
    7d0a:	80 91 2a 02 	lds	r24, 0x022A
    7d0e:	86 37       	cpi	r24, 0x76	; 118
    7d10:	31 f4       	brne	.+12     	; 0x7d1e <APP_Control_Car_App+0x132>
			HAL_Buzzer_u8BuzzerMode(PortA, Pin3, Buzzer_OFF);
    7d12:	80 e0       	ldi	r24, 0x00	; 0
    7d14:	63 e0       	ldi	r22, 0x03	; 3
    7d16:	40 e0       	ldi	r20, 0x00	; 0
    7d18:	0e 94 93 28 	call	0x5126	; 0x5126 <HAL_Buzzer_u8BuzzerMode>
    7d1c:	73 cf       	rjmp	.-282    	; 0x7c04 <APP_Control_Car_App+0x18>
		} else if (Glob_u8Event == 'X') {
    7d1e:	80 91 2a 02 	lds	r24, 0x022A
    7d22:	88 35       	cpi	r24, 0x58	; 88
    7d24:	09 f0       	breq	.+2      	; 0x7d28 <APP_Control_Car_App+0x13c>
    7d26:	6e cf       	rjmp	.-292    	; 0x7c04 <APP_Control_Car_App+0x18>
			APP_Autonomous_Car_voidApp();
    7d28:	0e 94 42 42 	call	0x8484	; 0x8484 <APP_Autonomous_Car_voidApp>
    7d2c:	6b cf       	rjmp	.-298    	; 0x7c04 <APP_Control_Car_App+0x18>

00007d2e <lcd_display>:
			//NOTHING
		}
	}

}
void lcd_display(void *ptr) {
    7d2e:	0f 93       	push	r16
    7d30:	1f 93       	push	r17
    7d32:	df 93       	push	r29
    7d34:	cf 93       	push	r28
    7d36:	cd b7       	in	r28, 0x3d	; 61
    7d38:	de b7       	in	r29, 0x3e	; 62
    7d3a:	c8 55       	subi	r28, 0x58	; 88
    7d3c:	d0 40       	sbci	r29, 0x00	; 0
    7d3e:	0f b6       	in	r0, 0x3f	; 63
    7d40:	f8 94       	cli
    7d42:	de bf       	out	0x3e, r29	; 62
    7d44:	0f be       	out	0x3f, r0	; 63
    7d46:	cd bf       	out	0x3d, r28	; 61
    7d48:	fe 01       	movw	r30, r28
    7d4a:	eb 5a       	subi	r30, 0xAB	; 171
    7d4c:	ff 4f       	sbci	r31, 0xFF	; 255
    7d4e:	91 83       	std	Z+1, r25	; 0x01
    7d50:	80 83       	st	Z, r24
	while (1) {
		switch (Glob_u8Event) {
    7d52:	80 91 2a 02 	lds	r24, 0x022A
    7d56:	28 2f       	mov	r18, r24
    7d58:	30 e0       	ldi	r19, 0x00	; 0
    7d5a:	69 96       	adiw	r28, 0x19	; 25
    7d5c:	3f af       	std	Y+63, r19	; 0x3f
    7d5e:	2e af       	std	Y+62, r18	; 0x3e
    7d60:	69 97       	sbiw	r28, 0x19	; 25
    7d62:	69 96       	adiw	r28, 0x19	; 25
    7d64:	8e ad       	ldd	r24, Y+62	; 0x3e
    7d66:	9f ad       	ldd	r25, Y+63	; 0x3f
    7d68:	69 97       	sbiw	r28, 0x19	; 25
    7d6a:	8c 34       	cpi	r24, 0x4C	; 76
    7d6c:	91 05       	cpc	r25, r1
    7d6e:	09 f4       	brne	.+2      	; 0x7d72 <lcd_display+0x44>
    7d70:	82 c1       	rjmp	.+772    	; 0x8076 <lcd_display+0x348>
    7d72:	69 96       	adiw	r28, 0x19	; 25
    7d74:	ee ad       	ldd	r30, Y+62	; 0x3e
    7d76:	ff ad       	ldd	r31, Y+63	; 0x3f
    7d78:	69 97       	sbiw	r28, 0x19	; 25
    7d7a:	ed 34       	cpi	r30, 0x4D	; 77
    7d7c:	f1 05       	cpc	r31, r1
    7d7e:	84 f4       	brge	.+32     	; 0x7da0 <lcd_display+0x72>
    7d80:	69 96       	adiw	r28, 0x19	; 25
    7d82:	2e ad       	ldd	r18, Y+62	; 0x3e
    7d84:	3f ad       	ldd	r19, Y+63	; 0x3f
    7d86:	69 97       	sbiw	r28, 0x19	; 25
    7d88:	22 34       	cpi	r18, 0x42	; 66
    7d8a:	31 05       	cpc	r19, r1
    7d8c:	09 f4       	brne	.+2      	; 0x7d90 <lcd_display+0x62>
    7d8e:	de c2       	rjmp	.+1468   	; 0x834c <lcd_display+0x61e>
    7d90:	69 96       	adiw	r28, 0x19	; 25
    7d92:	8e ad       	ldd	r24, Y+62	; 0x3e
    7d94:	9f ad       	ldd	r25, Y+63	; 0x3f
    7d96:	69 97       	sbiw	r28, 0x19	; 25
    7d98:	86 34       	cpi	r24, 0x46	; 70
    7d9a:	91 05       	cpc	r25, r1
    7d9c:	91 f0       	breq	.+36     	; 0x7dc2 <lcd_display+0x94>
    7d9e:	d9 cf       	rjmp	.-78     	; 0x7d52 <lcd_display+0x24>
    7da0:	69 96       	adiw	r28, 0x19	; 25
    7da2:	ee ad       	ldd	r30, Y+62	; 0x3e
    7da4:	ff ad       	ldd	r31, Y+63	; 0x3f
    7da6:	69 97       	sbiw	r28, 0x19	; 25
    7da8:	e2 35       	cpi	r30, 0x52	; 82
    7daa:	f1 05       	cpc	r31, r1
    7dac:	09 f4       	brne	.+2      	; 0x7db0 <lcd_display+0x82>
    7dae:	dc c1       	rjmp	.+952    	; 0x8168 <lcd_display+0x43a>
    7db0:	69 96       	adiw	r28, 0x19	; 25
    7db2:	2e ad       	ldd	r18, Y+62	; 0x3e
    7db4:	3f ad       	ldd	r19, Y+63	; 0x3f
    7db6:	69 97       	sbiw	r28, 0x19	; 25
    7db8:	23 35       	cpi	r18, 0x53	; 83
    7dba:	31 05       	cpc	r19, r1
    7dbc:	09 f4       	brne	.+2      	; 0x7dc0 <lcd_display+0x92>
    7dbe:	4d c2       	rjmp	.+1178   	; 0x825a <lcd_display+0x52c>
    7dc0:	c8 cf       	rjmp	.-112    	; 0x7d52 <lcd_display+0x24>
		case 'F':
			if(Glob_f32distance>30){
    7dc2:	80 91 cc 06 	lds	r24, 0x06CC
    7dc6:	90 91 cd 06 	lds	r25, 0x06CD
    7dca:	a0 91 ce 06 	lds	r26, 0x06CE
    7dce:	b0 91 cf 06 	lds	r27, 0x06CF
    7dd2:	bc 01       	movw	r22, r24
    7dd4:	cd 01       	movw	r24, r26
    7dd6:	20 e0       	ldi	r18, 0x00	; 0
    7dd8:	30 e0       	ldi	r19, 0x00	; 0
    7dda:	40 ef       	ldi	r20, 0xF0	; 240
    7ddc:	51 e4       	ldi	r21, 0x41	; 65
    7dde:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    7de2:	18 16       	cp	r1, r24
    7de4:	0c f0       	brlt	.+2      	; 0x7de8 <lcd_display+0xba>
    7de6:	bb c0       	rjmp	.+374    	; 0x7f5e <lcd_display+0x230>
			HAL_LCD_u8Clear();
    7de8:	0e 94 7e 26 	call	0x4cfc	; 0x4cfc <HAL_LCD_u8Clear>
			HAL_LCD_u8SendString("Moving Front: ");
    7dec:	88 e7       	ldi	r24, 0x78	; 120
    7dee:	90 e0       	ldi	r25, 0x00	; 0
    7df0:	0e 94 c9 23 	call	0x4792	; 0x4792 <HAL_LCD_u8SendString>
    7df4:	fe 01       	movw	r30, r28
    7df6:	ef 5a       	subi	r30, 0xAF	; 175
    7df8:	ff 4f       	sbci	r31, 0xFF	; 255
    7dfa:	80 e0       	ldi	r24, 0x00	; 0
    7dfc:	90 e0       	ldi	r25, 0x00	; 0
    7dfe:	aa ef       	ldi	r26, 0xFA	; 250
    7e00:	b3 e4       	ldi	r27, 0x43	; 67
    7e02:	80 83       	st	Z, r24
    7e04:	91 83       	std	Z+1, r25	; 0x01
    7e06:	a2 83       	std	Z+2, r26	; 0x02
    7e08:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    7e0a:	8e 01       	movw	r16, r28
    7e0c:	03 5b       	subi	r16, 0xB3	; 179
    7e0e:	1f 4f       	sbci	r17, 0xFF	; 255
    7e10:	fe 01       	movw	r30, r28
    7e12:	ef 5a       	subi	r30, 0xAF	; 175
    7e14:	ff 4f       	sbci	r31, 0xFF	; 255
    7e16:	60 81       	ld	r22, Z
    7e18:	71 81       	ldd	r23, Z+1	; 0x01
    7e1a:	82 81       	ldd	r24, Z+2	; 0x02
    7e1c:	93 81       	ldd	r25, Z+3	; 0x03
    7e1e:	20 e0       	ldi	r18, 0x00	; 0
    7e20:	30 e0       	ldi	r19, 0x00	; 0
    7e22:	4a e7       	ldi	r20, 0x7A	; 122
    7e24:	55 e4       	ldi	r21, 0x45	; 69
    7e26:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    7e2a:	dc 01       	movw	r26, r24
    7e2c:	cb 01       	movw	r24, r22
    7e2e:	f8 01       	movw	r30, r16
    7e30:	80 83       	st	Z, r24
    7e32:	91 83       	std	Z+1, r25	; 0x01
    7e34:	a2 83       	std	Z+2, r26	; 0x02
    7e36:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    7e38:	fe 01       	movw	r30, r28
    7e3a:	e3 5b       	subi	r30, 0xB3	; 179
    7e3c:	ff 4f       	sbci	r31, 0xFF	; 255
    7e3e:	60 81       	ld	r22, Z
    7e40:	71 81       	ldd	r23, Z+1	; 0x01
    7e42:	82 81       	ldd	r24, Z+2	; 0x02
    7e44:	93 81       	ldd	r25, Z+3	; 0x03
    7e46:	20 e0       	ldi	r18, 0x00	; 0
    7e48:	30 e0       	ldi	r19, 0x00	; 0
    7e4a:	40 e8       	ldi	r20, 0x80	; 128
    7e4c:	5f e3       	ldi	r21, 0x3F	; 63
    7e4e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    7e52:	88 23       	and	r24, r24
    7e54:	44 f4       	brge	.+16     	; 0x7e66 <lcd_display+0x138>
		__ticks = 1;
    7e56:	fe 01       	movw	r30, r28
    7e58:	e5 5b       	subi	r30, 0xB5	; 181
    7e5a:	ff 4f       	sbci	r31, 0xFF	; 255
    7e5c:	81 e0       	ldi	r24, 0x01	; 1
    7e5e:	90 e0       	ldi	r25, 0x00	; 0
    7e60:	91 83       	std	Z+1, r25	; 0x01
    7e62:	80 83       	st	Z, r24
    7e64:	64 c0       	rjmp	.+200    	; 0x7f2e <lcd_display+0x200>
	else if (__tmp > 65535)
    7e66:	fe 01       	movw	r30, r28
    7e68:	e3 5b       	subi	r30, 0xB3	; 179
    7e6a:	ff 4f       	sbci	r31, 0xFF	; 255
    7e6c:	60 81       	ld	r22, Z
    7e6e:	71 81       	ldd	r23, Z+1	; 0x01
    7e70:	82 81       	ldd	r24, Z+2	; 0x02
    7e72:	93 81       	ldd	r25, Z+3	; 0x03
    7e74:	20 e0       	ldi	r18, 0x00	; 0
    7e76:	3f ef       	ldi	r19, 0xFF	; 255
    7e78:	4f e7       	ldi	r20, 0x7F	; 127
    7e7a:	57 e4       	ldi	r21, 0x47	; 71
    7e7c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    7e80:	18 16       	cp	r1, r24
    7e82:	0c f0       	brlt	.+2      	; 0x7e86 <lcd_display+0x158>
    7e84:	43 c0       	rjmp	.+134    	; 0x7f0c <lcd_display+0x1de>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7e86:	fe 01       	movw	r30, r28
    7e88:	ef 5a       	subi	r30, 0xAF	; 175
    7e8a:	ff 4f       	sbci	r31, 0xFF	; 255
    7e8c:	60 81       	ld	r22, Z
    7e8e:	71 81       	ldd	r23, Z+1	; 0x01
    7e90:	82 81       	ldd	r24, Z+2	; 0x02
    7e92:	93 81       	ldd	r25, Z+3	; 0x03
    7e94:	20 e0       	ldi	r18, 0x00	; 0
    7e96:	30 e0       	ldi	r19, 0x00	; 0
    7e98:	40 e2       	ldi	r20, 0x20	; 32
    7e9a:	51 e4       	ldi	r21, 0x41	; 65
    7e9c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    7ea0:	dc 01       	movw	r26, r24
    7ea2:	cb 01       	movw	r24, r22
    7ea4:	8e 01       	movw	r16, r28
    7ea6:	05 5b       	subi	r16, 0xB5	; 181
    7ea8:	1f 4f       	sbci	r17, 0xFF	; 255
    7eaa:	bc 01       	movw	r22, r24
    7eac:	cd 01       	movw	r24, r26
    7eae:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7eb2:	dc 01       	movw	r26, r24
    7eb4:	cb 01       	movw	r24, r22
    7eb6:	f8 01       	movw	r30, r16
    7eb8:	91 83       	std	Z+1, r25	; 0x01
    7eba:	80 83       	st	Z, r24
    7ebc:	1f c0       	rjmp	.+62     	; 0x7efc <lcd_display+0x1ce>
    7ebe:	fe 01       	movw	r30, r28
    7ec0:	e7 5b       	subi	r30, 0xB7	; 183
    7ec2:	ff 4f       	sbci	r31, 0xFF	; 255
    7ec4:	80 e9       	ldi	r24, 0x90	; 144
    7ec6:	91 e0       	ldi	r25, 0x01	; 1
    7ec8:	91 83       	std	Z+1, r25	; 0x01
    7eca:	80 83       	st	Z, r24
    7ecc:	fe 01       	movw	r30, r28
    7ece:	e7 5b       	subi	r30, 0xB7	; 183
    7ed0:	ff 4f       	sbci	r31, 0xFF	; 255
    7ed2:	80 81       	ld	r24, Z
    7ed4:	91 81       	ldd	r25, Z+1	; 0x01
    7ed6:	01 97       	sbiw	r24, 0x01	; 1
    7ed8:	f1 f7       	brne	.-4      	; 0x7ed6 <lcd_display+0x1a8>
    7eda:	fe 01       	movw	r30, r28
    7edc:	e7 5b       	subi	r30, 0xB7	; 183
    7ede:	ff 4f       	sbci	r31, 0xFF	; 255
    7ee0:	91 83       	std	Z+1, r25	; 0x01
    7ee2:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7ee4:	de 01       	movw	r26, r28
    7ee6:	a5 5b       	subi	r26, 0xB5	; 181
    7ee8:	bf 4f       	sbci	r27, 0xFF	; 255
    7eea:	fe 01       	movw	r30, r28
    7eec:	e5 5b       	subi	r30, 0xB5	; 181
    7eee:	ff 4f       	sbci	r31, 0xFF	; 255
    7ef0:	80 81       	ld	r24, Z
    7ef2:	91 81       	ldd	r25, Z+1	; 0x01
    7ef4:	01 97       	sbiw	r24, 0x01	; 1
    7ef6:	11 96       	adiw	r26, 0x01	; 1
    7ef8:	9c 93       	st	X, r25
    7efa:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7efc:	fe 01       	movw	r30, r28
    7efe:	e5 5b       	subi	r30, 0xB5	; 181
    7f00:	ff 4f       	sbci	r31, 0xFF	; 255
    7f02:	80 81       	ld	r24, Z
    7f04:	91 81       	ldd	r25, Z+1	; 0x01
    7f06:	00 97       	sbiw	r24, 0x00	; 0
    7f08:	d1 f6       	brne	.-76     	; 0x7ebe <lcd_display+0x190>
    7f0a:	23 cf       	rjmp	.-442    	; 0x7d52 <lcd_display+0x24>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7f0c:	8e 01       	movw	r16, r28
    7f0e:	05 5b       	subi	r16, 0xB5	; 181
    7f10:	1f 4f       	sbci	r17, 0xFF	; 255
    7f12:	fe 01       	movw	r30, r28
    7f14:	e3 5b       	subi	r30, 0xB3	; 179
    7f16:	ff 4f       	sbci	r31, 0xFF	; 255
    7f18:	60 81       	ld	r22, Z
    7f1a:	71 81       	ldd	r23, Z+1	; 0x01
    7f1c:	82 81       	ldd	r24, Z+2	; 0x02
    7f1e:	93 81       	ldd	r25, Z+3	; 0x03
    7f20:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7f24:	dc 01       	movw	r26, r24
    7f26:	cb 01       	movw	r24, r22
    7f28:	f8 01       	movw	r30, r16
    7f2a:	91 83       	std	Z+1, r25	; 0x01
    7f2c:	80 83       	st	Z, r24
    7f2e:	de 01       	movw	r26, r28
    7f30:	a9 5b       	subi	r26, 0xB9	; 185
    7f32:	bf 4f       	sbci	r27, 0xFF	; 255
    7f34:	fe 01       	movw	r30, r28
    7f36:	e5 5b       	subi	r30, 0xB5	; 181
    7f38:	ff 4f       	sbci	r31, 0xFF	; 255
    7f3a:	80 81       	ld	r24, Z
    7f3c:	91 81       	ldd	r25, Z+1	; 0x01
    7f3e:	11 96       	adiw	r26, 0x01	; 1
    7f40:	9c 93       	st	X, r25
    7f42:	8e 93       	st	-X, r24
    7f44:	fe 01       	movw	r30, r28
    7f46:	e9 5b       	subi	r30, 0xB9	; 185
    7f48:	ff 4f       	sbci	r31, 0xFF	; 255
    7f4a:	80 81       	ld	r24, Z
    7f4c:	91 81       	ldd	r25, Z+1	; 0x01
    7f4e:	01 97       	sbiw	r24, 0x01	; 1
    7f50:	f1 f7       	brne	.-4      	; 0x7f4e <lcd_display+0x220>
    7f52:	fe 01       	movw	r30, r28
    7f54:	e9 5b       	subi	r30, 0xB9	; 185
    7f56:	ff 4f       	sbci	r31, 0xFF	; 255
    7f58:	91 83       	std	Z+1, r25	; 0x01
    7f5a:	80 83       	st	Z, r24
    7f5c:	fa ce       	rjmp	.-524    	; 0x7d52 <lcd_display+0x24>
			_delay_ms(500);
			}else{
				HAL_LCD_u8Clear();
    7f5e:	0e 94 7e 26 	call	0x4cfc	; 0x4cfc <HAL_LCD_u8Clear>
				HAL_LCD_u8SendString("Stopping!!");
    7f62:	87 e8       	ldi	r24, 0x87	; 135
    7f64:	90 e0       	ldi	r25, 0x00	; 0
    7f66:	0e 94 c9 23 	call	0x4792	; 0x4792 <HAL_LCD_u8SendString>
    7f6a:	fe 01       	movw	r30, r28
    7f6c:	ed 5b       	subi	r30, 0xBD	; 189
    7f6e:	ff 4f       	sbci	r31, 0xFF	; 255
    7f70:	80 e0       	ldi	r24, 0x00	; 0
    7f72:	90 e0       	ldi	r25, 0x00	; 0
    7f74:	aa ef       	ldi	r26, 0xFA	; 250
    7f76:	b3 e4       	ldi	r27, 0x43	; 67
    7f78:	80 83       	st	Z, r24
    7f7a:	91 83       	std	Z+1, r25	; 0x01
    7f7c:	a2 83       	std	Z+2, r26	; 0x02
    7f7e:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    7f80:	8e 01       	movw	r16, r28
    7f82:	01 5c       	subi	r16, 0xC1	; 193
    7f84:	1f 4f       	sbci	r17, 0xFF	; 255
    7f86:	fe 01       	movw	r30, r28
    7f88:	ed 5b       	subi	r30, 0xBD	; 189
    7f8a:	ff 4f       	sbci	r31, 0xFF	; 255
    7f8c:	60 81       	ld	r22, Z
    7f8e:	71 81       	ldd	r23, Z+1	; 0x01
    7f90:	82 81       	ldd	r24, Z+2	; 0x02
    7f92:	93 81       	ldd	r25, Z+3	; 0x03
    7f94:	20 e0       	ldi	r18, 0x00	; 0
    7f96:	30 e0       	ldi	r19, 0x00	; 0
    7f98:	4a e7       	ldi	r20, 0x7A	; 122
    7f9a:	55 e4       	ldi	r21, 0x45	; 69
    7f9c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    7fa0:	dc 01       	movw	r26, r24
    7fa2:	cb 01       	movw	r24, r22
    7fa4:	f8 01       	movw	r30, r16
    7fa6:	80 83       	st	Z, r24
    7fa8:	91 83       	std	Z+1, r25	; 0x01
    7faa:	a2 83       	std	Z+2, r26	; 0x02
    7fac:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    7fae:	fe 01       	movw	r30, r28
    7fb0:	ff 96       	adiw	r30, 0x3f	; 63
    7fb2:	60 81       	ld	r22, Z
    7fb4:	71 81       	ldd	r23, Z+1	; 0x01
    7fb6:	82 81       	ldd	r24, Z+2	; 0x02
    7fb8:	93 81       	ldd	r25, Z+3	; 0x03
    7fba:	20 e0       	ldi	r18, 0x00	; 0
    7fbc:	30 e0       	ldi	r19, 0x00	; 0
    7fbe:	40 e8       	ldi	r20, 0x80	; 128
    7fc0:	5f e3       	ldi	r21, 0x3F	; 63
    7fc2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    7fc6:	88 23       	and	r24, r24
    7fc8:	2c f4       	brge	.+10     	; 0x7fd4 <lcd_display+0x2a6>
		__ticks = 1;
    7fca:	81 e0       	ldi	r24, 0x01	; 1
    7fcc:	90 e0       	ldi	r25, 0x00	; 0
    7fce:	9e af       	std	Y+62, r25	; 0x3e
    7fd0:	8d af       	std	Y+61, r24	; 0x3d
    7fd2:	46 c0       	rjmp	.+140    	; 0x8060 <lcd_display+0x332>
	else if (__tmp > 65535)
    7fd4:	fe 01       	movw	r30, r28
    7fd6:	ff 96       	adiw	r30, 0x3f	; 63
    7fd8:	60 81       	ld	r22, Z
    7fda:	71 81       	ldd	r23, Z+1	; 0x01
    7fdc:	82 81       	ldd	r24, Z+2	; 0x02
    7fde:	93 81       	ldd	r25, Z+3	; 0x03
    7fe0:	20 e0       	ldi	r18, 0x00	; 0
    7fe2:	3f ef       	ldi	r19, 0xFF	; 255
    7fe4:	4f e7       	ldi	r20, 0x7F	; 127
    7fe6:	57 e4       	ldi	r21, 0x47	; 71
    7fe8:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    7fec:	18 16       	cp	r1, r24
    7fee:	64 f5       	brge	.+88     	; 0x8048 <lcd_display+0x31a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7ff0:	fe 01       	movw	r30, r28
    7ff2:	ed 5b       	subi	r30, 0xBD	; 189
    7ff4:	ff 4f       	sbci	r31, 0xFF	; 255
    7ff6:	60 81       	ld	r22, Z
    7ff8:	71 81       	ldd	r23, Z+1	; 0x01
    7ffa:	82 81       	ldd	r24, Z+2	; 0x02
    7ffc:	93 81       	ldd	r25, Z+3	; 0x03
    7ffe:	20 e0       	ldi	r18, 0x00	; 0
    8000:	30 e0       	ldi	r19, 0x00	; 0
    8002:	40 e2       	ldi	r20, 0x20	; 32
    8004:	51 e4       	ldi	r21, 0x41	; 65
    8006:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    800a:	dc 01       	movw	r26, r24
    800c:	cb 01       	movw	r24, r22
    800e:	bc 01       	movw	r22, r24
    8010:	cd 01       	movw	r24, r26
    8012:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8016:	dc 01       	movw	r26, r24
    8018:	cb 01       	movw	r24, r22
    801a:	9e af       	std	Y+62, r25	; 0x3e
    801c:	8d af       	std	Y+61, r24	; 0x3d
    801e:	0f c0       	rjmp	.+30     	; 0x803e <lcd_display+0x310>
    8020:	80 e9       	ldi	r24, 0x90	; 144
    8022:	91 e0       	ldi	r25, 0x01	; 1
    8024:	9c af       	std	Y+60, r25	; 0x3c
    8026:	8b af       	std	Y+59, r24	; 0x3b
    8028:	8b ad       	ldd	r24, Y+59	; 0x3b
    802a:	9c ad       	ldd	r25, Y+60	; 0x3c
    802c:	01 97       	sbiw	r24, 0x01	; 1
    802e:	f1 f7       	brne	.-4      	; 0x802c <lcd_display+0x2fe>
    8030:	9c af       	std	Y+60, r25	; 0x3c
    8032:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8034:	8d ad       	ldd	r24, Y+61	; 0x3d
    8036:	9e ad       	ldd	r25, Y+62	; 0x3e
    8038:	01 97       	sbiw	r24, 0x01	; 1
    803a:	9e af       	std	Y+62, r25	; 0x3e
    803c:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    803e:	8d ad       	ldd	r24, Y+61	; 0x3d
    8040:	9e ad       	ldd	r25, Y+62	; 0x3e
    8042:	00 97       	sbiw	r24, 0x00	; 0
    8044:	69 f7       	brne	.-38     	; 0x8020 <lcd_display+0x2f2>
    8046:	85 ce       	rjmp	.-758    	; 0x7d52 <lcd_display+0x24>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8048:	fe 01       	movw	r30, r28
    804a:	ff 96       	adiw	r30, 0x3f	; 63
    804c:	60 81       	ld	r22, Z
    804e:	71 81       	ldd	r23, Z+1	; 0x01
    8050:	82 81       	ldd	r24, Z+2	; 0x02
    8052:	93 81       	ldd	r25, Z+3	; 0x03
    8054:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8058:	dc 01       	movw	r26, r24
    805a:	cb 01       	movw	r24, r22
    805c:	9e af       	std	Y+62, r25	; 0x3e
    805e:	8d af       	std	Y+61, r24	; 0x3d
    8060:	8d ad       	ldd	r24, Y+61	; 0x3d
    8062:	9e ad       	ldd	r25, Y+62	; 0x3e
    8064:	9a af       	std	Y+58, r25	; 0x3a
    8066:	89 af       	std	Y+57, r24	; 0x39
    8068:	89 ad       	ldd	r24, Y+57	; 0x39
    806a:	9a ad       	ldd	r25, Y+58	; 0x3a
    806c:	01 97       	sbiw	r24, 0x01	; 1
    806e:	f1 f7       	brne	.-4      	; 0x806c <lcd_display+0x33e>
    8070:	9a af       	std	Y+58, r25	; 0x3a
    8072:	89 af       	std	Y+57, r24	; 0x39
    8074:	6e ce       	rjmp	.-804    	; 0x7d52 <lcd_display+0x24>
				_delay_ms(500);
			}
			break;
		case 'L':
			HAL_LCD_u8Clear();
    8076:	0e 94 7e 26 	call	0x4cfc	; 0x4cfc <HAL_LCD_u8Clear>
			HAL_LCD_u8SendString("Moving Left: ");
    807a:	82 e9       	ldi	r24, 0x92	; 146
    807c:	90 e0       	ldi	r25, 0x00	; 0
    807e:	0e 94 c9 23 	call	0x4792	; 0x4792 <HAL_LCD_u8SendString>
    8082:	80 e0       	ldi	r24, 0x00	; 0
    8084:	90 e0       	ldi	r25, 0x00	; 0
    8086:	aa ef       	ldi	r26, 0xFA	; 250
    8088:	b3 e4       	ldi	r27, 0x43	; 67
    808a:	8d ab       	std	Y+53, r24	; 0x35
    808c:	9e ab       	std	Y+54, r25	; 0x36
    808e:	af ab       	std	Y+55, r26	; 0x37
    8090:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8092:	6d a9       	ldd	r22, Y+53	; 0x35
    8094:	7e a9       	ldd	r23, Y+54	; 0x36
    8096:	8f a9       	ldd	r24, Y+55	; 0x37
    8098:	98 ad       	ldd	r25, Y+56	; 0x38
    809a:	20 e0       	ldi	r18, 0x00	; 0
    809c:	30 e0       	ldi	r19, 0x00	; 0
    809e:	4a e7       	ldi	r20, 0x7A	; 122
    80a0:	55 e4       	ldi	r21, 0x45	; 69
    80a2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    80a6:	dc 01       	movw	r26, r24
    80a8:	cb 01       	movw	r24, r22
    80aa:	89 ab       	std	Y+49, r24	; 0x31
    80ac:	9a ab       	std	Y+50, r25	; 0x32
    80ae:	ab ab       	std	Y+51, r26	; 0x33
    80b0:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    80b2:	69 a9       	ldd	r22, Y+49	; 0x31
    80b4:	7a a9       	ldd	r23, Y+50	; 0x32
    80b6:	8b a9       	ldd	r24, Y+51	; 0x33
    80b8:	9c a9       	ldd	r25, Y+52	; 0x34
    80ba:	20 e0       	ldi	r18, 0x00	; 0
    80bc:	30 e0       	ldi	r19, 0x00	; 0
    80be:	40 e8       	ldi	r20, 0x80	; 128
    80c0:	5f e3       	ldi	r21, 0x3F	; 63
    80c2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    80c6:	88 23       	and	r24, r24
    80c8:	2c f4       	brge	.+10     	; 0x80d4 <lcd_display+0x3a6>
		__ticks = 1;
    80ca:	81 e0       	ldi	r24, 0x01	; 1
    80cc:	90 e0       	ldi	r25, 0x00	; 0
    80ce:	98 ab       	std	Y+48, r25	; 0x30
    80d0:	8f a7       	std	Y+47, r24	; 0x2f
    80d2:	3f c0       	rjmp	.+126    	; 0x8152 <lcd_display+0x424>
	else if (__tmp > 65535)
    80d4:	69 a9       	ldd	r22, Y+49	; 0x31
    80d6:	7a a9       	ldd	r23, Y+50	; 0x32
    80d8:	8b a9       	ldd	r24, Y+51	; 0x33
    80da:	9c a9       	ldd	r25, Y+52	; 0x34
    80dc:	20 e0       	ldi	r18, 0x00	; 0
    80de:	3f ef       	ldi	r19, 0xFF	; 255
    80e0:	4f e7       	ldi	r20, 0x7F	; 127
    80e2:	57 e4       	ldi	r21, 0x47	; 71
    80e4:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    80e8:	18 16       	cp	r1, r24
    80ea:	4c f5       	brge	.+82     	; 0x813e <lcd_display+0x410>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    80ec:	6d a9       	ldd	r22, Y+53	; 0x35
    80ee:	7e a9       	ldd	r23, Y+54	; 0x36
    80f0:	8f a9       	ldd	r24, Y+55	; 0x37
    80f2:	98 ad       	ldd	r25, Y+56	; 0x38
    80f4:	20 e0       	ldi	r18, 0x00	; 0
    80f6:	30 e0       	ldi	r19, 0x00	; 0
    80f8:	40 e2       	ldi	r20, 0x20	; 32
    80fa:	51 e4       	ldi	r21, 0x41	; 65
    80fc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8100:	dc 01       	movw	r26, r24
    8102:	cb 01       	movw	r24, r22
    8104:	bc 01       	movw	r22, r24
    8106:	cd 01       	movw	r24, r26
    8108:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    810c:	dc 01       	movw	r26, r24
    810e:	cb 01       	movw	r24, r22
    8110:	98 ab       	std	Y+48, r25	; 0x30
    8112:	8f a7       	std	Y+47, r24	; 0x2f
    8114:	0f c0       	rjmp	.+30     	; 0x8134 <lcd_display+0x406>
    8116:	80 e9       	ldi	r24, 0x90	; 144
    8118:	91 e0       	ldi	r25, 0x01	; 1
    811a:	9e a7       	std	Y+46, r25	; 0x2e
    811c:	8d a7       	std	Y+45, r24	; 0x2d
    811e:	8d a5       	ldd	r24, Y+45	; 0x2d
    8120:	9e a5       	ldd	r25, Y+46	; 0x2e
    8122:	01 97       	sbiw	r24, 0x01	; 1
    8124:	f1 f7       	brne	.-4      	; 0x8122 <lcd_display+0x3f4>
    8126:	9e a7       	std	Y+46, r25	; 0x2e
    8128:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    812a:	8f a5       	ldd	r24, Y+47	; 0x2f
    812c:	98 a9       	ldd	r25, Y+48	; 0x30
    812e:	01 97       	sbiw	r24, 0x01	; 1
    8130:	98 ab       	std	Y+48, r25	; 0x30
    8132:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8134:	8f a5       	ldd	r24, Y+47	; 0x2f
    8136:	98 a9       	ldd	r25, Y+48	; 0x30
    8138:	00 97       	sbiw	r24, 0x00	; 0
    813a:	69 f7       	brne	.-38     	; 0x8116 <lcd_display+0x3e8>
    813c:	0a ce       	rjmp	.-1004   	; 0x7d52 <lcd_display+0x24>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    813e:	69 a9       	ldd	r22, Y+49	; 0x31
    8140:	7a a9       	ldd	r23, Y+50	; 0x32
    8142:	8b a9       	ldd	r24, Y+51	; 0x33
    8144:	9c a9       	ldd	r25, Y+52	; 0x34
    8146:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    814a:	dc 01       	movw	r26, r24
    814c:	cb 01       	movw	r24, r22
    814e:	98 ab       	std	Y+48, r25	; 0x30
    8150:	8f a7       	std	Y+47, r24	; 0x2f
    8152:	8f a5       	ldd	r24, Y+47	; 0x2f
    8154:	98 a9       	ldd	r25, Y+48	; 0x30
    8156:	9c a7       	std	Y+44, r25	; 0x2c
    8158:	8b a7       	std	Y+43, r24	; 0x2b
    815a:	8b a5       	ldd	r24, Y+43	; 0x2b
    815c:	9c a5       	ldd	r25, Y+44	; 0x2c
    815e:	01 97       	sbiw	r24, 0x01	; 1
    8160:	f1 f7       	brne	.-4      	; 0x815e <lcd_display+0x430>
    8162:	9c a7       	std	Y+44, r25	; 0x2c
    8164:	8b a7       	std	Y+43, r24	; 0x2b
    8166:	f5 cd       	rjmp	.-1046   	; 0x7d52 <lcd_display+0x24>
			_delay_ms(500);
			break;
		case 'R':
			HAL_LCD_u8Clear();
    8168:	0e 94 7e 26 	call	0x4cfc	; 0x4cfc <HAL_LCD_u8Clear>
			HAL_LCD_u8SendString("Moving Right: ");
    816c:	80 ea       	ldi	r24, 0xA0	; 160
    816e:	90 e0       	ldi	r25, 0x00	; 0
    8170:	0e 94 c9 23 	call	0x4792	; 0x4792 <HAL_LCD_u8SendString>
    8174:	80 e0       	ldi	r24, 0x00	; 0
    8176:	90 e0       	ldi	r25, 0x00	; 0
    8178:	aa ef       	ldi	r26, 0xFA	; 250
    817a:	b3 e4       	ldi	r27, 0x43	; 67
    817c:	8f a3       	std	Y+39, r24	; 0x27
    817e:	98 a7       	std	Y+40, r25	; 0x28
    8180:	a9 a7       	std	Y+41, r26	; 0x29
    8182:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8184:	6f a1       	ldd	r22, Y+39	; 0x27
    8186:	78 a5       	ldd	r23, Y+40	; 0x28
    8188:	89 a5       	ldd	r24, Y+41	; 0x29
    818a:	9a a5       	ldd	r25, Y+42	; 0x2a
    818c:	20 e0       	ldi	r18, 0x00	; 0
    818e:	30 e0       	ldi	r19, 0x00	; 0
    8190:	4a e7       	ldi	r20, 0x7A	; 122
    8192:	55 e4       	ldi	r21, 0x45	; 69
    8194:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8198:	dc 01       	movw	r26, r24
    819a:	cb 01       	movw	r24, r22
    819c:	8b a3       	std	Y+35, r24	; 0x23
    819e:	9c a3       	std	Y+36, r25	; 0x24
    81a0:	ad a3       	std	Y+37, r26	; 0x25
    81a2:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    81a4:	6b a1       	ldd	r22, Y+35	; 0x23
    81a6:	7c a1       	ldd	r23, Y+36	; 0x24
    81a8:	8d a1       	ldd	r24, Y+37	; 0x25
    81aa:	9e a1       	ldd	r25, Y+38	; 0x26
    81ac:	20 e0       	ldi	r18, 0x00	; 0
    81ae:	30 e0       	ldi	r19, 0x00	; 0
    81b0:	40 e8       	ldi	r20, 0x80	; 128
    81b2:	5f e3       	ldi	r21, 0x3F	; 63
    81b4:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    81b8:	88 23       	and	r24, r24
    81ba:	2c f4       	brge	.+10     	; 0x81c6 <lcd_display+0x498>
		__ticks = 1;
    81bc:	81 e0       	ldi	r24, 0x01	; 1
    81be:	90 e0       	ldi	r25, 0x00	; 0
    81c0:	9a a3       	std	Y+34, r25	; 0x22
    81c2:	89 a3       	std	Y+33, r24	; 0x21
    81c4:	3f c0       	rjmp	.+126    	; 0x8244 <lcd_display+0x516>
	else if (__tmp > 65535)
    81c6:	6b a1       	ldd	r22, Y+35	; 0x23
    81c8:	7c a1       	ldd	r23, Y+36	; 0x24
    81ca:	8d a1       	ldd	r24, Y+37	; 0x25
    81cc:	9e a1       	ldd	r25, Y+38	; 0x26
    81ce:	20 e0       	ldi	r18, 0x00	; 0
    81d0:	3f ef       	ldi	r19, 0xFF	; 255
    81d2:	4f e7       	ldi	r20, 0x7F	; 127
    81d4:	57 e4       	ldi	r21, 0x47	; 71
    81d6:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    81da:	18 16       	cp	r1, r24
    81dc:	4c f5       	brge	.+82     	; 0x8230 <lcd_display+0x502>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    81de:	6f a1       	ldd	r22, Y+39	; 0x27
    81e0:	78 a5       	ldd	r23, Y+40	; 0x28
    81e2:	89 a5       	ldd	r24, Y+41	; 0x29
    81e4:	9a a5       	ldd	r25, Y+42	; 0x2a
    81e6:	20 e0       	ldi	r18, 0x00	; 0
    81e8:	30 e0       	ldi	r19, 0x00	; 0
    81ea:	40 e2       	ldi	r20, 0x20	; 32
    81ec:	51 e4       	ldi	r21, 0x41	; 65
    81ee:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    81f2:	dc 01       	movw	r26, r24
    81f4:	cb 01       	movw	r24, r22
    81f6:	bc 01       	movw	r22, r24
    81f8:	cd 01       	movw	r24, r26
    81fa:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    81fe:	dc 01       	movw	r26, r24
    8200:	cb 01       	movw	r24, r22
    8202:	9a a3       	std	Y+34, r25	; 0x22
    8204:	89 a3       	std	Y+33, r24	; 0x21
    8206:	0f c0       	rjmp	.+30     	; 0x8226 <lcd_display+0x4f8>
    8208:	80 e9       	ldi	r24, 0x90	; 144
    820a:	91 e0       	ldi	r25, 0x01	; 1
    820c:	98 a3       	std	Y+32, r25	; 0x20
    820e:	8f 8f       	std	Y+31, r24	; 0x1f
    8210:	8f 8d       	ldd	r24, Y+31	; 0x1f
    8212:	98 a1       	ldd	r25, Y+32	; 0x20
    8214:	01 97       	sbiw	r24, 0x01	; 1
    8216:	f1 f7       	brne	.-4      	; 0x8214 <lcd_display+0x4e6>
    8218:	98 a3       	std	Y+32, r25	; 0x20
    821a:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    821c:	89 a1       	ldd	r24, Y+33	; 0x21
    821e:	9a a1       	ldd	r25, Y+34	; 0x22
    8220:	01 97       	sbiw	r24, 0x01	; 1
    8222:	9a a3       	std	Y+34, r25	; 0x22
    8224:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8226:	89 a1       	ldd	r24, Y+33	; 0x21
    8228:	9a a1       	ldd	r25, Y+34	; 0x22
    822a:	00 97       	sbiw	r24, 0x00	; 0
    822c:	69 f7       	brne	.-38     	; 0x8208 <lcd_display+0x4da>
    822e:	91 cd       	rjmp	.-1246   	; 0x7d52 <lcd_display+0x24>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8230:	6b a1       	ldd	r22, Y+35	; 0x23
    8232:	7c a1       	ldd	r23, Y+36	; 0x24
    8234:	8d a1       	ldd	r24, Y+37	; 0x25
    8236:	9e a1       	ldd	r25, Y+38	; 0x26
    8238:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    823c:	dc 01       	movw	r26, r24
    823e:	cb 01       	movw	r24, r22
    8240:	9a a3       	std	Y+34, r25	; 0x22
    8242:	89 a3       	std	Y+33, r24	; 0x21
    8244:	89 a1       	ldd	r24, Y+33	; 0x21
    8246:	9a a1       	ldd	r25, Y+34	; 0x22
    8248:	9e 8f       	std	Y+30, r25	; 0x1e
    824a:	8d 8f       	std	Y+29, r24	; 0x1d
    824c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    824e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    8250:	01 97       	sbiw	r24, 0x01	; 1
    8252:	f1 f7       	brne	.-4      	; 0x8250 <lcd_display+0x522>
    8254:	9e 8f       	std	Y+30, r25	; 0x1e
    8256:	8d 8f       	std	Y+29, r24	; 0x1d
    8258:	7c cd       	rjmp	.-1288   	; 0x7d52 <lcd_display+0x24>
			_delay_ms(500);
			break;
		case 'S':
			HAL_LCD_u8Clear();
    825a:	0e 94 7e 26 	call	0x4cfc	; 0x4cfc <HAL_LCD_u8Clear>
			HAL_LCD_u8SendString("Stopping!!");
    825e:	87 e8       	ldi	r24, 0x87	; 135
    8260:	90 e0       	ldi	r25, 0x00	; 0
    8262:	0e 94 c9 23 	call	0x4792	; 0x4792 <HAL_LCD_u8SendString>
    8266:	80 e0       	ldi	r24, 0x00	; 0
    8268:	90 e0       	ldi	r25, 0x00	; 0
    826a:	aa ef       	ldi	r26, 0xFA	; 250
    826c:	b3 e4       	ldi	r27, 0x43	; 67
    826e:	89 8f       	std	Y+25, r24	; 0x19
    8270:	9a 8f       	std	Y+26, r25	; 0x1a
    8272:	ab 8f       	std	Y+27, r26	; 0x1b
    8274:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8276:	69 8d       	ldd	r22, Y+25	; 0x19
    8278:	7a 8d       	ldd	r23, Y+26	; 0x1a
    827a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    827c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    827e:	20 e0       	ldi	r18, 0x00	; 0
    8280:	30 e0       	ldi	r19, 0x00	; 0
    8282:	4a e7       	ldi	r20, 0x7A	; 122
    8284:	55 e4       	ldi	r21, 0x45	; 69
    8286:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    828a:	dc 01       	movw	r26, r24
    828c:	cb 01       	movw	r24, r22
    828e:	8d 8b       	std	Y+21, r24	; 0x15
    8290:	9e 8b       	std	Y+22, r25	; 0x16
    8292:	af 8b       	std	Y+23, r26	; 0x17
    8294:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    8296:	6d 89       	ldd	r22, Y+21	; 0x15
    8298:	7e 89       	ldd	r23, Y+22	; 0x16
    829a:	8f 89       	ldd	r24, Y+23	; 0x17
    829c:	98 8d       	ldd	r25, Y+24	; 0x18
    829e:	20 e0       	ldi	r18, 0x00	; 0
    82a0:	30 e0       	ldi	r19, 0x00	; 0
    82a2:	40 e8       	ldi	r20, 0x80	; 128
    82a4:	5f e3       	ldi	r21, 0x3F	; 63
    82a6:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    82aa:	88 23       	and	r24, r24
    82ac:	2c f4       	brge	.+10     	; 0x82b8 <lcd_display+0x58a>
		__ticks = 1;
    82ae:	81 e0       	ldi	r24, 0x01	; 1
    82b0:	90 e0       	ldi	r25, 0x00	; 0
    82b2:	9c 8b       	std	Y+20, r25	; 0x14
    82b4:	8b 8b       	std	Y+19, r24	; 0x13
    82b6:	3f c0       	rjmp	.+126    	; 0x8336 <lcd_display+0x608>
	else if (__tmp > 65535)
    82b8:	6d 89       	ldd	r22, Y+21	; 0x15
    82ba:	7e 89       	ldd	r23, Y+22	; 0x16
    82bc:	8f 89       	ldd	r24, Y+23	; 0x17
    82be:	98 8d       	ldd	r25, Y+24	; 0x18
    82c0:	20 e0       	ldi	r18, 0x00	; 0
    82c2:	3f ef       	ldi	r19, 0xFF	; 255
    82c4:	4f e7       	ldi	r20, 0x7F	; 127
    82c6:	57 e4       	ldi	r21, 0x47	; 71
    82c8:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    82cc:	18 16       	cp	r1, r24
    82ce:	4c f5       	brge	.+82     	; 0x8322 <lcd_display+0x5f4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    82d0:	69 8d       	ldd	r22, Y+25	; 0x19
    82d2:	7a 8d       	ldd	r23, Y+26	; 0x1a
    82d4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    82d6:	9c 8d       	ldd	r25, Y+28	; 0x1c
    82d8:	20 e0       	ldi	r18, 0x00	; 0
    82da:	30 e0       	ldi	r19, 0x00	; 0
    82dc:	40 e2       	ldi	r20, 0x20	; 32
    82de:	51 e4       	ldi	r21, 0x41	; 65
    82e0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    82e4:	dc 01       	movw	r26, r24
    82e6:	cb 01       	movw	r24, r22
    82e8:	bc 01       	movw	r22, r24
    82ea:	cd 01       	movw	r24, r26
    82ec:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    82f0:	dc 01       	movw	r26, r24
    82f2:	cb 01       	movw	r24, r22
    82f4:	9c 8b       	std	Y+20, r25	; 0x14
    82f6:	8b 8b       	std	Y+19, r24	; 0x13
    82f8:	0f c0       	rjmp	.+30     	; 0x8318 <lcd_display+0x5ea>
    82fa:	80 e9       	ldi	r24, 0x90	; 144
    82fc:	91 e0       	ldi	r25, 0x01	; 1
    82fe:	9a 8b       	std	Y+18, r25	; 0x12
    8300:	89 8b       	std	Y+17, r24	; 0x11
    8302:	89 89       	ldd	r24, Y+17	; 0x11
    8304:	9a 89       	ldd	r25, Y+18	; 0x12
    8306:	01 97       	sbiw	r24, 0x01	; 1
    8308:	f1 f7       	brne	.-4      	; 0x8306 <lcd_display+0x5d8>
    830a:	9a 8b       	std	Y+18, r25	; 0x12
    830c:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    830e:	8b 89       	ldd	r24, Y+19	; 0x13
    8310:	9c 89       	ldd	r25, Y+20	; 0x14
    8312:	01 97       	sbiw	r24, 0x01	; 1
    8314:	9c 8b       	std	Y+20, r25	; 0x14
    8316:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8318:	8b 89       	ldd	r24, Y+19	; 0x13
    831a:	9c 89       	ldd	r25, Y+20	; 0x14
    831c:	00 97       	sbiw	r24, 0x00	; 0
    831e:	69 f7       	brne	.-38     	; 0x82fa <lcd_display+0x5cc>
    8320:	18 cd       	rjmp	.-1488   	; 0x7d52 <lcd_display+0x24>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8322:	6d 89       	ldd	r22, Y+21	; 0x15
    8324:	7e 89       	ldd	r23, Y+22	; 0x16
    8326:	8f 89       	ldd	r24, Y+23	; 0x17
    8328:	98 8d       	ldd	r25, Y+24	; 0x18
    832a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    832e:	dc 01       	movw	r26, r24
    8330:	cb 01       	movw	r24, r22
    8332:	9c 8b       	std	Y+20, r25	; 0x14
    8334:	8b 8b       	std	Y+19, r24	; 0x13
    8336:	8b 89       	ldd	r24, Y+19	; 0x13
    8338:	9c 89       	ldd	r25, Y+20	; 0x14
    833a:	98 8b       	std	Y+16, r25	; 0x10
    833c:	8f 87       	std	Y+15, r24	; 0x0f
    833e:	8f 85       	ldd	r24, Y+15	; 0x0f
    8340:	98 89       	ldd	r25, Y+16	; 0x10
    8342:	01 97       	sbiw	r24, 0x01	; 1
    8344:	f1 f7       	brne	.-4      	; 0x8342 <lcd_display+0x614>
    8346:	98 8b       	std	Y+16, r25	; 0x10
    8348:	8f 87       	std	Y+15, r24	; 0x0f
    834a:	03 cd       	rjmp	.-1530   	; 0x7d52 <lcd_display+0x24>
			_delay_ms(500);
			break;
		case 'B':
			HAL_LCD_u8Clear();
    834c:	0e 94 7e 26 	call	0x4cfc	; 0x4cfc <HAL_LCD_u8Clear>
			HAL_LCD_u8SendString("Moving Back:");
    8350:	8f ea       	ldi	r24, 0xAF	; 175
    8352:	90 e0       	ldi	r25, 0x00	; 0
    8354:	0e 94 c9 23 	call	0x4792	; 0x4792 <HAL_LCD_u8SendString>
    8358:	80 e0       	ldi	r24, 0x00	; 0
    835a:	90 e0       	ldi	r25, 0x00	; 0
    835c:	aa ef       	ldi	r26, 0xFA	; 250
    835e:	b3 e4       	ldi	r27, 0x43	; 67
    8360:	8b 87       	std	Y+11, r24	; 0x0b
    8362:	9c 87       	std	Y+12, r25	; 0x0c
    8364:	ad 87       	std	Y+13, r26	; 0x0d
    8366:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8368:	6b 85       	ldd	r22, Y+11	; 0x0b
    836a:	7c 85       	ldd	r23, Y+12	; 0x0c
    836c:	8d 85       	ldd	r24, Y+13	; 0x0d
    836e:	9e 85       	ldd	r25, Y+14	; 0x0e
    8370:	20 e0       	ldi	r18, 0x00	; 0
    8372:	30 e0       	ldi	r19, 0x00	; 0
    8374:	4a e7       	ldi	r20, 0x7A	; 122
    8376:	55 e4       	ldi	r21, 0x45	; 69
    8378:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    837c:	dc 01       	movw	r26, r24
    837e:	cb 01       	movw	r24, r22
    8380:	8f 83       	std	Y+7, r24	; 0x07
    8382:	98 87       	std	Y+8, r25	; 0x08
    8384:	a9 87       	std	Y+9, r26	; 0x09
    8386:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    8388:	6f 81       	ldd	r22, Y+7	; 0x07
    838a:	78 85       	ldd	r23, Y+8	; 0x08
    838c:	89 85       	ldd	r24, Y+9	; 0x09
    838e:	9a 85       	ldd	r25, Y+10	; 0x0a
    8390:	20 e0       	ldi	r18, 0x00	; 0
    8392:	30 e0       	ldi	r19, 0x00	; 0
    8394:	40 e8       	ldi	r20, 0x80	; 128
    8396:	5f e3       	ldi	r21, 0x3F	; 63
    8398:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    839c:	88 23       	and	r24, r24
    839e:	2c f4       	brge	.+10     	; 0x83aa <lcd_display+0x67c>
		__ticks = 1;
    83a0:	81 e0       	ldi	r24, 0x01	; 1
    83a2:	90 e0       	ldi	r25, 0x00	; 0
    83a4:	9e 83       	std	Y+6, r25	; 0x06
    83a6:	8d 83       	std	Y+5, r24	; 0x05
    83a8:	3f c0       	rjmp	.+126    	; 0x8428 <lcd_display+0x6fa>
	else if (__tmp > 65535)
    83aa:	6f 81       	ldd	r22, Y+7	; 0x07
    83ac:	78 85       	ldd	r23, Y+8	; 0x08
    83ae:	89 85       	ldd	r24, Y+9	; 0x09
    83b0:	9a 85       	ldd	r25, Y+10	; 0x0a
    83b2:	20 e0       	ldi	r18, 0x00	; 0
    83b4:	3f ef       	ldi	r19, 0xFF	; 255
    83b6:	4f e7       	ldi	r20, 0x7F	; 127
    83b8:	57 e4       	ldi	r21, 0x47	; 71
    83ba:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    83be:	18 16       	cp	r1, r24
    83c0:	4c f5       	brge	.+82     	; 0x8414 <lcd_display+0x6e6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    83c2:	6b 85       	ldd	r22, Y+11	; 0x0b
    83c4:	7c 85       	ldd	r23, Y+12	; 0x0c
    83c6:	8d 85       	ldd	r24, Y+13	; 0x0d
    83c8:	9e 85       	ldd	r25, Y+14	; 0x0e
    83ca:	20 e0       	ldi	r18, 0x00	; 0
    83cc:	30 e0       	ldi	r19, 0x00	; 0
    83ce:	40 e2       	ldi	r20, 0x20	; 32
    83d0:	51 e4       	ldi	r21, 0x41	; 65
    83d2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    83d6:	dc 01       	movw	r26, r24
    83d8:	cb 01       	movw	r24, r22
    83da:	bc 01       	movw	r22, r24
    83dc:	cd 01       	movw	r24, r26
    83de:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    83e2:	dc 01       	movw	r26, r24
    83e4:	cb 01       	movw	r24, r22
    83e6:	9e 83       	std	Y+6, r25	; 0x06
    83e8:	8d 83       	std	Y+5, r24	; 0x05
    83ea:	0f c0       	rjmp	.+30     	; 0x840a <lcd_display+0x6dc>
    83ec:	80 e9       	ldi	r24, 0x90	; 144
    83ee:	91 e0       	ldi	r25, 0x01	; 1
    83f0:	9c 83       	std	Y+4, r25	; 0x04
    83f2:	8b 83       	std	Y+3, r24	; 0x03
    83f4:	8b 81       	ldd	r24, Y+3	; 0x03
    83f6:	9c 81       	ldd	r25, Y+4	; 0x04
    83f8:	01 97       	sbiw	r24, 0x01	; 1
    83fa:	f1 f7       	brne	.-4      	; 0x83f8 <lcd_display+0x6ca>
    83fc:	9c 83       	std	Y+4, r25	; 0x04
    83fe:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8400:	8d 81       	ldd	r24, Y+5	; 0x05
    8402:	9e 81       	ldd	r25, Y+6	; 0x06
    8404:	01 97       	sbiw	r24, 0x01	; 1
    8406:	9e 83       	std	Y+6, r25	; 0x06
    8408:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    840a:	8d 81       	ldd	r24, Y+5	; 0x05
    840c:	9e 81       	ldd	r25, Y+6	; 0x06
    840e:	00 97       	sbiw	r24, 0x00	; 0
    8410:	69 f7       	brne	.-38     	; 0x83ec <lcd_display+0x6be>
    8412:	9f cc       	rjmp	.-1730   	; 0x7d52 <lcd_display+0x24>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8414:	6f 81       	ldd	r22, Y+7	; 0x07
    8416:	78 85       	ldd	r23, Y+8	; 0x08
    8418:	89 85       	ldd	r24, Y+9	; 0x09
    841a:	9a 85       	ldd	r25, Y+10	; 0x0a
    841c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8420:	dc 01       	movw	r26, r24
    8422:	cb 01       	movw	r24, r22
    8424:	9e 83       	std	Y+6, r25	; 0x06
    8426:	8d 83       	std	Y+5, r24	; 0x05
    8428:	8d 81       	ldd	r24, Y+5	; 0x05
    842a:	9e 81       	ldd	r25, Y+6	; 0x06
    842c:	9a 83       	std	Y+2, r25	; 0x02
    842e:	89 83       	std	Y+1, r24	; 0x01
    8430:	89 81       	ldd	r24, Y+1	; 0x01
    8432:	9a 81       	ldd	r25, Y+2	; 0x02
    8434:	01 97       	sbiw	r24, 0x01	; 1
    8436:	f1 f7       	brne	.-4      	; 0x8434 <lcd_display+0x706>
    8438:	9a 83       	std	Y+2, r25	; 0x02
    843a:	89 83       	std	Y+1, r24	; 0x01
    843c:	8a cc       	rjmp	.-1772   	; 0x7d52 <lcd_display+0x24>

0000843e <sensor>:
			_delay_ms(500);
			break;
		}
	}
}
void sensor(void *pt) {
    843e:	df 93       	push	r29
    8440:	cf 93       	push	r28
    8442:	00 d0       	rcall	.+0      	; 0x8444 <sensor+0x6>
    8444:	cd b7       	in	r28, 0x3d	; 61
    8446:	de b7       	in	r29, 0x3e	; 62
    8448:	9a 83       	std	Y+2, r25	; 0x02
    844a:	89 83       	std	Y+1, r24	; 0x01
	while (1) {
		HAL_Ultrasonic_Sensor_voidCalcDistancse(&Glob_f32distance);
    844c:	8c ec       	ldi	r24, 0xCC	; 204
    844e:	96 e0       	ldi	r25, 0x06	; 6
    8450:	0e 94 c9 1a 	call	0x3592	; 0x3592 <HAL_Ultrasonic_Sensor_voidCalcDistancse>
    8454:	fb cf       	rjmp	.-10     	; 0x844c <sensor+0xe>

00008456 <APP_Autonomous_Car_voidInit>:

#include "Autonomous_Car.h"
volatile u16 Glob_u16DirLeft = NUM0;
volatile u16 Glob_u16DirRight = NUM0;
volatile u16 Glob_u16DirFront = NUM0;
void APP_Autonomous_Car_voidInit(void) {
    8456:	df 93       	push	r29
    8458:	cf 93       	push	r28
    845a:	cd b7       	in	r28, 0x3d	; 61
    845c:	de b7       	in	r29, 0x3e	; 62
	//Init Buzzer
//	HAL_Buzzer_u8BuzzerInit(PortA, Pin3);
	//Init LCD
	HAL_LCD_u8LCDInit();
    845e:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <HAL_LCD_u8LCDInit>
	//Init Servo Motor
	HAL_SM_voidSMInit();
    8462:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <HAL_SM_voidSMInit>
	//Init UltraSonic Sensor
	HAL_Ultrasonic_Sensor_voidInit();
    8466:	0e 94 ca 19 	call	0x3394	; 0x3394 <HAL_Ultrasonic_Sensor_voidInit>
	//Init H_Bridge
	HAL_void_H_BridgeInit();
    846a:	0e 94 93 27 	call	0x4f26	; 0x4f26 <HAL_void_H_BridgeInit>
	//Leds
	HAL_LED_u8LedInit(PortA, Pin0);
    846e:	80 e0       	ldi	r24, 0x00	; 0
    8470:	60 e0       	ldi	r22, 0x00	; 0
    8472:	0e 94 ea 1d 	call	0x3bd4	; 0x3bd4 <HAL_LED_u8LedInit>
	HAL_LED_u8LedInit(PortA, Pin1);
    8476:	80 e0       	ldi	r24, 0x00	; 0
    8478:	61 e0       	ldi	r22, 0x01	; 1
    847a:	0e 94 ea 1d 	call	0x3bd4	; 0x3bd4 <HAL_LED_u8LedInit>
}
    847e:	cf 91       	pop	r28
    8480:	df 91       	pop	r29
    8482:	08 95       	ret

00008484 <APP_Autonomous_Car_voidApp>:
void APP_Autonomous_Car_voidApp(void) {
    8484:	0f 93       	push	r16
    8486:	1f 93       	push	r17
    8488:	df 93       	push	r29
    848a:	cf 93       	push	r28
    848c:	cd b7       	in	r28, 0x3d	; 61
    848e:	de b7       	in	r29, 0x3e	; 62
    8490:	c1 5c       	subi	r28, 0xC1	; 193
    8492:	d0 40       	sbci	r29, 0x00	; 0
    8494:	0f b6       	in	r0, 0x3f	; 63
    8496:	f8 94       	cli
    8498:	de bf       	out	0x3e, r29	; 62
    849a:	0f be       	out	0x3f, r0	; 63
    849c:	cd bf       	out	0x3d, r28	; 61
	u8 Loc_u8direction = 'E';
    849e:	fe 01       	movw	r30, r28
    84a0:	e3 54       	subi	r30, 0x43	; 67
    84a2:	ff 4f       	sbci	r31, 0xFF	; 255
    84a4:	85 e4       	ldi	r24, 0x45	; 69
    84a6:	80 83       	st	Z, r24
	f32 LOC_f32Distance = NUM0;
    84a8:	fe 01       	movw	r30, r28
    84aa:	e2 54       	subi	r30, 0x42	; 66
    84ac:	ff 4f       	sbci	r31, 0xFF	; 255
    84ae:	80 e0       	ldi	r24, 0x00	; 0
    84b0:	90 e0       	ldi	r25, 0x00	; 0
    84b2:	a0 e0       	ldi	r26, 0x00	; 0
    84b4:	b0 e0       	ldi	r27, 0x00	; 0
    84b6:	80 83       	st	Z, r24
    84b8:	91 83       	std	Z+1, r25	; 0x01
    84ba:	a2 83       	std	Z+2, r26	; 0x02
    84bc:	b3 83       	std	Z+3, r27	; 0x03
	//	Initially Set Servo Angle 90
	HAL_SM_voidSMSetAngle(START_ANGLE);
    84be:	8a e5       	ldi	r24, 0x5A	; 90
    84c0:	0e 94 f1 1b 	call	0x37e2	; 0x37e2 <HAL_SM_voidSMSetAngle>
	//Light Front LEDS
	HAL_LED_u8LedMode(PortA, Pin0, LED_ON);
    84c4:	80 e0       	ldi	r24, 0x00	; 0
    84c6:	60 e0       	ldi	r22, 0x00	; 0
    84c8:	41 e0       	ldi	r20, 0x01	; 1
    84ca:	0e 94 07 1e 	call	0x3c0e	; 0x3c0e <HAL_LED_u8LedMode>
	while (NUM1) {
		MCAL_UART_UARTReceive(Loc_u8direction);
    84ce:	fe 01       	movw	r30, r28
    84d0:	e3 54       	subi	r30, 0x43	; 67
    84d2:	ff 4f       	sbci	r31, 0xFF	; 255
    84d4:	80 81       	ld	r24, Z
    84d6:	88 2f       	mov	r24, r24
    84d8:	90 e0       	ldi	r25, 0x00	; 0
    84da:	0e 94 f3 07 	call	0xfe6	; 0xfe6 <MCAL_UART_UARTReceive>
		if(Loc_u8direction=='x'){
    84de:	fe 01       	movw	r30, r28
    84e0:	e3 54       	subi	r30, 0x43	; 67
    84e2:	ff 4f       	sbci	r31, 0xFF	; 255
    84e4:	80 81       	ld	r24, Z
    84e6:	88 37       	cpi	r24, 0x78	; 120
    84e8:	11 f4       	brne	.+4      	; 0x84ee <APP_Autonomous_Car_voidApp+0x6a>
			APP_Control_Car_App();
    84ea:	0e 94 f6 3d 	call	0x7bec	; 0x7bec <APP_Control_Car_App>
    84ee:	fe 01       	movw	r30, r28
    84f0:	ed 54       	subi	r30, 0x4D	; 77
    84f2:	ff 4f       	sbci	r31, 0xFF	; 255
    84f4:	80 e0       	ldi	r24, 0x00	; 0
    84f6:	90 e0       	ldi	r25, 0x00	; 0
    84f8:	a8 e4       	ldi	r26, 0x48	; 72
    84fa:	b2 e4       	ldi	r27, 0x42	; 66
    84fc:	80 83       	st	Z, r24
    84fe:	91 83       	std	Z+1, r25	; 0x01
    8500:	a2 83       	std	Z+2, r26	; 0x02
    8502:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8504:	8e 01       	movw	r16, r28
    8506:	01 55       	subi	r16, 0x51	; 81
    8508:	1f 4f       	sbci	r17, 0xFF	; 255
    850a:	fe 01       	movw	r30, r28
    850c:	ed 54       	subi	r30, 0x4D	; 77
    850e:	ff 4f       	sbci	r31, 0xFF	; 255
    8510:	60 81       	ld	r22, Z
    8512:	71 81       	ldd	r23, Z+1	; 0x01
    8514:	82 81       	ldd	r24, Z+2	; 0x02
    8516:	93 81       	ldd	r25, Z+3	; 0x03
    8518:	20 e0       	ldi	r18, 0x00	; 0
    851a:	30 e0       	ldi	r19, 0x00	; 0
    851c:	4a e7       	ldi	r20, 0x7A	; 122
    851e:	55 e4       	ldi	r21, 0x45	; 69
    8520:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8524:	dc 01       	movw	r26, r24
    8526:	cb 01       	movw	r24, r22
    8528:	f8 01       	movw	r30, r16
    852a:	80 83       	st	Z, r24
    852c:	91 83       	std	Z+1, r25	; 0x01
    852e:	a2 83       	std	Z+2, r26	; 0x02
    8530:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    8532:	fe 01       	movw	r30, r28
    8534:	e1 55       	subi	r30, 0x51	; 81
    8536:	ff 4f       	sbci	r31, 0xFF	; 255
    8538:	60 81       	ld	r22, Z
    853a:	71 81       	ldd	r23, Z+1	; 0x01
    853c:	82 81       	ldd	r24, Z+2	; 0x02
    853e:	93 81       	ldd	r25, Z+3	; 0x03
    8540:	20 e0       	ldi	r18, 0x00	; 0
    8542:	30 e0       	ldi	r19, 0x00	; 0
    8544:	40 e8       	ldi	r20, 0x80	; 128
    8546:	5f e3       	ldi	r21, 0x3F	; 63
    8548:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    854c:	88 23       	and	r24, r24
    854e:	44 f4       	brge	.+16     	; 0x8560 <APP_Autonomous_Car_voidApp+0xdc>
		__ticks = 1;
    8550:	fe 01       	movw	r30, r28
    8552:	e3 55       	subi	r30, 0x53	; 83
    8554:	ff 4f       	sbci	r31, 0xFF	; 255
    8556:	81 e0       	ldi	r24, 0x01	; 1
    8558:	90 e0       	ldi	r25, 0x00	; 0
    855a:	91 83       	std	Z+1, r25	; 0x01
    855c:	80 83       	st	Z, r24
    855e:	64 c0       	rjmp	.+200    	; 0x8628 <APP_Autonomous_Car_voidApp+0x1a4>
	else if (__tmp > 65535)
    8560:	fe 01       	movw	r30, r28
    8562:	e1 55       	subi	r30, 0x51	; 81
    8564:	ff 4f       	sbci	r31, 0xFF	; 255
    8566:	60 81       	ld	r22, Z
    8568:	71 81       	ldd	r23, Z+1	; 0x01
    856a:	82 81       	ldd	r24, Z+2	; 0x02
    856c:	93 81       	ldd	r25, Z+3	; 0x03
    856e:	20 e0       	ldi	r18, 0x00	; 0
    8570:	3f ef       	ldi	r19, 0xFF	; 255
    8572:	4f e7       	ldi	r20, 0x7F	; 127
    8574:	57 e4       	ldi	r21, 0x47	; 71
    8576:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    857a:	18 16       	cp	r1, r24
    857c:	0c f0       	brlt	.+2      	; 0x8580 <APP_Autonomous_Car_voidApp+0xfc>
    857e:	43 c0       	rjmp	.+134    	; 0x8606 <APP_Autonomous_Car_voidApp+0x182>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    8580:	fe 01       	movw	r30, r28
    8582:	ed 54       	subi	r30, 0x4D	; 77
    8584:	ff 4f       	sbci	r31, 0xFF	; 255
    8586:	60 81       	ld	r22, Z
    8588:	71 81       	ldd	r23, Z+1	; 0x01
    858a:	82 81       	ldd	r24, Z+2	; 0x02
    858c:	93 81       	ldd	r25, Z+3	; 0x03
    858e:	20 e0       	ldi	r18, 0x00	; 0
    8590:	30 e0       	ldi	r19, 0x00	; 0
    8592:	40 e2       	ldi	r20, 0x20	; 32
    8594:	51 e4       	ldi	r21, 0x41	; 65
    8596:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    859a:	dc 01       	movw	r26, r24
    859c:	cb 01       	movw	r24, r22
    859e:	8e 01       	movw	r16, r28
    85a0:	03 55       	subi	r16, 0x53	; 83
    85a2:	1f 4f       	sbci	r17, 0xFF	; 255
    85a4:	bc 01       	movw	r22, r24
    85a6:	cd 01       	movw	r24, r26
    85a8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    85ac:	dc 01       	movw	r26, r24
    85ae:	cb 01       	movw	r24, r22
    85b0:	f8 01       	movw	r30, r16
    85b2:	91 83       	std	Z+1, r25	; 0x01
    85b4:	80 83       	st	Z, r24
    85b6:	1f c0       	rjmp	.+62     	; 0x85f6 <APP_Autonomous_Car_voidApp+0x172>
    85b8:	fe 01       	movw	r30, r28
    85ba:	e5 55       	subi	r30, 0x55	; 85
    85bc:	ff 4f       	sbci	r31, 0xFF	; 255
    85be:	80 e9       	ldi	r24, 0x90	; 144
    85c0:	91 e0       	ldi	r25, 0x01	; 1
    85c2:	91 83       	std	Z+1, r25	; 0x01
    85c4:	80 83       	st	Z, r24
    85c6:	fe 01       	movw	r30, r28
    85c8:	e5 55       	subi	r30, 0x55	; 85
    85ca:	ff 4f       	sbci	r31, 0xFF	; 255
    85cc:	80 81       	ld	r24, Z
    85ce:	91 81       	ldd	r25, Z+1	; 0x01
    85d0:	01 97       	sbiw	r24, 0x01	; 1
    85d2:	f1 f7       	brne	.-4      	; 0x85d0 <APP_Autonomous_Car_voidApp+0x14c>
    85d4:	fe 01       	movw	r30, r28
    85d6:	e5 55       	subi	r30, 0x55	; 85
    85d8:	ff 4f       	sbci	r31, 0xFF	; 255
    85da:	91 83       	std	Z+1, r25	; 0x01
    85dc:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    85de:	de 01       	movw	r26, r28
    85e0:	a3 55       	subi	r26, 0x53	; 83
    85e2:	bf 4f       	sbci	r27, 0xFF	; 255
    85e4:	fe 01       	movw	r30, r28
    85e6:	e3 55       	subi	r30, 0x53	; 83
    85e8:	ff 4f       	sbci	r31, 0xFF	; 255
    85ea:	80 81       	ld	r24, Z
    85ec:	91 81       	ldd	r25, Z+1	; 0x01
    85ee:	01 97       	sbiw	r24, 0x01	; 1
    85f0:	11 96       	adiw	r26, 0x01	; 1
    85f2:	9c 93       	st	X, r25
    85f4:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    85f6:	fe 01       	movw	r30, r28
    85f8:	e3 55       	subi	r30, 0x53	; 83
    85fa:	ff 4f       	sbci	r31, 0xFF	; 255
    85fc:	80 81       	ld	r24, Z
    85fe:	91 81       	ldd	r25, Z+1	; 0x01
    8600:	00 97       	sbiw	r24, 0x00	; 0
    8602:	d1 f6       	brne	.-76     	; 0x85b8 <APP_Autonomous_Car_voidApp+0x134>
    8604:	27 c0       	rjmp	.+78     	; 0x8654 <APP_Autonomous_Car_voidApp+0x1d0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8606:	8e 01       	movw	r16, r28
    8608:	03 55       	subi	r16, 0x53	; 83
    860a:	1f 4f       	sbci	r17, 0xFF	; 255
    860c:	fe 01       	movw	r30, r28
    860e:	e1 55       	subi	r30, 0x51	; 81
    8610:	ff 4f       	sbci	r31, 0xFF	; 255
    8612:	60 81       	ld	r22, Z
    8614:	71 81       	ldd	r23, Z+1	; 0x01
    8616:	82 81       	ldd	r24, Z+2	; 0x02
    8618:	93 81       	ldd	r25, Z+3	; 0x03
    861a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    861e:	dc 01       	movw	r26, r24
    8620:	cb 01       	movw	r24, r22
    8622:	f8 01       	movw	r30, r16
    8624:	91 83       	std	Z+1, r25	; 0x01
    8626:	80 83       	st	Z, r24
    8628:	de 01       	movw	r26, r28
    862a:	a7 55       	subi	r26, 0x57	; 87
    862c:	bf 4f       	sbci	r27, 0xFF	; 255
    862e:	fe 01       	movw	r30, r28
    8630:	e3 55       	subi	r30, 0x53	; 83
    8632:	ff 4f       	sbci	r31, 0xFF	; 255
    8634:	80 81       	ld	r24, Z
    8636:	91 81       	ldd	r25, Z+1	; 0x01
    8638:	8d 93       	st	X+, r24
    863a:	9c 93       	st	X, r25
    863c:	fe 01       	movw	r30, r28
    863e:	e7 55       	subi	r30, 0x57	; 87
    8640:	ff 4f       	sbci	r31, 0xFF	; 255
    8642:	80 81       	ld	r24, Z
    8644:	91 81       	ldd	r25, Z+1	; 0x01
    8646:	01 97       	sbiw	r24, 0x01	; 1
    8648:	f1 f7       	brne	.-4      	; 0x8646 <APP_Autonomous_Car_voidApp+0x1c2>
    864a:	fe 01       	movw	r30, r28
    864c:	e7 55       	subi	r30, 0x57	; 87
    864e:	ff 4f       	sbci	r31, 0xFF	; 255
    8650:	91 83       	std	Z+1, r25	; 0x01
    8652:	80 83       	st	Z, r24
		}
		_delay_ms(50);
		HAL_Ultrasonic_Sensor_voidCalcDistancse(&LOC_f32Distance);
    8654:	ce 01       	movw	r24, r28
    8656:	82 54       	subi	r24, 0x42	; 66
    8658:	9f 4f       	sbci	r25, 0xFF	; 255
    865a:	0e 94 c9 1a 	call	0x3592	; 0x3592 <HAL_Ultrasonic_Sensor_voidCalcDistancse>
//		Glob_u16DirFront = LOC_f32Distance;
		if (LOC_f32Distance > DISTANCE_30) {
    865e:	fe 01       	movw	r30, r28
    8660:	e2 54       	subi	r30, 0x42	; 66
    8662:	ff 4f       	sbci	r31, 0xFF	; 255
    8664:	80 81       	ld	r24, Z
    8666:	91 81       	ldd	r25, Z+1	; 0x01
    8668:	a2 81       	ldd	r26, Z+2	; 0x02
    866a:	b3 81       	ldd	r27, Z+3	; 0x03
    866c:	bc 01       	movw	r22, r24
    866e:	cd 01       	movw	r24, r26
    8670:	20 e0       	ldi	r18, 0x00	; 0
    8672:	30 e0       	ldi	r19, 0x00	; 0
    8674:	40 ef       	ldi	r20, 0xF0	; 240
    8676:	51 e4       	ldi	r21, 0x41	; 65
    8678:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    867c:	18 16       	cp	r1, r24
    867e:	0c f0       	brlt	.+2      	; 0x8682 <APP_Autonomous_Car_voidApp+0x1fe>
    8680:	50 c2       	rjmp	.+1184   	; 0x8b22 <APP_Autonomous_Car_voidApp+0x69e>
			HAL_LCD_u8Clear();
    8682:	0e 94 7e 26 	call	0x4cfc	; 0x4cfc <HAL_LCD_u8Clear>
			HAL_LCD_u8SendString("Moving Front...");
    8686:	8c eb       	ldi	r24, 0xBC	; 188
    8688:	90 e0       	ldi	r25, 0x00	; 0
    868a:	0e 94 c9 23 	call	0x4792	; 0x4792 <HAL_LCD_u8SendString>
			HAL_LCD_u8GoTo(Second_Line, NUM0);
    868e:	83 e0       	ldi	r24, 0x03	; 3
    8690:	60 e0       	ldi	r22, 0x00	; 0
    8692:	0e 94 22 24 	call	0x4844	; 0x4844 <HAL_LCD_u8GoTo>
			HAL_LCD_u8SendString("Distance: ");
    8696:	8c ec       	ldi	r24, 0xCC	; 204
    8698:	90 e0       	ldi	r25, 0x00	; 0
    869a:	0e 94 c9 23 	call	0x4792	; 0x4792 <HAL_LCD_u8SendString>
    869e:	fe 01       	movw	r30, r28
    86a0:	eb 55       	subi	r30, 0x5B	; 91
    86a2:	ff 4f       	sbci	r31, 0xFF	; 255
    86a4:	80 e0       	ldi	r24, 0x00	; 0
    86a6:	90 e0       	ldi	r25, 0x00	; 0
    86a8:	a8 e4       	ldi	r26, 0x48	; 72
    86aa:	b2 e4       	ldi	r27, 0x42	; 66
    86ac:	80 83       	st	Z, r24
    86ae:	91 83       	std	Z+1, r25	; 0x01
    86b0:	a2 83       	std	Z+2, r26	; 0x02
    86b2:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    86b4:	8e 01       	movw	r16, r28
    86b6:	0f 55       	subi	r16, 0x5F	; 95
    86b8:	1f 4f       	sbci	r17, 0xFF	; 255
    86ba:	fe 01       	movw	r30, r28
    86bc:	eb 55       	subi	r30, 0x5B	; 91
    86be:	ff 4f       	sbci	r31, 0xFF	; 255
    86c0:	60 81       	ld	r22, Z
    86c2:	71 81       	ldd	r23, Z+1	; 0x01
    86c4:	82 81       	ldd	r24, Z+2	; 0x02
    86c6:	93 81       	ldd	r25, Z+3	; 0x03
    86c8:	20 e0       	ldi	r18, 0x00	; 0
    86ca:	30 e0       	ldi	r19, 0x00	; 0
    86cc:	4a e7       	ldi	r20, 0x7A	; 122
    86ce:	55 e4       	ldi	r21, 0x45	; 69
    86d0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    86d4:	dc 01       	movw	r26, r24
    86d6:	cb 01       	movw	r24, r22
    86d8:	f8 01       	movw	r30, r16
    86da:	80 83       	st	Z, r24
    86dc:	91 83       	std	Z+1, r25	; 0x01
    86de:	a2 83       	std	Z+2, r26	; 0x02
    86e0:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    86e2:	fe 01       	movw	r30, r28
    86e4:	ef 55       	subi	r30, 0x5F	; 95
    86e6:	ff 4f       	sbci	r31, 0xFF	; 255
    86e8:	60 81       	ld	r22, Z
    86ea:	71 81       	ldd	r23, Z+1	; 0x01
    86ec:	82 81       	ldd	r24, Z+2	; 0x02
    86ee:	93 81       	ldd	r25, Z+3	; 0x03
    86f0:	20 e0       	ldi	r18, 0x00	; 0
    86f2:	30 e0       	ldi	r19, 0x00	; 0
    86f4:	40 e8       	ldi	r20, 0x80	; 128
    86f6:	5f e3       	ldi	r21, 0x3F	; 63
    86f8:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    86fc:	88 23       	and	r24, r24
    86fe:	44 f4       	brge	.+16     	; 0x8710 <APP_Autonomous_Car_voidApp+0x28c>
		__ticks = 1;
    8700:	fe 01       	movw	r30, r28
    8702:	e1 56       	subi	r30, 0x61	; 97
    8704:	ff 4f       	sbci	r31, 0xFF	; 255
    8706:	81 e0       	ldi	r24, 0x01	; 1
    8708:	90 e0       	ldi	r25, 0x00	; 0
    870a:	91 83       	std	Z+1, r25	; 0x01
    870c:	80 83       	st	Z, r24
    870e:	64 c0       	rjmp	.+200    	; 0x87d8 <APP_Autonomous_Car_voidApp+0x354>
	else if (__tmp > 65535)
    8710:	fe 01       	movw	r30, r28
    8712:	ef 55       	subi	r30, 0x5F	; 95
    8714:	ff 4f       	sbci	r31, 0xFF	; 255
    8716:	60 81       	ld	r22, Z
    8718:	71 81       	ldd	r23, Z+1	; 0x01
    871a:	82 81       	ldd	r24, Z+2	; 0x02
    871c:	93 81       	ldd	r25, Z+3	; 0x03
    871e:	20 e0       	ldi	r18, 0x00	; 0
    8720:	3f ef       	ldi	r19, 0xFF	; 255
    8722:	4f e7       	ldi	r20, 0x7F	; 127
    8724:	57 e4       	ldi	r21, 0x47	; 71
    8726:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    872a:	18 16       	cp	r1, r24
    872c:	0c f0       	brlt	.+2      	; 0x8730 <APP_Autonomous_Car_voidApp+0x2ac>
    872e:	43 c0       	rjmp	.+134    	; 0x87b6 <APP_Autonomous_Car_voidApp+0x332>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    8730:	fe 01       	movw	r30, r28
    8732:	eb 55       	subi	r30, 0x5B	; 91
    8734:	ff 4f       	sbci	r31, 0xFF	; 255
    8736:	60 81       	ld	r22, Z
    8738:	71 81       	ldd	r23, Z+1	; 0x01
    873a:	82 81       	ldd	r24, Z+2	; 0x02
    873c:	93 81       	ldd	r25, Z+3	; 0x03
    873e:	20 e0       	ldi	r18, 0x00	; 0
    8740:	30 e0       	ldi	r19, 0x00	; 0
    8742:	40 e2       	ldi	r20, 0x20	; 32
    8744:	51 e4       	ldi	r21, 0x41	; 65
    8746:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    874a:	dc 01       	movw	r26, r24
    874c:	cb 01       	movw	r24, r22
    874e:	8e 01       	movw	r16, r28
    8750:	01 56       	subi	r16, 0x61	; 97
    8752:	1f 4f       	sbci	r17, 0xFF	; 255
    8754:	bc 01       	movw	r22, r24
    8756:	cd 01       	movw	r24, r26
    8758:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    875c:	dc 01       	movw	r26, r24
    875e:	cb 01       	movw	r24, r22
    8760:	f8 01       	movw	r30, r16
    8762:	91 83       	std	Z+1, r25	; 0x01
    8764:	80 83       	st	Z, r24
    8766:	1f c0       	rjmp	.+62     	; 0x87a6 <APP_Autonomous_Car_voidApp+0x322>
    8768:	fe 01       	movw	r30, r28
    876a:	e3 56       	subi	r30, 0x63	; 99
    876c:	ff 4f       	sbci	r31, 0xFF	; 255
    876e:	80 e9       	ldi	r24, 0x90	; 144
    8770:	91 e0       	ldi	r25, 0x01	; 1
    8772:	91 83       	std	Z+1, r25	; 0x01
    8774:	80 83       	st	Z, r24
    8776:	fe 01       	movw	r30, r28
    8778:	e3 56       	subi	r30, 0x63	; 99
    877a:	ff 4f       	sbci	r31, 0xFF	; 255
    877c:	80 81       	ld	r24, Z
    877e:	91 81       	ldd	r25, Z+1	; 0x01
    8780:	01 97       	sbiw	r24, 0x01	; 1
    8782:	f1 f7       	brne	.-4      	; 0x8780 <APP_Autonomous_Car_voidApp+0x2fc>
    8784:	fe 01       	movw	r30, r28
    8786:	e3 56       	subi	r30, 0x63	; 99
    8788:	ff 4f       	sbci	r31, 0xFF	; 255
    878a:	91 83       	std	Z+1, r25	; 0x01
    878c:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    878e:	de 01       	movw	r26, r28
    8790:	a1 56       	subi	r26, 0x61	; 97
    8792:	bf 4f       	sbci	r27, 0xFF	; 255
    8794:	fe 01       	movw	r30, r28
    8796:	e1 56       	subi	r30, 0x61	; 97
    8798:	ff 4f       	sbci	r31, 0xFF	; 255
    879a:	80 81       	ld	r24, Z
    879c:	91 81       	ldd	r25, Z+1	; 0x01
    879e:	01 97       	sbiw	r24, 0x01	; 1
    87a0:	11 96       	adiw	r26, 0x01	; 1
    87a2:	9c 93       	st	X, r25
    87a4:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    87a6:	fe 01       	movw	r30, r28
    87a8:	e1 56       	subi	r30, 0x61	; 97
    87aa:	ff 4f       	sbci	r31, 0xFF	; 255
    87ac:	80 81       	ld	r24, Z
    87ae:	91 81       	ldd	r25, Z+1	; 0x01
    87b0:	00 97       	sbiw	r24, 0x00	; 0
    87b2:	d1 f6       	brne	.-76     	; 0x8768 <APP_Autonomous_Car_voidApp+0x2e4>
    87b4:	27 c0       	rjmp	.+78     	; 0x8804 <APP_Autonomous_Car_voidApp+0x380>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    87b6:	8e 01       	movw	r16, r28
    87b8:	01 56       	subi	r16, 0x61	; 97
    87ba:	1f 4f       	sbci	r17, 0xFF	; 255
    87bc:	fe 01       	movw	r30, r28
    87be:	ef 55       	subi	r30, 0x5F	; 95
    87c0:	ff 4f       	sbci	r31, 0xFF	; 255
    87c2:	60 81       	ld	r22, Z
    87c4:	71 81       	ldd	r23, Z+1	; 0x01
    87c6:	82 81       	ldd	r24, Z+2	; 0x02
    87c8:	93 81       	ldd	r25, Z+3	; 0x03
    87ca:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    87ce:	dc 01       	movw	r26, r24
    87d0:	cb 01       	movw	r24, r22
    87d2:	f8 01       	movw	r30, r16
    87d4:	91 83       	std	Z+1, r25	; 0x01
    87d6:	80 83       	st	Z, r24
    87d8:	de 01       	movw	r26, r28
    87da:	a5 56       	subi	r26, 0x65	; 101
    87dc:	bf 4f       	sbci	r27, 0xFF	; 255
    87de:	fe 01       	movw	r30, r28
    87e0:	e1 56       	subi	r30, 0x61	; 97
    87e2:	ff 4f       	sbci	r31, 0xFF	; 255
    87e4:	80 81       	ld	r24, Z
    87e6:	91 81       	ldd	r25, Z+1	; 0x01
    87e8:	8d 93       	st	X+, r24
    87ea:	9c 93       	st	X, r25
    87ec:	fe 01       	movw	r30, r28
    87ee:	e5 56       	subi	r30, 0x65	; 101
    87f0:	ff 4f       	sbci	r31, 0xFF	; 255
    87f2:	80 81       	ld	r24, Z
    87f4:	91 81       	ldd	r25, Z+1	; 0x01
    87f6:	01 97       	sbiw	r24, 0x01	; 1
    87f8:	f1 f7       	brne	.-4      	; 0x87f6 <APP_Autonomous_Car_voidApp+0x372>
    87fa:	fe 01       	movw	r30, r28
    87fc:	e5 56       	subi	r30, 0x65	; 101
    87fe:	ff 4f       	sbci	r31, 0xFF	; 255
    8800:	91 83       	std	Z+1, r25	; 0x01
    8802:	80 83       	st	Z, r24
			_delay_ms(50);
			HAL_Ultrasonic_Sensor_voidCalcDistancse(&LOC_f32Distance);
    8804:	ce 01       	movw	r24, r28
    8806:	82 54       	subi	r24, 0x42	; 66
    8808:	9f 4f       	sbci	r25, 0xFF	; 255
    880a:	0e 94 c9 1a 	call	0x3592	; 0x3592 <HAL_Ultrasonic_Sensor_voidCalcDistancse>
    880e:	fe 01       	movw	r30, r28
    8810:	e9 56       	subi	r30, 0x69	; 105
    8812:	ff 4f       	sbci	r31, 0xFF	; 255
    8814:	80 e0       	ldi	r24, 0x00	; 0
    8816:	90 e0       	ldi	r25, 0x00	; 0
    8818:	a8 e4       	ldi	r26, 0x48	; 72
    881a:	b2 e4       	ldi	r27, 0x42	; 66
    881c:	80 83       	st	Z, r24
    881e:	91 83       	std	Z+1, r25	; 0x01
    8820:	a2 83       	std	Z+2, r26	; 0x02
    8822:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8824:	8e 01       	movw	r16, r28
    8826:	0d 56       	subi	r16, 0x6D	; 109
    8828:	1f 4f       	sbci	r17, 0xFF	; 255
    882a:	fe 01       	movw	r30, r28
    882c:	e9 56       	subi	r30, 0x69	; 105
    882e:	ff 4f       	sbci	r31, 0xFF	; 255
    8830:	60 81       	ld	r22, Z
    8832:	71 81       	ldd	r23, Z+1	; 0x01
    8834:	82 81       	ldd	r24, Z+2	; 0x02
    8836:	93 81       	ldd	r25, Z+3	; 0x03
    8838:	20 e0       	ldi	r18, 0x00	; 0
    883a:	30 e0       	ldi	r19, 0x00	; 0
    883c:	4a e7       	ldi	r20, 0x7A	; 122
    883e:	55 e4       	ldi	r21, 0x45	; 69
    8840:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8844:	dc 01       	movw	r26, r24
    8846:	cb 01       	movw	r24, r22
    8848:	f8 01       	movw	r30, r16
    884a:	80 83       	st	Z, r24
    884c:	91 83       	std	Z+1, r25	; 0x01
    884e:	a2 83       	std	Z+2, r26	; 0x02
    8850:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    8852:	fe 01       	movw	r30, r28
    8854:	ed 56       	subi	r30, 0x6D	; 109
    8856:	ff 4f       	sbci	r31, 0xFF	; 255
    8858:	60 81       	ld	r22, Z
    885a:	71 81       	ldd	r23, Z+1	; 0x01
    885c:	82 81       	ldd	r24, Z+2	; 0x02
    885e:	93 81       	ldd	r25, Z+3	; 0x03
    8860:	20 e0       	ldi	r18, 0x00	; 0
    8862:	30 e0       	ldi	r19, 0x00	; 0
    8864:	40 e8       	ldi	r20, 0x80	; 128
    8866:	5f e3       	ldi	r21, 0x3F	; 63
    8868:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    886c:	88 23       	and	r24, r24
    886e:	44 f4       	brge	.+16     	; 0x8880 <APP_Autonomous_Car_voidApp+0x3fc>
		__ticks = 1;
    8870:	fe 01       	movw	r30, r28
    8872:	ef 56       	subi	r30, 0x6F	; 111
    8874:	ff 4f       	sbci	r31, 0xFF	; 255
    8876:	81 e0       	ldi	r24, 0x01	; 1
    8878:	90 e0       	ldi	r25, 0x00	; 0
    887a:	91 83       	std	Z+1, r25	; 0x01
    887c:	80 83       	st	Z, r24
    887e:	64 c0       	rjmp	.+200    	; 0x8948 <APP_Autonomous_Car_voidApp+0x4c4>
	else if (__tmp > 65535)
    8880:	fe 01       	movw	r30, r28
    8882:	ed 56       	subi	r30, 0x6D	; 109
    8884:	ff 4f       	sbci	r31, 0xFF	; 255
    8886:	60 81       	ld	r22, Z
    8888:	71 81       	ldd	r23, Z+1	; 0x01
    888a:	82 81       	ldd	r24, Z+2	; 0x02
    888c:	93 81       	ldd	r25, Z+3	; 0x03
    888e:	20 e0       	ldi	r18, 0x00	; 0
    8890:	3f ef       	ldi	r19, 0xFF	; 255
    8892:	4f e7       	ldi	r20, 0x7F	; 127
    8894:	57 e4       	ldi	r21, 0x47	; 71
    8896:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    889a:	18 16       	cp	r1, r24
    889c:	0c f0       	brlt	.+2      	; 0x88a0 <APP_Autonomous_Car_voidApp+0x41c>
    889e:	43 c0       	rjmp	.+134    	; 0x8926 <APP_Autonomous_Car_voidApp+0x4a2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    88a0:	fe 01       	movw	r30, r28
    88a2:	e9 56       	subi	r30, 0x69	; 105
    88a4:	ff 4f       	sbci	r31, 0xFF	; 255
    88a6:	60 81       	ld	r22, Z
    88a8:	71 81       	ldd	r23, Z+1	; 0x01
    88aa:	82 81       	ldd	r24, Z+2	; 0x02
    88ac:	93 81       	ldd	r25, Z+3	; 0x03
    88ae:	20 e0       	ldi	r18, 0x00	; 0
    88b0:	30 e0       	ldi	r19, 0x00	; 0
    88b2:	40 e2       	ldi	r20, 0x20	; 32
    88b4:	51 e4       	ldi	r21, 0x41	; 65
    88b6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    88ba:	dc 01       	movw	r26, r24
    88bc:	cb 01       	movw	r24, r22
    88be:	8e 01       	movw	r16, r28
    88c0:	0f 56       	subi	r16, 0x6F	; 111
    88c2:	1f 4f       	sbci	r17, 0xFF	; 255
    88c4:	bc 01       	movw	r22, r24
    88c6:	cd 01       	movw	r24, r26
    88c8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    88cc:	dc 01       	movw	r26, r24
    88ce:	cb 01       	movw	r24, r22
    88d0:	f8 01       	movw	r30, r16
    88d2:	91 83       	std	Z+1, r25	; 0x01
    88d4:	80 83       	st	Z, r24
    88d6:	1f c0       	rjmp	.+62     	; 0x8916 <APP_Autonomous_Car_voidApp+0x492>
    88d8:	fe 01       	movw	r30, r28
    88da:	e1 57       	subi	r30, 0x71	; 113
    88dc:	ff 4f       	sbci	r31, 0xFF	; 255
    88de:	80 e9       	ldi	r24, 0x90	; 144
    88e0:	91 e0       	ldi	r25, 0x01	; 1
    88e2:	91 83       	std	Z+1, r25	; 0x01
    88e4:	80 83       	st	Z, r24
    88e6:	fe 01       	movw	r30, r28
    88e8:	e1 57       	subi	r30, 0x71	; 113
    88ea:	ff 4f       	sbci	r31, 0xFF	; 255
    88ec:	80 81       	ld	r24, Z
    88ee:	91 81       	ldd	r25, Z+1	; 0x01
    88f0:	01 97       	sbiw	r24, 0x01	; 1
    88f2:	f1 f7       	brne	.-4      	; 0x88f0 <APP_Autonomous_Car_voidApp+0x46c>
    88f4:	fe 01       	movw	r30, r28
    88f6:	e1 57       	subi	r30, 0x71	; 113
    88f8:	ff 4f       	sbci	r31, 0xFF	; 255
    88fa:	91 83       	std	Z+1, r25	; 0x01
    88fc:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    88fe:	de 01       	movw	r26, r28
    8900:	af 56       	subi	r26, 0x6F	; 111
    8902:	bf 4f       	sbci	r27, 0xFF	; 255
    8904:	fe 01       	movw	r30, r28
    8906:	ef 56       	subi	r30, 0x6F	; 111
    8908:	ff 4f       	sbci	r31, 0xFF	; 255
    890a:	80 81       	ld	r24, Z
    890c:	91 81       	ldd	r25, Z+1	; 0x01
    890e:	01 97       	sbiw	r24, 0x01	; 1
    8910:	11 96       	adiw	r26, 0x01	; 1
    8912:	9c 93       	st	X, r25
    8914:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8916:	fe 01       	movw	r30, r28
    8918:	ef 56       	subi	r30, 0x6F	; 111
    891a:	ff 4f       	sbci	r31, 0xFF	; 255
    891c:	80 81       	ld	r24, Z
    891e:	91 81       	ldd	r25, Z+1	; 0x01
    8920:	00 97       	sbiw	r24, 0x00	; 0
    8922:	d1 f6       	brne	.-76     	; 0x88d8 <APP_Autonomous_Car_voidApp+0x454>
    8924:	27 c0       	rjmp	.+78     	; 0x8974 <APP_Autonomous_Car_voidApp+0x4f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8926:	8e 01       	movw	r16, r28
    8928:	0f 56       	subi	r16, 0x6F	; 111
    892a:	1f 4f       	sbci	r17, 0xFF	; 255
    892c:	fe 01       	movw	r30, r28
    892e:	ed 56       	subi	r30, 0x6D	; 109
    8930:	ff 4f       	sbci	r31, 0xFF	; 255
    8932:	60 81       	ld	r22, Z
    8934:	71 81       	ldd	r23, Z+1	; 0x01
    8936:	82 81       	ldd	r24, Z+2	; 0x02
    8938:	93 81       	ldd	r25, Z+3	; 0x03
    893a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    893e:	dc 01       	movw	r26, r24
    8940:	cb 01       	movw	r24, r22
    8942:	f8 01       	movw	r30, r16
    8944:	91 83       	std	Z+1, r25	; 0x01
    8946:	80 83       	st	Z, r24
    8948:	de 01       	movw	r26, r28
    894a:	a3 57       	subi	r26, 0x73	; 115
    894c:	bf 4f       	sbci	r27, 0xFF	; 255
    894e:	fe 01       	movw	r30, r28
    8950:	ef 56       	subi	r30, 0x6F	; 111
    8952:	ff 4f       	sbci	r31, 0xFF	; 255
    8954:	80 81       	ld	r24, Z
    8956:	91 81       	ldd	r25, Z+1	; 0x01
    8958:	8d 93       	st	X+, r24
    895a:	9c 93       	st	X, r25
    895c:	fe 01       	movw	r30, r28
    895e:	e3 57       	subi	r30, 0x73	; 115
    8960:	ff 4f       	sbci	r31, 0xFF	; 255
    8962:	80 81       	ld	r24, Z
    8964:	91 81       	ldd	r25, Z+1	; 0x01
    8966:	01 97       	sbiw	r24, 0x01	; 1
    8968:	f1 f7       	brne	.-4      	; 0x8966 <APP_Autonomous_Car_voidApp+0x4e2>
    896a:	fe 01       	movw	r30, r28
    896c:	e3 57       	subi	r30, 0x73	; 115
    896e:	ff 4f       	sbci	r31, 0xFF	; 255
    8970:	91 83       	std	Z+1, r25	; 0x01
    8972:	80 83       	st	Z, r24
			_delay_ms(50);
			Glob_u16DirFront = LOC_f32Distance;
    8974:	fe 01       	movw	r30, r28
    8976:	e2 54       	subi	r30, 0x42	; 66
    8978:	ff 4f       	sbci	r31, 0xFF	; 255
    897a:	80 81       	ld	r24, Z
    897c:	91 81       	ldd	r25, Z+1	; 0x01
    897e:	a2 81       	ldd	r26, Z+2	; 0x02
    8980:	b3 81       	ldd	r27, Z+3	; 0x03
    8982:	bc 01       	movw	r22, r24
    8984:	cd 01       	movw	r24, r26
    8986:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    898a:	dc 01       	movw	r26, r24
    898c:	cb 01       	movw	r24, r22
    898e:	90 93 d5 06 	sts	0x06D5, r25
    8992:	80 93 d4 06 	sts	0x06D4, r24
			HAL_LCD_u8SendNumber(Glob_u16DirFront);
    8996:	80 91 d4 06 	lds	r24, 0x06D4
    899a:	90 91 d5 06 	lds	r25, 0x06D5
    899e:	0e 94 ff 23 	call	0x47fe	; 0x47fe <HAL_LCD_u8SendNumber>
    89a2:	fe 01       	movw	r30, r28
    89a4:	e7 57       	subi	r30, 0x77	; 119
    89a6:	ff 4f       	sbci	r31, 0xFF	; 255
    89a8:	80 e0       	ldi	r24, 0x00	; 0
    89aa:	90 e0       	ldi	r25, 0x00	; 0
    89ac:	a0 ea       	ldi	r26, 0xA0	; 160
    89ae:	b1 e4       	ldi	r27, 0x41	; 65
    89b0:	80 83       	st	Z, r24
    89b2:	91 83       	std	Z+1, r25	; 0x01
    89b4:	a2 83       	std	Z+2, r26	; 0x02
    89b6:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    89b8:	8e 01       	movw	r16, r28
    89ba:	0b 57       	subi	r16, 0x7B	; 123
    89bc:	1f 4f       	sbci	r17, 0xFF	; 255
    89be:	fe 01       	movw	r30, r28
    89c0:	e7 57       	subi	r30, 0x77	; 119
    89c2:	ff 4f       	sbci	r31, 0xFF	; 255
    89c4:	60 81       	ld	r22, Z
    89c6:	71 81       	ldd	r23, Z+1	; 0x01
    89c8:	82 81       	ldd	r24, Z+2	; 0x02
    89ca:	93 81       	ldd	r25, Z+3	; 0x03
    89cc:	20 e0       	ldi	r18, 0x00	; 0
    89ce:	30 e0       	ldi	r19, 0x00	; 0
    89d0:	4a e7       	ldi	r20, 0x7A	; 122
    89d2:	55 e4       	ldi	r21, 0x45	; 69
    89d4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    89d8:	dc 01       	movw	r26, r24
    89da:	cb 01       	movw	r24, r22
    89dc:	f8 01       	movw	r30, r16
    89de:	80 83       	st	Z, r24
    89e0:	91 83       	std	Z+1, r25	; 0x01
    89e2:	a2 83       	std	Z+2, r26	; 0x02
    89e4:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    89e6:	fe 01       	movw	r30, r28
    89e8:	eb 57       	subi	r30, 0x7B	; 123
    89ea:	ff 4f       	sbci	r31, 0xFF	; 255
    89ec:	60 81       	ld	r22, Z
    89ee:	71 81       	ldd	r23, Z+1	; 0x01
    89f0:	82 81       	ldd	r24, Z+2	; 0x02
    89f2:	93 81       	ldd	r25, Z+3	; 0x03
    89f4:	20 e0       	ldi	r18, 0x00	; 0
    89f6:	30 e0       	ldi	r19, 0x00	; 0
    89f8:	40 e8       	ldi	r20, 0x80	; 128
    89fa:	5f e3       	ldi	r21, 0x3F	; 63
    89fc:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    8a00:	88 23       	and	r24, r24
    8a02:	44 f4       	brge	.+16     	; 0x8a14 <APP_Autonomous_Car_voidApp+0x590>
		__ticks = 1;
    8a04:	fe 01       	movw	r30, r28
    8a06:	ed 57       	subi	r30, 0x7D	; 125
    8a08:	ff 4f       	sbci	r31, 0xFF	; 255
    8a0a:	81 e0       	ldi	r24, 0x01	; 1
    8a0c:	90 e0       	ldi	r25, 0x00	; 0
    8a0e:	91 83       	std	Z+1, r25	; 0x01
    8a10:	80 83       	st	Z, r24
    8a12:	64 c0       	rjmp	.+200    	; 0x8adc <APP_Autonomous_Car_voidApp+0x658>
	else if (__tmp > 65535)
    8a14:	fe 01       	movw	r30, r28
    8a16:	eb 57       	subi	r30, 0x7B	; 123
    8a18:	ff 4f       	sbci	r31, 0xFF	; 255
    8a1a:	60 81       	ld	r22, Z
    8a1c:	71 81       	ldd	r23, Z+1	; 0x01
    8a1e:	82 81       	ldd	r24, Z+2	; 0x02
    8a20:	93 81       	ldd	r25, Z+3	; 0x03
    8a22:	20 e0       	ldi	r18, 0x00	; 0
    8a24:	3f ef       	ldi	r19, 0xFF	; 255
    8a26:	4f e7       	ldi	r20, 0x7F	; 127
    8a28:	57 e4       	ldi	r21, 0x47	; 71
    8a2a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    8a2e:	18 16       	cp	r1, r24
    8a30:	0c f0       	brlt	.+2      	; 0x8a34 <APP_Autonomous_Car_voidApp+0x5b0>
    8a32:	43 c0       	rjmp	.+134    	; 0x8aba <APP_Autonomous_Car_voidApp+0x636>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    8a34:	fe 01       	movw	r30, r28
    8a36:	e7 57       	subi	r30, 0x77	; 119
    8a38:	ff 4f       	sbci	r31, 0xFF	; 255
    8a3a:	60 81       	ld	r22, Z
    8a3c:	71 81       	ldd	r23, Z+1	; 0x01
    8a3e:	82 81       	ldd	r24, Z+2	; 0x02
    8a40:	93 81       	ldd	r25, Z+3	; 0x03
    8a42:	20 e0       	ldi	r18, 0x00	; 0
    8a44:	30 e0       	ldi	r19, 0x00	; 0
    8a46:	40 e2       	ldi	r20, 0x20	; 32
    8a48:	51 e4       	ldi	r21, 0x41	; 65
    8a4a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8a4e:	dc 01       	movw	r26, r24
    8a50:	cb 01       	movw	r24, r22
    8a52:	8e 01       	movw	r16, r28
    8a54:	0d 57       	subi	r16, 0x7D	; 125
    8a56:	1f 4f       	sbci	r17, 0xFF	; 255
    8a58:	bc 01       	movw	r22, r24
    8a5a:	cd 01       	movw	r24, r26
    8a5c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8a60:	dc 01       	movw	r26, r24
    8a62:	cb 01       	movw	r24, r22
    8a64:	f8 01       	movw	r30, r16
    8a66:	91 83       	std	Z+1, r25	; 0x01
    8a68:	80 83       	st	Z, r24
    8a6a:	1f c0       	rjmp	.+62     	; 0x8aaa <APP_Autonomous_Car_voidApp+0x626>
    8a6c:	fe 01       	movw	r30, r28
    8a6e:	ef 57       	subi	r30, 0x7F	; 127
    8a70:	ff 4f       	sbci	r31, 0xFF	; 255
    8a72:	80 e9       	ldi	r24, 0x90	; 144
    8a74:	91 e0       	ldi	r25, 0x01	; 1
    8a76:	91 83       	std	Z+1, r25	; 0x01
    8a78:	80 83       	st	Z, r24
    8a7a:	fe 01       	movw	r30, r28
    8a7c:	ef 57       	subi	r30, 0x7F	; 127
    8a7e:	ff 4f       	sbci	r31, 0xFF	; 255
    8a80:	80 81       	ld	r24, Z
    8a82:	91 81       	ldd	r25, Z+1	; 0x01
    8a84:	01 97       	sbiw	r24, 0x01	; 1
    8a86:	f1 f7       	brne	.-4      	; 0x8a84 <APP_Autonomous_Car_voidApp+0x600>
    8a88:	fe 01       	movw	r30, r28
    8a8a:	ef 57       	subi	r30, 0x7F	; 127
    8a8c:	ff 4f       	sbci	r31, 0xFF	; 255
    8a8e:	91 83       	std	Z+1, r25	; 0x01
    8a90:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8a92:	de 01       	movw	r26, r28
    8a94:	ad 57       	subi	r26, 0x7D	; 125
    8a96:	bf 4f       	sbci	r27, 0xFF	; 255
    8a98:	fe 01       	movw	r30, r28
    8a9a:	ed 57       	subi	r30, 0x7D	; 125
    8a9c:	ff 4f       	sbci	r31, 0xFF	; 255
    8a9e:	80 81       	ld	r24, Z
    8aa0:	91 81       	ldd	r25, Z+1	; 0x01
    8aa2:	01 97       	sbiw	r24, 0x01	; 1
    8aa4:	11 96       	adiw	r26, 0x01	; 1
    8aa6:	9c 93       	st	X, r25
    8aa8:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8aaa:	fe 01       	movw	r30, r28
    8aac:	ed 57       	subi	r30, 0x7D	; 125
    8aae:	ff 4f       	sbci	r31, 0xFF	; 255
    8ab0:	80 81       	ld	r24, Z
    8ab2:	91 81       	ldd	r25, Z+1	; 0x01
    8ab4:	00 97       	sbiw	r24, 0x00	; 0
    8ab6:	d1 f6       	brne	.-76     	; 0x8a6c <APP_Autonomous_Car_voidApp+0x5e8>
    8ab8:	27 c0       	rjmp	.+78     	; 0x8b08 <APP_Autonomous_Car_voidApp+0x684>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8aba:	8e 01       	movw	r16, r28
    8abc:	0d 57       	subi	r16, 0x7D	; 125
    8abe:	1f 4f       	sbci	r17, 0xFF	; 255
    8ac0:	fe 01       	movw	r30, r28
    8ac2:	eb 57       	subi	r30, 0x7B	; 123
    8ac4:	ff 4f       	sbci	r31, 0xFF	; 255
    8ac6:	60 81       	ld	r22, Z
    8ac8:	71 81       	ldd	r23, Z+1	; 0x01
    8aca:	82 81       	ldd	r24, Z+2	; 0x02
    8acc:	93 81       	ldd	r25, Z+3	; 0x03
    8ace:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8ad2:	dc 01       	movw	r26, r24
    8ad4:	cb 01       	movw	r24, r22
    8ad6:	f8 01       	movw	r30, r16
    8ad8:	91 83       	std	Z+1, r25	; 0x01
    8ada:	80 83       	st	Z, r24
    8adc:	de 01       	movw	r26, r28
    8ade:	a1 58       	subi	r26, 0x81	; 129
    8ae0:	bf 4f       	sbci	r27, 0xFF	; 255
    8ae2:	fe 01       	movw	r30, r28
    8ae4:	ed 57       	subi	r30, 0x7D	; 125
    8ae6:	ff 4f       	sbci	r31, 0xFF	; 255
    8ae8:	80 81       	ld	r24, Z
    8aea:	91 81       	ldd	r25, Z+1	; 0x01
    8aec:	8d 93       	st	X+, r24
    8aee:	9c 93       	st	X, r25
    8af0:	fe 01       	movw	r30, r28
    8af2:	e1 58       	subi	r30, 0x81	; 129
    8af4:	ff 4f       	sbci	r31, 0xFF	; 255
    8af6:	80 81       	ld	r24, Z
    8af8:	91 81       	ldd	r25, Z+1	; 0x01
    8afa:	01 97       	sbiw	r24, 0x01	; 1
    8afc:	f1 f7       	brne	.-4      	; 0x8afa <APP_Autonomous_Car_voidApp+0x676>
    8afe:	fe 01       	movw	r30, r28
    8b00:	e1 58       	subi	r30, 0x81	; 129
    8b02:	ff 4f       	sbci	r31, 0xFF	; 255
    8b04:	91 83       	std	Z+1, r25	; 0x01
    8b06:	80 83       	st	Z, r24
			_delay_ms(20);
			HAL_LCD_u8SendString("cm");
    8b08:	87 ed       	ldi	r24, 0xD7	; 215
    8b0a:	90 e0       	ldi	r25, 0x00	; 0
    8b0c:	0e 94 c9 23 	call	0x4792	; 0x4792 <HAL_LCD_u8SendString>
			HAL_void_H_BridgeFront(MAX_SPEED);
    8b10:	83 e6       	ldi	r24, 0x63	; 99
    8b12:	0e 94 d4 27 	call	0x4fa8	; 0x4fa8 <HAL_void_H_BridgeFront>
			HAL_LED_u8LedMode(PortA, Pin1, LED_OFF);
    8b16:	80 e0       	ldi	r24, 0x00	; 0
    8b18:	61 e0       	ldi	r22, 0x01	; 1
    8b1a:	40 e0       	ldi	r20, 0x00	; 0
    8b1c:	0e 94 07 1e 	call	0x3c0e	; 0x3c0e <HAL_LED_u8LedMode>
    8b20:	d6 cc       	rjmp	.-1620   	; 0x84ce <APP_Autonomous_Car_voidApp+0x4a>
		} else if (LOC_f32Distance <= DISTANCE_30) {
    8b22:	fe 01       	movw	r30, r28
    8b24:	e2 54       	subi	r30, 0x42	; 66
    8b26:	ff 4f       	sbci	r31, 0xFF	; 255
    8b28:	80 81       	ld	r24, Z
    8b2a:	91 81       	ldd	r25, Z+1	; 0x01
    8b2c:	a2 81       	ldd	r26, Z+2	; 0x02
    8b2e:	b3 81       	ldd	r27, Z+3	; 0x03
    8b30:	bc 01       	movw	r22, r24
    8b32:	cd 01       	movw	r24, r26
    8b34:	20 e0       	ldi	r18, 0x00	; 0
    8b36:	30 e0       	ldi	r19, 0x00	; 0
    8b38:	40 ef       	ldi	r20, 0xF0	; 240
    8b3a:	51 e4       	ldi	r21, 0x41	; 65
    8b3c:	0e 94 55 04 	call	0x8aa	; 0x8aa <__lesf2>
    8b40:	18 16       	cp	r1, r24
    8b42:	0c f4       	brge	.+2      	; 0x8b46 <APP_Autonomous_Car_voidApp+0x6c2>
    8b44:	c4 cc       	rjmp	.-1656   	; 0x84ce <APP_Autonomous_Car_voidApp+0x4a>
			if (LOC_f32Distance <= DISTANCE_10) {
    8b46:	fe 01       	movw	r30, r28
    8b48:	e2 54       	subi	r30, 0x42	; 66
    8b4a:	ff 4f       	sbci	r31, 0xFF	; 255
    8b4c:	80 81       	ld	r24, Z
    8b4e:	91 81       	ldd	r25, Z+1	; 0x01
    8b50:	a2 81       	ldd	r26, Z+2	; 0x02
    8b52:	b3 81       	ldd	r27, Z+3	; 0x03
    8b54:	bc 01       	movw	r22, r24
    8b56:	cd 01       	movw	r24, r26
    8b58:	20 e0       	ldi	r18, 0x00	; 0
    8b5a:	30 e0       	ldi	r19, 0x00	; 0
    8b5c:	40 e2       	ldi	r20, 0x20	; 32
    8b5e:	51 e4       	ldi	r21, 0x41	; 65
    8b60:	0e 94 55 04 	call	0x8aa	; 0x8aa <__lesf2>
    8b64:	18 16       	cp	r1, r24
    8b66:	0c f4       	brge	.+2      	; 0x8b6a <APP_Autonomous_Car_voidApp+0x6e6>
    8b68:	bc c0       	rjmp	.+376    	; 0x8ce2 <APP_Autonomous_Car_voidApp+0x85e>
//				HAL_Buzzer_u8BuzzerMode(PortA, Pin3, Pin_High);
				HAL_LCD_u8Clear();
    8b6a:	0e 94 7e 26 	call	0x4cfc	; 0x4cfc <HAL_LCD_u8Clear>
				HAL_LCD_u8SendString("Moving Back...");
    8b6e:	8a ed       	ldi	r24, 0xDA	; 218
    8b70:	90 e0       	ldi	r25, 0x00	; 0
    8b72:	0e 94 c9 23 	call	0x4792	; 0x4792 <HAL_LCD_u8SendString>
				HAL_void_H_BridgeBack(MAX_SPEED);
    8b76:	83 e6       	ldi	r24, 0x63	; 99
    8b78:	0e 94 04 28 	call	0x5008	; 0x5008 <HAL_void_H_BridgeBack>
    8b7c:	fe 01       	movw	r30, r28
    8b7e:	e5 58       	subi	r30, 0x85	; 133
    8b80:	ff 4f       	sbci	r31, 0xFF	; 255
    8b82:	80 e0       	ldi	r24, 0x00	; 0
    8b84:	90 e0       	ldi	r25, 0x00	; 0
    8b86:	aa e7       	ldi	r26, 0x7A	; 122
    8b88:	b4 e4       	ldi	r27, 0x44	; 68
    8b8a:	80 83       	st	Z, r24
    8b8c:	91 83       	std	Z+1, r25	; 0x01
    8b8e:	a2 83       	std	Z+2, r26	; 0x02
    8b90:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8b92:	8e 01       	movw	r16, r28
    8b94:	09 58       	subi	r16, 0x89	; 137
    8b96:	1f 4f       	sbci	r17, 0xFF	; 255
    8b98:	fe 01       	movw	r30, r28
    8b9a:	e5 58       	subi	r30, 0x85	; 133
    8b9c:	ff 4f       	sbci	r31, 0xFF	; 255
    8b9e:	60 81       	ld	r22, Z
    8ba0:	71 81       	ldd	r23, Z+1	; 0x01
    8ba2:	82 81       	ldd	r24, Z+2	; 0x02
    8ba4:	93 81       	ldd	r25, Z+3	; 0x03
    8ba6:	20 e0       	ldi	r18, 0x00	; 0
    8ba8:	30 e0       	ldi	r19, 0x00	; 0
    8baa:	4a e7       	ldi	r20, 0x7A	; 122
    8bac:	55 e4       	ldi	r21, 0x45	; 69
    8bae:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8bb2:	dc 01       	movw	r26, r24
    8bb4:	cb 01       	movw	r24, r22
    8bb6:	f8 01       	movw	r30, r16
    8bb8:	80 83       	st	Z, r24
    8bba:	91 83       	std	Z+1, r25	; 0x01
    8bbc:	a2 83       	std	Z+2, r26	; 0x02
    8bbe:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    8bc0:	fe 01       	movw	r30, r28
    8bc2:	e9 58       	subi	r30, 0x89	; 137
    8bc4:	ff 4f       	sbci	r31, 0xFF	; 255
    8bc6:	60 81       	ld	r22, Z
    8bc8:	71 81       	ldd	r23, Z+1	; 0x01
    8bca:	82 81       	ldd	r24, Z+2	; 0x02
    8bcc:	93 81       	ldd	r25, Z+3	; 0x03
    8bce:	20 e0       	ldi	r18, 0x00	; 0
    8bd0:	30 e0       	ldi	r19, 0x00	; 0
    8bd2:	40 e8       	ldi	r20, 0x80	; 128
    8bd4:	5f e3       	ldi	r21, 0x3F	; 63
    8bd6:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    8bda:	88 23       	and	r24, r24
    8bdc:	44 f4       	brge	.+16     	; 0x8bee <APP_Autonomous_Car_voidApp+0x76a>
		__ticks = 1;
    8bde:	fe 01       	movw	r30, r28
    8be0:	eb 58       	subi	r30, 0x8B	; 139
    8be2:	ff 4f       	sbci	r31, 0xFF	; 255
    8be4:	81 e0       	ldi	r24, 0x01	; 1
    8be6:	90 e0       	ldi	r25, 0x00	; 0
    8be8:	91 83       	std	Z+1, r25	; 0x01
    8bea:	80 83       	st	Z, r24
    8bec:	64 c0       	rjmp	.+200    	; 0x8cb6 <APP_Autonomous_Car_voidApp+0x832>
	else if (__tmp > 65535)
    8bee:	fe 01       	movw	r30, r28
    8bf0:	e9 58       	subi	r30, 0x89	; 137
    8bf2:	ff 4f       	sbci	r31, 0xFF	; 255
    8bf4:	60 81       	ld	r22, Z
    8bf6:	71 81       	ldd	r23, Z+1	; 0x01
    8bf8:	82 81       	ldd	r24, Z+2	; 0x02
    8bfa:	93 81       	ldd	r25, Z+3	; 0x03
    8bfc:	20 e0       	ldi	r18, 0x00	; 0
    8bfe:	3f ef       	ldi	r19, 0xFF	; 255
    8c00:	4f e7       	ldi	r20, 0x7F	; 127
    8c02:	57 e4       	ldi	r21, 0x47	; 71
    8c04:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    8c08:	18 16       	cp	r1, r24
    8c0a:	0c f0       	brlt	.+2      	; 0x8c0e <APP_Autonomous_Car_voidApp+0x78a>
    8c0c:	43 c0       	rjmp	.+134    	; 0x8c94 <APP_Autonomous_Car_voidApp+0x810>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    8c0e:	fe 01       	movw	r30, r28
    8c10:	e5 58       	subi	r30, 0x85	; 133
    8c12:	ff 4f       	sbci	r31, 0xFF	; 255
    8c14:	60 81       	ld	r22, Z
    8c16:	71 81       	ldd	r23, Z+1	; 0x01
    8c18:	82 81       	ldd	r24, Z+2	; 0x02
    8c1a:	93 81       	ldd	r25, Z+3	; 0x03
    8c1c:	20 e0       	ldi	r18, 0x00	; 0
    8c1e:	30 e0       	ldi	r19, 0x00	; 0
    8c20:	40 e2       	ldi	r20, 0x20	; 32
    8c22:	51 e4       	ldi	r21, 0x41	; 65
    8c24:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8c28:	dc 01       	movw	r26, r24
    8c2a:	cb 01       	movw	r24, r22
    8c2c:	8e 01       	movw	r16, r28
    8c2e:	0b 58       	subi	r16, 0x8B	; 139
    8c30:	1f 4f       	sbci	r17, 0xFF	; 255
    8c32:	bc 01       	movw	r22, r24
    8c34:	cd 01       	movw	r24, r26
    8c36:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8c3a:	dc 01       	movw	r26, r24
    8c3c:	cb 01       	movw	r24, r22
    8c3e:	f8 01       	movw	r30, r16
    8c40:	91 83       	std	Z+1, r25	; 0x01
    8c42:	80 83       	st	Z, r24
    8c44:	1f c0       	rjmp	.+62     	; 0x8c84 <APP_Autonomous_Car_voidApp+0x800>
    8c46:	fe 01       	movw	r30, r28
    8c48:	ed 58       	subi	r30, 0x8D	; 141
    8c4a:	ff 4f       	sbci	r31, 0xFF	; 255
    8c4c:	80 e9       	ldi	r24, 0x90	; 144
    8c4e:	91 e0       	ldi	r25, 0x01	; 1
    8c50:	91 83       	std	Z+1, r25	; 0x01
    8c52:	80 83       	st	Z, r24
    8c54:	fe 01       	movw	r30, r28
    8c56:	ed 58       	subi	r30, 0x8D	; 141
    8c58:	ff 4f       	sbci	r31, 0xFF	; 255
    8c5a:	80 81       	ld	r24, Z
    8c5c:	91 81       	ldd	r25, Z+1	; 0x01
    8c5e:	01 97       	sbiw	r24, 0x01	; 1
    8c60:	f1 f7       	brne	.-4      	; 0x8c5e <APP_Autonomous_Car_voidApp+0x7da>
    8c62:	fe 01       	movw	r30, r28
    8c64:	ed 58       	subi	r30, 0x8D	; 141
    8c66:	ff 4f       	sbci	r31, 0xFF	; 255
    8c68:	91 83       	std	Z+1, r25	; 0x01
    8c6a:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8c6c:	de 01       	movw	r26, r28
    8c6e:	ab 58       	subi	r26, 0x8B	; 139
    8c70:	bf 4f       	sbci	r27, 0xFF	; 255
    8c72:	fe 01       	movw	r30, r28
    8c74:	eb 58       	subi	r30, 0x8B	; 139
    8c76:	ff 4f       	sbci	r31, 0xFF	; 255
    8c78:	80 81       	ld	r24, Z
    8c7a:	91 81       	ldd	r25, Z+1	; 0x01
    8c7c:	01 97       	sbiw	r24, 0x01	; 1
    8c7e:	11 96       	adiw	r26, 0x01	; 1
    8c80:	9c 93       	st	X, r25
    8c82:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8c84:	fe 01       	movw	r30, r28
    8c86:	eb 58       	subi	r30, 0x8B	; 139
    8c88:	ff 4f       	sbci	r31, 0xFF	; 255
    8c8a:	80 81       	ld	r24, Z
    8c8c:	91 81       	ldd	r25, Z+1	; 0x01
    8c8e:	00 97       	sbiw	r24, 0x00	; 0
    8c90:	d1 f6       	brne	.-76     	; 0x8c46 <APP_Autonomous_Car_voidApp+0x7c2>
    8c92:	27 c0       	rjmp	.+78     	; 0x8ce2 <APP_Autonomous_Car_voidApp+0x85e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8c94:	8e 01       	movw	r16, r28
    8c96:	0b 58       	subi	r16, 0x8B	; 139
    8c98:	1f 4f       	sbci	r17, 0xFF	; 255
    8c9a:	fe 01       	movw	r30, r28
    8c9c:	e9 58       	subi	r30, 0x89	; 137
    8c9e:	ff 4f       	sbci	r31, 0xFF	; 255
    8ca0:	60 81       	ld	r22, Z
    8ca2:	71 81       	ldd	r23, Z+1	; 0x01
    8ca4:	82 81       	ldd	r24, Z+2	; 0x02
    8ca6:	93 81       	ldd	r25, Z+3	; 0x03
    8ca8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8cac:	dc 01       	movw	r26, r24
    8cae:	cb 01       	movw	r24, r22
    8cb0:	f8 01       	movw	r30, r16
    8cb2:	91 83       	std	Z+1, r25	; 0x01
    8cb4:	80 83       	st	Z, r24
    8cb6:	de 01       	movw	r26, r28
    8cb8:	af 58       	subi	r26, 0x8F	; 143
    8cba:	bf 4f       	sbci	r27, 0xFF	; 255
    8cbc:	fe 01       	movw	r30, r28
    8cbe:	eb 58       	subi	r30, 0x8B	; 139
    8cc0:	ff 4f       	sbci	r31, 0xFF	; 255
    8cc2:	80 81       	ld	r24, Z
    8cc4:	91 81       	ldd	r25, Z+1	; 0x01
    8cc6:	8d 93       	st	X+, r24
    8cc8:	9c 93       	st	X, r25
    8cca:	fe 01       	movw	r30, r28
    8ccc:	ef 58       	subi	r30, 0x8F	; 143
    8cce:	ff 4f       	sbci	r31, 0xFF	; 255
    8cd0:	80 81       	ld	r24, Z
    8cd2:	91 81       	ldd	r25, Z+1	; 0x01
    8cd4:	01 97       	sbiw	r24, 0x01	; 1
    8cd6:	f1 f7       	brne	.-4      	; 0x8cd4 <APP_Autonomous_Car_voidApp+0x850>
    8cd8:	fe 01       	movw	r30, r28
    8cda:	ef 58       	subi	r30, 0x8F	; 143
    8cdc:	ff 4f       	sbci	r31, 0xFF	; 255
    8cde:	91 83       	std	Z+1, r25	; 0x01
    8ce0:	80 83       	st	Z, r24
				_delay_ms(1000);
//				HAL_Buzzer_u8BuzzerMode(PortA, Pin3, Pin_Low);
			}
			HAL_void_H_BridgeStop(NUM0);
    8ce2:	80 e0       	ldi	r24, 0x00	; 0
    8ce4:	0e 94 50 28 	call	0x50a0	; 0x50a0 <HAL_void_H_BridgeStop>
			HAL_LED_u8LedMode(PortA, Pin1, LED_ON);
    8ce8:	80 e0       	ldi	r24, 0x00	; 0
    8cea:	61 e0       	ldi	r22, 0x01	; 1
    8cec:	41 e0       	ldi	r20, 0x01	; 1
    8cee:	0e 94 07 1e 	call	0x3c0e	; 0x3c0e <HAL_LED_u8LedMode>
			for (int i = START_ANGLE; i >= MAX_CCW_ANGLE; i -= NUM_2) {
    8cf2:	fe 01       	movw	r30, r28
    8cf4:	e5 54       	subi	r30, 0x45	; 69
    8cf6:	ff 4f       	sbci	r31, 0xFF	; 255
    8cf8:	8a e5       	ldi	r24, 0x5A	; 90
    8cfa:	90 e0       	ldi	r25, 0x00	; 0
    8cfc:	91 83       	std	Z+1, r25	; 0x01
    8cfe:	80 83       	st	Z, r24
    8d00:	35 c4       	rjmp	.+2154   	; 0x956c <APP_Autonomous_Car_voidApp+0x10e8>
				HAL_SM_voidSMSetAngle(i);
    8d02:	fe 01       	movw	r30, r28
    8d04:	e5 54       	subi	r30, 0x45	; 69
    8d06:	ff 4f       	sbci	r31, 0xFF	; 255
    8d08:	80 81       	ld	r24, Z
    8d0a:	0e 94 f1 1b 	call	0x37e2	; 0x37e2 <HAL_SM_voidSMSetAngle>
				if (i == MAX_CCW_ANGLE) {
    8d0e:	fe 01       	movw	r30, r28
    8d10:	e5 54       	subi	r30, 0x45	; 69
    8d12:	ff 4f       	sbci	r31, 0xFF	; 255
    8d14:	80 81       	ld	r24, Z
    8d16:	91 81       	ldd	r25, Z+1	; 0x01
    8d18:	00 97       	sbiw	r24, 0x00	; 0
    8d1a:	09 f0       	breq	.+2      	; 0x8d1e <APP_Autonomous_Car_voidApp+0x89a>
    8d1c:	1b c4       	rjmp	.+2102   	; 0x9554 <APP_Autonomous_Car_voidApp+0x10d0>
    8d1e:	fe 01       	movw	r30, r28
    8d20:	e3 59       	subi	r30, 0x93	; 147
    8d22:	ff 4f       	sbci	r31, 0xFF	; 255
    8d24:	80 e0       	ldi	r24, 0x00	; 0
    8d26:	90 e0       	ldi	r25, 0x00	; 0
    8d28:	a8 e4       	ldi	r26, 0x48	; 72
    8d2a:	b2 e4       	ldi	r27, 0x42	; 66
    8d2c:	80 83       	st	Z, r24
    8d2e:	91 83       	std	Z+1, r25	; 0x01
    8d30:	a2 83       	std	Z+2, r26	; 0x02
    8d32:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8d34:	8e 01       	movw	r16, r28
    8d36:	07 59       	subi	r16, 0x97	; 151
    8d38:	1f 4f       	sbci	r17, 0xFF	; 255
    8d3a:	fe 01       	movw	r30, r28
    8d3c:	e3 59       	subi	r30, 0x93	; 147
    8d3e:	ff 4f       	sbci	r31, 0xFF	; 255
    8d40:	60 81       	ld	r22, Z
    8d42:	71 81       	ldd	r23, Z+1	; 0x01
    8d44:	82 81       	ldd	r24, Z+2	; 0x02
    8d46:	93 81       	ldd	r25, Z+3	; 0x03
    8d48:	20 e0       	ldi	r18, 0x00	; 0
    8d4a:	30 e0       	ldi	r19, 0x00	; 0
    8d4c:	4a e7       	ldi	r20, 0x7A	; 122
    8d4e:	55 e4       	ldi	r21, 0x45	; 69
    8d50:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8d54:	dc 01       	movw	r26, r24
    8d56:	cb 01       	movw	r24, r22
    8d58:	f8 01       	movw	r30, r16
    8d5a:	80 83       	st	Z, r24
    8d5c:	91 83       	std	Z+1, r25	; 0x01
    8d5e:	a2 83       	std	Z+2, r26	; 0x02
    8d60:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    8d62:	fe 01       	movw	r30, r28
    8d64:	e7 59       	subi	r30, 0x97	; 151
    8d66:	ff 4f       	sbci	r31, 0xFF	; 255
    8d68:	60 81       	ld	r22, Z
    8d6a:	71 81       	ldd	r23, Z+1	; 0x01
    8d6c:	82 81       	ldd	r24, Z+2	; 0x02
    8d6e:	93 81       	ldd	r25, Z+3	; 0x03
    8d70:	20 e0       	ldi	r18, 0x00	; 0
    8d72:	30 e0       	ldi	r19, 0x00	; 0
    8d74:	40 e8       	ldi	r20, 0x80	; 128
    8d76:	5f e3       	ldi	r21, 0x3F	; 63
    8d78:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    8d7c:	88 23       	and	r24, r24
    8d7e:	44 f4       	brge	.+16     	; 0x8d90 <APP_Autonomous_Car_voidApp+0x90c>
		__ticks = 1;
    8d80:	fe 01       	movw	r30, r28
    8d82:	e9 59       	subi	r30, 0x99	; 153
    8d84:	ff 4f       	sbci	r31, 0xFF	; 255
    8d86:	81 e0       	ldi	r24, 0x01	; 1
    8d88:	90 e0       	ldi	r25, 0x00	; 0
    8d8a:	91 83       	std	Z+1, r25	; 0x01
    8d8c:	80 83       	st	Z, r24
    8d8e:	64 c0       	rjmp	.+200    	; 0x8e58 <APP_Autonomous_Car_voidApp+0x9d4>
	else if (__tmp > 65535)
    8d90:	fe 01       	movw	r30, r28
    8d92:	e7 59       	subi	r30, 0x97	; 151
    8d94:	ff 4f       	sbci	r31, 0xFF	; 255
    8d96:	60 81       	ld	r22, Z
    8d98:	71 81       	ldd	r23, Z+1	; 0x01
    8d9a:	82 81       	ldd	r24, Z+2	; 0x02
    8d9c:	93 81       	ldd	r25, Z+3	; 0x03
    8d9e:	20 e0       	ldi	r18, 0x00	; 0
    8da0:	3f ef       	ldi	r19, 0xFF	; 255
    8da2:	4f e7       	ldi	r20, 0x7F	; 127
    8da4:	57 e4       	ldi	r21, 0x47	; 71
    8da6:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    8daa:	18 16       	cp	r1, r24
    8dac:	0c f0       	brlt	.+2      	; 0x8db0 <APP_Autonomous_Car_voidApp+0x92c>
    8dae:	43 c0       	rjmp	.+134    	; 0x8e36 <APP_Autonomous_Car_voidApp+0x9b2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    8db0:	fe 01       	movw	r30, r28
    8db2:	e3 59       	subi	r30, 0x93	; 147
    8db4:	ff 4f       	sbci	r31, 0xFF	; 255
    8db6:	60 81       	ld	r22, Z
    8db8:	71 81       	ldd	r23, Z+1	; 0x01
    8dba:	82 81       	ldd	r24, Z+2	; 0x02
    8dbc:	93 81       	ldd	r25, Z+3	; 0x03
    8dbe:	20 e0       	ldi	r18, 0x00	; 0
    8dc0:	30 e0       	ldi	r19, 0x00	; 0
    8dc2:	40 e2       	ldi	r20, 0x20	; 32
    8dc4:	51 e4       	ldi	r21, 0x41	; 65
    8dc6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8dca:	dc 01       	movw	r26, r24
    8dcc:	cb 01       	movw	r24, r22
    8dce:	8e 01       	movw	r16, r28
    8dd0:	09 59       	subi	r16, 0x99	; 153
    8dd2:	1f 4f       	sbci	r17, 0xFF	; 255
    8dd4:	bc 01       	movw	r22, r24
    8dd6:	cd 01       	movw	r24, r26
    8dd8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8ddc:	dc 01       	movw	r26, r24
    8dde:	cb 01       	movw	r24, r22
    8de0:	f8 01       	movw	r30, r16
    8de2:	91 83       	std	Z+1, r25	; 0x01
    8de4:	80 83       	st	Z, r24
    8de6:	1f c0       	rjmp	.+62     	; 0x8e26 <APP_Autonomous_Car_voidApp+0x9a2>
    8de8:	fe 01       	movw	r30, r28
    8dea:	eb 59       	subi	r30, 0x9B	; 155
    8dec:	ff 4f       	sbci	r31, 0xFF	; 255
    8dee:	80 e9       	ldi	r24, 0x90	; 144
    8df0:	91 e0       	ldi	r25, 0x01	; 1
    8df2:	91 83       	std	Z+1, r25	; 0x01
    8df4:	80 83       	st	Z, r24
    8df6:	fe 01       	movw	r30, r28
    8df8:	eb 59       	subi	r30, 0x9B	; 155
    8dfa:	ff 4f       	sbci	r31, 0xFF	; 255
    8dfc:	80 81       	ld	r24, Z
    8dfe:	91 81       	ldd	r25, Z+1	; 0x01
    8e00:	01 97       	sbiw	r24, 0x01	; 1
    8e02:	f1 f7       	brne	.-4      	; 0x8e00 <APP_Autonomous_Car_voidApp+0x97c>
    8e04:	fe 01       	movw	r30, r28
    8e06:	eb 59       	subi	r30, 0x9B	; 155
    8e08:	ff 4f       	sbci	r31, 0xFF	; 255
    8e0a:	91 83       	std	Z+1, r25	; 0x01
    8e0c:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8e0e:	de 01       	movw	r26, r28
    8e10:	a9 59       	subi	r26, 0x99	; 153
    8e12:	bf 4f       	sbci	r27, 0xFF	; 255
    8e14:	fe 01       	movw	r30, r28
    8e16:	e9 59       	subi	r30, 0x99	; 153
    8e18:	ff 4f       	sbci	r31, 0xFF	; 255
    8e1a:	80 81       	ld	r24, Z
    8e1c:	91 81       	ldd	r25, Z+1	; 0x01
    8e1e:	01 97       	sbiw	r24, 0x01	; 1
    8e20:	11 96       	adiw	r26, 0x01	; 1
    8e22:	9c 93       	st	X, r25
    8e24:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8e26:	fe 01       	movw	r30, r28
    8e28:	e9 59       	subi	r30, 0x99	; 153
    8e2a:	ff 4f       	sbci	r31, 0xFF	; 255
    8e2c:	80 81       	ld	r24, Z
    8e2e:	91 81       	ldd	r25, Z+1	; 0x01
    8e30:	00 97       	sbiw	r24, 0x00	; 0
    8e32:	d1 f6       	brne	.-76     	; 0x8de8 <APP_Autonomous_Car_voidApp+0x964>
    8e34:	27 c0       	rjmp	.+78     	; 0x8e84 <APP_Autonomous_Car_voidApp+0xa00>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8e36:	8e 01       	movw	r16, r28
    8e38:	09 59       	subi	r16, 0x99	; 153
    8e3a:	1f 4f       	sbci	r17, 0xFF	; 255
    8e3c:	fe 01       	movw	r30, r28
    8e3e:	e7 59       	subi	r30, 0x97	; 151
    8e40:	ff 4f       	sbci	r31, 0xFF	; 255
    8e42:	60 81       	ld	r22, Z
    8e44:	71 81       	ldd	r23, Z+1	; 0x01
    8e46:	82 81       	ldd	r24, Z+2	; 0x02
    8e48:	93 81       	ldd	r25, Z+3	; 0x03
    8e4a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8e4e:	dc 01       	movw	r26, r24
    8e50:	cb 01       	movw	r24, r22
    8e52:	f8 01       	movw	r30, r16
    8e54:	91 83       	std	Z+1, r25	; 0x01
    8e56:	80 83       	st	Z, r24
    8e58:	de 01       	movw	r26, r28
    8e5a:	ad 59       	subi	r26, 0x9D	; 157
    8e5c:	bf 4f       	sbci	r27, 0xFF	; 255
    8e5e:	fe 01       	movw	r30, r28
    8e60:	e9 59       	subi	r30, 0x99	; 153
    8e62:	ff 4f       	sbci	r31, 0xFF	; 255
    8e64:	80 81       	ld	r24, Z
    8e66:	91 81       	ldd	r25, Z+1	; 0x01
    8e68:	8d 93       	st	X+, r24
    8e6a:	9c 93       	st	X, r25
    8e6c:	fe 01       	movw	r30, r28
    8e6e:	ed 59       	subi	r30, 0x9D	; 157
    8e70:	ff 4f       	sbci	r31, 0xFF	; 255
    8e72:	80 81       	ld	r24, Z
    8e74:	91 81       	ldd	r25, Z+1	; 0x01
    8e76:	01 97       	sbiw	r24, 0x01	; 1
    8e78:	f1 f7       	brne	.-4      	; 0x8e76 <APP_Autonomous_Car_voidApp+0x9f2>
    8e7a:	fe 01       	movw	r30, r28
    8e7c:	ed 59       	subi	r30, 0x9D	; 157
    8e7e:	ff 4f       	sbci	r31, 0xFF	; 255
    8e80:	91 83       	std	Z+1, r25	; 0x01
    8e82:	80 83       	st	Z, r24
					_delay_ms(50);
					HAL_Ultrasonic_Sensor_voidCalcDistancse(&LOC_f32Distance);
    8e84:	ce 01       	movw	r24, r28
    8e86:	82 54       	subi	r24, 0x42	; 66
    8e88:	9f 4f       	sbci	r25, 0xFF	; 255
    8e8a:	0e 94 c9 1a 	call	0x3592	; 0x3592 <HAL_Ultrasonic_Sensor_voidCalcDistancse>
    8e8e:	fe 01       	movw	r30, r28
    8e90:	e1 5a       	subi	r30, 0xA1	; 161
    8e92:	ff 4f       	sbci	r31, 0xFF	; 255
    8e94:	80 e0       	ldi	r24, 0x00	; 0
    8e96:	90 e0       	ldi	r25, 0x00	; 0
    8e98:	a8 e4       	ldi	r26, 0x48	; 72
    8e9a:	b2 e4       	ldi	r27, 0x42	; 66
    8e9c:	80 83       	st	Z, r24
    8e9e:	91 83       	std	Z+1, r25	; 0x01
    8ea0:	a2 83       	std	Z+2, r26	; 0x02
    8ea2:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8ea4:	8e 01       	movw	r16, r28
    8ea6:	05 5a       	subi	r16, 0xA5	; 165
    8ea8:	1f 4f       	sbci	r17, 0xFF	; 255
    8eaa:	fe 01       	movw	r30, r28
    8eac:	e1 5a       	subi	r30, 0xA1	; 161
    8eae:	ff 4f       	sbci	r31, 0xFF	; 255
    8eb0:	60 81       	ld	r22, Z
    8eb2:	71 81       	ldd	r23, Z+1	; 0x01
    8eb4:	82 81       	ldd	r24, Z+2	; 0x02
    8eb6:	93 81       	ldd	r25, Z+3	; 0x03
    8eb8:	20 e0       	ldi	r18, 0x00	; 0
    8eba:	30 e0       	ldi	r19, 0x00	; 0
    8ebc:	4a e7       	ldi	r20, 0x7A	; 122
    8ebe:	55 e4       	ldi	r21, 0x45	; 69
    8ec0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8ec4:	dc 01       	movw	r26, r24
    8ec6:	cb 01       	movw	r24, r22
    8ec8:	f8 01       	movw	r30, r16
    8eca:	80 83       	st	Z, r24
    8ecc:	91 83       	std	Z+1, r25	; 0x01
    8ece:	a2 83       	std	Z+2, r26	; 0x02
    8ed0:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    8ed2:	fe 01       	movw	r30, r28
    8ed4:	e5 5a       	subi	r30, 0xA5	; 165
    8ed6:	ff 4f       	sbci	r31, 0xFF	; 255
    8ed8:	60 81       	ld	r22, Z
    8eda:	71 81       	ldd	r23, Z+1	; 0x01
    8edc:	82 81       	ldd	r24, Z+2	; 0x02
    8ede:	93 81       	ldd	r25, Z+3	; 0x03
    8ee0:	20 e0       	ldi	r18, 0x00	; 0
    8ee2:	30 e0       	ldi	r19, 0x00	; 0
    8ee4:	40 e8       	ldi	r20, 0x80	; 128
    8ee6:	5f e3       	ldi	r21, 0x3F	; 63
    8ee8:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    8eec:	88 23       	and	r24, r24
    8eee:	44 f4       	brge	.+16     	; 0x8f00 <APP_Autonomous_Car_voidApp+0xa7c>
		__ticks = 1;
    8ef0:	fe 01       	movw	r30, r28
    8ef2:	e7 5a       	subi	r30, 0xA7	; 167
    8ef4:	ff 4f       	sbci	r31, 0xFF	; 255
    8ef6:	81 e0       	ldi	r24, 0x01	; 1
    8ef8:	90 e0       	ldi	r25, 0x00	; 0
    8efa:	91 83       	std	Z+1, r25	; 0x01
    8efc:	80 83       	st	Z, r24
    8efe:	64 c0       	rjmp	.+200    	; 0x8fc8 <APP_Autonomous_Car_voidApp+0xb44>
	else if (__tmp > 65535)
    8f00:	fe 01       	movw	r30, r28
    8f02:	e5 5a       	subi	r30, 0xA5	; 165
    8f04:	ff 4f       	sbci	r31, 0xFF	; 255
    8f06:	60 81       	ld	r22, Z
    8f08:	71 81       	ldd	r23, Z+1	; 0x01
    8f0a:	82 81       	ldd	r24, Z+2	; 0x02
    8f0c:	93 81       	ldd	r25, Z+3	; 0x03
    8f0e:	20 e0       	ldi	r18, 0x00	; 0
    8f10:	3f ef       	ldi	r19, 0xFF	; 255
    8f12:	4f e7       	ldi	r20, 0x7F	; 127
    8f14:	57 e4       	ldi	r21, 0x47	; 71
    8f16:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    8f1a:	18 16       	cp	r1, r24
    8f1c:	0c f0       	brlt	.+2      	; 0x8f20 <APP_Autonomous_Car_voidApp+0xa9c>
    8f1e:	43 c0       	rjmp	.+134    	; 0x8fa6 <APP_Autonomous_Car_voidApp+0xb22>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    8f20:	fe 01       	movw	r30, r28
    8f22:	e1 5a       	subi	r30, 0xA1	; 161
    8f24:	ff 4f       	sbci	r31, 0xFF	; 255
    8f26:	60 81       	ld	r22, Z
    8f28:	71 81       	ldd	r23, Z+1	; 0x01
    8f2a:	82 81       	ldd	r24, Z+2	; 0x02
    8f2c:	93 81       	ldd	r25, Z+3	; 0x03
    8f2e:	20 e0       	ldi	r18, 0x00	; 0
    8f30:	30 e0       	ldi	r19, 0x00	; 0
    8f32:	40 e2       	ldi	r20, 0x20	; 32
    8f34:	51 e4       	ldi	r21, 0x41	; 65
    8f36:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8f3a:	dc 01       	movw	r26, r24
    8f3c:	cb 01       	movw	r24, r22
    8f3e:	8e 01       	movw	r16, r28
    8f40:	07 5a       	subi	r16, 0xA7	; 167
    8f42:	1f 4f       	sbci	r17, 0xFF	; 255
    8f44:	bc 01       	movw	r22, r24
    8f46:	cd 01       	movw	r24, r26
    8f48:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8f4c:	dc 01       	movw	r26, r24
    8f4e:	cb 01       	movw	r24, r22
    8f50:	f8 01       	movw	r30, r16
    8f52:	91 83       	std	Z+1, r25	; 0x01
    8f54:	80 83       	st	Z, r24
    8f56:	1f c0       	rjmp	.+62     	; 0x8f96 <APP_Autonomous_Car_voidApp+0xb12>
    8f58:	fe 01       	movw	r30, r28
    8f5a:	e9 5a       	subi	r30, 0xA9	; 169
    8f5c:	ff 4f       	sbci	r31, 0xFF	; 255
    8f5e:	80 e9       	ldi	r24, 0x90	; 144
    8f60:	91 e0       	ldi	r25, 0x01	; 1
    8f62:	91 83       	std	Z+1, r25	; 0x01
    8f64:	80 83       	st	Z, r24
    8f66:	fe 01       	movw	r30, r28
    8f68:	e9 5a       	subi	r30, 0xA9	; 169
    8f6a:	ff 4f       	sbci	r31, 0xFF	; 255
    8f6c:	80 81       	ld	r24, Z
    8f6e:	91 81       	ldd	r25, Z+1	; 0x01
    8f70:	01 97       	sbiw	r24, 0x01	; 1
    8f72:	f1 f7       	brne	.-4      	; 0x8f70 <APP_Autonomous_Car_voidApp+0xaec>
    8f74:	fe 01       	movw	r30, r28
    8f76:	e9 5a       	subi	r30, 0xA9	; 169
    8f78:	ff 4f       	sbci	r31, 0xFF	; 255
    8f7a:	91 83       	std	Z+1, r25	; 0x01
    8f7c:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8f7e:	de 01       	movw	r26, r28
    8f80:	a7 5a       	subi	r26, 0xA7	; 167
    8f82:	bf 4f       	sbci	r27, 0xFF	; 255
    8f84:	fe 01       	movw	r30, r28
    8f86:	e7 5a       	subi	r30, 0xA7	; 167
    8f88:	ff 4f       	sbci	r31, 0xFF	; 255
    8f8a:	80 81       	ld	r24, Z
    8f8c:	91 81       	ldd	r25, Z+1	; 0x01
    8f8e:	01 97       	sbiw	r24, 0x01	; 1
    8f90:	11 96       	adiw	r26, 0x01	; 1
    8f92:	9c 93       	st	X, r25
    8f94:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8f96:	fe 01       	movw	r30, r28
    8f98:	e7 5a       	subi	r30, 0xA7	; 167
    8f9a:	ff 4f       	sbci	r31, 0xFF	; 255
    8f9c:	80 81       	ld	r24, Z
    8f9e:	91 81       	ldd	r25, Z+1	; 0x01
    8fa0:	00 97       	sbiw	r24, 0x00	; 0
    8fa2:	d1 f6       	brne	.-76     	; 0x8f58 <APP_Autonomous_Car_voidApp+0xad4>
    8fa4:	27 c0       	rjmp	.+78     	; 0x8ff4 <APP_Autonomous_Car_voidApp+0xb70>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8fa6:	8e 01       	movw	r16, r28
    8fa8:	07 5a       	subi	r16, 0xA7	; 167
    8faa:	1f 4f       	sbci	r17, 0xFF	; 255
    8fac:	fe 01       	movw	r30, r28
    8fae:	e5 5a       	subi	r30, 0xA5	; 165
    8fb0:	ff 4f       	sbci	r31, 0xFF	; 255
    8fb2:	60 81       	ld	r22, Z
    8fb4:	71 81       	ldd	r23, Z+1	; 0x01
    8fb6:	82 81       	ldd	r24, Z+2	; 0x02
    8fb8:	93 81       	ldd	r25, Z+3	; 0x03
    8fba:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8fbe:	dc 01       	movw	r26, r24
    8fc0:	cb 01       	movw	r24, r22
    8fc2:	f8 01       	movw	r30, r16
    8fc4:	91 83       	std	Z+1, r25	; 0x01
    8fc6:	80 83       	st	Z, r24
    8fc8:	de 01       	movw	r26, r28
    8fca:	ab 5a       	subi	r26, 0xAB	; 171
    8fcc:	bf 4f       	sbci	r27, 0xFF	; 255
    8fce:	fe 01       	movw	r30, r28
    8fd0:	e7 5a       	subi	r30, 0xA7	; 167
    8fd2:	ff 4f       	sbci	r31, 0xFF	; 255
    8fd4:	80 81       	ld	r24, Z
    8fd6:	91 81       	ldd	r25, Z+1	; 0x01
    8fd8:	8d 93       	st	X+, r24
    8fda:	9c 93       	st	X, r25
    8fdc:	fe 01       	movw	r30, r28
    8fde:	eb 5a       	subi	r30, 0xAB	; 171
    8fe0:	ff 4f       	sbci	r31, 0xFF	; 255
    8fe2:	80 81       	ld	r24, Z
    8fe4:	91 81       	ldd	r25, Z+1	; 0x01
    8fe6:	01 97       	sbiw	r24, 0x01	; 1
    8fe8:	f1 f7       	brne	.-4      	; 0x8fe6 <APP_Autonomous_Car_voidApp+0xb62>
    8fea:	fe 01       	movw	r30, r28
    8fec:	eb 5a       	subi	r30, 0xAB	; 171
    8fee:	ff 4f       	sbci	r31, 0xFF	; 255
    8ff0:	91 83       	std	Z+1, r25	; 0x01
    8ff2:	80 83       	st	Z, r24
					_delay_ms(50);
					Glob_u16DirRight = LOC_f32Distance;
    8ff4:	fe 01       	movw	r30, r28
    8ff6:	e2 54       	subi	r30, 0x42	; 66
    8ff8:	ff 4f       	sbci	r31, 0xFF	; 255
    8ffa:	80 81       	ld	r24, Z
    8ffc:	91 81       	ldd	r25, Z+1	; 0x01
    8ffe:	a2 81       	ldd	r26, Z+2	; 0x02
    9000:	b3 81       	ldd	r27, Z+3	; 0x03
    9002:	bc 01       	movw	r22, r24
    9004:	cd 01       	movw	r24, r26
    9006:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    900a:	dc 01       	movw	r26, r24
    900c:	cb 01       	movw	r24, r22
    900e:	90 93 d3 06 	sts	0x06D3, r25
    9012:	80 93 d2 06 	sts	0x06D2, r24
					HAL_LCD_u8Clear();
    9016:	0e 94 7e 26 	call	0x4cfc	; 0x4cfc <HAL_LCD_u8Clear>
					HAL_LCD_u8SendString("Dir Right: ");
    901a:	89 ee       	ldi	r24, 0xE9	; 233
    901c:	90 e0       	ldi	r25, 0x00	; 0
    901e:	0e 94 c9 23 	call	0x4792	; 0x4792 <HAL_LCD_u8SendString>
					HAL_LCD_u8SendNumber(Glob_u16DirRight);
    9022:	80 91 d2 06 	lds	r24, 0x06D2
    9026:	90 91 d3 06 	lds	r25, 0x06D3
    902a:	0e 94 ff 23 	call	0x47fe	; 0x47fe <HAL_LCD_u8SendNumber>
					HAL_LCD_u8SendString("cm");
    902e:	87 ed       	ldi	r24, 0xD7	; 215
    9030:	90 e0       	ldi	r25, 0x00	; 0
    9032:	0e 94 c9 23 	call	0x4792	; 0x4792 <HAL_LCD_u8SendString>
    9036:	fe 01       	movw	r30, r28
    9038:	ef 5a       	subi	r30, 0xAF	; 175
    903a:	ff 4f       	sbci	r31, 0xFF	; 255
    903c:	80 e0       	ldi	r24, 0x00	; 0
    903e:	90 e0       	ldi	r25, 0x00	; 0
    9040:	a8 e4       	ldi	r26, 0x48	; 72
    9042:	b3 e4       	ldi	r27, 0x43	; 67
    9044:	80 83       	st	Z, r24
    9046:	91 83       	std	Z+1, r25	; 0x01
    9048:	a2 83       	std	Z+2, r26	; 0x02
    904a:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    904c:	8e 01       	movw	r16, r28
    904e:	03 5b       	subi	r16, 0xB3	; 179
    9050:	1f 4f       	sbci	r17, 0xFF	; 255
    9052:	fe 01       	movw	r30, r28
    9054:	ef 5a       	subi	r30, 0xAF	; 175
    9056:	ff 4f       	sbci	r31, 0xFF	; 255
    9058:	60 81       	ld	r22, Z
    905a:	71 81       	ldd	r23, Z+1	; 0x01
    905c:	82 81       	ldd	r24, Z+2	; 0x02
    905e:	93 81       	ldd	r25, Z+3	; 0x03
    9060:	20 e0       	ldi	r18, 0x00	; 0
    9062:	30 e0       	ldi	r19, 0x00	; 0
    9064:	4a e7       	ldi	r20, 0x7A	; 122
    9066:	55 e4       	ldi	r21, 0x45	; 69
    9068:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    906c:	dc 01       	movw	r26, r24
    906e:	cb 01       	movw	r24, r22
    9070:	f8 01       	movw	r30, r16
    9072:	80 83       	st	Z, r24
    9074:	91 83       	std	Z+1, r25	; 0x01
    9076:	a2 83       	std	Z+2, r26	; 0x02
    9078:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    907a:	fe 01       	movw	r30, r28
    907c:	e3 5b       	subi	r30, 0xB3	; 179
    907e:	ff 4f       	sbci	r31, 0xFF	; 255
    9080:	60 81       	ld	r22, Z
    9082:	71 81       	ldd	r23, Z+1	; 0x01
    9084:	82 81       	ldd	r24, Z+2	; 0x02
    9086:	93 81       	ldd	r25, Z+3	; 0x03
    9088:	20 e0       	ldi	r18, 0x00	; 0
    908a:	30 e0       	ldi	r19, 0x00	; 0
    908c:	40 e8       	ldi	r20, 0x80	; 128
    908e:	5f e3       	ldi	r21, 0x3F	; 63
    9090:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    9094:	88 23       	and	r24, r24
    9096:	44 f4       	brge	.+16     	; 0x90a8 <APP_Autonomous_Car_voidApp+0xc24>
		__ticks = 1;
    9098:	fe 01       	movw	r30, r28
    909a:	e5 5b       	subi	r30, 0xB5	; 181
    909c:	ff 4f       	sbci	r31, 0xFF	; 255
    909e:	81 e0       	ldi	r24, 0x01	; 1
    90a0:	90 e0       	ldi	r25, 0x00	; 0
    90a2:	91 83       	std	Z+1, r25	; 0x01
    90a4:	80 83       	st	Z, r24
    90a6:	64 c0       	rjmp	.+200    	; 0x9170 <APP_Autonomous_Car_voidApp+0xcec>
	else if (__tmp > 65535)
    90a8:	fe 01       	movw	r30, r28
    90aa:	e3 5b       	subi	r30, 0xB3	; 179
    90ac:	ff 4f       	sbci	r31, 0xFF	; 255
    90ae:	60 81       	ld	r22, Z
    90b0:	71 81       	ldd	r23, Z+1	; 0x01
    90b2:	82 81       	ldd	r24, Z+2	; 0x02
    90b4:	93 81       	ldd	r25, Z+3	; 0x03
    90b6:	20 e0       	ldi	r18, 0x00	; 0
    90b8:	3f ef       	ldi	r19, 0xFF	; 255
    90ba:	4f e7       	ldi	r20, 0x7F	; 127
    90bc:	57 e4       	ldi	r21, 0x47	; 71
    90be:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    90c2:	18 16       	cp	r1, r24
    90c4:	0c f0       	brlt	.+2      	; 0x90c8 <APP_Autonomous_Car_voidApp+0xc44>
    90c6:	43 c0       	rjmp	.+134    	; 0x914e <APP_Autonomous_Car_voidApp+0xcca>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    90c8:	fe 01       	movw	r30, r28
    90ca:	ef 5a       	subi	r30, 0xAF	; 175
    90cc:	ff 4f       	sbci	r31, 0xFF	; 255
    90ce:	60 81       	ld	r22, Z
    90d0:	71 81       	ldd	r23, Z+1	; 0x01
    90d2:	82 81       	ldd	r24, Z+2	; 0x02
    90d4:	93 81       	ldd	r25, Z+3	; 0x03
    90d6:	20 e0       	ldi	r18, 0x00	; 0
    90d8:	30 e0       	ldi	r19, 0x00	; 0
    90da:	40 e2       	ldi	r20, 0x20	; 32
    90dc:	51 e4       	ldi	r21, 0x41	; 65
    90de:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    90e2:	dc 01       	movw	r26, r24
    90e4:	cb 01       	movw	r24, r22
    90e6:	8e 01       	movw	r16, r28
    90e8:	05 5b       	subi	r16, 0xB5	; 181
    90ea:	1f 4f       	sbci	r17, 0xFF	; 255
    90ec:	bc 01       	movw	r22, r24
    90ee:	cd 01       	movw	r24, r26
    90f0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    90f4:	dc 01       	movw	r26, r24
    90f6:	cb 01       	movw	r24, r22
    90f8:	f8 01       	movw	r30, r16
    90fa:	91 83       	std	Z+1, r25	; 0x01
    90fc:	80 83       	st	Z, r24
    90fe:	1f c0       	rjmp	.+62     	; 0x913e <APP_Autonomous_Car_voidApp+0xcba>
    9100:	fe 01       	movw	r30, r28
    9102:	e7 5b       	subi	r30, 0xB7	; 183
    9104:	ff 4f       	sbci	r31, 0xFF	; 255
    9106:	80 e9       	ldi	r24, 0x90	; 144
    9108:	91 e0       	ldi	r25, 0x01	; 1
    910a:	91 83       	std	Z+1, r25	; 0x01
    910c:	80 83       	st	Z, r24
    910e:	fe 01       	movw	r30, r28
    9110:	e7 5b       	subi	r30, 0xB7	; 183
    9112:	ff 4f       	sbci	r31, 0xFF	; 255
    9114:	80 81       	ld	r24, Z
    9116:	91 81       	ldd	r25, Z+1	; 0x01
    9118:	01 97       	sbiw	r24, 0x01	; 1
    911a:	f1 f7       	brne	.-4      	; 0x9118 <APP_Autonomous_Car_voidApp+0xc94>
    911c:	fe 01       	movw	r30, r28
    911e:	e7 5b       	subi	r30, 0xB7	; 183
    9120:	ff 4f       	sbci	r31, 0xFF	; 255
    9122:	91 83       	std	Z+1, r25	; 0x01
    9124:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    9126:	de 01       	movw	r26, r28
    9128:	a5 5b       	subi	r26, 0xB5	; 181
    912a:	bf 4f       	sbci	r27, 0xFF	; 255
    912c:	fe 01       	movw	r30, r28
    912e:	e5 5b       	subi	r30, 0xB5	; 181
    9130:	ff 4f       	sbci	r31, 0xFF	; 255
    9132:	80 81       	ld	r24, Z
    9134:	91 81       	ldd	r25, Z+1	; 0x01
    9136:	01 97       	sbiw	r24, 0x01	; 1
    9138:	11 96       	adiw	r26, 0x01	; 1
    913a:	9c 93       	st	X, r25
    913c:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    913e:	fe 01       	movw	r30, r28
    9140:	e5 5b       	subi	r30, 0xB5	; 181
    9142:	ff 4f       	sbci	r31, 0xFF	; 255
    9144:	80 81       	ld	r24, Z
    9146:	91 81       	ldd	r25, Z+1	; 0x01
    9148:	00 97       	sbiw	r24, 0x00	; 0
    914a:	d1 f6       	brne	.-76     	; 0x9100 <APP_Autonomous_Car_voidApp+0xc7c>
    914c:	28 c0       	rjmp	.+80     	; 0x919e <APP_Autonomous_Car_voidApp+0xd1a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    914e:	8e 01       	movw	r16, r28
    9150:	05 5b       	subi	r16, 0xB5	; 181
    9152:	1f 4f       	sbci	r17, 0xFF	; 255
    9154:	fe 01       	movw	r30, r28
    9156:	e3 5b       	subi	r30, 0xB3	; 179
    9158:	ff 4f       	sbci	r31, 0xFF	; 255
    915a:	60 81       	ld	r22, Z
    915c:	71 81       	ldd	r23, Z+1	; 0x01
    915e:	82 81       	ldd	r24, Z+2	; 0x02
    9160:	93 81       	ldd	r25, Z+3	; 0x03
    9162:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    9166:	dc 01       	movw	r26, r24
    9168:	cb 01       	movw	r24, r22
    916a:	f8 01       	movw	r30, r16
    916c:	91 83       	std	Z+1, r25	; 0x01
    916e:	80 83       	st	Z, r24
    9170:	de 01       	movw	r26, r28
    9172:	a9 5b       	subi	r26, 0xB9	; 185
    9174:	bf 4f       	sbci	r27, 0xFF	; 255
    9176:	fe 01       	movw	r30, r28
    9178:	e5 5b       	subi	r30, 0xB5	; 181
    917a:	ff 4f       	sbci	r31, 0xFF	; 255
    917c:	80 81       	ld	r24, Z
    917e:	91 81       	ldd	r25, Z+1	; 0x01
    9180:	11 96       	adiw	r26, 0x01	; 1
    9182:	9c 93       	st	X, r25
    9184:	8e 93       	st	-X, r24
    9186:	fe 01       	movw	r30, r28
    9188:	e9 5b       	subi	r30, 0xB9	; 185
    918a:	ff 4f       	sbci	r31, 0xFF	; 255
    918c:	80 81       	ld	r24, Z
    918e:	91 81       	ldd	r25, Z+1	; 0x01
    9190:	01 97       	sbiw	r24, 0x01	; 1
    9192:	f1 f7       	brne	.-4      	; 0x9190 <APP_Autonomous_Car_voidApp+0xd0c>
    9194:	fe 01       	movw	r30, r28
    9196:	e9 5b       	subi	r30, 0xB9	; 185
    9198:	ff 4f       	sbci	r31, 0xFF	; 255
    919a:	91 83       	std	Z+1, r25	; 0x01
    919c:	80 83       	st	Z, r24
					_delay_ms(200);
					for (int j = MAX_CCW_ANGLE; j <= MAX_CW_ANGLE; j += NUM_2) {
    919e:	fe 01       	movw	r30, r28
    91a0:	e7 54       	subi	r30, 0x47	; 71
    91a2:	ff 4f       	sbci	r31, 0xFF	; 255
    91a4:	11 82       	std	Z+1, r1	; 0x01
    91a6:	10 82       	st	Z, r1
    91a8:	cc c1       	rjmp	.+920    	; 0x9542 <APP_Autonomous_Car_voidApp+0x10be>
						HAL_SM_voidSMSetAngle(j);
    91aa:	fe 01       	movw	r30, r28
    91ac:	e7 54       	subi	r30, 0x47	; 71
    91ae:	ff 4f       	sbci	r31, 0xFF	; 255
    91b0:	80 81       	ld	r24, Z
    91b2:	0e 94 f1 1b 	call	0x37e2	; 0x37e2 <HAL_SM_voidSMSetAngle>
						if (j == MAX_CW_ANGLE) {
    91b6:	fe 01       	movw	r30, r28
    91b8:	e7 54       	subi	r30, 0x47	; 71
    91ba:	ff 4f       	sbci	r31, 0xFF	; 255
    91bc:	80 81       	ld	r24, Z
    91be:	91 81       	ldd	r25, Z+1	; 0x01
    91c0:	84 3b       	cpi	r24, 0xB4	; 180
    91c2:	91 05       	cpc	r25, r1
    91c4:	09 f0       	breq	.+2      	; 0x91c8 <APP_Autonomous_Car_voidApp+0xd44>
    91c6:	b1 c1       	rjmp	.+866    	; 0x952a <APP_Autonomous_Car_voidApp+0x10a6>
    91c8:	fe 01       	movw	r30, r28
    91ca:	ed 5b       	subi	r30, 0xBD	; 189
    91cc:	ff 4f       	sbci	r31, 0xFF	; 255
    91ce:	80 e0       	ldi	r24, 0x00	; 0
    91d0:	90 e0       	ldi	r25, 0x00	; 0
    91d2:	a8 e4       	ldi	r26, 0x48	; 72
    91d4:	b2 e4       	ldi	r27, 0x42	; 66
    91d6:	80 83       	st	Z, r24
    91d8:	91 83       	std	Z+1, r25	; 0x01
    91da:	a2 83       	std	Z+2, r26	; 0x02
    91dc:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    91de:	8e 01       	movw	r16, r28
    91e0:	01 5c       	subi	r16, 0xC1	; 193
    91e2:	1f 4f       	sbci	r17, 0xFF	; 255
    91e4:	fe 01       	movw	r30, r28
    91e6:	ed 5b       	subi	r30, 0xBD	; 189
    91e8:	ff 4f       	sbci	r31, 0xFF	; 255
    91ea:	60 81       	ld	r22, Z
    91ec:	71 81       	ldd	r23, Z+1	; 0x01
    91ee:	82 81       	ldd	r24, Z+2	; 0x02
    91f0:	93 81       	ldd	r25, Z+3	; 0x03
    91f2:	20 e0       	ldi	r18, 0x00	; 0
    91f4:	30 e0       	ldi	r19, 0x00	; 0
    91f6:	4a e7       	ldi	r20, 0x7A	; 122
    91f8:	55 e4       	ldi	r21, 0x45	; 69
    91fa:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    91fe:	dc 01       	movw	r26, r24
    9200:	cb 01       	movw	r24, r22
    9202:	f8 01       	movw	r30, r16
    9204:	80 83       	st	Z, r24
    9206:	91 83       	std	Z+1, r25	; 0x01
    9208:	a2 83       	std	Z+2, r26	; 0x02
    920a:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    920c:	fe 01       	movw	r30, r28
    920e:	ff 96       	adiw	r30, 0x3f	; 63
    9210:	60 81       	ld	r22, Z
    9212:	71 81       	ldd	r23, Z+1	; 0x01
    9214:	82 81       	ldd	r24, Z+2	; 0x02
    9216:	93 81       	ldd	r25, Z+3	; 0x03
    9218:	20 e0       	ldi	r18, 0x00	; 0
    921a:	30 e0       	ldi	r19, 0x00	; 0
    921c:	40 e8       	ldi	r20, 0x80	; 128
    921e:	5f e3       	ldi	r21, 0x3F	; 63
    9220:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    9224:	88 23       	and	r24, r24
    9226:	2c f4       	brge	.+10     	; 0x9232 <APP_Autonomous_Car_voidApp+0xdae>
		__ticks = 1;
    9228:	81 e0       	ldi	r24, 0x01	; 1
    922a:	90 e0       	ldi	r25, 0x00	; 0
    922c:	9e af       	std	Y+62, r25	; 0x3e
    922e:	8d af       	std	Y+61, r24	; 0x3d
    9230:	46 c0       	rjmp	.+140    	; 0x92be <APP_Autonomous_Car_voidApp+0xe3a>
	else if (__tmp > 65535)
    9232:	fe 01       	movw	r30, r28
    9234:	ff 96       	adiw	r30, 0x3f	; 63
    9236:	60 81       	ld	r22, Z
    9238:	71 81       	ldd	r23, Z+1	; 0x01
    923a:	82 81       	ldd	r24, Z+2	; 0x02
    923c:	93 81       	ldd	r25, Z+3	; 0x03
    923e:	20 e0       	ldi	r18, 0x00	; 0
    9240:	3f ef       	ldi	r19, 0xFF	; 255
    9242:	4f e7       	ldi	r20, 0x7F	; 127
    9244:	57 e4       	ldi	r21, 0x47	; 71
    9246:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    924a:	18 16       	cp	r1, r24
    924c:	64 f5       	brge	.+88     	; 0x92a6 <APP_Autonomous_Car_voidApp+0xe22>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    924e:	fe 01       	movw	r30, r28
    9250:	ed 5b       	subi	r30, 0xBD	; 189
    9252:	ff 4f       	sbci	r31, 0xFF	; 255
    9254:	60 81       	ld	r22, Z
    9256:	71 81       	ldd	r23, Z+1	; 0x01
    9258:	82 81       	ldd	r24, Z+2	; 0x02
    925a:	93 81       	ldd	r25, Z+3	; 0x03
    925c:	20 e0       	ldi	r18, 0x00	; 0
    925e:	30 e0       	ldi	r19, 0x00	; 0
    9260:	40 e2       	ldi	r20, 0x20	; 32
    9262:	51 e4       	ldi	r21, 0x41	; 65
    9264:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    9268:	dc 01       	movw	r26, r24
    926a:	cb 01       	movw	r24, r22
    926c:	bc 01       	movw	r22, r24
    926e:	cd 01       	movw	r24, r26
    9270:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    9274:	dc 01       	movw	r26, r24
    9276:	cb 01       	movw	r24, r22
    9278:	9e af       	std	Y+62, r25	; 0x3e
    927a:	8d af       	std	Y+61, r24	; 0x3d
    927c:	0f c0       	rjmp	.+30     	; 0x929c <APP_Autonomous_Car_voidApp+0xe18>
    927e:	80 e9       	ldi	r24, 0x90	; 144
    9280:	91 e0       	ldi	r25, 0x01	; 1
    9282:	9c af       	std	Y+60, r25	; 0x3c
    9284:	8b af       	std	Y+59, r24	; 0x3b
    9286:	8b ad       	ldd	r24, Y+59	; 0x3b
    9288:	9c ad       	ldd	r25, Y+60	; 0x3c
    928a:	01 97       	sbiw	r24, 0x01	; 1
    928c:	f1 f7       	brne	.-4      	; 0x928a <APP_Autonomous_Car_voidApp+0xe06>
    928e:	9c af       	std	Y+60, r25	; 0x3c
    9290:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    9292:	8d ad       	ldd	r24, Y+61	; 0x3d
    9294:	9e ad       	ldd	r25, Y+62	; 0x3e
    9296:	01 97       	sbiw	r24, 0x01	; 1
    9298:	9e af       	std	Y+62, r25	; 0x3e
    929a:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    929c:	8d ad       	ldd	r24, Y+61	; 0x3d
    929e:	9e ad       	ldd	r25, Y+62	; 0x3e
    92a0:	00 97       	sbiw	r24, 0x00	; 0
    92a2:	69 f7       	brne	.-38     	; 0x927e <APP_Autonomous_Car_voidApp+0xdfa>
    92a4:	16 c0       	rjmp	.+44     	; 0x92d2 <APP_Autonomous_Car_voidApp+0xe4e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    92a6:	fe 01       	movw	r30, r28
    92a8:	ff 96       	adiw	r30, 0x3f	; 63
    92aa:	60 81       	ld	r22, Z
    92ac:	71 81       	ldd	r23, Z+1	; 0x01
    92ae:	82 81       	ldd	r24, Z+2	; 0x02
    92b0:	93 81       	ldd	r25, Z+3	; 0x03
    92b2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    92b6:	dc 01       	movw	r26, r24
    92b8:	cb 01       	movw	r24, r22
    92ba:	9e af       	std	Y+62, r25	; 0x3e
    92bc:	8d af       	std	Y+61, r24	; 0x3d
    92be:	8d ad       	ldd	r24, Y+61	; 0x3d
    92c0:	9e ad       	ldd	r25, Y+62	; 0x3e
    92c2:	9a af       	std	Y+58, r25	; 0x3a
    92c4:	89 af       	std	Y+57, r24	; 0x39
    92c6:	89 ad       	ldd	r24, Y+57	; 0x39
    92c8:	9a ad       	ldd	r25, Y+58	; 0x3a
    92ca:	01 97       	sbiw	r24, 0x01	; 1
    92cc:	f1 f7       	brne	.-4      	; 0x92ca <APP_Autonomous_Car_voidApp+0xe46>
    92ce:	9a af       	std	Y+58, r25	; 0x3a
    92d0:	89 af       	std	Y+57, r24	; 0x39
							_delay_ms(50);
							HAL_Ultrasonic_Sensor_voidCalcDistancse(
    92d2:	ce 01       	movw	r24, r28
    92d4:	82 54       	subi	r24, 0x42	; 66
    92d6:	9f 4f       	sbci	r25, 0xFF	; 255
    92d8:	0e 94 c9 1a 	call	0x3592	; 0x3592 <HAL_Ultrasonic_Sensor_voidCalcDistancse>
    92dc:	80 e0       	ldi	r24, 0x00	; 0
    92de:	90 e0       	ldi	r25, 0x00	; 0
    92e0:	a8 e4       	ldi	r26, 0x48	; 72
    92e2:	b2 e4       	ldi	r27, 0x42	; 66
    92e4:	8d ab       	std	Y+53, r24	; 0x35
    92e6:	9e ab       	std	Y+54, r25	; 0x36
    92e8:	af ab       	std	Y+55, r26	; 0x37
    92ea:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    92ec:	6d a9       	ldd	r22, Y+53	; 0x35
    92ee:	7e a9       	ldd	r23, Y+54	; 0x36
    92f0:	8f a9       	ldd	r24, Y+55	; 0x37
    92f2:	98 ad       	ldd	r25, Y+56	; 0x38
    92f4:	20 e0       	ldi	r18, 0x00	; 0
    92f6:	30 e0       	ldi	r19, 0x00	; 0
    92f8:	4a e7       	ldi	r20, 0x7A	; 122
    92fa:	55 e4       	ldi	r21, 0x45	; 69
    92fc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    9300:	dc 01       	movw	r26, r24
    9302:	cb 01       	movw	r24, r22
    9304:	89 ab       	std	Y+49, r24	; 0x31
    9306:	9a ab       	std	Y+50, r25	; 0x32
    9308:	ab ab       	std	Y+51, r26	; 0x33
    930a:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    930c:	69 a9       	ldd	r22, Y+49	; 0x31
    930e:	7a a9       	ldd	r23, Y+50	; 0x32
    9310:	8b a9       	ldd	r24, Y+51	; 0x33
    9312:	9c a9       	ldd	r25, Y+52	; 0x34
    9314:	20 e0       	ldi	r18, 0x00	; 0
    9316:	30 e0       	ldi	r19, 0x00	; 0
    9318:	40 e8       	ldi	r20, 0x80	; 128
    931a:	5f e3       	ldi	r21, 0x3F	; 63
    931c:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    9320:	88 23       	and	r24, r24
    9322:	2c f4       	brge	.+10     	; 0x932e <APP_Autonomous_Car_voidApp+0xeaa>
		__ticks = 1;
    9324:	81 e0       	ldi	r24, 0x01	; 1
    9326:	90 e0       	ldi	r25, 0x00	; 0
    9328:	98 ab       	std	Y+48, r25	; 0x30
    932a:	8f a7       	std	Y+47, r24	; 0x2f
    932c:	3f c0       	rjmp	.+126    	; 0x93ac <APP_Autonomous_Car_voidApp+0xf28>
	else if (__tmp > 65535)
    932e:	69 a9       	ldd	r22, Y+49	; 0x31
    9330:	7a a9       	ldd	r23, Y+50	; 0x32
    9332:	8b a9       	ldd	r24, Y+51	; 0x33
    9334:	9c a9       	ldd	r25, Y+52	; 0x34
    9336:	20 e0       	ldi	r18, 0x00	; 0
    9338:	3f ef       	ldi	r19, 0xFF	; 255
    933a:	4f e7       	ldi	r20, 0x7F	; 127
    933c:	57 e4       	ldi	r21, 0x47	; 71
    933e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    9342:	18 16       	cp	r1, r24
    9344:	4c f5       	brge	.+82     	; 0x9398 <APP_Autonomous_Car_voidApp+0xf14>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    9346:	6d a9       	ldd	r22, Y+53	; 0x35
    9348:	7e a9       	ldd	r23, Y+54	; 0x36
    934a:	8f a9       	ldd	r24, Y+55	; 0x37
    934c:	98 ad       	ldd	r25, Y+56	; 0x38
    934e:	20 e0       	ldi	r18, 0x00	; 0
    9350:	30 e0       	ldi	r19, 0x00	; 0
    9352:	40 e2       	ldi	r20, 0x20	; 32
    9354:	51 e4       	ldi	r21, 0x41	; 65
    9356:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    935a:	dc 01       	movw	r26, r24
    935c:	cb 01       	movw	r24, r22
    935e:	bc 01       	movw	r22, r24
    9360:	cd 01       	movw	r24, r26
    9362:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    9366:	dc 01       	movw	r26, r24
    9368:	cb 01       	movw	r24, r22
    936a:	98 ab       	std	Y+48, r25	; 0x30
    936c:	8f a7       	std	Y+47, r24	; 0x2f
    936e:	0f c0       	rjmp	.+30     	; 0x938e <APP_Autonomous_Car_voidApp+0xf0a>
    9370:	80 e9       	ldi	r24, 0x90	; 144
    9372:	91 e0       	ldi	r25, 0x01	; 1
    9374:	9e a7       	std	Y+46, r25	; 0x2e
    9376:	8d a7       	std	Y+45, r24	; 0x2d
    9378:	8d a5       	ldd	r24, Y+45	; 0x2d
    937a:	9e a5       	ldd	r25, Y+46	; 0x2e
    937c:	01 97       	sbiw	r24, 0x01	; 1
    937e:	f1 f7       	brne	.-4      	; 0x937c <APP_Autonomous_Car_voidApp+0xef8>
    9380:	9e a7       	std	Y+46, r25	; 0x2e
    9382:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    9384:	8f a5       	ldd	r24, Y+47	; 0x2f
    9386:	98 a9       	ldd	r25, Y+48	; 0x30
    9388:	01 97       	sbiw	r24, 0x01	; 1
    938a:	98 ab       	std	Y+48, r25	; 0x30
    938c:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    938e:	8f a5       	ldd	r24, Y+47	; 0x2f
    9390:	98 a9       	ldd	r25, Y+48	; 0x30
    9392:	00 97       	sbiw	r24, 0x00	; 0
    9394:	69 f7       	brne	.-38     	; 0x9370 <APP_Autonomous_Car_voidApp+0xeec>
    9396:	14 c0       	rjmp	.+40     	; 0x93c0 <APP_Autonomous_Car_voidApp+0xf3c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    9398:	69 a9       	ldd	r22, Y+49	; 0x31
    939a:	7a a9       	ldd	r23, Y+50	; 0x32
    939c:	8b a9       	ldd	r24, Y+51	; 0x33
    939e:	9c a9       	ldd	r25, Y+52	; 0x34
    93a0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    93a4:	dc 01       	movw	r26, r24
    93a6:	cb 01       	movw	r24, r22
    93a8:	98 ab       	std	Y+48, r25	; 0x30
    93aa:	8f a7       	std	Y+47, r24	; 0x2f
    93ac:	8f a5       	ldd	r24, Y+47	; 0x2f
    93ae:	98 a9       	ldd	r25, Y+48	; 0x30
    93b0:	9c a7       	std	Y+44, r25	; 0x2c
    93b2:	8b a7       	std	Y+43, r24	; 0x2b
    93b4:	8b a5       	ldd	r24, Y+43	; 0x2b
    93b6:	9c a5       	ldd	r25, Y+44	; 0x2c
    93b8:	01 97       	sbiw	r24, 0x01	; 1
    93ba:	f1 f7       	brne	.-4      	; 0x93b8 <APP_Autonomous_Car_voidApp+0xf34>
    93bc:	9c a7       	std	Y+44, r25	; 0x2c
    93be:	8b a7       	std	Y+43, r24	; 0x2b
									&LOC_f32Distance);
							_delay_ms(50);
							Glob_u16DirLeft = LOC_f32Distance;
    93c0:	fe 01       	movw	r30, r28
    93c2:	e2 54       	subi	r30, 0x42	; 66
    93c4:	ff 4f       	sbci	r31, 0xFF	; 255
    93c6:	80 81       	ld	r24, Z
    93c8:	91 81       	ldd	r25, Z+1	; 0x01
    93ca:	a2 81       	ldd	r26, Z+2	; 0x02
    93cc:	b3 81       	ldd	r27, Z+3	; 0x03
    93ce:	bc 01       	movw	r22, r24
    93d0:	cd 01       	movw	r24, r26
    93d2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    93d6:	dc 01       	movw	r26, r24
    93d8:	cb 01       	movw	r24, r22
    93da:	90 93 d1 06 	sts	0x06D1, r25
    93de:	80 93 d0 06 	sts	0x06D0, r24
							HAL_LCD_u8Clear();
    93e2:	0e 94 7e 26 	call	0x4cfc	; 0x4cfc <HAL_LCD_u8Clear>
							HAL_LCD_u8SendString("Dir Left: ");
    93e6:	85 ef       	ldi	r24, 0xF5	; 245
    93e8:	90 e0       	ldi	r25, 0x00	; 0
    93ea:	0e 94 c9 23 	call	0x4792	; 0x4792 <HAL_LCD_u8SendString>
							HAL_LCD_u8SendNumber(Glob_u16DirLeft);
    93ee:	80 91 d0 06 	lds	r24, 0x06D0
    93f2:	90 91 d1 06 	lds	r25, 0x06D1
    93f6:	0e 94 ff 23 	call	0x47fe	; 0x47fe <HAL_LCD_u8SendNumber>
							HAL_LCD_u8SendString("cm");
    93fa:	87 ed       	ldi	r24, 0xD7	; 215
    93fc:	90 e0       	ldi	r25, 0x00	; 0
    93fe:	0e 94 c9 23 	call	0x4792	; 0x4792 <HAL_LCD_u8SendString>
    9402:	80 e0       	ldi	r24, 0x00	; 0
    9404:	90 e0       	ldi	r25, 0x00	; 0
    9406:	a8 e4       	ldi	r26, 0x48	; 72
    9408:	b3 e4       	ldi	r27, 0x43	; 67
    940a:	8f a3       	std	Y+39, r24	; 0x27
    940c:	98 a7       	std	Y+40, r25	; 0x28
    940e:	a9 a7       	std	Y+41, r26	; 0x29
    9410:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    9412:	6f a1       	ldd	r22, Y+39	; 0x27
    9414:	78 a5       	ldd	r23, Y+40	; 0x28
    9416:	89 a5       	ldd	r24, Y+41	; 0x29
    9418:	9a a5       	ldd	r25, Y+42	; 0x2a
    941a:	20 e0       	ldi	r18, 0x00	; 0
    941c:	30 e0       	ldi	r19, 0x00	; 0
    941e:	4a e7       	ldi	r20, 0x7A	; 122
    9420:	55 e4       	ldi	r21, 0x45	; 69
    9422:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    9426:	dc 01       	movw	r26, r24
    9428:	cb 01       	movw	r24, r22
    942a:	8b a3       	std	Y+35, r24	; 0x23
    942c:	9c a3       	std	Y+36, r25	; 0x24
    942e:	ad a3       	std	Y+37, r26	; 0x25
    9430:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    9432:	6b a1       	ldd	r22, Y+35	; 0x23
    9434:	7c a1       	ldd	r23, Y+36	; 0x24
    9436:	8d a1       	ldd	r24, Y+37	; 0x25
    9438:	9e a1       	ldd	r25, Y+38	; 0x26
    943a:	20 e0       	ldi	r18, 0x00	; 0
    943c:	30 e0       	ldi	r19, 0x00	; 0
    943e:	40 e8       	ldi	r20, 0x80	; 128
    9440:	5f e3       	ldi	r21, 0x3F	; 63
    9442:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    9446:	88 23       	and	r24, r24
    9448:	2c f4       	brge	.+10     	; 0x9454 <APP_Autonomous_Car_voidApp+0xfd0>
		__ticks = 1;
    944a:	81 e0       	ldi	r24, 0x01	; 1
    944c:	90 e0       	ldi	r25, 0x00	; 0
    944e:	9a a3       	std	Y+34, r25	; 0x22
    9450:	89 a3       	std	Y+33, r24	; 0x21
    9452:	3f c0       	rjmp	.+126    	; 0x94d2 <APP_Autonomous_Car_voidApp+0x104e>
	else if (__tmp > 65535)
    9454:	6b a1       	ldd	r22, Y+35	; 0x23
    9456:	7c a1       	ldd	r23, Y+36	; 0x24
    9458:	8d a1       	ldd	r24, Y+37	; 0x25
    945a:	9e a1       	ldd	r25, Y+38	; 0x26
    945c:	20 e0       	ldi	r18, 0x00	; 0
    945e:	3f ef       	ldi	r19, 0xFF	; 255
    9460:	4f e7       	ldi	r20, 0x7F	; 127
    9462:	57 e4       	ldi	r21, 0x47	; 71
    9464:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    9468:	18 16       	cp	r1, r24
    946a:	4c f5       	brge	.+82     	; 0x94be <APP_Autonomous_Car_voidApp+0x103a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    946c:	6f a1       	ldd	r22, Y+39	; 0x27
    946e:	78 a5       	ldd	r23, Y+40	; 0x28
    9470:	89 a5       	ldd	r24, Y+41	; 0x29
    9472:	9a a5       	ldd	r25, Y+42	; 0x2a
    9474:	20 e0       	ldi	r18, 0x00	; 0
    9476:	30 e0       	ldi	r19, 0x00	; 0
    9478:	40 e2       	ldi	r20, 0x20	; 32
    947a:	51 e4       	ldi	r21, 0x41	; 65
    947c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    9480:	dc 01       	movw	r26, r24
    9482:	cb 01       	movw	r24, r22
    9484:	bc 01       	movw	r22, r24
    9486:	cd 01       	movw	r24, r26
    9488:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    948c:	dc 01       	movw	r26, r24
    948e:	cb 01       	movw	r24, r22
    9490:	9a a3       	std	Y+34, r25	; 0x22
    9492:	89 a3       	std	Y+33, r24	; 0x21
    9494:	0f c0       	rjmp	.+30     	; 0x94b4 <APP_Autonomous_Car_voidApp+0x1030>
    9496:	80 e9       	ldi	r24, 0x90	; 144
    9498:	91 e0       	ldi	r25, 0x01	; 1
    949a:	98 a3       	std	Y+32, r25	; 0x20
    949c:	8f 8f       	std	Y+31, r24	; 0x1f
    949e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    94a0:	98 a1       	ldd	r25, Y+32	; 0x20
    94a2:	01 97       	sbiw	r24, 0x01	; 1
    94a4:	f1 f7       	brne	.-4      	; 0x94a2 <APP_Autonomous_Car_voidApp+0x101e>
    94a6:	98 a3       	std	Y+32, r25	; 0x20
    94a8:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    94aa:	89 a1       	ldd	r24, Y+33	; 0x21
    94ac:	9a a1       	ldd	r25, Y+34	; 0x22
    94ae:	01 97       	sbiw	r24, 0x01	; 1
    94b0:	9a a3       	std	Y+34, r25	; 0x22
    94b2:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    94b4:	89 a1       	ldd	r24, Y+33	; 0x21
    94b6:	9a a1       	ldd	r25, Y+34	; 0x22
    94b8:	00 97       	sbiw	r24, 0x00	; 0
    94ba:	69 f7       	brne	.-38     	; 0x9496 <APP_Autonomous_Car_voidApp+0x1012>
    94bc:	14 c0       	rjmp	.+40     	; 0x94e6 <APP_Autonomous_Car_voidApp+0x1062>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    94be:	6b a1       	ldd	r22, Y+35	; 0x23
    94c0:	7c a1       	ldd	r23, Y+36	; 0x24
    94c2:	8d a1       	ldd	r24, Y+37	; 0x25
    94c4:	9e a1       	ldd	r25, Y+38	; 0x26
    94c6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    94ca:	dc 01       	movw	r26, r24
    94cc:	cb 01       	movw	r24, r22
    94ce:	9a a3       	std	Y+34, r25	; 0x22
    94d0:	89 a3       	std	Y+33, r24	; 0x21
    94d2:	89 a1       	ldd	r24, Y+33	; 0x21
    94d4:	9a a1       	ldd	r25, Y+34	; 0x22
    94d6:	9e 8f       	std	Y+30, r25	; 0x1e
    94d8:	8d 8f       	std	Y+29, r24	; 0x1d
    94da:	8d 8d       	ldd	r24, Y+29	; 0x1d
    94dc:	9e 8d       	ldd	r25, Y+30	; 0x1e
    94de:	01 97       	sbiw	r24, 0x01	; 1
    94e0:	f1 f7       	brne	.-4      	; 0x94de <APP_Autonomous_Car_voidApp+0x105a>
    94e2:	9e 8f       	std	Y+30, r25	; 0x1e
    94e4:	8d 8f       	std	Y+29, r24	; 0x1d
							_delay_ms(200);
							for (int k = MAX_CW_ANGLE; k >= START_ANGLE; k -=
    94e6:	fe 01       	movw	r30, r28
    94e8:	e9 54       	subi	r30, 0x49	; 73
    94ea:	ff 4f       	sbci	r31, 0xFF	; 255
    94ec:	84 eb       	ldi	r24, 0xB4	; 180
    94ee:	90 e0       	ldi	r25, 0x00	; 0
    94f0:	91 83       	std	Z+1, r25	; 0x01
    94f2:	80 83       	st	Z, r24
    94f4:	12 c0       	rjmp	.+36     	; 0x951a <APP_Autonomous_Car_voidApp+0x1096>
							NUM_2) {
								HAL_SM_voidSMSetAngle(k);
    94f6:	fe 01       	movw	r30, r28
    94f8:	e9 54       	subi	r30, 0x49	; 73
    94fa:	ff 4f       	sbci	r31, 0xFF	; 255
    94fc:	80 81       	ld	r24, Z
    94fe:	0e 94 f1 1b 	call	0x37e2	; 0x37e2 <HAL_SM_voidSMSetAngle>
							HAL_LCD_u8SendString("Dir Left: ");
							HAL_LCD_u8SendNumber(Glob_u16DirLeft);
							HAL_LCD_u8SendString("cm");
							_delay_ms(200);
							for (int k = MAX_CW_ANGLE; k >= START_ANGLE; k -=
							NUM_2) {
    9502:	de 01       	movw	r26, r28
    9504:	a9 54       	subi	r26, 0x49	; 73
    9506:	bf 4f       	sbci	r27, 0xFF	; 255
    9508:	fe 01       	movw	r30, r28
    950a:	e9 54       	subi	r30, 0x49	; 73
    950c:	ff 4f       	sbci	r31, 0xFF	; 255
    950e:	80 81       	ld	r24, Z
    9510:	91 81       	ldd	r25, Z+1	; 0x01
    9512:	02 97       	sbiw	r24, 0x02	; 2
    9514:	11 96       	adiw	r26, 0x01	; 1
    9516:	9c 93       	st	X, r25
    9518:	8e 93       	st	-X, r24
							HAL_LCD_u8Clear();
							HAL_LCD_u8SendString("Dir Left: ");
							HAL_LCD_u8SendNumber(Glob_u16DirLeft);
							HAL_LCD_u8SendString("cm");
							_delay_ms(200);
							for (int k = MAX_CW_ANGLE; k >= START_ANGLE; k -=
    951a:	fe 01       	movw	r30, r28
    951c:	e9 54       	subi	r30, 0x49	; 73
    951e:	ff 4f       	sbci	r31, 0xFF	; 255
    9520:	80 81       	ld	r24, Z
    9522:	91 81       	ldd	r25, Z+1	; 0x01
    9524:	8a 35       	cpi	r24, 0x5A	; 90
    9526:	91 05       	cpc	r25, r1
    9528:	34 f7       	brge	.-52     	; 0x94f6 <APP_Autonomous_Car_voidApp+0x1072>
					HAL_LCD_u8Clear();
					HAL_LCD_u8SendString("Dir Right: ");
					HAL_LCD_u8SendNumber(Glob_u16DirRight);
					HAL_LCD_u8SendString("cm");
					_delay_ms(200);
					for (int j = MAX_CCW_ANGLE; j <= MAX_CW_ANGLE; j += NUM_2) {
    952a:	de 01       	movw	r26, r28
    952c:	a7 54       	subi	r26, 0x47	; 71
    952e:	bf 4f       	sbci	r27, 0xFF	; 255
    9530:	fe 01       	movw	r30, r28
    9532:	e7 54       	subi	r30, 0x47	; 71
    9534:	ff 4f       	sbci	r31, 0xFF	; 255
    9536:	80 81       	ld	r24, Z
    9538:	91 81       	ldd	r25, Z+1	; 0x01
    953a:	02 96       	adiw	r24, 0x02	; 2
    953c:	11 96       	adiw	r26, 0x01	; 1
    953e:	9c 93       	st	X, r25
    9540:	8e 93       	st	-X, r24
    9542:	fe 01       	movw	r30, r28
    9544:	e7 54       	subi	r30, 0x47	; 71
    9546:	ff 4f       	sbci	r31, 0xFF	; 255
    9548:	80 81       	ld	r24, Z
    954a:	91 81       	ldd	r25, Z+1	; 0x01
    954c:	85 3b       	cpi	r24, 0xB5	; 181
    954e:	91 05       	cpc	r25, r1
    9550:	0c f4       	brge	.+2      	; 0x9554 <APP_Autonomous_Car_voidApp+0x10d0>
    9552:	2b ce       	rjmp	.-938    	; 0x91aa <APP_Autonomous_Car_voidApp+0xd26>
				_delay_ms(1000);
//				HAL_Buzzer_u8BuzzerMode(PortA, Pin3, Pin_Low);
			}
			HAL_void_H_BridgeStop(NUM0);
			HAL_LED_u8LedMode(PortA, Pin1, LED_ON);
			for (int i = START_ANGLE; i >= MAX_CCW_ANGLE; i -= NUM_2) {
    9554:	de 01       	movw	r26, r28
    9556:	a5 54       	subi	r26, 0x45	; 69
    9558:	bf 4f       	sbci	r27, 0xFF	; 255
    955a:	fe 01       	movw	r30, r28
    955c:	e5 54       	subi	r30, 0x45	; 69
    955e:	ff 4f       	sbci	r31, 0xFF	; 255
    9560:	80 81       	ld	r24, Z
    9562:	91 81       	ldd	r25, Z+1	; 0x01
    9564:	02 97       	sbiw	r24, 0x02	; 2
    9566:	11 96       	adiw	r26, 0x01	; 1
    9568:	9c 93       	st	X, r25
    956a:	8e 93       	st	-X, r24
    956c:	fe 01       	movw	r30, r28
    956e:	e5 54       	subi	r30, 0x45	; 69
    9570:	ff 4f       	sbci	r31, 0xFF	; 255
    9572:	80 81       	ld	r24, Z
    9574:	91 81       	ldd	r25, Z+1	; 0x01
    9576:	99 23       	and	r25, r25
    9578:	0c f0       	brlt	.+2      	; 0x957c <APP_Autonomous_Car_voidApp+0x10f8>
    957a:	c3 cb       	rjmp	.-2170   	; 0x8d02 <APP_Autonomous_Car_voidApp+0x87e>
							}
						}
					}
				}
			}
			if (Glob_u16DirLeft > Glob_u16DirRight) {
    957c:	20 91 d0 06 	lds	r18, 0x06D0
    9580:	30 91 d1 06 	lds	r19, 0x06D1
    9584:	80 91 d2 06 	lds	r24, 0x06D2
    9588:	90 91 d3 06 	lds	r25, 0x06D3
    958c:	82 17       	cp	r24, r18
    958e:	93 07       	cpc	r25, r19
    9590:	08 f0       	brcs	.+2      	; 0x9594 <APP_Autonomous_Car_voidApp+0x1110>
    9592:	90 c0       	rjmp	.+288    	; 0x96b4 <APP_Autonomous_Car_voidApp+0x1230>
				HAL_LCD_u8Clear();
    9594:	0e 94 7e 26 	call	0x4cfc	; 0x4cfc <HAL_LCD_u8Clear>
				HAL_LCD_u8SendString("Moving Left...");
    9598:	80 e0       	ldi	r24, 0x00	; 0
    959a:	91 e0       	ldi	r25, 0x01	; 1
    959c:	0e 94 c9 23 	call	0x4792	; 0x4792 <HAL_LCD_u8SendString>
				HAL_LCD_u8GoTo(Second_Line, NUM0);
    95a0:	83 e0       	ldi	r24, 0x03	; 3
    95a2:	60 e0       	ldi	r22, 0x00	; 0
    95a4:	0e 94 22 24 	call	0x4844	; 0x4844 <HAL_LCD_u8GoTo>
				HAL_LCD_u8SendString("Distance: ");
    95a8:	8c ec       	ldi	r24, 0xCC	; 204
    95aa:	90 e0       	ldi	r25, 0x00	; 0
    95ac:	0e 94 c9 23 	call	0x4792	; 0x4792 <HAL_LCD_u8SendString>
				HAL_LCD_u8SendNumber((u16) Glob_u16DirLeft);
    95b0:	80 91 d0 06 	lds	r24, 0x06D0
    95b4:	90 91 d1 06 	lds	r25, 0x06D1
    95b8:	0e 94 ff 23 	call	0x47fe	; 0x47fe <HAL_LCD_u8SendNumber>
				HAL_LCD_u8SendString("cm");
    95bc:	87 ed       	ldi	r24, 0xD7	; 215
    95be:	90 e0       	ldi	r25, 0x00	; 0
    95c0:	0e 94 c9 23 	call	0x4792	; 0x4792 <HAL_LCD_u8SendString>
				HAL_void_H_BridgeCCW(MAX_SPEED);
    95c4:	83 e6       	ldi	r24, 0x63	; 99
    95c6:	0e 94 2a 28 	call	0x5054	; 0x5054 <HAL_void_H_BridgeCCW>
    95ca:	80 e0       	ldi	r24, 0x00	; 0
    95cc:	90 e0       	ldi	r25, 0x00	; 0
    95ce:	a1 e6       	ldi	r26, 0x61	; 97
    95d0:	b4 e4       	ldi	r27, 0x44	; 68
    95d2:	89 8f       	std	Y+25, r24	; 0x19
    95d4:	9a 8f       	std	Y+26, r25	; 0x1a
    95d6:	ab 8f       	std	Y+27, r26	; 0x1b
    95d8:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    95da:	69 8d       	ldd	r22, Y+25	; 0x19
    95dc:	7a 8d       	ldd	r23, Y+26	; 0x1a
    95de:	8b 8d       	ldd	r24, Y+27	; 0x1b
    95e0:	9c 8d       	ldd	r25, Y+28	; 0x1c
    95e2:	20 e0       	ldi	r18, 0x00	; 0
    95e4:	30 e0       	ldi	r19, 0x00	; 0
    95e6:	4a e7       	ldi	r20, 0x7A	; 122
    95e8:	55 e4       	ldi	r21, 0x45	; 69
    95ea:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    95ee:	dc 01       	movw	r26, r24
    95f0:	cb 01       	movw	r24, r22
    95f2:	8d 8b       	std	Y+21, r24	; 0x15
    95f4:	9e 8b       	std	Y+22, r25	; 0x16
    95f6:	af 8b       	std	Y+23, r26	; 0x17
    95f8:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    95fa:	6d 89       	ldd	r22, Y+21	; 0x15
    95fc:	7e 89       	ldd	r23, Y+22	; 0x16
    95fe:	8f 89       	ldd	r24, Y+23	; 0x17
    9600:	98 8d       	ldd	r25, Y+24	; 0x18
    9602:	20 e0       	ldi	r18, 0x00	; 0
    9604:	30 e0       	ldi	r19, 0x00	; 0
    9606:	40 e8       	ldi	r20, 0x80	; 128
    9608:	5f e3       	ldi	r21, 0x3F	; 63
    960a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    960e:	88 23       	and	r24, r24
    9610:	2c f4       	brge	.+10     	; 0x961c <APP_Autonomous_Car_voidApp+0x1198>
		__ticks = 1;
    9612:	81 e0       	ldi	r24, 0x01	; 1
    9614:	90 e0       	ldi	r25, 0x00	; 0
    9616:	9c 8b       	std	Y+20, r25	; 0x14
    9618:	8b 8b       	std	Y+19, r24	; 0x13
    961a:	40 c0       	rjmp	.+128    	; 0x969c <APP_Autonomous_Car_voidApp+0x1218>
	else if (__tmp > 65535)
    961c:	6d 89       	ldd	r22, Y+21	; 0x15
    961e:	7e 89       	ldd	r23, Y+22	; 0x16
    9620:	8f 89       	ldd	r24, Y+23	; 0x17
    9622:	98 8d       	ldd	r25, Y+24	; 0x18
    9624:	20 e0       	ldi	r18, 0x00	; 0
    9626:	3f ef       	ldi	r19, 0xFF	; 255
    9628:	4f e7       	ldi	r20, 0x7F	; 127
    962a:	57 e4       	ldi	r21, 0x47	; 71
    962c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    9630:	18 16       	cp	r1, r24
    9632:	54 f5       	brge	.+84     	; 0x9688 <APP_Autonomous_Car_voidApp+0x1204>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    9634:	69 8d       	ldd	r22, Y+25	; 0x19
    9636:	7a 8d       	ldd	r23, Y+26	; 0x1a
    9638:	8b 8d       	ldd	r24, Y+27	; 0x1b
    963a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    963c:	20 e0       	ldi	r18, 0x00	; 0
    963e:	30 e0       	ldi	r19, 0x00	; 0
    9640:	40 e2       	ldi	r20, 0x20	; 32
    9642:	51 e4       	ldi	r21, 0x41	; 65
    9644:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    9648:	dc 01       	movw	r26, r24
    964a:	cb 01       	movw	r24, r22
    964c:	bc 01       	movw	r22, r24
    964e:	cd 01       	movw	r24, r26
    9650:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    9654:	dc 01       	movw	r26, r24
    9656:	cb 01       	movw	r24, r22
    9658:	9c 8b       	std	Y+20, r25	; 0x14
    965a:	8b 8b       	std	Y+19, r24	; 0x13
    965c:	0f c0       	rjmp	.+30     	; 0x967c <APP_Autonomous_Car_voidApp+0x11f8>
    965e:	80 e9       	ldi	r24, 0x90	; 144
    9660:	91 e0       	ldi	r25, 0x01	; 1
    9662:	9a 8b       	std	Y+18, r25	; 0x12
    9664:	89 8b       	std	Y+17, r24	; 0x11
    9666:	89 89       	ldd	r24, Y+17	; 0x11
    9668:	9a 89       	ldd	r25, Y+18	; 0x12
    966a:	01 97       	sbiw	r24, 0x01	; 1
    966c:	f1 f7       	brne	.-4      	; 0x966a <APP_Autonomous_Car_voidApp+0x11e6>
    966e:	9a 8b       	std	Y+18, r25	; 0x12
    9670:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    9672:	8b 89       	ldd	r24, Y+19	; 0x13
    9674:	9c 89       	ldd	r25, Y+20	; 0x14
    9676:	01 97       	sbiw	r24, 0x01	; 1
    9678:	9c 8b       	std	Y+20, r25	; 0x14
    967a:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    967c:	8b 89       	ldd	r24, Y+19	; 0x13
    967e:	9c 89       	ldd	r25, Y+20	; 0x14
    9680:	00 97       	sbiw	r24, 0x00	; 0
    9682:	69 f7       	brne	.-38     	; 0x965e <APP_Autonomous_Car_voidApp+0x11da>
    9684:	0c 94 67 42 	jmp	0x84ce	; 0x84ce <APP_Autonomous_Car_voidApp+0x4a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    9688:	6d 89       	ldd	r22, Y+21	; 0x15
    968a:	7e 89       	ldd	r23, Y+22	; 0x16
    968c:	8f 89       	ldd	r24, Y+23	; 0x17
    968e:	98 8d       	ldd	r25, Y+24	; 0x18
    9690:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    9694:	dc 01       	movw	r26, r24
    9696:	cb 01       	movw	r24, r22
    9698:	9c 8b       	std	Y+20, r25	; 0x14
    969a:	8b 8b       	std	Y+19, r24	; 0x13
    969c:	8b 89       	ldd	r24, Y+19	; 0x13
    969e:	9c 89       	ldd	r25, Y+20	; 0x14
    96a0:	98 8b       	std	Y+16, r25	; 0x10
    96a2:	8f 87       	std	Y+15, r24	; 0x0f
    96a4:	8f 85       	ldd	r24, Y+15	; 0x0f
    96a6:	98 89       	ldd	r25, Y+16	; 0x10
    96a8:	01 97       	sbiw	r24, 0x01	; 1
    96aa:	f1 f7       	brne	.-4      	; 0x96a8 <APP_Autonomous_Car_voidApp+0x1224>
    96ac:	98 8b       	std	Y+16, r25	; 0x10
    96ae:	8f 87       	std	Y+15, r24	; 0x0f
    96b0:	0c 94 67 42 	jmp	0x84ce	; 0x84ce <APP_Autonomous_Car_voidApp+0x4a>
				_delay_ms(900);
			} else if (Glob_u16DirRight >= Glob_u16DirLeft) {
    96b4:	20 91 d2 06 	lds	r18, 0x06D2
    96b8:	30 91 d3 06 	lds	r19, 0x06D3
    96bc:	80 91 d0 06 	lds	r24, 0x06D0
    96c0:	90 91 d1 06 	lds	r25, 0x06D1
    96c4:	28 17       	cp	r18, r24
    96c6:	39 07       	cpc	r19, r25
    96c8:	10 f4       	brcc	.+4      	; 0x96ce <APP_Autonomous_Car_voidApp+0x124a>
    96ca:	0c 94 67 42 	jmp	0x84ce	; 0x84ce <APP_Autonomous_Car_voidApp+0x4a>
				HAL_LCD_u8Clear();
    96ce:	0e 94 7e 26 	call	0x4cfc	; 0x4cfc <HAL_LCD_u8Clear>
				HAL_LCD_u8SendString("Moving Right...");
    96d2:	8f e0       	ldi	r24, 0x0F	; 15
    96d4:	91 e0       	ldi	r25, 0x01	; 1
    96d6:	0e 94 c9 23 	call	0x4792	; 0x4792 <HAL_LCD_u8SendString>
				HAL_LCD_u8GoTo(Second_Line, NUM0);
    96da:	83 e0       	ldi	r24, 0x03	; 3
    96dc:	60 e0       	ldi	r22, 0x00	; 0
    96de:	0e 94 22 24 	call	0x4844	; 0x4844 <HAL_LCD_u8GoTo>
				HAL_LCD_u8SendString("Distance: ");
    96e2:	8c ec       	ldi	r24, 0xCC	; 204
    96e4:	90 e0       	ldi	r25, 0x00	; 0
    96e6:	0e 94 c9 23 	call	0x4792	; 0x4792 <HAL_LCD_u8SendString>
				HAL_LCD_u8SendNumber((u16) Glob_u16DirRight);
    96ea:	80 91 d2 06 	lds	r24, 0x06D2
    96ee:	90 91 d3 06 	lds	r25, 0x06D3
    96f2:	0e 94 ff 23 	call	0x47fe	; 0x47fe <HAL_LCD_u8SendNumber>
				HAL_LCD_u8SendString("cm");
    96f6:	87 ed       	ldi	r24, 0xD7	; 215
    96f8:	90 e0       	ldi	r25, 0x00	; 0
    96fa:	0e 94 c9 23 	call	0x4792	; 0x4792 <HAL_LCD_u8SendString>
				HAL_void_H_BridgeCW(MAX_SPEED);
    96fe:	83 e6       	ldi	r24, 0x63	; 99
    9700:	0e 94 ae 27 	call	0x4f5c	; 0x4f5c <HAL_void_H_BridgeCW>
    9704:	80 e0       	ldi	r24, 0x00	; 0
    9706:	90 e0       	ldi	r25, 0x00	; 0
    9708:	a1 e6       	ldi	r26, 0x61	; 97
    970a:	b4 e4       	ldi	r27, 0x44	; 68
    970c:	8b 87       	std	Y+11, r24	; 0x0b
    970e:	9c 87       	std	Y+12, r25	; 0x0c
    9710:	ad 87       	std	Y+13, r26	; 0x0d
    9712:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    9714:	6b 85       	ldd	r22, Y+11	; 0x0b
    9716:	7c 85       	ldd	r23, Y+12	; 0x0c
    9718:	8d 85       	ldd	r24, Y+13	; 0x0d
    971a:	9e 85       	ldd	r25, Y+14	; 0x0e
    971c:	20 e0       	ldi	r18, 0x00	; 0
    971e:	30 e0       	ldi	r19, 0x00	; 0
    9720:	4a e7       	ldi	r20, 0x7A	; 122
    9722:	55 e4       	ldi	r21, 0x45	; 69
    9724:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    9728:	dc 01       	movw	r26, r24
    972a:	cb 01       	movw	r24, r22
    972c:	8f 83       	std	Y+7, r24	; 0x07
    972e:	98 87       	std	Y+8, r25	; 0x08
    9730:	a9 87       	std	Y+9, r26	; 0x09
    9732:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    9734:	6f 81       	ldd	r22, Y+7	; 0x07
    9736:	78 85       	ldd	r23, Y+8	; 0x08
    9738:	89 85       	ldd	r24, Y+9	; 0x09
    973a:	9a 85       	ldd	r25, Y+10	; 0x0a
    973c:	20 e0       	ldi	r18, 0x00	; 0
    973e:	30 e0       	ldi	r19, 0x00	; 0
    9740:	40 e8       	ldi	r20, 0x80	; 128
    9742:	5f e3       	ldi	r21, 0x3F	; 63
    9744:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    9748:	88 23       	and	r24, r24
    974a:	2c f4       	brge	.+10     	; 0x9756 <APP_Autonomous_Car_voidApp+0x12d2>
		__ticks = 1;
    974c:	81 e0       	ldi	r24, 0x01	; 1
    974e:	90 e0       	ldi	r25, 0x00	; 0
    9750:	9e 83       	std	Y+6, r25	; 0x06
    9752:	8d 83       	std	Y+5, r24	; 0x05
    9754:	40 c0       	rjmp	.+128    	; 0x97d6 <APP_Autonomous_Car_voidApp+0x1352>
	else if (__tmp > 65535)
    9756:	6f 81       	ldd	r22, Y+7	; 0x07
    9758:	78 85       	ldd	r23, Y+8	; 0x08
    975a:	89 85       	ldd	r24, Y+9	; 0x09
    975c:	9a 85       	ldd	r25, Y+10	; 0x0a
    975e:	20 e0       	ldi	r18, 0x00	; 0
    9760:	3f ef       	ldi	r19, 0xFF	; 255
    9762:	4f e7       	ldi	r20, 0x7F	; 127
    9764:	57 e4       	ldi	r21, 0x47	; 71
    9766:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    976a:	18 16       	cp	r1, r24
    976c:	54 f5       	brge	.+84     	; 0x97c2 <APP_Autonomous_Car_voidApp+0x133e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    976e:	6b 85       	ldd	r22, Y+11	; 0x0b
    9770:	7c 85       	ldd	r23, Y+12	; 0x0c
    9772:	8d 85       	ldd	r24, Y+13	; 0x0d
    9774:	9e 85       	ldd	r25, Y+14	; 0x0e
    9776:	20 e0       	ldi	r18, 0x00	; 0
    9778:	30 e0       	ldi	r19, 0x00	; 0
    977a:	40 e2       	ldi	r20, 0x20	; 32
    977c:	51 e4       	ldi	r21, 0x41	; 65
    977e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    9782:	dc 01       	movw	r26, r24
    9784:	cb 01       	movw	r24, r22
    9786:	bc 01       	movw	r22, r24
    9788:	cd 01       	movw	r24, r26
    978a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    978e:	dc 01       	movw	r26, r24
    9790:	cb 01       	movw	r24, r22
    9792:	9e 83       	std	Y+6, r25	; 0x06
    9794:	8d 83       	std	Y+5, r24	; 0x05
    9796:	0f c0       	rjmp	.+30     	; 0x97b6 <APP_Autonomous_Car_voidApp+0x1332>
    9798:	80 e9       	ldi	r24, 0x90	; 144
    979a:	91 e0       	ldi	r25, 0x01	; 1
    979c:	9c 83       	std	Y+4, r25	; 0x04
    979e:	8b 83       	std	Y+3, r24	; 0x03
    97a0:	8b 81       	ldd	r24, Y+3	; 0x03
    97a2:	9c 81       	ldd	r25, Y+4	; 0x04
    97a4:	01 97       	sbiw	r24, 0x01	; 1
    97a6:	f1 f7       	brne	.-4      	; 0x97a4 <APP_Autonomous_Car_voidApp+0x1320>
    97a8:	9c 83       	std	Y+4, r25	; 0x04
    97aa:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    97ac:	8d 81       	ldd	r24, Y+5	; 0x05
    97ae:	9e 81       	ldd	r25, Y+6	; 0x06
    97b0:	01 97       	sbiw	r24, 0x01	; 1
    97b2:	9e 83       	std	Y+6, r25	; 0x06
    97b4:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    97b6:	8d 81       	ldd	r24, Y+5	; 0x05
    97b8:	9e 81       	ldd	r25, Y+6	; 0x06
    97ba:	00 97       	sbiw	r24, 0x00	; 0
    97bc:	69 f7       	brne	.-38     	; 0x9798 <APP_Autonomous_Car_voidApp+0x1314>
    97be:	0c 94 67 42 	jmp	0x84ce	; 0x84ce <APP_Autonomous_Car_voidApp+0x4a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    97c2:	6f 81       	ldd	r22, Y+7	; 0x07
    97c4:	78 85       	ldd	r23, Y+8	; 0x08
    97c6:	89 85       	ldd	r24, Y+9	; 0x09
    97c8:	9a 85       	ldd	r25, Y+10	; 0x0a
    97ca:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    97ce:	dc 01       	movw	r26, r24
    97d0:	cb 01       	movw	r24, r22
    97d2:	9e 83       	std	Y+6, r25	; 0x06
    97d4:	8d 83       	std	Y+5, r24	; 0x05
    97d6:	8d 81       	ldd	r24, Y+5	; 0x05
    97d8:	9e 81       	ldd	r25, Y+6	; 0x06
    97da:	9a 83       	std	Y+2, r25	; 0x02
    97dc:	89 83       	std	Y+1, r24	; 0x01
    97de:	89 81       	ldd	r24, Y+1	; 0x01
    97e0:	9a 81       	ldd	r25, Y+2	; 0x02
    97e2:	01 97       	sbiw	r24, 0x01	; 1
    97e4:	f1 f7       	brne	.-4      	; 0x97e2 <APP_Autonomous_Car_voidApp+0x135e>
    97e6:	9a 83       	std	Y+2, r25	; 0x02
    97e8:	89 83       	std	Y+1, r24	; 0x01
    97ea:	0c 94 67 42 	jmp	0x84ce	; 0x84ce <APP_Autonomous_Car_voidApp+0x4a>

000097ee <main>:
 *      Author: Mohamed
 */

#include "Autonomous_Car/Autonomous_Car.h"
#include "Control_Car/Control_Car.h"
int main(void) {
    97ee:	df 93       	push	r29
    97f0:	cf 93       	push	r28
    97f2:	0f 92       	push	r0
    97f4:	cd b7       	in	r28, 0x3d	; 61
    97f6:	de b7       	in	r29, 0x3e	; 62
	u8 Loc_u8Mode = 'X';
    97f8:	88 e5       	ldi	r24, 0x58	; 88
    97fa:	89 83       	std	Y+1, r24	; 0x01
	APP_Autonomous_Car_voidInit();
    97fc:	0e 94 2b 42 	call	0x8456	; 0x8456 <APP_Autonomous_Car_voidInit>
	APP_Control_Car_Init();
    9800:	0e 94 b5 3d 	call	0x7b6a	; 0x7b6a <APP_Control_Car_Init>
	while (1) {
		//MCAL_UART_UARTReceive(&Loc_u8Mode);
		//if (Loc_u8Mode == 'x') {
			APP_Control_Car_App();
    9804:	0e 94 f6 3d 	call	0x7bec	; 0x7bec <APP_Control_Car_App>
    9808:	fd cf       	rjmp	.-6      	; 0x9804 <main+0x16>

0000980a <__udivmodsi4>:
    980a:	a1 e2       	ldi	r26, 0x21	; 33
    980c:	1a 2e       	mov	r1, r26
    980e:	aa 1b       	sub	r26, r26
    9810:	bb 1b       	sub	r27, r27
    9812:	fd 01       	movw	r30, r26
    9814:	0d c0       	rjmp	.+26     	; 0x9830 <__udivmodsi4_ep>

00009816 <__udivmodsi4_loop>:
    9816:	aa 1f       	adc	r26, r26
    9818:	bb 1f       	adc	r27, r27
    981a:	ee 1f       	adc	r30, r30
    981c:	ff 1f       	adc	r31, r31
    981e:	a2 17       	cp	r26, r18
    9820:	b3 07       	cpc	r27, r19
    9822:	e4 07       	cpc	r30, r20
    9824:	f5 07       	cpc	r31, r21
    9826:	20 f0       	brcs	.+8      	; 0x9830 <__udivmodsi4_ep>
    9828:	a2 1b       	sub	r26, r18
    982a:	b3 0b       	sbc	r27, r19
    982c:	e4 0b       	sbc	r30, r20
    982e:	f5 0b       	sbc	r31, r21

00009830 <__udivmodsi4_ep>:
    9830:	66 1f       	adc	r22, r22
    9832:	77 1f       	adc	r23, r23
    9834:	88 1f       	adc	r24, r24
    9836:	99 1f       	adc	r25, r25
    9838:	1a 94       	dec	r1
    983a:	69 f7       	brne	.-38     	; 0x9816 <__udivmodsi4_loop>
    983c:	60 95       	com	r22
    983e:	70 95       	com	r23
    9840:	80 95       	com	r24
    9842:	90 95       	com	r25
    9844:	9b 01       	movw	r18, r22
    9846:	ac 01       	movw	r20, r24
    9848:	bd 01       	movw	r22, r26
    984a:	cf 01       	movw	r24, r30
    984c:	08 95       	ret

0000984e <__prologue_saves__>:
    984e:	2f 92       	push	r2
    9850:	3f 92       	push	r3
    9852:	4f 92       	push	r4
    9854:	5f 92       	push	r5
    9856:	6f 92       	push	r6
    9858:	7f 92       	push	r7
    985a:	8f 92       	push	r8
    985c:	9f 92       	push	r9
    985e:	af 92       	push	r10
    9860:	bf 92       	push	r11
    9862:	cf 92       	push	r12
    9864:	df 92       	push	r13
    9866:	ef 92       	push	r14
    9868:	ff 92       	push	r15
    986a:	0f 93       	push	r16
    986c:	1f 93       	push	r17
    986e:	cf 93       	push	r28
    9870:	df 93       	push	r29
    9872:	cd b7       	in	r28, 0x3d	; 61
    9874:	de b7       	in	r29, 0x3e	; 62
    9876:	ca 1b       	sub	r28, r26
    9878:	db 0b       	sbc	r29, r27
    987a:	0f b6       	in	r0, 0x3f	; 63
    987c:	f8 94       	cli
    987e:	de bf       	out	0x3e, r29	; 62
    9880:	0f be       	out	0x3f, r0	; 63
    9882:	cd bf       	out	0x3d, r28	; 61
    9884:	09 94       	ijmp

00009886 <__epilogue_restores__>:
    9886:	2a 88       	ldd	r2, Y+18	; 0x12
    9888:	39 88       	ldd	r3, Y+17	; 0x11
    988a:	48 88       	ldd	r4, Y+16	; 0x10
    988c:	5f 84       	ldd	r5, Y+15	; 0x0f
    988e:	6e 84       	ldd	r6, Y+14	; 0x0e
    9890:	7d 84       	ldd	r7, Y+13	; 0x0d
    9892:	8c 84       	ldd	r8, Y+12	; 0x0c
    9894:	9b 84       	ldd	r9, Y+11	; 0x0b
    9896:	aa 84       	ldd	r10, Y+10	; 0x0a
    9898:	b9 84       	ldd	r11, Y+9	; 0x09
    989a:	c8 84       	ldd	r12, Y+8	; 0x08
    989c:	df 80       	ldd	r13, Y+7	; 0x07
    989e:	ee 80       	ldd	r14, Y+6	; 0x06
    98a0:	fd 80       	ldd	r15, Y+5	; 0x05
    98a2:	0c 81       	ldd	r16, Y+4	; 0x04
    98a4:	1b 81       	ldd	r17, Y+3	; 0x03
    98a6:	aa 81       	ldd	r26, Y+2	; 0x02
    98a8:	b9 81       	ldd	r27, Y+1	; 0x01
    98aa:	ce 0f       	add	r28, r30
    98ac:	d1 1d       	adc	r29, r1
    98ae:	0f b6       	in	r0, 0x3f	; 63
    98b0:	f8 94       	cli
    98b2:	de bf       	out	0x3e, r29	; 62
    98b4:	0f be       	out	0x3f, r0	; 63
    98b6:	cd bf       	out	0x3d, r28	; 61
    98b8:	ed 01       	movw	r28, r26
    98ba:	08 95       	ret

000098bc <itoa>:
    98bc:	fb 01       	movw	r30, r22
    98be:	9f 01       	movw	r18, r30
    98c0:	e8 94       	clt
    98c2:	42 30       	cpi	r20, 0x02	; 2
    98c4:	c4 f0       	brlt	.+48     	; 0x98f6 <itoa+0x3a>
    98c6:	45 32       	cpi	r20, 0x25	; 37
    98c8:	b4 f4       	brge	.+44     	; 0x98f6 <itoa+0x3a>
    98ca:	4a 30       	cpi	r20, 0x0A	; 10
    98cc:	29 f4       	brne	.+10     	; 0x98d8 <itoa+0x1c>
    98ce:	97 fb       	bst	r25, 7
    98d0:	1e f4       	brtc	.+6      	; 0x98d8 <itoa+0x1c>
    98d2:	90 95       	com	r25
    98d4:	81 95       	neg	r24
    98d6:	9f 4f       	sbci	r25, 0xFF	; 255
    98d8:	64 2f       	mov	r22, r20
    98da:	77 27       	eor	r23, r23
    98dc:	0e 94 8f 4c 	call	0x991e	; 0x991e <__udivmodhi4>
    98e0:	80 5d       	subi	r24, 0xD0	; 208
    98e2:	8a 33       	cpi	r24, 0x3A	; 58
    98e4:	0c f0       	brlt	.+2      	; 0x98e8 <itoa+0x2c>
    98e6:	89 5d       	subi	r24, 0xD9	; 217
    98e8:	81 93       	st	Z+, r24
    98ea:	cb 01       	movw	r24, r22
    98ec:	00 97       	sbiw	r24, 0x00	; 0
    98ee:	a1 f7       	brne	.-24     	; 0x98d8 <itoa+0x1c>
    98f0:	16 f4       	brtc	.+4      	; 0x98f6 <itoa+0x3a>
    98f2:	5d e2       	ldi	r21, 0x2D	; 45
    98f4:	51 93       	st	Z+, r21
    98f6:	10 82       	st	Z, r1
    98f8:	c9 01       	movw	r24, r18
    98fa:	0c 94 7f 4c 	jmp	0x98fe	; 0x98fe <strrev>

000098fe <strrev>:
    98fe:	dc 01       	movw	r26, r24
    9900:	fc 01       	movw	r30, r24
    9902:	67 2f       	mov	r22, r23
    9904:	71 91       	ld	r23, Z+
    9906:	77 23       	and	r23, r23
    9908:	e1 f7       	brne	.-8      	; 0x9902 <strrev+0x4>
    990a:	32 97       	sbiw	r30, 0x02	; 2
    990c:	04 c0       	rjmp	.+8      	; 0x9916 <strrev+0x18>
    990e:	7c 91       	ld	r23, X
    9910:	6d 93       	st	X+, r22
    9912:	70 83       	st	Z, r23
    9914:	62 91       	ld	r22, -Z
    9916:	ae 17       	cp	r26, r30
    9918:	bf 07       	cpc	r27, r31
    991a:	c8 f3       	brcs	.-14     	; 0x990e <strrev+0x10>
    991c:	08 95       	ret

0000991e <__udivmodhi4>:
    991e:	aa 1b       	sub	r26, r26
    9920:	bb 1b       	sub	r27, r27
    9922:	51 e1       	ldi	r21, 0x11	; 17
    9924:	07 c0       	rjmp	.+14     	; 0x9934 <__udivmodhi4_ep>

00009926 <__udivmodhi4_loop>:
    9926:	aa 1f       	adc	r26, r26
    9928:	bb 1f       	adc	r27, r27
    992a:	a6 17       	cp	r26, r22
    992c:	b7 07       	cpc	r27, r23
    992e:	10 f0       	brcs	.+4      	; 0x9934 <__udivmodhi4_ep>
    9930:	a6 1b       	sub	r26, r22
    9932:	b7 0b       	sbc	r27, r23

00009934 <__udivmodhi4_ep>:
    9934:	88 1f       	adc	r24, r24
    9936:	99 1f       	adc	r25, r25
    9938:	5a 95       	dec	r21
    993a:	a9 f7       	brne	.-22     	; 0x9926 <__udivmodhi4_loop>
    993c:	80 95       	com	r24
    993e:	90 95       	com	r25
    9940:	bc 01       	movw	r22, r24
    9942:	cd 01       	movw	r24, r26
    9944:	08 95       	ret

00009946 <_exit>:
    9946:	f8 94       	cli

00009948 <__stop_program>:
    9948:	ff cf       	rjmp	.-2      	; 0x9948 <__stop_program>
